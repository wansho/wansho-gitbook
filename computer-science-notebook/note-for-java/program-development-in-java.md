# Java 程序开发 抽象、规格与面向对象设计

[TOC]

这本书教我们如何编程，将编程理论化。



## 第一章 概述

* 程序应该本着让人理解的原则来构建。（可读性）
* 分解（decomposition）和抽象（abstraction）是本书的两个核心概念

### 分解和抽象

当分解一个问题时，我们遵循一下的原则将其分解成几个可以再分的子问题：

* 每个子问题在细节上处于相同的级别
* 每个子问题能够独立解决
* 每个子问题的解决方法综合起来能够解决原来的问题。

通过改变问题所涉及的细节等级，抽象可以有效地处理分解的问题。当我们对一个问题进行抽象时，为了简化问题，需要忽略某些细节。例如，我们可能要将剧本的问题抽象为决定这个剧本中有几幕，或者是什么剧情，甚至抽象为每组对话的意思（但不是具体措辞）。完成这些事情以后，似乎最初的问题（即写出剧本中的所有对话）还是没有解决。但是，它已经大大简化了，甚至可以简化到在何处可以从一个要点转到另一个或几个要点。



### 抽象

抽象主要是希望通过将相关的属性和其他不想关的属性分开，以简化分析过程。

抽象关注共有的特征。

两种抽象

* 参数化抽象 abstraction by parameterization

  用参数替换数据特征来进行抽象，这样能归纳出模块，使其可以用于更多的情况。

* 规格化抽象 abstraction by specification

  将执行细节（即模块如何实现）抽象为用户所需求的行为（即模块做什么）。这是从具体实现中抽象出模块。

在规格抽象中，我们关注的是用户所关心的行为，而不是实现行为的细节。规格抽象的关键优势在于，能让我们改变一种实现而不改变任何使用抽象描述的程序的含义（规格抽象就是接口）。例如，我们能够改变用来实现 isPrime 过程的算法，但是 isPrime 对外提供的功能是不变的。

每当要将一个过程与一个注释（这个注释提供了充分的信息，使其他人不用看过程主题就可以使用该过程）关联起来时，我们就会使用规格化抽象。写这种注释的一个好方法是用成对的断言（assertion）注释。一个过程中的 requires 断言（requires assertion）[或者说前置条件(precondition)] 是过程执行前指定一个假定成立的对象。在实践中，最常用到的断言是一组足以确保过程能正确操作的条件。（这也通常成为无实质断言，成立标志为 “TRUE”）。effects 断言（effects assertion）[或者叫后置条件(postcondition)] 是在满足前置条件的过程运行完毕后，指定一个假定成立的结果。

例如如下程序，因为已经提供了响应的规格，所以我们能够忽略过程主题，并且将过程调用 y = sqrt(x) 的意思理解为「过程调用时，如果参数大于 0，则在过程执行完毕后 y 就是 x 平方根的近似值」。

```java
float sqrt(float coef){
  //requires: coef > 0
  //effects: return a approximation to the square root of coef
  float ans = coef / 2.0;
  int i = 1;
  while(i < 7){
    ans = ans - ((ans * ans - coef) / (2.0 * ans));
    i = i + 1;
  }
  return ans;
}
```



抽象的种类：

* 过程抽象：对过程进行抽象（引入新的方法）
* 数据抽象：状态 + 行为（引入新的数据类型）
* 迭代抽象：能够迭代遍历在集合中的元素，而不需要显示如何获取元素的细节

数据抽象是重点，是面向对象程序设计的基础。



## 第二章 理解 Java 中的对象

对象中封装的成员变量，准确的来说，应该叫状态，而方法，是用来修改和获取状态的操作。

对于方法来说，异常也是一种返回结果！

方法的签名：入参和返回值（包括异常）。(函数真正叫什么其实不重要，参考 lambda 表达式。)

Java 是强类型语言，Java 编译器会检查代码，确保每个赋值和调用都是类型正确的。

int 和 float 可以损失精度赋值给 long 类型，但是不能反向提升精度。



## 第三章 过程抽象

过程抽象组合了参数抽象和规格抽象，是输入到输出的映射。（过程就是接口）



### 过程的规格

规格是抽象的唯一记录。

一个接口的规格，除了接口名、输入和输出（异常）外，还可能有以下三点：

* requires: 使用该接口的前提条件（入参的条件），例如 binarySearch() 方法要求入参必须已经排好序
* modifies: 描述了哪些入参（包含隐式输入）被修改了
* effects: 程序运行的结果

Arrays 中的 sort 和 search 方法是全局的(total)，因为其规格并不包含 requires 要求。而 binarySearch 是局部的（partial），只在参数数组已经排序的情况下才能工作。应该尽量避免规格中包含 requires 条件。

requires 是前置条件，前置条件是和调用方（客户端）的约定，如果可能，应该检查这个 requires 格式是否满足。



### 过程的实现

接口的实现

过程的实现应产生由过程的规格所定义的行为。特别是，过程的实现必须只对出现在 modifies 格式中的那些输入进行修改；如果所有输入都满足 requires 格式，则必须得出与 effects 格式一致的结果。

例如用 Java 语言实现的线性查找方法 searchSorted()，当传入的参数数组为 null 的时候，实现 searchSorted 会返回 -1。这个行为与在规格中描述的行为是一致的。然而，更好的规格可能会对这个情况进行特殊处理，会指示必须抛出一个异常。



### 设计过程抽象

过程（接口）可能包含有如下属性：

* 未确定性：Arrays.search() 就是未确定的，数组中可能包含有多个要查找的元素，不同的算法实现会返回不同的值
* 一般性：如果一个规格能够处理比较大的一类输入，则这个规格就比另一个规格更有一般性

过程（接口）的另一个重要属性是简单性。过程应该要有一个明确定义并且易于解释的名字，如果要想出这样一个名称很困难，则这个过程可能就有问题了。

如果检查显示 requires 格式没有满足，则过程可以产生一个错误提示消息。但更好的方法通常是抛出一个异常。

接口可以分成两类：局部的（partial）和全局的（total）。对外暴露的接口，最好是全局的（没有 requires 约束），私有方法可以用局部约束。

全局过程和局部过程：

* 如果一个过程的行为对所有合法输入都是合适的，则这个过程就是全局的；否则，这个过程就是局部的。一个局部过程的规格总是包含一个 requires 格式。
* 局部过程比全局过程更不安全。因此，它们应该只在使用环境是有限时或者能带来重要好处时才能使用。
* 可能的时候，编程时应该检查 requires 格式中的约束条件。并且，如果这些约束条件不能满足就抛出一个异常。



## 异常



### 为什么要引入异常



### Java 异常机制



