<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>wanshuo-gitbook</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Table of contents</li><li class="chapter-item expanded "><a href="reading/modern-os/index.html"><strong aria-hidden="true">1.</strong> 现代操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/modern-os/chapter-1-introduction.html"><strong aria-hidden="true">1.1.</strong> chapter1-introduction</a></li><li class="chapter-item expanded "><a href="reading/modern-os/chapter-2-processes-and-threads.html"><strong aria-hidden="true">1.2.</strong> chapter2-processes-and-threads</a></li><li class="chapter-item expanded "><a href="reading/modern-os/chapter-7-virtualization-and-cloud.html"><strong aria-hidden="true">1.3.</strong> chapter7-virtualization-and-cloud</a></li><li class="chapter-item expanded "><a href="reading/modern-os/questions.html"><strong aria-hidden="true">1.4.</strong> questions</a></li></ol></li><li class="chapter-item expanded "><a href="reading/fluent-python/index.html"><strong aria-hidden="true">2.</strong> 流畅的 Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/index.html"><strong aria-hidden="true">2.1.</strong> chapters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter1.the-python-data-model.html"><strong aria-hidden="true">2.1.1.</strong> chapter1-the-python-data-model</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter2.an-array-of-sequences.html"><strong aria-hidden="true">2.1.2.</strong> chapter2-an-array-of-sequences</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter3.dictionaries-and-sets.html"><strong aria-hidden="true">2.1.3.</strong> chapter3-dictionaries-and-sets</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter4.text-versus-bytes.html"><strong aria-hidden="true">2.1.4.</strong> chapter4-text-versus-bytes</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter5.first-class-functions.html"><strong aria-hidden="true">2.1.5.</strong> chapter5-first-class-functions</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter6-design-patterns-with-first-class-functions.html"><strong aria-hidden="true">2.1.6.</strong> chapter6-design-patterns-with-functions</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter7-function-decorators-and-closures.html"><strong aria-hidden="true">2.1.7.</strong> chapter7-function-decorators-and-closures</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter8-object-reference-mutability-recycling.html"><strong aria-hidden="true">2.1.8.</strong> chapter8-object-reference-mutability-and-recycling</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter9-a-pythonic-object.html"><strong aria-hidden="true">2.1.9.</strong> chapter9-a-pythonic-object</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter10-sequence-hacking-hashing-slicing.html"><strong aria-hidden="true">2.1.10.</strong> chapter10-sequencec-hacking-hashing-and-slicing</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/chapters/chapter11-interfaces-from-protocols-to-abcs.html"><strong aria-hidden="true">2.1.11.</strong> chapter11-interfaces-from-protocols-to-abcs</a></li></ol></li><li class="chapter-item expanded "><a href="reading/fluent-python/summary/index.html"><strong aria-hidden="true">2.2.</strong> summary</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/fluent-python/summary/questions.html"><strong aria-hidden="true">2.2.1.</strong> questions</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/summary/python-code-optimization.html"><strong aria-hidden="true">2.2.2.</strong> python-code-optimization</a></li><li class="chapter-item expanded "><a href="reading/fluent-python/summary/python-30-seconds.html"><strong aria-hidden="true">2.2.3.</strong> python-30-seconds</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reading/computer-networking/index.html"><strong aria-hidden="true">3.</strong> 计算机网络-自顶向下</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/computer-networking/chapter1-computer-networks-and-the-internet.html"><strong aria-hidden="true">3.1.</strong> chapter1-computer-networks-and-the-internet</a></li></ol></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/index.html"><strong aria-hidden="true">4.</strong> 数据结构与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/index.html"><strong aria-hidden="true">4.1.</strong> chapters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-1-introduction.html"><strong aria-hidden="true">4.1.1.</strong> chapter1-introduction</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-2-algorithm-analysis.html"><strong aria-hidden="true">4.1.2.</strong> chapter2-algorithm-analysis</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-3-list-stack-queue.html"><strong aria-hidden="true">4.1.3.</strong> chapter3-list-stack-queue</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-4-tree.html"><strong aria-hidden="true">4.1.4.</strong> chapter4-tree</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-6-heap.html"><strong aria-hidden="true">4.1.5.</strong> chapter6-heap</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/chapters/chapter-7-sorting.html"><strong aria-hidden="true">4.1.6.</strong> chapter7-sorting</a></li></ol></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/summary/index.html"><strong aria-hidden="true">4.2.</strong> summary</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/summary/questions.html"><strong aria-hidden="true">4.2.1.</strong> questions</a></li><li class="chapter-item expanded "><a href="reading/data-structures-and-algorithm-analysis-in-c/summary/classic-problems.html"><strong aria-hidden="true">4.2.2.</strong> 经典问题</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reading/books/index.html"><strong aria-hidden="true">5.</strong> 其他书籍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading/books/bookshelf.html"><strong aria-hidden="true">5.1.</strong> 书籍列表</a></li><li class="chapter-item expanded "><a href="reading/books/zen-and-the-art.html"><strong aria-hidden="true">5.2.</strong> 禅与摩托车维修艺术</a></li><li class="chapter-item expanded "><a href="reading/books/the-road-less-traveled.html"><strong aria-hidden="true">5.3.</strong> 少有人走的路</a></li><li class="chapter-item expanded "><a href="reading/books/time-as-a-friend.html"><strong aria-hidden="true">5.4.</strong> 李笑来-与时间做朋友</a></li><li class="chapter-item expanded "><a href="reading/books/reborn.html"><strong aria-hidden="true">5.5.</strong> 李笑来-Reborn</a></li><li class="chapter-item expanded "><a href="reading/books/shediao-yingxiongzhuan.html"><strong aria-hidden="true">5.6.</strong> 射雕英雄传</a></li><li class="chapter-item expanded "><a href="reading/books/liangjian.html"><strong aria-hidden="true">5.7.</strong> 亮剑</a></li><li class="chapter-item expanded "><a href="reading/books/wan-li-shi-wu-nian.html"><strong aria-hidden="true">5.8.</strong> 万历十五年</a></li><li class="chapter-item expanded "><a href="reading/books/zi-bei-yu-chao-yue.html"><strong aria-hidden="true">5.9.</strong> 自卑与超越</a></li><li class="chapter-item expanded "><a href="reading/books/ming-li-xue.html"><strong aria-hidden="true">5.10.</strong> 王德峰-命理学</a></li><li class="chapter-item expanded "><a href="reading/books/a-brief-history-of-humankind.html"><strong aria-hidden="true">5.11.</strong> 人类简史</a></li><li class="chapter-item expanded "><a href="reading/books/mao-xuan.html"><strong aria-hidden="true">5.12.</strong> 毛选</a></li><li class="chapter-item expanded "><a href="reading/books/tian-dao.html"><strong aria-hidden="true">5.13.</strong> 遥远的救世主</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/algorithms/index.html"><strong aria-hidden="true">6.</strong> 算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/algorithms/arraylist-vs-linklist.html"><strong aria-hidden="true">6.1.</strong> arraylist-vs-linklist</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/algorithms/information-entropy.html"><strong aria-hidden="true">6.2.</strong> information-entropy</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/algorithms/summary.html"><strong aria-hidden="true">6.3.</strong> summary</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/index.html"><strong aria-hidden="true">7.</strong> database</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/database/zen-of-db.html"><strong aria-hidden="true">7.1.</strong> zen-of-db</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/mysql-101.html"><strong aria-hidden="true">7.2.</strong> MySQL-101</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/mysql-102.html"><strong aria-hidden="true">7.3.</strong> MySQL-102</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/mysql-103.html"><strong aria-hidden="true">7.4.</strong> MySQL-103</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/elastic-search.html"><strong aria-hidden="true">7.5.</strong> Elasticsearch</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/elastic-logstash.html"><strong aria-hidden="true">7.6.</strong> Logstash</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/oracle-101.html"><strong aria-hidden="true">7.7.</strong> Oracle-101</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/mysql-leetcode.html"><strong aria-hidden="true">7.8.</strong> Mysql-Leetcode</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/database-others.html"><strong aria-hidden="true">7.9.</strong> 其他数据库产品</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/design-data-intensive-app.html"><strong aria-hidden="true">7.10.</strong> 书籍-设计数据密集型应用</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/database/questions.html"><strong aria-hidden="true">7.11.</strong> Questions</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/index.html"><strong aria-hidden="true">8.</strong> 密码学与网络安全</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/cryptography.html"><strong aria-hidden="true">8.1.</strong> 密码学</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/ssh.html"><strong aria-hidden="true">8.2.</strong> ssh 教程</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/authentication-authorization.html"><strong aria-hidden="true">8.3.</strong> 认证和授权</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/single-sign-on.html"><strong aria-hidden="true">8.4.</strong> SSO 单点登录</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/oauth.html"><strong aria-hidden="true">8.5.</strong> OAuth</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/jwt.html"><strong aria-hidden="true">8.6.</strong> jwt</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/cryptography-web-security/security-vulnerability.html"><strong aria-hidden="true">8.7.</strong> 安全漏洞</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/network-web/index.html"><strong aria-hidden="true">9.</strong> 计算机网络相关知识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/network-web/computer-network.html"><strong aria-hidden="true">9.1.</strong> 计算机网络小知识集合</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/network-web/web-service.html"><strong aria-hidden="true">9.2.</strong> web-service</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/network-web/http-protocol.html"><strong aria-hidden="true">9.3.</strong> http 协议</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/network-web/questions.html"><strong aria-hidden="true">9.4.</strong> questions</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/index.html"><strong aria-hidden="true">10.</strong> 编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/go.html"><strong aria-hidden="true">10.1.</strong> go</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/kotlin.html"><strong aria-hidden="true">10.2.</strong> kotlin</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/rust.html"><strong aria-hidden="true">10.3.</strong> rust</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/svg.html"><strong aria-hidden="true">10.4.</strong> svg</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/regex.html"><strong aria-hidden="true">10.5.</strong> regex</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/windows-bat.html"><strong aria-hidden="true">10.6.</strong> windows-bat</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/programming-language/qt.html"><strong aria-hidden="true">10.7.</strong> QT</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-c/index.html"><strong aria-hidden="true">11.</strong> C++ 开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-c/how-to-learn-c.html"><strong aria-hidden="true">11.1.</strong> C语言学习教程</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-c/think-c.html"><strong aria-hidden="true">11.2.</strong> 书籍：Think-C</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-c/deep-c.html"><strong aria-hidden="true">11.3.</strong> C语言深度剖析</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-c/c++.html"><strong aria-hidden="true">11.4.</strong> C++学习</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/index.html"><strong aria-hidden="true">12.</strong> Python 学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/note-for-pandas.html"><strong aria-hidden="true">12.1.</strong> pandas 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/django-version-upgrade.html"><strong aria-hidden="true">12.2.</strong> django 版本升级</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-hacker.html"><strong aria-hidden="true">12.3.</strong> 书籍：python-hacker</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-craftsman.html"><strong aria-hidden="true">12.4.</strong> 书籍：python 工匠</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-packages.html"><strong aria-hidden="true">12.5.</strong> pip 相关知识</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-exception.html"><strong aria-hidden="true">12.6.</strong> python 异常处理</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-cheetsheet.html"><strong aria-hidden="true">12.7.</strong> python 小知识</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/jupyter-notebook.html"><strong aria-hidden="true">12.8.</strong> jupyter 使用笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/different-methods-in-class.html"><strong aria-hidden="true">12.9.</strong> python 不同的方法</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/pep.html"><strong aria-hidden="true">12.10.</strong> pep: python-enhanced-proposal</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/python-algorithm-data-structure.html"><strong aria-hidden="true">12.11.</strong> python 数据结构与算法</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-python/multiprocessing-and-threading.html"><strong aria-hidden="true">12.12.</strong> 多线程和多进程</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/index.html"><strong aria-hidden="true">13.</strong> Java 学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java.html"><strong aria-hidden="true">13.1.</strong> 毕向东 java se 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java.html"><strong aria-hidden="true">13.2.</strong> java 进阶</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-collection-map.html"><strong aria-hidden="true">13.3.</strong> Java collection学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-array.html"><strong aria-hidden="true">13.4.</strong> Java array 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/string.html"><strong aria-hidden="true">13.5.</strong> Java string 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/annotation.html"><strong aria-hidden="true">13.6.</strong> Java Annotation 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-datetime.html"><strong aria-hidden="true">13.7.</strong> java datetime 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-reflection.html"><strong aria-hidden="true">13.8.</strong> java 反射学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-new-features.html"><strong aria-hidden="true">13.9.</strong> Java 新特性</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-log.html"><strong aria-hidden="true">13.10.</strong> Java 日志</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-exception.html"><strong aria-hidden="true">13.11.</strong> Java 异常</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-vm.html"><strong aria-hidden="true">13.12.</strong> java 虚拟机</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-junit.html"><strong aria-hidden="true">13.13.</strong> Java JUnit 测试</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/template-engine.html"><strong aria-hidden="true">13.14.</strong> Java 模板引擎</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/design-patterns.html"><strong aria-hidden="true">13.15.</strong> 设计模式学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/generics.html"><strong aria-hidden="true">13.16.</strong> 泛型</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/stream.html"><strong aria-hidden="true">13.17.</strong> stream 学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/functional-programming.html"><strong aria-hidden="true">13.18.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/program-development-in-java.html"><strong aria-hidden="true">13.19.</strong> Java 程序开发原理</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-bin.html"><strong aria-hidden="true">13.20.</strong> Java 自带命令学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/java-dev-tools.html"><strong aria-hidden="true">13.21.</strong> Java 开发工具</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java/big-number.html"><strong aria-hidden="true">13.22.</strong> 大数计算和存储</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/index.html"><strong aria-hidden="true">14.</strong> JavaWeb 学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/database.html"><strong aria-hidden="true">14.1.</strong> 访问数据库笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/java-persistence-api.html"><strong aria-hidden="true">14.2.</strong> JPA 深入学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/mybatis.html"><strong aria-hidden="true">14.3.</strong> mybatis 学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/bean-pojo-dto.html"><strong aria-hidden="true">14.4.</strong> java-bean 分类</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/maven.html"><strong aria-hidden="true">14.5.</strong> Maven 学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/dependencies.html"><strong aria-hidden="true">14.6.</strong> 依赖库整理</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/micro-service.html"><strong aria-hidden="true">14.7.</strong> 微服务架构课</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/architect.html"><strong aria-hidden="true">14.8.</strong> IT老齐架构课笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/restful-api.html"><strong aria-hidden="true">14.9.</strong> restful-api</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/spring.html"><strong aria-hidden="true">14.10.</strong> spring</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/spring-security.html"><strong aria-hidden="true">14.11.</strong> spring-security</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/springboot.html"><strong aria-hidden="true">14.12.</strong> spring-boot</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/springcloud.html"><strong aria-hidden="true">14.13.</strong> spring-cloud</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/reactive.html"><strong aria-hidden="true">14.14.</strong> 响应式 web</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/cache.html"><strong aria-hidden="true">14.15.</strong> 缓存</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/web-api-the-good-parts.html"><strong aria-hidden="true">14.16.</strong> WebAPI 的设计与开发</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/rbac.html"><strong aria-hidden="true">14.17.</strong> RBAC</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/socket.html"><strong aria-hidden="true">14.18.</strong> Socket</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/webservice.html"><strong aria-hidden="true">14.19.</strong> webservice</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/tomcat-servlet.html"><strong aria-hidden="true">14.20.</strong> tomcat-servlet</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/encode-decode.html"><strong aria-hidden="true">14.21.</strong> 编解码</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/note-for-java-web/netty.html"><strong aria-hidden="true">14.22.</strong> Netty</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/index.html"><strong aria-hidden="true">15.</strong> 前端开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/nodejs.html"><strong aria-hidden="true">15.1.</strong> nodejs</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/yarn.html"><strong aria-hidden="true">15.2.</strong> yarn 使用</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/repos.html"><strong aria-hidden="true">15.3.</strong> 前端库总结</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/react-dev.html"><strong aria-hidden="true">15.4.</strong> React 开发笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/chrome-extension.html"><strong aria-hidden="true">15.5.</strong> chrome 插件开发</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/ajax.html"><strong aria-hidden="true">15.6.</strong> ajax</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/jquery.html"><strong aria-hidden="true">15.7.</strong> jquery</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/javascript-101.html"><strong aria-hidden="true">15.8.</strong> javascript-101</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/javascript-102.html"><strong aria-hidden="true">15.9.</strong> javascript-102</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/javascript-ie11-compatible.html"><strong aria-hidden="true">15.10.</strong> javascript兼容IE11</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/immutable-js.html"><strong aria-hidden="true">15.11.</strong> immutable.js</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/npm-libs.html"><strong aria-hidden="true">15.12.</strong> npm库</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/html-css-dom.html"><strong aria-hidden="true">15.13.</strong> html-css-dom 学习</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/front-end/web-assembly.html"><strong aria-hidden="true">15.14.</strong> web-assembly</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/nlp/index.html"><strong aria-hidden="true">16.</strong> NLP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/nlp/nlp-learning.html"><strong aria-hidden="true">16.1.</strong> NLP-Learning</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/nlp/machine-learning.html"><strong aria-hidden="true">16.2.</strong> Machine-Learning</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/index.html"><strong aria-hidden="true">17.</strong> linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-cmds.html"><strong aria-hidden="true">17.1.</strong> linux 命令手册</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-cmd-enhanced.html"><strong aria-hidden="true">17.2.</strong> linux 增强命令</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-mythink.html"><strong aria-hidden="true">17.3.</strong> linux 使用心得</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-devops.html"><strong aria-hidden="true">17.4.</strong> linux-运维</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-init.html"><strong aria-hidden="true">17.5.</strong> linux 初始化</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/vim.html"><strong aria-hidden="true">17.6.</strong> vim</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/shell.html"><strong aria-hidden="true">17.7.</strong> shell</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/script-demos.html"><strong aria-hidden="true">17.8.</strong> shell 脚本 demo</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/linux/linux-distribution-history.html"><strong aria-hidden="true">17.9.</strong> linux 历史和发行版</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/index.html"><strong aria-hidden="true">18.</strong> github</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/github/github.html"><strong aria-hidden="true">18.1.</strong> github 使用技巧</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/gitbook.html"><strong aria-hidden="true">18.2.</strong> 优雅锋利的 gitbook</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/git.html"><strong aria-hidden="true">18.3.</strong> 书籍：git-pro</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/github-actions.html"><strong aria-hidden="true">18.4.</strong> github-actions</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/markdown.html"><strong aria-hidden="true">18.5.</strong> markdown 语法</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/github/git-hook.html"><strong aria-hidden="true">18.6.</strong> githook</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/index.html"><strong aria-hidden="true">19.</strong> 开发工具与技术栈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/technology-stack.html"><strong aria-hidden="true">19.1.</strong> 技术栈</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/idea.html"><strong aria-hidden="true">19.2.</strong> IDEA 使用学习笔记</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/idea-debug.html"><strong aria-hidden="true">19.3.</strong> IDEA Debug</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/serverless.html"><strong aria-hidden="true">19.4.</strong> serverless</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/apifox.html"><strong aria-hidden="true">19.5.</strong> apifox</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/blockchain.html"><strong aria-hidden="true">19.6.</strong> 区块链</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/web3.html"><strong aria-hidden="true">19.7.</strong> Web3.0</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/vscode.html"><strong aria-hidden="true">19.8.</strong> VSCode</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/docker.html"><strong aria-hidden="true">19.9.</strong> Docker</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/cloud-native.html"><strong aria-hidden="true">19.10.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/message-queue.html"><strong aria-hidden="true">19.11.</strong> 消息队列</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/redis.html"><strong aria-hidden="true">19.12.</strong> Redis</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/selenium.html"><strong aria-hidden="true">19.13.</strong> Selenium</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/nginx.html"><strong aria-hidden="true">19.14.</strong> nginx</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/zookeeper.html"><strong aria-hidden="true">19.15.</strong> zookeeper</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/haproxy.html"><strong aria-hidden="true">19.16.</strong> haproxy-keepalived</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/webhook.html"><strong aria-hidden="true">19.17.</strong> webhook</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/lowcode.html"><strong aria-hidden="true">19.18.</strong> 低代码</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/web-spider.html"><strong aria-hidden="true">19.19.</strong> 网络爬虫</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/make-hexo-theme.html"><strong aria-hidden="true">19.20.</strong> Hexo 主题定制</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/development-tools/swagger.html"><strong aria-hidden="true">19.21.</strong> Swagger</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/index.html"><strong aria-hidden="true">20.</strong> 软件工程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/software-testing.html"><strong aria-hidden="true">20.1.</strong> 软件测试</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/uml.html"><strong aria-hidden="true">20.2.</strong> UML</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/continuous-integration.html"><strong aria-hidden="true">20.3.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/software-version.html"><strong aria-hidden="true">20.4.</strong> 软件版本命名</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/zentao.html"><strong aria-hidden="true">20.5.</strong> 项目管理-禅道</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/software-engineering.html"><strong aria-hidden="true">20.6.</strong> 软件工程</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/os-installed-software.html"><strong aria-hidden="true">20.7.</strong> 电脑常用软件整理</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/software-engineering/code-summary.html"><strong aria-hidden="true">20.8.</strong> 编程经验总结</a></li></ol></li><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/index.html"><strong aria-hidden="true">21.</strong> 技术讲座</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/cs-keep-learning.html"><strong aria-hidden="true">21.1.</strong> keep-learning</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/atguigu-os.html"><strong aria-hidden="true">21.2.</strong> 尚硅谷-操作系统</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/future-of-computation.html"><strong aria-hidden="true">21.3.</strong> 吴翰清-计算的未来</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/xu-shi-wei-architecture.html"><strong aria-hidden="true">21.4.</strong> 许式伟-架构课</a></li><li class="chapter-item expanded "><a href="computer-science-notebook/technology-lecture/questions.html"><strong aria-hidden="true">21.5.</strong> questions</a></li></ol></li><li class="chapter-item expanded "><a href="weekly/2022/index.html"><strong aria-hidden="true">22.</strong> 2022</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="weekly/2022/week-27.html"><strong aria-hidden="true">22.1.</strong> week-27</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-28.html"><strong aria-hidden="true">22.2.</strong> week-28</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-29.html"><strong aria-hidden="true">22.3.</strong> week-29</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-30.html"><strong aria-hidden="true">22.4.</strong> week-30</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-31-32.html"><strong aria-hidden="true">22.5.</strong> week-31-32</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-32.html"><strong aria-hidden="true">22.6.</strong> week-32</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-33.html"><strong aria-hidden="true">22.7.</strong> week-33</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-34.html"><strong aria-hidden="true">22.8.</strong> week-34</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-35.html"><strong aria-hidden="true">22.9.</strong> week-35</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-36.html"><strong aria-hidden="true">22.10.</strong> week-36</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-37.html"><strong aria-hidden="true">22.11.</strong> week-37</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-38.html"><strong aria-hidden="true">22.12.</strong> week-38</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-39.html"><strong aria-hidden="true">22.13.</strong> week-39</a></li><li class="chapter-item expanded "><a href="weekly/2022/week-40.html"><strong aria-hidden="true">22.14.</strong> week-40</a></li></ol></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/index.html"><strong aria-hidden="true">23.</strong> blog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life-and-thinking/blog/for-a-job.html"><strong aria-hidden="true">23.1.</strong> 关于找工作</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/how-to-study.html"><strong aria-hidden="true">23.2.</strong> 如何学习</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/summary-for-examination-oriented-education.html"><strong aria-hidden="true">23.3.</strong> 应试教育总结思考</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/cyber-spirit-opium.html"><strong aria-hidden="true">23.4.</strong> 网络精神鸦片</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/why-perfect.html"><strong aria-hidden="true">23.5.</strong> 追求完美？</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/about-love.html"><strong aria-hidden="true">23.6.</strong> 我的恋爱观</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/pin-duo-duo.html"><strong aria-hidden="true">23.7.</strong> 细数在拼多多开店遇到的坑</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/summary-of-marketing.html"><strong aria-hidden="true">23.8.</strong> 营销经验总结</a></li><li class="chapter-item expanded "><a href="life-and-thinking/blog/real-estate.html"><strong aria-hidden="true">23.9.</strong> 买房经验总结</a></li></ol></li><li class="chapter-item expanded "><a href="life-and-thinking/health/index.html"><strong aria-hidden="true">24.</strong> 关于健康</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life-and-thinking/health/zhong-yi.html"><strong aria-hidden="true">24.1.</strong> 关于中医</a></li><li class="chapter-item expanded "><a href="life-and-thinking/health/health.html"><strong aria-hidden="true">24.2.</strong> 关于健康</a></li></ol></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/index.html"><strong aria-hidden="true">25.</strong> 求知若渴虚心若愚</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/how-to-keep-learning.html"><strong aria-hidden="true">25.1.</strong> 如何保持学习激情</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/weekly.html"><strong aria-hidden="true">25.2.</strong> 周刊</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/weekly-02.html"><strong aria-hidden="true">25.3.</strong> 周刊-02</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/authentic-expression.html"><strong aria-hidden="true">25.4.</strong> 英语单词和专业词汇</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/knowledge-summary.html"><strong aria-hidden="true">25.5.</strong> 网上冲浪知识总结</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/zhihu.html"><strong aria-hidden="true">25.6.</strong> 知乎摘抄</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/story.html"><strong aria-hidden="true">25.7.</strong> 好的文章</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/principle-of-economics.html"><strong aria-hidden="true">25.8.</strong> 经济学原理学习</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/how-to.html"><strong aria-hidden="true">25.9.</strong> 如何</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/office-tricks.html"><strong aria-hidden="true">25.10.</strong> Office 三件套</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/movies.html"><strong aria-hidden="true">25.11.</strong> 看电影</a></li><li class="chapter-item expanded "><a href="life-and-thinking/keep-learning/daily-news.html"><strong aria-hidden="true">25.12.</strong> 每日新闻</a></li></ol></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/index.html"><strong aria-hidden="true">26.</strong> 安心立命</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life-and-thinking/peace/why.html"><strong aria-hidden="true">26.1.</strong> 为什么要学习</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/difference-between-east-and-west.html"><strong aria-hidden="true">26.2.</strong> 王德峰-中西文化差异</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/yangming.html"><strong aria-hidden="true">26.3.</strong> 王德峰-阳明心学</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/feat-and-practice.html"><strong aria-hidden="true">26.4.</strong> 王德峰-命运与修行</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/truly-maturity.html"><strong aria-hidden="true">26.5.</strong> 关于成熟</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/poetry.html"><strong aria-hidden="true">26.6.</strong> 古诗词摘抄</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-perface.html"><strong aria-hidden="true">26.7.</strong> 王德峰讲坛经-序言</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-01.html"><strong aria-hidden="true">26.8.</strong> 王德峰讲坛经-行由品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-02.html"><strong aria-hidden="true">26.9.</strong> 王德峰讲坛经-般若品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-03.html"><strong aria-hidden="true">26.10.</strong> 王德峰讲坛经-疑问品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-04.html"><strong aria-hidden="true">26.11.</strong> 王德峰讲坛经-定慧品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-05.html"><strong aria-hidden="true">26.12.</strong> 王德峰讲坛经-坐禅品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-06.html"><strong aria-hidden="true">26.13.</strong> 王德峰讲坛经-忏悔品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-07.html"><strong aria-hidden="true">26.14.</strong> 王德峰讲坛经-机缘品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-08.html"><strong aria-hidden="true">26.15.</strong> 王德峰讲坛经-顿悟品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-09.html"><strong aria-hidden="true">26.16.</strong> 王德峰讲坛经-护法品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-10.html"><strong aria-hidden="true">26.17.</strong> 王德峰讲坛经-付嘱品</a></li><li class="chapter-item expanded "><a href="life-and-thinking/peace/altar-sutra-wdf-finish.html"><strong aria-hidden="true">26.18.</strong> 王德峰讲坛经-结束语</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">wanshuo-gitbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="reading-modern-os"><a class="header" href="#reading-modern-os">Reading-Modern-OS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="如何学习操作系统"><a class="header" href="#如何学习操作系统">如何学习操作系统</a></h2>
<ul>
<li>结合生活，结合实践</li>
<li>结合 Linux / Windows 系统</li>
<li>学操作系统，可以沿着操作系统提供的系统调用这条线来学习</li>
</ul>
<h2 id="17-operating-system-structure"><a class="header" href="#17-operating-system-structure">1.7 Operating System Structure</a></h2>
<h3 id="microkernels"><a class="header" href="#microkernels">MicroKernels</a></h3>
<p>The basic idea behind the microkernel design is to achieve high reliability by splitting the operating system up into small, well-defined modules, only one of which—the microkernel—runs in kernel mode and the rest run as relatively powerless ordinary user processes.</p>
<p>微内核通常具有较高的<strong>可靠性和安全性</strong>，其内核精简，特别的，其将输入输出设备的<strong>驱动程序</strong>都作为用户进程来执行，单个驱动程序的崩溃并不会影响内核的运行。微内核的可靠性决定了其通常应用于<strong>工业级或军用级领域</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Mach_(kernel)">Mach microkernel</a> 通常被公认为最早的微内核实现，由卡耐基梅隆大学研发，主要用于分布式和并行计算。Mach 的最著名的衍生品为 MacOS X，也就是说，苹果电脑的操作系统采用了微内核。采用 MicroKernel 的操作系统有：Symbian，MacOS，<a href="reading/modern-os/www.minix3.org">MINIX 3</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章进程与线程"><a class="header" href="#第二章进程与线程">第二章：进程与线程</a></h1>
<p>[TOC]</p>
<h2 id="引入进程的重要性"><a class="header" href="#引入进程的重要性">引入进程的重要性</a></h2>
<p>进程概念的引入，使得多个任务可以在一个 CPU 上并发执行，<strong>实现了 CPU 的虚拟化</strong>，提高了 CPU 的利用率。</p>
<h2 id="进程processes"><a class="header" href="#进程processes">进程：Processes</a></h2>
<p><strong>Pseudoparallelism  伪并行</strong></p>
<p>在一个单核的操作系统中，任何一个时刻，CPU 都只在做一件事情，CPU 通过在多个任务之前来回切换，来实现进程的并发。</p>
<p>注意：pseudoparallelism 和 hardware parallelism of multiprocessor systems 有本质的区别，后者是真正的在多个 CPU 上进行并行计算。</p>
<h3 id="进程的定义-process-model-进程模型"><a class="header" href="#进程的定义-process-model-进程模型">进程的定义: Process Model 进程模型</a></h3>
<p><strong>进程就是运行在计算机上的任务</strong>。所有在计算机上执行的<strong>任务</strong>，包括<strong>操作系统</strong>，都被看做一个进程。In process model, each has its own virtual cpu.</p>
<p><strong>Program and Process 的区别</strong></p>
<p>Program 是静态的，而 process 是动态的。<strong>进程是运行着的程序</strong>。</p>
<h3 id="进程的创建process-creation"><a class="header" href="#进程的创建process-creation">进程的创建：Process Creation</a></h3>
<h4 id="操作系统中创建进程的几个场景"><a class="header" href="#操作系统中创建进程的几个场景">操作系统中创建进程的几个场景</a></h4>
<p>从创建进程的发起者角度，可以分为三个场景：</p>
<table><thead><tr><th>发起者</th><th>short-desc</th><th>desc</th></tr></thead><tbody>
<tr><td>操作系统</td><td>系统初始化创建大量进程</td><td>系统在初始化的时候，会创建大量的进程，有很多都是常驻后台的守护进程</td></tr>
<tr><td>进程</td><td>进程发起 process-creation 的系统调用，创建子进程</td><td>如果一个任务可以由多个进程协作，并且高效的完成时，进程就可以通过系统调用创建多个子进程，用于工作协同，加快效率</td></tr>
<tr><td>用户</td><td>用户请求创建一个进程</td><td>在类 Unix 系统中，用户可以通过在 shell 中输入命令，创建子进程；在 Windows 系统中，用户可以通过操作鼠标键盘，打开软件（创建进程）</td></tr>
</tbody></table>
<p>实际上，上述所有的进程创建，都是父进程通过<strong>发起创建进程的系统调用</strong>，由操作系统创建的子进程。区别在于，进程创建的发起者不同，是操作系统，还是正在运行的进程，还是用户。What that process does is execute a system call to create the new process.</p>
<h4 id="进程的分类"><a class="header" href="#进程的分类">进程的分类</a></h4>
<ol>
<li>
<p><strong>Background Process</strong> </p>
<p>后台进程，后台进程中有一类特殊的进程，类似邮件服务/Web服务/打印服务等任务叫做  <strong>daemons</strong>  （守护进程），Linux 中通过在 cmd 后面加上 <code>&amp;</code> 来实现后台进程，例如：<code>sleep 100&amp;</code></p>
</li>
<li>
<p><strong>Foreground Process</strong></p>
<p>前台进程，与用户交互，Linux 中的 shell 就是一个前台进程，用于和用户进行交互</p>
</li>
</ol>
<h4 id="创建进程的系统调用"><a class="header" href="#创建进程的系统调用">创建进程的系统调用</a></h4>
<ul>
<li>
<p>In Unix： <strong>fork</strong></p>
<p>在 Unix 系统中，只有唯一的一个系统调用：fork，用于创建进程</p>
<p>fork 会对发起系统调用的进程，创建一个<strong>完全一样的副本</strong>（相同的内存镜像，相同的环境变量），也就是 fork 一个子进程。例如用户在 shell 中输入 sort 命令，shell 进程就会 fork 一个子进程，然后执行 sort 命令。</p>
</li>
<li>
<p>In Windows: <strong>win32 function call: CreateProcess</strong></p>
<p>CreateProcess 用于创建进程，加载 program。该系统调用有 10 个参数。除了 CreateProcess，Windows 系统还提供了 100+ 个 function 用于管理进程。</p>
</li>
</ul>
<p>注意：子进程一旦创建，其地址空间（address space）相对于父进程就独立了，没有任何一块可写空间是共享的。<strong>Again, no writable memory is shared</strong>.  这也解释了，Linux 中 子 shell 对 父 shell 变量只读的机制。</p>
<h3 id="进程的终止process-termination"><a class="header" href="#进程的终止process-termination">进程的终止：Process Termination</a></h3>
<h4 id="进程终止的两种情况"><a class="header" href="#进程终止的两种情况">进程终止的两种情况</a></h4>
<ol>
<li><strong>自然终止</strong>：正常终止，异常终止 <strong>exit</strong></li>
<li><strong>非自然终止</strong>：致命错误导致的终止，被其他程序终止 <strong>kill</strong></li>
</ol>
<h4 id="进程终止的-system-call"><a class="header" href="#进程终止的-system-call">进程终止的 system call</a></h4>
<table><thead><tr><th></th><th>自然终止的 system call</th><th>被其他程序终止的 system call</th></tr></thead><tbody>
<tr><td>Unix</td><td>exit</td><td>kill</td></tr>
<tr><td>Windows</td><td>ExitProcess</td><td>TerminateProcess</td></tr>
</tbody></table>
<h3 id="进程的层次结构process-hierarchies"><a class="header" href="#进程的层次结构process-hierarchies">进程的层次结构：Process Hierarchies</a></h3>
<h4 id="linux-进程层级"><a class="header" href="#linux-进程层级">Linux 进程层级</a></h4>
<p>Linux 的进程都是单继承(Fork from 父进程)</p>
<p><img src="reading/modern-os/assets/1559723002837.png" alt="Linux 进程层次结构" /></p>
<p>Windows 没有进程层次的说法，所有的进程都是平等的。</p>
<h3 id="进程的状态process-states"><a class="header" href="#进程的状态process-states">进程的状态：Process States</a></h3>
<p>进程的三大状态：<strong>Running/Ready/Blocked</strong></p>
<p><img src="reading/modern-os/assets/1559725180702.png" alt="进程状态的切换" /></p>
<h3 id="进程的实现implementation-of-processes"><a class="header" href="#进程的实现implementation-of-processes">进程的实现：Implementation of Processes</a></h3>
<h4 id="process-control-block-pcb"><a class="header" href="#process-control-block-pcb">Process Control Block (PCB)</a></h4>
<p>进程控制块，其数据结构为 array。</p>
<p><img src="reading/modern-os/assets/1559870394755.png" alt="进程控制块" /></p>
<p>注意：</p>
<ul>
<li>一个进程在执行的过程中，可能会遇到上千个中断，关键在于，每次中断过后，进程能否精确恢复到中断之前的状态。（中断发生时，所有信息入栈，进入 Ready 状态，中断结束后，信息出栈，恢复 Runable 状态）</li>
<li>CPU 在运行时，也就是 process 在运行时，有大量的时间是花费在了 IO 上，举例来说，交互式进程 bash 的大多数时间就是被 IO 所阻塞(等待输入)</li>
</ul>
<h2 id="线程threads"><a class="header" href="#线程threads">线程：Threads</a></h2>
<h3 id="进程与线程的区别thread-usage"><a class="header" href="#进程与线程的区别thread-usage">进程与线程的区别：Thread Usage</a></h3>
<h4 id="从计算机角度冯诺伊曼架构的三个角度"><a class="header" href="#从计算机角度冯诺伊曼架构的三个角度">从计算机角度（冯诺伊曼架构的三个角度）</a></h4>
<ul>
<li>
<p><strong>存储</strong>：内存地址空间的差别</p>
<p>进程的<strong>地址空间</strong>的<strong>相互隔离</strong>的，而线程间的地址空间是<strong>共享</strong>的，这导致了进程之间<strong>切换</strong>和<strong>通信</strong>的代价远远大于线程直接的调度和通信，进程是拥有资源的基本单位，线程是 CPU 调度的基本单位。</p>
</li>
<li>
<p><strong>计算</strong>：并行计算 / 调度代价</p>
<ol>
<li>线程可以充分利用多核 CPU 进行并行计算</li>
<li>CPU 对于线程<strong>调度</strong>的代价也远远小于进程，线程更加轻量，更加 Lite，易于<strong>创建</strong>和<strong>销毁</strong>。在很多系统中，线程的速度，是进程的 10—100 倍</li>
</ol>
</li>
<li>
<p><strong>输入输出设备</strong></p>
<p>输入输出设备常常伴随着大量的 IO，有 IO 就会有阻塞，线程的出现解决了<strong>进程内 IO 阻塞</strong>导致主进程无法推进的问题</p>
</li>
</ul>
<h4 id="从程序员角度"><a class="header" href="#从程序员角度">从程序员角度</a></h4>
<p>线程的出现，使得程序员可以方便的对<strong>很多不同种类的业务逻辑进行解耦</strong>，以下不同的业务，都可以用线程解决，从而使得主进程不受影响：</p>
<ul>
<li>IO 型业务：键盘监听，文本读写</li>
<li>后台服务型业务：自动纠错，自动保存等</li>
</ul>
<h3 id="线程使用场景举例"><a class="header" href="#线程使用场景举例">线程使用场景举例</a></h3>
<h4 id="wps"><a class="header" href="#wps">WPS</a></h4>
<p>new a thread for 定时保存用户编辑的内容</p>
<p>new a thread for 监听用户键入的快捷键命令并相应</p>
<p>new a thread for 自动格式化用户刚输入的文本</p>
<p>……</p>
<h4 id="web-服务端"><a class="header" href="#web-服务端">Web 服务端</a></h4>
<p>服务端每接收到一个新的请求，就 new 一个 thread，如果服务端软件是单线程的，那么只会导致阻塞。</p>
<h3 id="线程介绍"><a class="header" href="#线程介绍">线程介绍</a></h3>
<p>线程和进程一样，也有运行，就绪，阻塞几种状态。每一个线程都有自己的<strong>栈</strong>，</p>
<h3 id="多线程介绍"><a class="header" href="#多线程介绍">多线程介绍</a></h3>
<p>多线程的执行和多进程的执行在单核 CPU 上比较相似，都是 CPU 在频繁的切换，造成并行的假象。多线程共用的是所属进程的资源，而多进程共享的是计算机硬件的资源。多线程之间<strong>共享</strong>其所属进程的<strong>所有资源</strong>，包括打开的文件，进程变量，子进程，信号量。举例来说，<strong>如果一个线程打开了一个文件，那么其他线程也可以进行文件内容的读写</strong>。</p>
<p>资源共享也带来一个问题，如何进行多线程之间的协同？</p>
<h2 id="进程间通信interprocess-communication-ipc"><a class="header" href="#进程间通信interprocess-communication-ipc">进程间通信：InterProcess Communication (IPC)</a></h2>
<p>IPC 方式：信号量、管道、消息队列、共享存储</p>
<p><strong>进程间通信包括进程间的同步和互斥</strong>：</p>
<ol>
<li>多个进程间传递信息 </li>
<li>多个进程间如何进行同步协作 （生产者消费者）</li>
<li>多个进程间如何进行互斥（互斥访问临界区）</li>
</ol>
<p>另外，进程间的通信的三种问题，同样适用于线程。</p>
<h3 id="race-condition-竞争"><a class="header" href="#race-condition-竞争">Race Condition （竞争）</a></h3>
<p>进程间共享存储会导致 race condition 的问题，当多个进程同时读写同一块共享空间时（例如往打印机的 spooler 中写入待打印的内容），可能会因为中断等原因导致 race condition 问题，尤其在并发率非常高的情况下，race condition 问题尤为严重。</p>
<p><img src="reading/modern-os/assets/1566702916353.png" alt="Race condition: 打印机" /></p>
<h3 id="critical-region临界区"><a class="header" href="#critical-region临界区">Critical Region（临界区）</a></h3>
<p>一个进程在运行内部计算，没有访问共享资源的时候，并不会产生竞争，只有进程访问共享资源的那部分代码才会产生竞争，我们将访问共享资源的代码块叫做 Critical Region，中文叫做临界区。</p>
<h3 id="如何避免-race-condition"><a class="header" href="#如何避免-race-condition">如何避免 Race Condition</a></h3>
<ul>
<li>在进入临界区后，关掉中断 （从根本上解决中断带来了 Race Condition）</li>
<li>变量锁 （同样会导致 Race Condition）</li>
<li>Peterson’s solution </li>
</ul>
<p>以上这些措施，都会因为进程陷入忙等（CPU循环测试）而浪费 CPU 的时间。正确的方法是，在进程无法进入临界区的时候，应该让进程进入阻塞状态。最简单的方法是，用操作系统提供的系统调用：<strong>Sleep</strong> 和 <strong>Wakeup</strong>。</p>
<p><strong>Sleep</strong>：使进程进入阻塞状态，挂起</p>
<p><strong>Wakeup</strong>：唤醒进程，使进程进入就绪状态</p>
<h3 id="生产者消费者问题"><a class="header" href="#生产者消费者问题">生产者消费者问题</a></h3>
<p>生产者消费者问题，本质上就是一个进程间通信的问题，生产者进程和消费者进程之间共享了一块存储空间。</p>
<p>生产者消费者问题的一个错误实现：</p>
<pre><code class="language-C">#define N 100 /* number of slots in the buffer */
int count = 0; /* number of items in the buffer */
void producer(void){
    int item;
    while (TRUE) { /* repeat forever */
        item = produce item( ); 	/* generate next item */
        if (count == N) sleep( ); 	/* if buffer is full, go to sleep */
        insert_item(item);	 	/* put item in buffer */
        count = count + 1; 		/* increment count of items in buffer */
        if (count == 1) wakeup(consumer); /* was buffer empty? */
    }
}

// 在实践中，生产者和消费者实际上是两个进程
void consumer(void){
    int item;
    while (TRUE) { /* repeat forever */
        if (count == 0) sleep( ); /* if buffer is empty, got to sleep */
        item = remove_item( ); /* take item out of buffer */
        count = count − 1; /* decrement count of items in buffer */
        if (count == N − 1) wakeup(producer); /* was buffer full? */
        consume item(item); /* print item */
    }
}
</code></pre>
<p>上面这个例子中，假设 buffer 为空，此时消费者已经读取了 count 的值，用来判断 buffer 是否为空，但是此时操作系统进行了一次调度，将执行权交给了生产者。生产者生产产品后放入 buffer 并唤醒消费者，但是，当执行权切换到消费者时，由于其已经读取了 count 的值（为0），所以仍然会进入 sleep。生产者由于无法唤醒消费者，当 buffer 放满了商品后，也会进入睡眠，这就违反了空闲让进的原则。</p>
<h3 id="semaphore-信号量"><a class="header" href="#semaphore-信号量">semaphore 信号量</a></h3>
<p><strong>原子操作</strong></p>
<p>一批指令，要么在没有遇到中断的情况下全部执行完，如果中途遇到中断了，则全部不执行，已经执行的撤销。</p>
<p><strong>Semaphore</strong></p>
<p>信号量是一种<strong>变量类型</strong>，这种变量只能通过 P，V 进行减少获增加，而且 P，V 操作是<strong>原子操作</strong>，防止在执行过程中出现中断导致 Race Condition。</p>
<p>P：判断信号量是否为 0，如果不为 0，则信号量减一，如果为 0，则使得进程进入 sleep 状态</p>
<p>V：判断信号量是否为 N，如果不为 N，则信号量加一，如果为 N，则使进程进入 sleep 状态</p>
<pre><code class="language-C">#define N 100 /* number of slots in the buffer */
typedef int semaphore; /* semaphores are a special kind of int */
semaphore mutex = 1; /* controls access to critical region */
semaphore empty = N; /* counts empty buffer slots */
semaphore full = 0; /* counts full buffer slots */
void producer(void){
    int item;
    while (TRUE) { /* TRUE is the constant 1 */
        item = produce item( ); /* generate something to put in buffer */
        down(&amp;empty); /* decrement empty count */
        down(&amp;mutex); /* enter critical region */
        inser t item(item); /* put new item in buffer */
        up(&amp;mutex); /* leave critical region */
        up(&amp;full); /* increment count of full slots */
    }
}
void consumer(void){
    int item;
    while (TRUE) { /* infinite loop */
        down(&amp;full); /* decrement full count */
        down(&amp;mutex); /* enter critical region */
        item = remove item( ); /* take item from buffer */
        up(&amp;mutex); /* leave critical region */
        up(&amp;empty); /* increment count of empty slots */
        consume item(item); /* do something with the item */
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter7-virtualization-and-cloud"><a class="header" href="#chapter7-virtualization-and-cloud">Chapter7. Virtualization and Cloud</a></h1>
<p>[TOC]</p>
<h2 id="云计算"><a class="header" href="#云计算">云计算</a></h2>
<h3 id="什么是云计算"><a class="header" href="#什么是云计算">什么是云计算</a></h3>
<p><strong>对用户来说</strong>，云计算就是像水电一样提供计算资源。未来，算力和水电一样，应该是按需收费的。目前，大多数年轻人人手一部智能手机，但是我们的手机大多数时间都在待机，这其实是非常浪费资源的，最佳的资源分配方法，是我们的手机连上云端，所有的计算和存储，都由云计算完成。</p>
<p><strong>对开发者来说</strong>，云计算就是对硬件资源进行虚拟化和管理。物理机 虚拟化为 虚拟机，本质上是操作系统虚拟化的知识。</p>
<h3 id="云计算分类iaaspaassaas"><a class="header" href="#云计算分类iaaspaassaas">云计算分类：IaaS，PaaS，SaaS</a></h3>
<table><thead><tr><th></th><th>全称</th><th>Demo</th></tr></thead><tbody>
<tr><td>IaaS</td><td>Infrastructure as a Service</td><td>阿里云申请的虚拟机（实体）</td></tr>
<tr><td>PaaS</td><td>Platform as a Service</td><td>Google App Engine(GAE)，Aws Lambda，Azure Pipelines，Sina App Engine</td></tr>
<tr><td>SaaS</td><td>Software as a Service</td><td>手机 App</td></tr>
</tbody></table>
<p>从上到下，用户需要关注的自主权越来越小，需要关注的细节越来越少。</p>
<img align="left" src="reading/modern-os/assets/image-20220120182148872.png" alt="image-20220120182148872" style="zoom:50%;" />
<p>浅色的是自己需要管理的部分，深色的是不用自己操心的。</p>
<h3 id="云计算的分类"><a class="header" href="#云计算的分类">云计算的分类</a></h3>
<p>公有云，私有云，混合云</p>
<h3 id="学习资料"><a class="header" href="#学习资料">学习资料</a></h3>
<ul>
<li><a href="reading/modern-os/">Modern Operation System Chapter7: Virtualization and Cloud</a></li>
<li><a href="reading/modern-os/">Docker</a></li>
</ul>
<p>先搞定上面两个知识</p>
<h3 id="openstack"><a class="header" href="#openstack">OpenStack</a></h3>
<p>OpenStack 是用来创建公有云和私有云的开源云操作系统。OpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions"><a class="header" href="#questions">Questions</a></h1>
<h2 id="chapter2-process-and-threads"><a class="header" href="#chapter2-process-and-threads">Chapter2. Process-and-Threads</a></h2>
<ul>
<li>进程的引入，给操作系统带来了什么</li>
<li>进程并发的本质是什么</li>
<li>进程与程序的区别</li>
<li>创建进程的几个场景</li>
<li>进程创建的本质，父进程与子进程的关系</li>
<li>Unix / Windows 系统创建进程的系统调用</li>
<li>进程的分类并举例，Linux 中如何实现后台进程，什么是 daemon</li>
<li>进程自然终止和非自然终止的系统调用</li>
<li>Linux / Windows 系统进程的层次结构</li>
<li>进程的状态以及切换场景</li>
<li>进程的实现</li>
<li>线程和进程的区别，从两个大的角度来考虑</li>
<li>线程的使用场景举例</li>
<li>进程间通信可以被解释成哪三种问题</li>
<li>什么是临界区，什么是 Race Condition，什么原因会导致 Race Condition</li>
<li>忙等的缺点是什么，如何才能避免进程进入忙等状态</li>
<li>生产者消费者问题本质上是一个什么问题</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluent-python"><a class="header" href="#fluent-python">Fluent-Python</a></h1>
<p>本人学习 <a href="https://book.douban.com/subject/26278021/">Fluent-Python</a> 的读书笔记，结合我的 Python 编程经验，记录了一些我认为重要的 Python 知识点（很多暂时用不到的知识点，没有学习）。</p>
<p>笔记想要传达出的思想和书的宗旨一样，致力于写出地道的 / 高效的 Python 代码（即 Fluent），仅此而已。</p>
<h2 id="python-学习资源"><a class="header" href="#python-学习资源">Python 学习资源</a></h2>
<ul>
<li><a href="https://github.com/gto76/python-cheatsheet">Python Cheatsheet</a></li>
</ul>
<h2 id="pep20-the-zen-of-python"><a class="header" href="#pep20-the-zen-of-python">PEP20 The Zen of Python</a></h2>
<pre><code>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>
<h2 id="next-reading"><a class="header" href="#next-reading">Next Reading</a></h2>
<ul>
<li>对书中记录的大佬和经典书籍/参考文献进行详细深入的了解</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapters"><a class="header" href="#chapters">Chapters</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter1-the-python-data-model"><a class="header" href="#chapter1-the-python-data-model">Chapter1. The Python Data Model</a></h1>
<p>[TOC]</p>
<h2 id="special--magic--dunder-methods"><a class="header" href="#special--magic--dunder-methods">special / magic / dunder methods</a></h2>
<p>Python 最大的特性，在于其语言的一致性。其定义了大量的与自然语言相近的魔法方法，用来保证语言的统一和一致性。当我们接触一个新的 Python 包时，我们能根据这些魔法方法，快速上手这个 Python 包。</p>
<p>魔法方法分为两类：</p>
<ul>
<li>
<p>magic method</p>
<table><thead><tr><th style="text-align: left">magic method</th><th style="text-align: left">built-in method</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>__str__</code></td><td style="text-align: left"><code>str()</code></td></tr>
<tr><td style="text-align: left"><code>__len__</code></td><td style="text-align: left"><code>len()</code></td></tr>
<tr><td style="text-align: left"><code>__int__</code></td><td style="text-align: left"><code>int()</code></td></tr>
</tbody></table>
</li>
<li>
<p>magic method for operators</p>
<table><thead><tr><th style="text-align: left">magic method for operators</th><th style="text-align: left">built-in operator</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>__and__</code></td><td style="text-align: left"><code>and</code></td></tr>
<tr><td style="text-align: left"><code>__or__</code></td><td style="text-align: left"><code>or</code></td></tr>
<tr><td style="text-align: left"><code>__add__</code></td><td style="text-align: left"><code>+</code></td></tr>
</tbody></table>
</li>
</ul>
<p><strong>魔法方法的优点</strong>：</p>
<ul>
<li>
<p>魔法方法统一了常见的语法规则</p>
<p>用户不需要再去记忆，对于获取一个对象的长度，究竟是用 .length() 还是 .size()</p>
</li>
<li>
<p>实现了魔法方法的类可以方便的调用 Python 丰富的标准库（不需要自己重复造轮子，<strong>Python 使用 Magic method 来实现多态</strong>）</p>
<p>例如，通过实现 <code>__len__</code> 和 <code>__getitem__</code> 这两个魔法方法，该类就拥有了 list 特性，几乎所有 list 的方法都能适用</p>
</li>
<li>
<p>魔法方法的执行速度很快（其由 Python 解释器直接执行）</p>
<p>Python 解释器会将 built-in 方法解释成其对应的 <code>__method__</code>魔法实现，然后执行这些魔法方法，Python解释器是这些魔法方法最频繁的执行者。</p>
</li>
</ul>
<p>通过实现这些魔法方法，使得我们自定义的类，能够像 Python 的 built-in 类型一样用起来很方便。当我们想要创建一个新的类时，我们不仅要考虑其继承自哪些类，更要考虑，要实现哪些魔法方法，Python 的多态！</p>
<p>通常情况下，我们应该去实现魔法方法，而不是去直接调用这些方法，尽管我们可以直接调用。只有一个魔法方法比较特殊：<code>__init__</code>用来调用父类的 init 方法</p>
<h3 id="magic-methods-demo构造向量"><a class="header" href="#magic-methods-demo构造向量">Magic methods Demo：构造向量</a></h3>
<pre><code class="language-python">import math

class Vector():

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __bool__(self):
        return bool(abs(self))

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __mul__(self, other):
        return Vector(self.x * other, self.y * other)

    def __repr__(self):
        return &quot;vector(&quot; + str(vector.x) + &quot;, &quot; + str(vector.y) + &quot;)&quot;

    def __str__(self):
        &quot;&quot;&quot;
        __str__ 定义后，print(object) 会被 Python 解释器解释成 print(str(object))
        如果没有定义 __str__，那么 print(object) 和 str(object) 会被解释成 __repr__(object)
        如果连 __repr__ 也没有定义，那么就会打印一个对象 0x 值
        通常情况下，只需要定义 __repr__ 即可
        :return:
        &quot;&quot;&quot;
        return &quot;hehe&quot;

vector = Vector(3, 4)
print(abs(vector))
print(str(vector))
print(vector)
print(bool(vector))

5.0
hehe
hehe
True
</code></pre>
<h2 id="duck-typing"><a class="header" href="#duck-typing">Duck Typing</a></h2>
<blockquote>
<p><strong>Duck typing</strong> in computer programming is an application of the <a href="https://en.wikipedia.org/wiki/Duck_test">duck test</a>—&quot;If it walks like a duck and it quacks like a duck, then it must be a duck&quot;—to determine if an [object](<a href="https://en.wikipedia.org/wiki/Object_%28computer_science">https://en.wikipedia.org/wiki/Object_(computer_science</a>)) can be used for a particular purpose. With normal typing, suitability is determined by an object's type. In duck typing, an object's suitability is determined by the presence of certain [methods](<a href="https://en.wikipedia.org/wiki/Method_%28computer_programming">https://en.wikipedia.org/wiki/Method_(computer_programming</a>)) and properties, rather than the type of the object itself.<a href="https://en.wikipedia.org/wiki/Duck_typing#cite_note-1">[1]</a></p>
<p>如果它走起来像一只鸭子，叫声也像一只鸭子，那么它就是一个鸭子。</p>
<p>举例来说，如果一个类实现了 <code>__len__()</code> 方法和 <code>__getitem__()</code> 两个 magic method, 那么该类就是一只list</p>
</blockquote>
<p><strong>Duck Typing</strong> is used to to determine if an object can be used for a particular purpose. 鸭子模型通常用于实现动态语言的<strong>多态</strong>。</p>
<p><strong>Python 如何实现多态</strong></p>
<p>大多数面向对象的编程语言，其<strong>多态</strong>的实现是因为某一类的对象都继承自一个 father，某一个类的特征也取决于该类的继承、接口及其自身的特征。而 Python 这一类语言不同，其多态的实现，可能是因为其类中实现了某一个特定的方法，使得该类拥有某一类特性。例如：</p>
<ul>
<li>
<p>通过实现 <code>__len__</code> 和 <code>__getitem__</code> 这两个魔法方法，我们自定义的类，就是一个 list，就可以拥有 list 的全部特性</p>
</li>
<li>
<p>字典的 <code>update()</code> 方法，其接受任何有 mapping 或 iterating 特性的对象</p>
<p>首先判断接收的对象是否有 <code>keys()</code> 方法，如果有，则把它当成一只鸭子(mapping)，否则再尝试 iterate 该对象，如果可以 iterate，那么就假定该对象中的元素为 元组对(key, value)。</p>
</li>
<li>
<p><code>lst.extend()</code> 方法可以接受任何 iterating 的对象</p>
</li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<h3 id="in-与-__contains__-的关系"><a class="header" href="#in-与-__contains__-的关系"><code>in</code> 与 <code>__contains__()</code> 的关系</a></h3>
<p>如果不实现 <code>__contains__</code> 方法，那么 in 的操作，就会在 list 中做一个顺序遍历</p>
<h3 id="__repr__-和-__str__-的区别"><a class="header" href="#__repr__-和-__str__-的区别"><code>__repr__</code> 和 <code>__str__</code> 的区别</a></h3>
<ul>
<li>
<p><code>repr()</code> 会被解释成 <code>__repr__()</code>，repr 是 representation 的缩写，<code>str()</code> 会被解释成 <code>__str__()</code></p>
</li>
<li>
<p><code>print()</code> 会隐式调用 <code>__str__()</code></p>
</li>
<li>
<p><code>__repr__</code> 是对 object 的字符串描述，<code>__str__</code> 是 <code>str()</code>的魔法方法，并且 <code>print(object)</code>会默认被解释成 <code>print(__str__(object))</code></p>
</li>
<li>
<p>优先实现 <code>__repr__()</code> 方法。如果没有实现 <code>__str__</code>，那么 Python 解释器会默认调用 <code>__repr__</code> 方法，所以 <code>__repr__</code> 方法更通用</p>
</li>
<li>
<p><code>__repr__</code> 在 debugging 和 logging 时会调用，是面向开发者的，<code>__str__</code> 通常用于终端用户的字符描述，是面向终端用户的</p>
</li>
</ul>
<h3 id="__bool__-方法与-__len__-的关系"><a class="header" href="#__bool__-方法与-__len__-的关系"><code>__bool__</code> 方法与 <code>__len__</code> 的关系</a></h3>
<p><code>bool(object)</code> 会被解释成 <code>object.__bool__()</code>，如果 <code>__bool__()</code> 方法没有被定义，那么 Python 解释器会尝试调用 <code>object.__len__()</code>方法，如果返回结果为0，则为 false. 这也解释了，为什么，对空的 list 和 set 取 bool 值时，返回的结果为 false。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter2-an-array-of-sequences"><a class="header" href="#chapter2-an-array-of-sequences">Chapter2. An Array of Sequences</a></h1>
<p>从第二章开始，一直到第四章，都是在研究 Python 的数据结构。</p>
<p>[TOC]</p>
<h2 id="built-in-sequences"><a class="header" href="#built-in-sequences">Built-in Sequences</a></h2>
<p>Python 中的 Sequences 按照不同 traits(特征)，可以分成很多类</p>
<p><strong>分类依据</strong>: 是否为混合类型 mix-type</p>
<ul>
<li>
<p>Contrainer Sequences</p>
<p>Demo: <code>list, tuple, collections.deque</code></p>
</li>
<li>
<p>Flat Sequences</p>
<p>Demo: <code>str, bytes, bytearray, memoryview, array.array</code></p>
<p>优点：节约内存，速度快，便于使用</p>
<p>缺点：只能存储原子数据</p>
</li>
</ul>
<p><strong>分类依据</strong>: 元素是否可变</p>
<ul>
<li>
<p>Mutable Sequences</p>
<p>Demo: <code>list, bytearray, array.array, collections.deque, memoryview</code></p>
</li>
<li>
<p>Immutable Sequences</p>
<p>Demo: <code>str, tuple, bytes</code></p>
</li>
</ul>
<p>注意，字符串 str 也是 sequence 类型。</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Mastering the standard library sequence types is a prerequisite for writing concise effective, and idiomatic Python code.</li>
</ul>
<h2 id="sequences-常用方法"><a class="header" href="#sequences-常用方法">Sequences 常用方法</a></h2>
<table><thead><tr><th style="text-align: left">方法</th><th style="text-align: left">解释</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>clear()</code></td><td style="text-align: left">clear all items</td></tr>
<tr><td style="text-align: left"><code>__contains__()</code></td><td style="text-align: left">in</td></tr>
<tr><td style="text-align: left"><code>copy</code></td><td style="text-align: left">shallow copy</td></tr>
<tr><td style="text-align: left"><code>count</code></td><td style="text-align: left">count occurences of an element</td></tr>
<tr><td style="text-align: left"><code>extend</code></td><td style="text-align: left"><code>list1.extend(list2)</code></td></tr>
<tr><td style="text-align: left"><code>index</code></td><td style="text-align: left"><code>list1.index(&quot;wansho&quot;)</code> find position of first occurence of e</td></tr>
<tr><td style="text-align: left">insert(p, e)</td><td style="text-align: left">insert item e before the position p</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>[0] * 5</code>  <code>&quot;abc&quot; * 5</code> create a new object</td></tr>
<tr><td style="text-align: left"><code>pop</code></td><td style="text-align: left">remove the last item or pop optional item in position p: <code>pop([p])</code></td></tr>
<tr><td style="text-align: left"><code>remove(e)</code></td><td style="text-align: left">remove first occurence of element e by value</td></tr>
<tr><td style="text-align: left"><code>reverse()</code></td><td style="text-align: left">reverse the order of items in place.(原地逆置)</td></tr>
<tr><td style="text-align: left"><code>sort([key], [reverse])</code></td><td style="text-align: left">sort items in place with optional keyword arguments key and reverse</td></tr>
</tbody></table>
<p>注意，以上方法并不适用于全部的 sequence，但是都适用于 list</p>
<h2 id="slicing"><a class="header" href="#slicing">Slicing</a></h2>
<p>所有的 sequence 都支持 slicing。</p>
<h3 id="why-slices-and-range-exclude-the-last-item"><a class="header" href="#why-slices-and-range-exclude-the-last-item">Why slices and range exclude the last item</a></h3>
<p>主要原因是(排除历史原因)，sequence 都是从 0 开始索引的，所以不包含最后一个 item，有几个好处：</p>
<ul>
<li>
<p>能方便地知道 range 生成的 list 和 slice 截取的<strong>长度</strong></p>
<pre><code class="language-python">range(3) # 生成一个长度为 3 的list
my_list[: 3] # 截取一个长度为 3 的片段
</code></pre>
</li>
<li>
<p>能方便地计算出 slice 后的 sequence <strong>长度</strong></p>
<pre><code class="language-python">my_list[3: 9] # 其长度就是 9 - 3 = 6
</code></pre>
</li>
</ul>
<h3 id="slicing-技巧"><a class="header" href="#slicing-技巧">Slicing 技巧</a></h3>
<pre><code class="language-python">s = &quot;bicycle&quot;
s[::3] # bye
s[::-1] # 逆序输出
s[start: stop: step]
</code></pre>
<h3 id="slice-object"><a class="header" href="#slice-object">Slice Object</a></h3>
<p>如果我们想要复用一些 slice 规则，可以将规则封装成 slice object:</p>
<pre><code class="language-python">list1 = &quot;abcdefg&quot;
slice_object = slice(0, len(list1), 2)
list1[slice_object] # 'aceg'
</code></pre>
<h3 id="assigning-to-slices"><a class="header" href="#assigning-to-slices">Assigning to Slices</a></h3>
<pre><code class="language-python">my_list = list(range(9))
my_list[2: 6] = [10, 20] #这条语句执行后，my_list 的第 3 到 第 6 个一共 4 个 element，会被替换成 10， 20，相当于用两个 element 替换了 4 个 element

# 删除一部分数据
my_list[2: 5] = []

# 注意：右边的赋值对象，必须是 iterable 的
</code></pre>
<h3 id="负数-index"><a class="header" href="#负数-index">负数 index</a></h3>
<p><img src="reading/fluent-python/chapters/assets/1565832923247.png" alt="负数 index" /></p>
<h2 id="-导致的指针混淆问题"><a class="header" href="#-导致的指针混淆问题"><code>*</code> 导致的指针混淆问题</a></h2>
<h3 id="两次相乘导致所有元素指针指向同一个内存地址"><a class="header" href="#两次相乘导致所有元素指针指向同一个内存地址">两次相乘导致所有元素指针指向同一个内存地址</a></h3>
<p>下面的两组代码，其利用 <code>*</code> 生成的 list 是不同的：</p>
<pre><code class="language-python">list1 = [[&quot;_&quot;] * 3 for i in range(3)]

list2 = [[&quot;_&quot;] * 3] * 3
# list1 和 list2 的打印结果是一样的，但是，其在内存中的却天差地别

list1[2][2] = &quot;X&quot;
print(list1) 
# [[&quot;_&quot;, &quot;_&quot;, &quot;_&quot;], [&quot;_&quot;, &quot;_&quot;, &quot;_&quot;], [&quot;_&quot;, &quot;_&quot;, &quot;X&quot;]]

list2[2][2] = &quot;X&quot;
print(list2)
# [[&quot;_&quot;, &quot;_&quot;, &quot;X&quot;], [&quot;_&quot;, &quot;_&quot;, &quot;X&quot;], [&quot;_&quot;, &quot;_&quot;, &quot;X&quot;]]

# 实际上，list2 中的三个元素，在内存中是一个元素，* 3 只是 new 了 3 个不同的指针，指向了这一个元素

# 实际上，这个问题，我还没有完全搞懂，下面还有一个Demo
my_list = [&quot;a&quot;] * 3
my_list[0] = b
print(my_list) = [&quot;b&quot;, &quot;a&quot;, &quot;a&quot;]
# 上面这个例子，貌似证明了，只有在两次相乘的时候，才会出现这种指针混淆的问题
</code></pre>
<h3 id="-"><a class="header" href="#-"><code>+=</code> <code>*=</code></a></h3>
<p><code>+=</code> <code>*=</code> 可以实现对于 mutable sequence 的 in-place 操作，具体可以看 <a href="reading/fluent-python/chapters/../summary/python-code-optimization.html">Python-Code-Optimization.</a></p>
<h2 id="list-comprehensions-and-generator-experssion"><a class="header" href="#list-comprehensions-and-generator-experssion">List Comprehensions and Generator Experssion</a></h2>
<p><strong>列表推导式 listcomps 和 生成器表达式 genexps</strong></p>
<h3 id="list-comperhensionlistcomp"><a class="header" href="#list-comperhensionlistcomp">List Comperhension(listcomp)</a></h3>
<p>列表推导式的作用：to build a new list</p>
<h4 id="列表推导式中变量的生效范围"><a class="header" href="#列表推导式中变量的生效范围">列表推导式中变量的生效范围</a></h4>
<p>在 Python 2.x 中，列表推导式中定义的临时变量会污染全局的同名变量，例如：</p>
<pre><code class="language-python">x = &quot;my sweat&quot;
my_list = [x for x in &quot;ABC&quot;]
print(x)

# 结果为 C
</code></pre>
<p>Python 3.x 对此进行了优化，</p>
<pre><code class="language-python">x = &quot;ABC&quot;
my_list = [ord(x) for x in x]
print(x) # &quot;ABC&quot;
print(my_list) # [65,66,67]
</code></pre>
<p>列表推导式中的变量，在 Python3.x 后，有了自己的作用域，即使与括号外的变量重名，也不会混淆。这使得列表推导式更像函数。</p>
<h4 id="列表推导式与-map--filter"><a class="header" href="#列表推导式与-map--filter">列表推导式与 map / filter</a></h4>
<ul>
<li><strong>列表推导式可以替换 map 和 filter，任何 map 和 filter 能做到的操作，列表推导式都能做到</strong></li>
<li>列表推导式的速度，并不比 map 和 filter 慢</li>
</ul>
<h4 id="cartesian-products-笛卡尔积"><a class="header" href="#cartesian-products-笛卡尔积">Cartesian Products 笛卡尔积</a></h4>
<p>列表推导式可以根据多个列表生成一个笛卡尔积，通常是两个列表。Demo:</p>
<pre><code class="language-python">colors = [&quot;red&quot;, &quot;blue&quot;]
sizes = [&quot;M&quot;, &quot;S&quot;]

tshirts = [(size, color) for size in sizes
                           for color in colors]

# 集合采用 {}
numbers = [1,2,3,3,4,5,5,6,6,7,7]
distinct_numbers = {number for number in numbers} 
distinct_numbers
</code></pre>
<h3 id="generator-experssion-genexp"><a class="header" href="#generator-experssion-genexp">Generator Experssion (genexp)</a></h3>
<p>生成器表达式的语法和列表推导式的语法几近相同，唯一的区别在于列表推导式使用 <code>[] {}</code>，而生成表达式使用 <code>()</code></p>
<p><strong>genexp 更加节省内存</strong>，其会用 Iterator 迭代器一个接着一个地生成元素。Demo:</p>
<pre><code class="language-python">colors = [&quot;red&quot;, &quot;blue&quot;]
sizes = [&quot;M&quot;, &quot;S&quot;]

for tshirt in (&quot;{color} {size}&quot;.format(color=color, size=size) for color in colors
                                                               for size in sizes)
</code></pre>
<p>相比 listcomp，genexp不会一次性把 colors 和 sizes 全部读入内存，而是一个接着一个地读取。</p>
<h2 id="tuple"><a class="header" href="#tuple">Tuple</a></h2>
<p>读作：ta pao</p>
<p>Tuple 不仅仅是一个 immutable list，其更多时候充当着 <strong>record</strong> 的角色，从数据库中读取的数据，通常都放在 tuple 中。</p>
<p>元组的特殊定义方式:</p>
<pre><code class="language-python">my_tuple = 1, 2, 3, 4
# 等价于
my_tuple = (1, 2, 3, 4)
</code></pre>
<p>注意：</p>
<ul>
<li>在 tuple 中加入 mutable 的元素，是不建议的，容易触发异常</li>
</ul>
<h3 id="元组加法"><a class="header" href="#元组加法">元组加法</a></h3>
<p>与 list 的 += 不同，元组相加会产生一个新的 tuple，因为 tuple is immutable</p>
<pre><code class="language-Python">t1 = (1, 2, 3)
print(id(t1)) # 2318927351672
t1 += (4, 5)
print(id(t1)) # 2318925585576
</code></pre>
<h3 id="tuple-的两个应用场景"><a class="header" href="#tuple-的两个应用场景">Tuple 的两个应用场景</a></h3>
<ul>
<li>不可更改的 immutable list</li>
<li>record：(经度, 纬度) (用户名, 密码)（从数据库中读取出来的数据）</li>
</ul>
<h3 id="tuple-unpacking-元组拆包"><a class="header" href="#tuple-unpacking-元组拆包">Tuple unpacking 元组拆包</a></h3>
<p>两种 tuple unpacking 的方式：</p>
<pre><code class="language-python"># 第一种
city, year, pop, chg, area = (&quot;Tokyo&quot;, 2003, 32450, 0.66, 8014)
# list 也可以 unpacking
a, b, c = [1, 2, 3]

# 第二种
traveler_ids = [(&quot;USA&quot;, &quot;123456&quot;), (&quot;CHINA&quot;, &quot;1222&quot;)]
for passport in sorted(traveler_ids):
    print(&quot;%s/%s&quot;, passport)
</code></pre>
<p>元组拆包性质多用于对于元素为元组的 sequence 的遍历：</p>
<pre><code class="language-python"># 获取每个元组的第一个元素
list1 = [(1,2,3), (3,4,5), (4,5,6)]
for a, *others in list1:
    print(a)
    print(others) # [2,3] [4,5] [5,6]
</code></pre>
<p>tuple unpacking 的一个优雅的应用：交换两个数的值</p>
<pre><code class="language-python">a, b = b, a
# 实际上，右边的 b, a 是一个元组，将右边的元组 unpack 到左边
</code></pre>
<p>注意，当我们想要获取 tuple 的元素时，对其进行 unpacking 是最快速的方式。<code>*</code> 可以帮助我们更方便的 unpacking，忽略不重要的字段，保留我们想要处理的字段，例如：</p>
<pre><code class="language-python">tuple1 = 1,2,3,4,5
a, *b, c = tuple1
print(a, c) #
</code></pre>
<p><code>*</code> 的 unpacking 属性，多用于函数的参数定义</p>
<h3 id="relative-immutability-of-tuples"><a class="header" href="#relative-immutability-of-tuples">Relative Immutability of Tuples</a></h3>
<p>Tuple 并不是完全 immutable 的，我们可以看一下这个例子：</p>
<pre><code class="language-Python">t1 = (1, 2, [1, 2])
t1[2].append(3)
t1
(1, 2, [1, 2, 3])

hash(t1) # 不可 hash
Traceback (most recent call last):
  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<h3 id="namedtuple"><a class="header" href="#namedtuple">NamedTuple</a></h3>
<p><code>collections.namedtuple</code> 可以帮助我们创建一个带有字段名的 tuple（数据结构类似于两个 tuple，一个放字段名，一个放对应的值）。</p>
<pre><code class="language-python">from collections import namedtuple
City = namedtuple(&quot;City&quot;, &quot;name country population coordinates&quot;) # 创建了一个 City 类
# namedtuple 需要传入两个参数，第一个参数是 classname, 第二个参数是 a list of field names, 也可以传入带空格的字符串, 注意：通常类命要大写
tokyo = City(&quot;Tokyo&quot;, &quot;JP&quot;, 36.3, (35.789772, 139,691667))
# 通过 字段名 或者 position 获取字段值  
print(tokyo) # City(name=&quot;Tokyo&quot;, country=&quot;JP&quot;, population=...)
print(tokyo.name) # Tokyo
print(tokyo.country) # JP
print(tokyo[0]) # Tokyo，这个特性更像是 tuplej
</code></pre>
<p><code>namedtuple</code> <strong>的使用场景</strong>：</p>
<ol>
<li><strong>用来快速创建一个只包含属性（不包含方法）的类</strong></li>
<li>存储从数据库中读取的数据。</li>
</ol>
<p><code>namedtuple</code>的几个属性和方法：</p>
<pre><code class="language-python">tokyo._fields # 返回字段列表

tokyo_data = (&quot;Tokyo&quot;, &quot;JP&quot;, 36.3, (35.789772, 139,691667)
tokyo = City._make(tokyo_data) # generate a element
</code></pre>
<h3 id="dummy-variable-虚拟变量"><a class="header" href="#dummy-variable-虚拟变量">dummy variable 虚拟变量</a></h3>
<pre><code class="language-python">import os
_, filename = os.path.split(&quot;/home/work/test.h&quot;)
print(filename) # test.h

# 其中 _ 就是一个虚拟变量，其更多时候充当一个占位符的角色，可以是任何字符串
</code></pre>
<h3 id="-号的作用"><a class="header" href="#-号的作用"><code>*</code> 号的作用</a></h3>
<ol>
<li>
<p>unpacking tuple or str for positional arguments: <strong>将 tuple 解包用于位置参数</strong></p>
<pre><code class="language-python">t = (20, 8)
divmod(*t) # 注意 divmod 必须传入两个参数，如果我们不加 t，那么只会传入一整个 tuple，这样就会报错
# 等价于
divmod(20, 8)

'{2}, {1}, {0}'.format(*'abc') # 'c, b, a'
</code></pre>
</li>
<li>
<p>用于定义一个可以接受任意多个位置参数的函数</p>
<pre><code class="language-python">def add_list(*params):
    sum = 0
    for num in params:
        sum +=num
    print(sum)

add_list(*(1,2,3))
# 等价于
add_list(1, 2, 3)
</code></pre>
</li>
<li>
<p>use * to grap excess items</p>
<pre><code class="language-python">a, b, *rest = range(5) # 0, 1, [2, 3, 4]

a, b, *rest = range(2) # 0, 1, []

a, *body, b, c = range(5) # 0, [1, 2], 3, 4

*head, a, b, c = range(5) # [0, 1], 2, 3, 4
</code></pre>
</li>
</ol>
<h3 id="enumerate-built-in-function"><a class="header" href="#enumerate-built-in-function">enumerate() built in function</a></h3>
<p>enumerate() 接收一个 Iterative Sequence，生成一个包含 index 的生成器，生成器生成的元素是 <code>tuple (index, sequence[index])</code>，其常见的 Demo 为：</p>
<pre><code class="language-python">for index, value in enumerate([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]):
    print(index, value)
</code></pre>
<h2 id="str-字符串"><a class="header" href="#str-字符串">str 字符串</a></h2>
<p>字符串本质上也是 sequence，其可以通过 for 循环进行遍历</p>
<h3 id="字符串遍历"><a class="header" href="#字符串遍历">字符串遍历</a></h3>
<pre><code class="language-python">for ch in &quot;test&quot;:
    print(ch)
</code></pre>
<h3 id="字符串拆成字符数组"><a class="header" href="#字符串拆成字符数组">字符串拆成字符数组</a></h3>
<pre><code class="language-Python">char_list = list(&quot;test&quot;)
# ['t', 'e', 's', 't']
</code></pre>
<h2 id="listsort-和-sorted"><a class="header" href="#listsort-和-sorted">list.sort 和 sorted</a></h2>
<blockquote>
<p><code>list.sort</code> sort a list in place — that is, without making a copy.</p>
</blockquote>
<p><code>list.sort</code> 是一个 in-place function，返回一个 None，表示其并不会创建一个新的 list.</p>
<p>sorted(list1) 则会创建一个新的 list 并返回；并且 sorted 可以对所有可迭代的对象进行排序操作，而 list1.sort() 只能对 list 进行排序。</p>
<p>list.sort 和 sorted(list) 都有两个共同的关键词参数: <code>reverse=True/False</code> <code>key=function</code></p>
<p>Demos:</p>
<pre><code class="language-python">fruits = [&quot;grape&quot;, &quot;raspberry&quot;, &quot;apple&quot;, &quot;banana&quot;]
sorted(fruits, reverse=True, key=len)
</code></pre>
<h3 id="manage-ordered-sequences-with-bisect二分排序"><a class="header" href="#manage-ordered-sequences-with-bisect二分排序">manage ordered Sequences with bisect（二分排序）</a></h3>
<p>bisect 经常用于动态的维护一个有序的列表，其作用对象是有序的列表，其本质上是对二分查找算法的封装。其主要作用有两个：</p>
<ul>
<li>利用二分查找，在有序表中 <strong>快速查找</strong> 到要插入的数字应该被放置的位置 <code>bisect.bisect(sorte_list, to_insert_num)</code></li>
<li>利用二分查找，在有序表中 <strong>快速插入</strong> 一个对象</li>
</ul>
<pre><code class="language-python">import bisect
sorted_list = [1,2,3,4,5]
bisect.bisect(sorted_list, 1) # 返回 1，表示 1 应该插入到 sorted_list[1] 的位置，其余元素顺延
bisect.insort(sorted_list, 4) # 往 sorted_list 插入一个数字，并保持有序，注意是 insort
</code></pre>
<p>注意：bisect 只对按照正序排序的列表生效，也就是所 sorted_list 必须是正序的。</p>
<p>涉及到排序的问题，都可以使用内置标准模块： bisect</p>
<h2 id="arrayarray"><a class="header" href="#arrayarray">array.array</a></h2>
<p><a href="https://docs.python.org/2/library/array.html%3E">Tutorial</a></p>
<p>array 是设计用来专门处理<strong>数值类型</strong>的的 sequence，其在处理数值型数据的效率，要远远高于 list，其兼容 mutable sequence 的一切特性，还支持快速加载和存储，但并不是混合型类型（mixed-type）的 sequence。array 之所以效率高，是因为其<strong>底层就是 C 的数组</strong>。</p>
<p>所以，当我们需要进行<strong>数值运算</strong>的时候，我们应该使用 array.array。Demo:</p>
<pre><code class="language-python">from array import array
from random import random

# 用生成表达式生成一个双精度的 float 类型 array, 其中包含有 1000 万个元素
# array 接受两个参数，第一个参数是存储的数据类型，第二个参数是存储的数据
# array 目前接受的存储类型为：
# I: integer 整形
# u: unicode 类型
# d: double 类型
# others: ……
floats = array(&quot;d&quot;, (random() for i in range(10**7))) # 此处用生成器的好处在于，我们并不会直接生成一个 10**7 长度的数组，这样的话，相当于占用了 double 的内存，而改用生成器的话，在生成 array 的时候，就不需要占用多余的内存，因为元素是一个一个生成的。
print(&quot;the last number: &quot; + str(floats[-1]))
fw = open(&quot;array.bin&quot;, &quot;wb&quot;)
floats.tofile(fw) # 讲数据写入二进制文件中
fw.close()

# 构建一个空的 array，然后从二进制文件中读取数据
floats2 = array(&quot;d&quot;) 
fr = open(&quot;array.bin&quot;, &quot;rb&quot;)
floats2.fromfile(fr, 10**7) # 读取的时候，指定读取多少个数据
fr.close()
print(&quot;the last number: &quot; + str(floats2[-1]))

# 并不是共用内存，当时内容相同
print(id(floats))
print(id(floats2)) 
print(floats == floats2) # true
</code></pre>
<p><strong>array 的优点</strong>：</p>
<ul>
<li>底层数据结构为 C 的 array，占用内存小</li>
<li>可以将 array 写入到二进制文件中，速度非常快，而且占用的磁盘空间小。写入的速度大概是 write per line with float 的 7 倍，读取数据的速度大概是 read from txt per line 的 60 倍</li>
</ul>
<p>另一个和 array.array 速度几近相同的模块，是 pickle 模块。</p>
<p>注意：Python3 并没有对于 array 的 in-place sort 方法，对于 array 的 sort 的正确做法是使用 sorted：</p>
<pre><code class="language-python">a = array.array(a.typecode, sorted(a))
</code></pre>
<p>如果我们想要动态维护一个 sorted array 的话，还是要用到 bisect。</p>
<h2 id="numpy-and-scipy"><a class="header" href="#numpy-and-scipy">Numpy and SciPy</a></h2>
<p>Numpy == Numerical Python 读作 num + py (nangpai)</p>
<p>当我们需要对数字类型的 sequence 进行复杂的操作时，例如向量的分解，向量的乘除法时，就需要用到 Numpy。Numpy 是 SciPy 和 Pandas 的基础。</p>
<p>SciPy 是基于 Numpy 的一个库，其提供了更多关于线性代数/数值计算和统计的工具，其底层调用的是 C 和 Fortran 的库。</p>
<h2 id="deques"><a class="header" href="#deques">Deques</a></h2>
<p>双端队列，使用情景：只对 sequence 的两端进行操作。</p>
<p>用 list 实现栈和队列：</p>
<p>通过对 list 进行 <code>.append()</code> 和 <code>.pop(index)</code>，我们可以实现栈或队列。例如，我们可以通过如下的方法，实现一个队列：</p>
<pre><code class="language-python">queue = [1,2,3,4]
queue.append(5) # 入队
queue.pop(index=0) # 出队
</code></pre>
<p>但是用以上的方法实现队列，有一个很大的问题：每一次出队，queue 中所有的元素，都要往前移一位，时间复杂度是 <code>O(n)</code>。</p>
<p>Python 的标准库自带了一个 <strong>双端队列</strong> 的实现：<code>collections.deque</code>，<code>collections.deque</code> 是一个<strong>线程安全</strong>的双端队列，其被设计用来快速的在双端进行插入和删除。<code>deque</code> 还有一个特性，当一端的插入导致队列满了后，<code>deque</code>会抛弃另一端的数据。</p>
<p>Demos:</p>
<pre><code class="language-python">from collections import deque
dq = deque(range(10), maxlen=10) # 初始化一个 双端队列，可以不给出 maxlen
print(dq) # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)

# rotate(n) 当 n &gt; 0 时，其功能为从 deque 的右边取出 n 个数，移动到左边，当 n&lt;0时，其功能为从左边取出 -n 个数，移动到右边
dq.rotate(3) 
print(dq) # deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
dq.rotate(-4)
print(dq) # deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)

# 从左端插入，append() 是默认右端插入
dq.appendleft(-1) 
print(dq) # deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
# 默认从右端扩展
dq.extend([11,12,13,14])
print(dq) # deque([4, 5, 6, 7, 8, 9, 11, 12, 13, 14], maxlen=10)

# 从左端扩展，要注意的是，extendleft 是 iterate 的操作，所以插入后是逆序的
dq.extendleft([10,20,30,40])
print(dq) # deque([40, 30, 20, 10, 4, 5, 6, 7, 8, 9], maxlen=10)

# 双端弹出数据的操作，
dq.pop() # 右端弹出数据
dq.popleft() # 左端弹出数据
</code></pre>
<p><code>collections.deque</code> 实现了 list 的大多数方法，并且对双端的插入和删除进行了优化，但是需要注意的是，删除 deque 的中部的数据，会是比较耗时的操作。另外，deque 不支持 <code>pop(index)</code> 的操作，因为 index 对于 deque 并没有意义，其双端的 index 都是不固定的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter3-dictionaries-and-sets"><a class="header" href="#chapter3-dictionaries-and-sets">Chapter3. Dictionaries and Sets</a></h1>
<p>[TOC]</p>
<h2 id="mapping-types-的特征"><a class="header" href="#mapping-types-的特征">Mapping Types 的特征</a></h2>
<p>所有的 mapping types 的底层，都是 <code>dict</code>，他们的 key 必须是可以 hashable 的。</p>
<pre><code class="language-python">ss = &quot;hello&quot;
hash(ss)
</code></pre>
<p>在使用 mapping types 的时候，应该始终考虑内存的效率问题。Dict 是设计被用来高效查找的，其并不适合存储，在存储的时候，考虑用 namedtuple 来代替！</p>
<h2 id="hash-table-的原理"><a class="header" href="#hash-table-的原理">hash table 的原理</a></h2>
<p>hash table 本质上是一个<strong>稀疏的顺序表</strong>，每一个表中的单元叫做<strong>桶</strong>，每一个桶中包含有两个引用：reference to the key and reference to the value, 我们通过哈希函数 hash(key) 将 key 和 value 映射到桶里。</p>
<p><img src="reading/fluent-python/chapters/assets/1565876595770.png" alt="hash table原理" /></p>
<p>Python 会保证顺序表中，<strong>至少有 1/3 的空桶</strong>，如果 hash table 变得拥挤，那么 Python 会将开启一块更大的空间，然后将原来的 hash table copy 过去。</p>
<h2 id="hashable-built-in-types"><a class="header" href="#hashable-built-in-types">hashable built-in types</a></h2>
<p>可以 hash 的内置类型有：</p>
<ul>
<li>atomic immutable types: (str, bytes, numeric types)</li>
<li>tuple only if all its items are hashable</li>
<li>user-defined types</li>
<li>如果一个对象实现了 <code>__eq__()</code> 方法，那么只有类的内部属性都是私有的，才能 hashable</li>
</ul>
<p>Demo:</p>
<pre><code class="language-Python">class Demo:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.names == other


demo = Demo(&quot;wansho&quot;, 25)
print(hash(demo))

&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;D:/Github-Code/test/hashable.py&quot;, line 13, in &lt;module&gt;
    print(hash(demo))
TypeError: unhashable type: 'Demo'
&quot;&quot;&quot;
</code></pre>
<p>注意，并不是所有的 immutable types 都是 hashable 的，如果一个 tuple 中有 mutable 的对象，那么这个 tuple 就是不可 hash 的。</p>
<p>用户自定义的类型，都是可以 hash 的，因为其每个对象都是独一无二的，其 hash 值就是其 id，</p>
<h3 id="why-list-unhashable"><a class="header" href="#why-list-unhashable">why list unhashable</a></h3>
<p>list 的内容会变动，而 hash 要求 key 不变。</p>
<h2 id="build-a-dict"><a class="header" href="#build-a-dict">build a dict</a></h2>
<h3 id="常见构造方法"><a class="header" href="#常见构造方法">常见构造方法</a></h3>
<pre><code class="language-python">my_dict = {&quot;name&quot;: &quot;wansho&quot;, &quot;age&quot;: 25} # 最常见的构建方法

# 用 dict() 方法构建
my_dict = dict(name=&quot;wansho&quot;, age=25)
my_dict = dict(zip([&quot;name&quot;, &quot;age&quot;], [&quot;wansho&quot;, 25]))
my_dict = dict([(&quot;name&quot;, &quot;wansho&quot;), (&quot;age&quot;, 25)])
my_dict = dict({&quot;name&quot;: &quot;wansho&quot;, &quot;age&quot;: 25})

# values 不确定的情况下，根据 keys 值创建一个 dict
dt = dict.fromkeys([1,2,3], defalut_value) # default_value 就是一个值
# {1: defalut_value, 2: defalut_vlue, 3: defalut_value}
</code></pre>
<h3 id="dict-comprehensions-字典推导式"><a class="header" href="#dict-comprehensions-字典推导式">dict comprehensions 字典推导式</a></h3>
<pre><code class="language-python">my_dict = {key: value for key, value in lst}
</code></pre>
<h2 id="dict-常见方法"><a class="header" href="#dict-常见方法">dict 常见方法</a></h2>
<pre><code class="language-python">my_dict = {&quot;name&quot;: &quot;wansho&quot;, &quot;age&quot;: 25} 
my_dict.keys()
my_dict.values()

my_dict.items() # 将 keys 和 values 组合在一起
my_dict.clear()

my_dict.pop(key) # 删除一对数据并返回
my_dict.popitem() # 随机删除一对元素并返回
</code></pre>
<h3 id="update-方法详解"><a class="header" href="#update-方法详解">update() 方法详解</a></h3>
<p>update 方法是鸭子模型的典型体现。</p>
<p>其可以接收拥有 mapping 或 iterating 的对象。首先判断接收的对象是否有 <code>keys()</code> 方法，如果有，则把它当成一只鸭子(mapping)，否则再尝试 iterate 该对象，如果可以 iterate，那么就假定该对象中的元素为 元组对(key, value)。</p>
<p>update() 接受的对象，可以是如下几种：</p>
<ol>
<li>mapping types</li>
<li>iterated types with (key, value) tuple items</li>
<li>keyword arguments</li>
</ol>
<h3 id="handle-missing-keys-with-setdefault--defaultdict"><a class="header" href="#handle-missing-keys-with-setdefault--defaultdict">handle missing keys with setdefault() / defaultdict</a></h3>
<p>Python 有四种通过 key 获取值的方式：</p>
<pre><code class="language-python"># 第一种
my_dict[&quot;students&quot;]
# 第二种
my_dict.get(&quot;students&quot;, [])
# 第三种
my_dict.setdefault(&quot;students&quot;, [])

# 第四种
import collections
my_dcit = collections.defaultdict(list) # 默认缺失值为 list，list 为 default_factory
my_dict[&quot;students&quot;].append(&quot;wansho&quot;)
</code></pre>
<p>其中，第二种和第三种都有处理 missing key 的方式，第二种方式常见的代码逻辑为：</p>
<pre><code class="language-python">student_list = my_dict.get(&quot;students&quot;, []) # 第一次搜索
student_list.append(&quot;wansho&quot;)
my_dict[&quot;students&quot;] = student_list # 插入数据，实际上是第二次搜索
</code></pre>
<p>实际上，第二种方式进行了两次搜索，我们再来看一下第三种方式：</p>
<pre><code class="language-python">my_dict.setdefault(&quot;students&quot;, []).append(&quot;wansho&quot;)
# setdefault 方法先按照 key 进行搜索 value，如果 key 不存在，则就地插入 (key, default_value)并返回 default_value 的引用，这样就避免了插入时的第二次搜索。
</code></pre>
<p>第四种方式的效率和第三种一样，不同的是其采用了 <code>collections.defalutdict</code> 来处理缺失值，下面拆解一下插入语句：</p>
<pre><code class="language-python">my_dict[&quot;students&quot;].append(&quot;wansho&quot;)
# 1. 执行一遍搜索，发现 students 是 missing key
# 2. 按照默认的缺失值类型，生成一个 list，并将 (key, default_value) 就地插入到 my_dict 中，然后返回 default_value 的引用
# 3. default_value 加入新的数据
</code></pre>
<h2 id="dict-的变体"><a class="header" href="#dict-的变体">dict 的变体</a></h2>
<p>注意，这些 dict 的变体，都拥有 dict 的基础特性，也就是说，可以使用 dict 的 built-in 方法（<strong>鸭子类型</strong>）。</p>
<h3 id="collectionsordereddict"><a class="header" href="#collectionsordereddict">collections.OrderedDict</a></h3>
<p><strong>有序字典</strong>，使得在遍历 Dict 时，输出顺序为元素的插入顺序。</p>
<pre><code class="language-python">import collections
ordered_dict = collections.OrderedDict([(&quot;name&quot;, &quot;wansho&quot;), (&quot;age&quot;, 25)])
print(ordered_dict) # OrderedDict([('name', 'wansho'), ('age', 25)])
</code></pre>
<h3 id="collectionscounter"><a class="header" href="#collectionscounter">collections.Counter</a></h3>
<p>Counter 通常用来<strong>对字符串中的字符进行计数</strong>，Demo:</p>
<pre><code class="language-python">import collections
counter_dict = collections.Counter(&quot;aaaaabbbbcccdde&quot;)
print(counter_dict) # Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1})
counter_dict.update(&quot;aaabb&quot;)
print(counter_dict.most_common(2)) # [('a', 8), ('b', 6)]
</code></pre>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<h3 id="set-的构造"><a class="header" href="#set-的构造">Set 的构造</a></h3>
<pre><code class="language-python">my_set = set()

my_set = {1, 2, 3} # 初始化一个有初始值的 set

# 注意，构建空的 set 只能用 set()，如果是如下的构造，实际上是生成了一个字典
my_dict = {}
</code></pre>
<h3 id="set-的特性"><a class="header" href="#set-的特性">Set 的特性</a></h3>
<ul>
<li>元素独一无二</li>
<li>元素必须是可以 hashable</li>
<li>针对 set 优化的算术运算符：<code>| &amp; -</code></li>
</ul>
<h3 id="set-算数运算符优化"><a class="header" href="#set-算数运算符优化">Set 算数运算符优化</a></h3>
<p>灵活运用 Set 的算数运算符，比写 for 循环的效率高很多，Demo:</p>
<pre><code class="language-python">found = len(needless &amp; haystack)

for n in needless:
    if n in haystack:
        found += 1
</code></pre>
<p>以上的两个块代码，在效果上等价，但是前者运用了算数运算符，其速度远大于 for 循环。</p>
<h3 id="inplaced-mathematical-set-operations"><a class="header" href="#inplaced-mathematical-set-operations">Inplaced mathematical set operations</a></h3>
<p>set 的算数运算符，同样也可以进行 inplace 的算数运算，从而优化</p>
<pre><code class="language-python">set1 = set()
set2 = set()

set1 |= set2 # 就地合并 set1 和 set2 到 set1
set1 = set1 | set2 # produce a new set
</code></pre>
<h3 id="set-comparison-operators"><a class="header" href="#set-comparison-operators">Set comparison operators</a></h3>
<p>set 比较运算符，返回的结果是一个 bool 值，<code>in, &lt;=, &lt;, &gt;=, &gt;</code></p>
<pre><code class="language-python">set1 = {1,2}
set2 = {1,2,3}

set1 in set2

set1 &lt;= set2
</code></pre>
<h2 id="set--dict-利弊"><a class="header" href="#set--dict-利弊">Set / Dict 利弊</a></h2>
<h3 id="set-和-dict-的区别"><a class="header" href="#set-和-dict-的区别">Set 和 Dict 的区别</a></h3>
<p>set 和 dict 的底层都是 hashtable，set 的 hashtable 的每个桶中，只有指向其 key 的指针，而 dict 的 hashtable 的桶中，还有指向其 value 的指针。</p>
<h3 id="利"><a class="header" href="#利">利</a></h3>
<p>Set，Dict 适合 O(1) 复杂度的高效查找，dict / set / list 查找效率比较：set &gt; dict &gt; list</p>
<h3 id="弊端"><a class="header" href="#弊端">弊端</a></h3>
<p>由于 dict 和 set 使用了 hashtable，hashtable 在内存中是是个稀疏的 array（Python 会保证 1/3 的空桶，否则会开辟一个新的空间），这会导致大量的内存空间被占用。所以，当我们要对处理大量的 record 时，最好用 tuple 或者 namedtuple 进行暂存，而不是用 dict in JSON Style。这是大多数人会忽略的一个事实：<code>天下没有免费的午餐，不要走捷径</code>。这也解释了，有时候我们从数据库中读取数据，用 dict 来暂存后，内存占用过大的问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter4-text-versus-bytes"><a class="header" href="#chapter4-text-versus-bytes">Chapter4. Text versus Bytes</a></h1>
<p>[TOC]</p>
<h2 id="text-and-bytes"><a class="header" href="#text-and-bytes">Text and Bytes</a></h2>
<h3 id="string-sequence"><a class="header" href="#string-sequence">String Sequence</a></h3>
<p><strong>String is a sequence of unicode characters.</strong></p>
<p>每一个 Unicode char 有一个 identity: code point，code point is a number from 0 to 111411.</p>
<pre><code class="language-python"># get unicode code point
print(ord(&quot;a&quot;)) # 97
print(ord('€')) # 8364
</code></pre>
<h3 id="byte-sequence-bytes"><a class="header" href="#byte-sequence-bytes">Byte Sequence: bytes()</a></h3>
<p>bytes 用于将对象转换成字节表示，其输出只能是 ascii 字符。</p>
<pre><code class="language-python">ss = b&quot;nihao, i'm wansho&quot; # 仅支持 ASCII 字符
ss = bytes(u&quot;你好&quot;, encoding=&quot;utf-8&quot;) # 将 unicode 字符转成字节
</code></pre>
<h3 id="区别"><a class="header" href="#区别">区别</a></h3>
<pre><code class="language-python"># in python3 
ss = &quot;1&quot; # unicode
s = b&quot;1&quot; # byte

ss == s
# false
</code></pre>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left">unicode sequence 定义</th><th style="text-align: left">byte sequence定义</th></tr></thead><tbody>
<tr><td style="text-align: left">Python2</td><td style="text-align: left"><code>u(&quot;你好&quot;)</code></td><td style="text-align: left"><code>&quot;nihao&quot;</code></td></tr>
<tr><td style="text-align: left">Python3</td><td style="text-align: left"><code>&quot;你好&quot;</code></td><td style="text-align: left"><code>bytes(&quot;你好&quot;, encoding=&quot;utf-8&quot;)</code></td></tr>
</tbody></table>
<p><strong>Tips</strong>:</p>
<ul>
<li>
<p>Python2 的字符串<strong>默认为 Byte 类型</strong>，如果输入非 ASCII 字符，则自动编码为 byte</p>
<pre><code class="language-python">ss = &quot;你好&quot;
print(ss) # \xe4\xbd\xa0\xe5\xa5\xbd
</code></pre>
</li>
<li>
<p>Python3 中的字符串默认为 Unicode Sequence</p>
</li>
</ul>
<h3 id="python3-中定义-byte-sequence"><a class="header" href="#python3-中定义-byte-sequence">Python3 中定义 byte sequence</a></h3>
<h2 id="encode-and-decode"><a class="header" href="#encode-and-decode">Encode and Decode</a></h2>
<h3 id="框架"><a class="header" href="#框架">框架</a></h3>
<p><img src="http://assets.processon.com/chart_image/5cdf647ae4b00446dc68e782.png" alt="encode and decode" /></p>
<p><strong>Tips</strong>:</p>
<ul>
<li>A<strong>n encoding is an algorithm is an algorithm that converts code points to byte sequences and vice versa.</strong></li>
</ul>
<h3 id="为何要-encode"><a class="header" href="#为何要-encode">为何要 encode</a></h3>
<p>encode 可以将内存中的数据进行压缩，<strong>提高存储和传输效率</strong>。</p>
<h3 id="basic-encoders-and-decoders"><a class="header" href="#basic-encoders-and-decoders">Basic Encoders and Decoders</a></h3>
<p>Python 中集成了 100+ 个 codec，实现 text 到 byte 的互相转换。常见的 codec 有：<code>utf-8, utf-16, gb2312</code></p>
<p>每一个 codec 都有一个名字，通常还有一些别名，例如：<code>utf_8</code> 对应的别名有 <code>utf8, utf-8, U8</code>。</p>
<p><strong>decode 出现乱码的问题</strong></p>
<p>decode 出现乱码，大概率是因为 decode 和 encode 的 codec 不匹配，那么 encoded byte 对于 decode 来说就是噪声，而恰巧负责 deocde 的 codec 能够 decode random noise，所以才会 decode 出一些乱码。</p>
<h3 id="python-源码默认的-encoder"><a class="header" href="#python-源码默认的-encoder">Python 源码默认的 Encoder</a></h3>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left">Encoder</th></tr></thead><tbody>
<tr><td style="text-align: left">Python2</td><td style="text-align: left">ASCII</td></tr>
<tr><td style="text-align: left">Python3</td><td style="text-align: left">UTF-8</td></tr>
</tbody></table>
<p>这也是为什么，Python2 的源码，在文件开头需要加入 <code># -*- coding: utf-8 -*-</code> 指定编码器。</p>
<p>Python3 允许 non-ASCII identifiers in source code，任何 Unicode 字符，都可以作为变量，也就是说，<strong>中文也可以作为变量</strong>！</p>
<h3 id="如何判断一个-byte-sequence-的编码器-chardet"><a class="header" href="#如何判断一个-byte-sequence-的编码器-chardet">如何判断一个 byte sequence 的编码器: chardet</a></h3>
<p>结论：无法判断。</p>
<p>许多通信协议和文本的格式，例如 HTTP 和 XML，会在 headers 中明确指出其内容是如何 encode。大多数时候，我们能否判断 byte sequence 并不是 ASCII，因为其中有很多符号的 value &gt; 127，但是我们可以通过经验，察觉到这些 byte sequence 是怎么编码得来的。</p>
<p>例如，如果 <code>\x00</code> 很常见，那么其很可能是 16bit 或 32bit 编码得来的，而不是 ASCII，因为 <code>\x00</code> 在 ASCII 中是一个 bug，当 byte sequence 中有较多的 b<code>\x20\x00</code> 时，那么这个符号很可能是编码规则 <code>utf-16le</code> 编码得到的空格。</p>
<p>所以，虽然理论上无法判断，但是我们还是可以通过经验来大概猜出来 byte sequence 的编码方式。package <code>chardet</code> 就是用来 detect codec 的。</p>
<h3 id="大端小端--有-bom无bom"><a class="header" href="#大端小端--有-bom无bom">大端/小端 — 有 BOM/无BOM</a></h3>
<h4 id="大端小端"><a class="header" href="#大端小端">大端/小端</a></h4>
<p>大端小端是指机器对于多字节数据类型的在内存中的存储顺序。</p>
<p>如果是先存储有效位，则是小端，如果先存储无效位，则是大端。</p>
<p>拿 C 语言的数据类型 int 类型举例，一个 int 类型在内存中占 4 个字节，例如 <code>int num = 1;</code>，其在内存中，应该存储为：<code>0x00 00 00 01</code>那么这 4 个字节，是 <code>00</code> 在前，还是 <code>01</code> 在前？如果 <code>01</code> 在前，即其在内存中的存储顺序为：<code>01000000</code>，则为小端（大多数 x86 机器都是小端），如果 1 在内存中的存储顺序为 <code>00000001</code>，则为大端。</p>
<p><strong>如何判断一个机器是大端还是小端</strong></p>
<p>用 char 指针访问一个多字节的数值 1，例如 int 类型，然后访问该数在内存中的第一个字节，如果第一个字节的值为 1，则说明其在内存中存储的顺序为 <code>0100……</code>，为小端；如果第一个字节的值为 0，则说明其在内存中存储的顺序为 <code>00……01</code>，为大端。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
/**
 * 用于判断机器是大端机器还是小端机器
*/
void print_int(char* p){
    // 一个字节一个字节的按照内存顺序打印内容
    int len = sizeof(int); // 4 个字节
    int i;
    for(i = 0; i &lt; len; i++){
        printf(&quot;%d&quot;, *p);
        p += 1;
    }
}

void main(){
    int num = 1; // int 占用4个字节
    // 获取 num 的地址，然后转成 char* 指针类型，这样就保证了一个一个字节的访问
    char* p = (char*)(&amp;num);
    print_int(p);
    // 打印结果为 1000，其最先输出的是有效数字端，为小端
    return;
}
</code></pre>
<h4 id="bom-byte-order-mark--utf-8-bom-的由来"><a class="header" href="#bom-byte-order-mark--utf-8-bom-的由来">BOM (Byte Order Mark) / UTF-8 BOM 的由来</a></h4>
<p>从大端和小端我们可以知道，内存存储顺序，对于不同的机器是不一样的。Python 在对 Unicode 字符进行 encode 进而转换成 byte 时，不同的机器，其产生的 byte 顺序是不一样的。这就导致了数据在存储和传输的时候，出现即使是相同的编码规则，也解析出乱码的问题。</p>
<p>为了解决机器带来的大端小端的问题，很多编码器会预先获取机器大小端顺序，然后在进行编码的时候，将顺序规则写入编码得到的 byte，这就是 BOM 的<strong>由来</strong>。由于只有在 encoder 为双字节编码的时候才会有顺序之分，所以照说 <code>utf-8</code> 生成的字节不需要加 BOM，但是很多 Windows 的应用(Notepad，Excel)会在编码的时候，将 BOM 加入 utf-8 编码的文件中，尤其是 Excel，其依赖于 BOM 来识别 utf-8 文件。由于 Windows 系统会在 utf-8 编码时，往文件中写入 BOM，所以 utf-8 编码才会衍生出：<code>utf-8 和 utf-8 BOM</code> 两种编码。</p>
<h2 id="unicode-sandwich"><a class="header" href="#unicode-sandwich">Unicode Sandwich</a></h2>
<p>Python 采用 Unicode 模型来进行文本的处理。实际上，该模型的思想适用于大都数的系统。在系统输入时，将 byte decode 为 Unicode，在系统输出时，再将 Unicode encode 进行存储或传输。</p>
<p><img src="reading/fluent-python/chapters/assets/1558260080911.png" alt="Unicode Sandwich" /></p>
<p>注意：</p>
<ul>
<li>当我们在读写文件的时候，如果没有指定编码，那么 Python 会默认使用系统的编码，类 Unix 系统的默认编码都是 utf-8，而 Windows 系统的默认编码并不是 utf-8.</li>
<li>由于不同的系统，默认的编码规则不同，所以我们应该在代码文件中明确指定编码</li>
</ul>
<h2 id="tips-for-文件读写代码"><a class="header" href="#tips-for-文件读写代码">Tips for 文件读写代码</a></h2>
<p>见注释：</p>
<pre><code class="language-python">ss = &quot;hello万朔&quot;
# 1. encoding 是为了指定存储的编码格式，编码后存储的文件，可以节省存储资源。
# 2. 读和写的 encoding 要一致
# 3. encoding 不能省略，否则 Python 会使用当前操作系统默认的编码，而不同的操作系统，其默认编码可能不同
fw = open(&quot;test.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) 
print(fw.write(ss)) # write 和 read 会返回读取的长度，打印 7，表明写入了 7 个 Unicode 字符 
fw.close()

import os
print(os.stat(&quot;test.txt&quot;).st_size) # 返回 11，表示 test.txt 的内容(大小)为 11 个字节，也就是说 test.txt 为 11Byte，而实际上，该文件在 Windows 上显示也是 11 个字节大小。
fr = open(&quot;test.txt&quot;, &quot;rb&quot;) # rb 为 read binary，该模式下读取的内容为字节流，也就是说，如果我们想要分析一个文件的字节组成，可以，另外，注意 binary 模式下，不需要指定 encoder
print(fr.read())
# b'hello\xe4\xb8\x87\xe6\x9c\x94'，就像结果一样，确实有 11 个字节，并且显示的确实是 byte 字节格式
</code></pre>
<p>注意：</p>
<ul>
<li>如果我们想要探究一个文件的字节，在简单的情境下，可以使用 <code>binary</code> 模式进行读取，但是如果上升到了业务，就不需要自己动手造轮子了，应该使用现成的轮子 <strong>Chardet</strong>，Chardet 是探究文件 Byte 的利器。</li>
</ul>
<h2 id="byte-in-re"><a class="header" href="#byte-in-re">byte in RE</a></h2>
<p>Python3 中，可以强制指定进行 byte 的匹配，这样只能匹配到 ASCII。</p>
<pre><code class="language-python">import re
re.compile(rb&quot;\d&quot;) # b 代表进行 byte匹配
</code></pre>
<h2 id="本章学习感悟"><a class="header" href="#本章学习感悟">本章学习感悟</a></h2>
<p>本章学习的知识，让我把</p>
<ul>
<li>C 语言的 char* 指针</li>
<li>计组的字节/大端小端</li>
<li>Python 的字符和字节 / BOM 和无 BOM</li>
</ul>
<p>等知识串在了一起。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter5-first-class-functions"><a class="header" href="#chapter5-first-class-functions">Chapter5. First-Class Functions</a></h1>
<p>从第五章开始，一直到第七章，都是在研究函数。</p>
<p>[TOC]</p>
<h2 id="what-is-first-class-functions"><a class="header" href="#what-is-first-class-functions">What is First-Class Functions</a></h2>
<p>Functions are treated like any other variable. Treating functions as objects.</p>
<p>函数也被作为一个对象，其和对象一样，是 Python 语言中的第一公民。一个对象，其可以拥有属性，也可以定义其对应的方法，也可以将其赋值为其他变量。</p>
<p>Demo:</p>
<pre><code class="language-python">def factorial(n):
    &quot;&quot;&quot;return n!&quot;&quot;&quot;
    return 1 if n &lt; 2 else n * factorial(n-1)

fact = factorial # function 作为变量传递给另外一个变量
# fact 作为变量传入 map 方法，其参数为 range 生成的数据，map 返回一个 iterated 的对象
list(map(fact, range(10))) 
# 等价于
list(map(factorial, range(10)))
</code></pre>
<h3 id="函数的-attributes"><a class="header" href="#函数的-attributes">函数的 attributes</a></h3>
<p>Demo:</p>
<pre><code class="language-python">print(factorial.__doc__) # return n!
# __doc__ 用于生成 help text of and object
print(help(factorial))
&quot;&quot;&quot;
Help on function factorial in module __main__:
factorial(n)
    return n!
None
&quot;&quot;&quot;

dir(factorial) # 查看 factorial 的属性
&quot;&quot;&quot;
['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
&quot;&quot;&quot;
</code></pre>
<p><strong>赋予 function attribute</strong></p>
<pre><code class="language-Python">factorial.short_desc = &quot;阶乘&quot;
</code></pre>
<p><strong>查看 function 所有自定义的 attribute</strong></p>
<pre><code class="language-python">print(factorial.__dict__)
# {'short_desc': '阶乘'}
</code></pre>
<table><thead><tr><th>属性</th><th>desc</th></tr></thead><tbody>
<tr><td><code>__dict__</code></td><td>获取 function 的所有自定义的 attribute</td></tr>
<tr><td><code>__name__</code></td><td>获取函数名</td></tr>
<tr><td><code>__doc__</code></td><td>获取函数的注释</td></tr>
<tr><td><code>__closure__</code></td><td>获取闭包绑定的 free 变量 (list)</td></tr>
<tr><td><code>__defaults__</code></td><td>tuple(位置参数和关键字参数的默认值)</td></tr>
<tr><td><code>__code__.co_varnames</code></td><td>tuple(存储了函数参数的name还有函数中定义的name)</td></tr>
<tr><td><code>__code__.co_argcount</code></td><td>value: 参数的个数，不包括以 <code>*</code> 和 <code>**</code> 打头的参数</td></tr>
<tr><td><code>__annotations__</code></td><td>dict{ 函数的注解，包括输入和输出的注解}，Python3 引入</td></tr>
</tbody></table>
<h3 id="函数的-methods"><a class="header" href="#函数的-methods">函数的 methods</a></h3>
<h2 id="higer-order-functions"><a class="header" href="#higer-order-functions">Higer-Order Functions</a></h2>
<p>A function that takes a function as argument or returns a function as the result is a higher-order function.</p>
<p>传入或者<strong>返回</strong>一个函数的函数叫做 higer-order-function。</p>
<p>Higer-Order Functions: <strong>sort, map, filter, reduce</strong></p>
<h3 id="demo-sort"><a class="header" href="#demo-sort">Demo: sort()</a></h3>
<pre><code class="language-python">def reverse(word):
    &quot;&quot;&quot;逆置word&quot;&quot;&quot;
    return word[::-1]
fruits = [&quot;straberry&quot;, &quot;fig&quot;, &quot;cherry&quot;, &quot;apple&quot;, &quot;banana&quot;]
sorted(fruits, key=reverse) # key 为一个 function，返回排序后的 sorted object，是一个新的 object, sorted 并不是 inplcae 方法，lst.sort() 是 inplace 方法
# 结果为：[&quot;banana&quot;,&quot;apple&quot;, &quot;fig&quot;, &quot;straberry&quot;, &quot;cherry&quot;]
# 上述代码执行的步骤：
# 1. 根据传入的 key 函数，对 fruits 进行变换，得到变换后的 list
# 2. 对 fruits 按照变换后的规则进行排序

# 其他变换规则
sorted(fruits, key=len)
</code></pre>
<h3 id="modern-replacements-for-mapfilterreduce"><a class="header" href="#modern-replacements-for-mapfilterreduce">Modern Replacements for map/filter/reduce</a></h3>
<p>lambda / map / filter / reduce 的特性源于 Lisp.</p>
<p>Chapter2 中已经指出，任何用到 map 和 filter 的地方，都可以用 列表推导式 和 生成器表达式来替换。而 reduce 可以被 <code>sum, all, any</code> 等 Python 自带的built-ins 取代。Demo:</p>
<pre><code class="language-python">list(map(factoria, filter(lambda n: n % 2, range(6)))) # list of factorial of odd numbers up to 5!, using both map and filter

from functools import reduce
from operator import add
# 两者等价
reduce(add, range(100)) 
sum(range(100))

all(iterable)
any(iterable)
</code></pre>
<p><img src="reading/fluent-python/chapters/assets/1558485596538.png" alt="map/filter" /></p>
<p><strong>reduce</strong></p>
<p>The common idea of <strong>reduce</strong> is to apply some operation to successive items in a sequence, <strong>accumulating</strong> previous result, thus reducing a sequence of values to a single value.</p>
<p>reduce 用于对一个 sequence 进行 successive compute，从而得到一个 single value。降维。</p>
<p><img src="reading/fluent-python/chapters/assets/1558443265331.png" alt="Reduce" /></p>
<pre><code class="language-python">from functools import reduce
from operator import add, sub

reduce(add, range(10)) # 等价于 0 + 1 + 2 + ……  + 9
reduce(sub, [1,2,3]) # 等价于 1 - 2 - 3
</code></pre>
<p>Other reducing built-ins:</p>
<pre><code class="language-python">all(iterable) # return true if all value is true
any(iterable) # return true if one value is true

all([&quot;1&quot;, [1], (1), {1:2}]) # true
all([&quot;1&quot;, [1], (1), {}]) # false

any([&quot;1&quot;, [1], (1), {}]) # true
</code></pre>
<p>注意：</p>
<ul>
<li>在 Python3 中， <strong>map</strong> 和 <strong>filter</strong> 会返回一个 <strong>generator</strong> (iterable)对象，并不是一个 sequence</li>
</ul>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h3>
<p>keyword lambda 用于创建一个匿名函数，其本质上是一个<strong>语法糖</strong>（syntactic sugar）。</p>
<p>**lambda expression 的优点和应用场景：**简洁，适合处理 sequence，通常用于 Higher-Order-Function 的函数参数</p>
<p>**匿名函数的应用场景：**当一个函数创建出来只需要在一个地方调用的时候，为了减少代码复杂性，其与 Java 和 Javascript 的 inner function，有同样的作用。下面是 JavaScript 对于 inner func 的优点的论述：</p>
<p>This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down, which is always a good thing.</p>
<p>This is also a great counter to the lure of global variables. When writing complex code it is often tempting to use global variables to share values between multiple functions — which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together when it makes sense without polluting your global namespace — &quot;local globals&quot; if you like. This technique should be used with caution, but it's a useful ability to have.</p>
<p>**lambda expression 的缺点：**不能处理复杂的逻辑，比较晦涩，unreadable</p>
<p>Demo:</p>
<pre><code class="language-python">fruits = [&quot;straberry&quot;, &quot;fig&quot;, &quot;cherry&quot;, &quot;apple&quot;, &quot;banana&quot;]
sorted(fruits, key=lambda fruit: fruit[::-1])
# 其等价于
sorted(fruits, key=reverse)
</code></pre>
<p>值得注意的是，lambda expression 除了应用在 High-Order-Function 中，其他地方使用得不多。</p>
<p><strong>去 lambda expression 的四个步骤</strong></p>
<p>如果我们发现一个 lambda expression 十分晦涩难懂，那么可以用如下步骤来解决：</p>
<ol>
<li>理解这个 lambda expression 的业务逻辑</li>
<li>对业务逻辑进行重命名</li>
<li>用步骤二的名字 def 一个 function，用 function 替代 lambda expression</li>
<li>移除 lambda expression</li>
</ol>
<h2 id="callable-objects"><a class="header" href="#callable-objects">Callable Objects</a></h2>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p><strong>A <em>callable object</em> is an object that can accept some arguments (also called parameters) and possibly return an object (often a tuple containing multiple objects)</strong>. A function is the simplest callable object in Python, but there are others, such as <a href="https://en.wikibooks.org/wiki/Python_Programming/Classes">classes</a> or certain class instances. <a href="https://en.wikibooks.org/wiki/Python_Programming/Functions%3E">From wikibooks</a></p>
<p>如何判断一个 object 是否是 callable object:</p>
<pre><code class="language-python">[callable(obj) for obj in (abs, str, 13)]
# print [True, True, False]
</code></pre>
<h3 id="what-are-the-methods-functions-built-in"><a class="header" href="#what-are-the-methods-functions-built-in">What are the methods, functions, built-in？</a></h3>
<p><strong>Class 中定义的函数叫 method</strong></p>
<p><strong>非 Class 中定义的函数叫 function</strong></p>
<table><thead><tr><th></th><th>methods</th><th>functions</th></tr></thead><tbody>
<tr><td>built-in</td><td>Python 自带类中定义的 method，例如：<code>dict.get()</code> 的 <code>get</code> 方法</td><td>Python 自带的 function，例如 <code>len</code>, <code>str</code></td></tr>
<tr><td>user-defined</td><td>用户定义类中定义的 method</td><td>用户定义的 function</td></tr>
</tbody></table>
<h3 id="seven-callable-objects"><a class="header" href="#seven-callable-objects">Seven Callable Objects</a></h3>
<h4 id="user-defined-functions"><a class="header" href="#user-defined-functions">User-defined Functions</a></h4>
<p>Created with <code>def</code> statements or <code>lambda</code> expressions.</p>
<pre><code class="language-Python">import pandas as pd

def get_columns(pd_data):
    return pd_data.columns.tolist()
</code></pre>
<h4 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h4>
<p>A function implemented in C (for CPython), like <code>len()</code> or <code>time.strftime</code></p>
<h4 id="built-in-methods"><a class="header" href="#built-in-methods">Built-in methods</a></h4>
<p>Methods implemented in C, like <code>dict.get</code></p>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p>Functions defined in the body of a class.</p>
<h4 id="classes"><a class="header" href="#classes">Classes</a></h4>
<p>For example, pd_data = pd.DataFrame([(1,2,3),(4,5,6)], columns=[&quot;a&quot;， &quot;b&quot;, &quot;c&quot;])</p>
<h4 id="class-instances"><a class="header" href="#class-instances">Class instances</a></h4>
<p>If a class defined a <em><code>__call__</code></em> method, then its instances may be invoked as functions. </p>
<p>也就是说，如果一个 class 实现了 <code>__call__()</code> 方法，那么其对象就可以像方法一样被调用，参考 [User-Defined Callable Types](#User-Defined Callable Types)</p>
<h4 id="generator-functions"><a class="header" href="#generator-functions">Generator functions</a></h4>
<p>Functions or methods that use the <code>yield</code> keyword. When called, generator functions return a generator object.</p>
<h3 id="user-defined-callable-types"><a class="header" href="#user-defined-callable-types">User-Defined Callable Types</a></h3>
<p>一个类只要实现了 <code>__call__</code> 方法，那么其对象就是一个 callable object</p>
<pre><code class="language-python">class BingoCage:
	def __init__(self, items):
        self._items = list(items) # deep copy
        random.shuffle(self._items)
        
    def pick(self):
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError(&quot;pick from empty BingoCage&quot;)
            
    def __call__(self):
        &quot;&quot;&quot; 实现了该方法后，该类的对象，就可以被当成函数一样调用该方法 &quot;&quot;&quot;
        return self.pick()
</code></pre>
<pre><code class="language-Python">bingo = BingoCage(range(3))
print(bingo.pick()) # 1
print(bingo()) # 0，注意这里，一个对象，也可以是 callable object, shortcut to bingo.pick: bingo()
print(callable(bingo)) # True
</code></pre>
<h2 id="function-introsepction-function-深挖"><a class="header" href="#function-introsepction-function-深挖">Function Introsepction (Function 深挖)</a></h2>
<h3 id="get-function-all-attributes"><a class="header" href="#get-function-all-attributes">Get Function All Attributes</a></h3>
<p>如何查看一个对象的属性，包括一个函数对象的属性？<code>dir()</code></p>
<pre><code class="language-python">dir(factorial)
&quot;&quot;&quot;
['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
&quot;&quot;&quot;
</code></pre>
<p>上述大多数的属性，都是 Python 对象通用的属性，我们主要分析和 Function 作为 object 相关的属性：<code>__dict__</code>。</p>
<h3 id="attribute-__dict__"><a class="header" href="#attribute-__dict__">attribute: <code>__dict__</code></a></h3>
<p>Function 作为一个 object，其肯定和其他对象一样，也有 attribute 和 method。<code>__dict__</code> 就是用于查看 function object 的 attribute，<code>__dict__</code> 用于存储 function 的 attribute 和对应的值。</p>
<pre><code class="language-Python">factorial.short_desc = &quot;斐波那契数列&quot;
print(factorial.__dict__)
# {'short_desc': '斐波那契数列'}
</code></pre>
<h3 id="positional-parameters-vs-keyword-only-parameters"><a class="header" href="#positional-parameters-vs-keyword-only-parameters">Positional Parameters vs Keyword-Only Parameters</a></h3>
<p>从位置参数到关键字参数。Python 3 中引入 Keyword-Only Parameters.</p>
<ul>
<li>可以利用 <code>*param</code> 传入更多的位置参数，可以利用 <code>**attrs</code> 传入更多的键值参数</li>
<li><code>cls=None</code> 的规则可以用于设置 default 参数，例如： <code>cls=default_value</code></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>位置参数在调用时必须给定</p>
</li>
<li>
<p>函数调用时，可以不传入关键字参数，而只传入位置参数</p>
</li>
<li>
<p>关键字参数应该在位置参数后面进行定义</p>
</li>
</ul>
<p><strong>Demo1</strong>:</p>
<pre><code class="language-Python">def tag(name, *content, cls=None, **attrs): # name 和 cls 之间的参数，全部打包给 content(tuple类型)
    &quot;&quot;&quot;Generate one or more HTML tags&quot;&quot;&quot;
    if cls is not None:
        attrs['class'] = cls
    if attrs:
        attr_str = ''.join(' %s=&quot;%s&quot;' % (attr, value) for attr, value in sorted(attrs.items()))
    else:
        attr_str = ''
    if content:
        return '\n'.join('&lt;%s%s&gt;%s&lt;/%s&gt;' % (name, attr_str, c, name) for c in content)
    else:
        return '&lt;%s%s /&gt;' % (name, attr_str)
</code></pre>
<pre><code class="language-Python">&gt;&gt;&gt; tag('br')
'&lt;br /&gt;'
&gt;&gt;&gt; tag('p', 'hello')
'&lt;p&gt;hello&lt;/p&gt;'
&gt;&gt;&gt; print(tag('p', 'hello', 'world'))
&lt;p&gt;hello&lt;/p&gt;
&lt;p&gt;world&lt;/p&gt;
&gt;&gt;&gt; tag('p', 'hello', id=33)
'&lt;p id=&quot;33&quot;&gt;hello&lt;/p&gt;'
&gt;&gt;&gt; print(tag('p', 'hello', 'world', cls='sidebar'))
&lt;p class=&quot;sidebar&quot;&gt;hello&lt;/p&gt;
&lt;p class=&quot;sidebar&quot;&gt;world&lt;/p&gt;
&gt;&gt;&gt; tag(content='testing', name=&quot;img&quot;)
'&lt;img content=&quot;testing&quot; /&gt;'
&gt;&gt;&gt; my_tag = {'name': 'img', 'title': 'Sunset Boulevard',
... 'src': 'sunset.jpg', 'cls': 'framed'}
&gt;&gt;&gt; tag(**my_tag)
'&lt;img class=&quot;framed&quot; src=&quot;sunset.jpg&quot; title=&quot;Sunset Boulevard&quot; /&gt;'
</code></pre>
<p><strong>Demo2</strong>:</p>
<pre><code class="language-Python">def run(a, b):
    print a + b
    
dictionary = {'a': 1, 'b': 2}
run(**dictionary) # ** 的作用，类似于 *(1,2,3) 的 unpack
</code></pre>
<h3 id="retriving-information-about-parameters-inspect"><a class="header" href="#retriving-information-about-parameters-inspect">Retriving Information About Parameters: inspect</a></h3>
<p>我们在只知道函数接口的情况下，如何获知 function 的所有参数及其类型？Python标准库: <strong>inspect</strong></p>
<table><thead><tr><th>属性</th><th>desc</th></tr></thead><tbody>
<tr><td><code>__defaults__</code></td><td>tuple(位置参数和关键字参数的默认值)</td></tr>
<tr><td><code>__code__.co_varnames</code></td><td>tuple(存储了函数参数的name还有函数中定义的name)</td></tr>
<tr><td><code>__code__.co_argcount</code></td><td>value: 参数的个数，不包括以 <code>*</code> 和 <code>**</code> 打头的参数</td></tr>
</tbody></table>
<p>通过 <code>__defaults__</code> 变量，我们可以得到函数的参数的默认值，通过 <code>__code__</code> 变量，我们可以知道变量的名字还有变量的个数。通过这两个变量，我们就可以倒推出所有的变量和默认值。</p>
<pre><code class="language-Python">def factorial(n=5):
    &quot;&quot;&quot;return n!&quot;&quot;&quot;
    return 1 if n &lt; 2 else n * factorial(n-1)

factorial.__defaults__ # (5,)
factorial.__code__.co_argcount # 1
factorial.__code__.co_varnames # ('n',)
</code></pre>
<p>不过有一个 Python 的 built-in package 已经帮我们封装好了该功能：<code>inspect</code>, Demo:</p>
<pre><code class="language-Python">from inspect import signature
def foo(num, mul=10):
    pass
sig = signature(foo) # &lt;class 'inspect.Signature'&gt;
    for name, param in sig.parameters.items(): # inspect.Signature.parameters 是一个 map object
    print(param.kind, &quot;:&quot;, name, &quot;=&quot;, param.default)

&quot;&quot;&quot;
POSITIONAL_OR_KEYWORD : num = &lt;class 'inspect._empty'&gt;
POSITIONAL_OR_KEYWORD : mul = 10
&quot;&quot;&quot;
</code></pre>
<p>其中，inspect._empty 表示该参数没有 default value，kind 表示该参数的参数类型。</p>
<p>inspect.Signature 对象有一个 <strong><code>bind</code> 方法</strong>，用于将参数绑定到函数进行测试，看看传入的参数是否满足函数的要求。Demo:</p>
<pre><code class="language-Python">&gt;&gt;&gt; import inspect
&gt;&gt;&gt; sig = inspect.signature(tag)
&gt;&gt;&gt; my_tag = {'name': 'img', 'title': 'Sunset Boulevard',
... 'src': 'sunset.jpg', 'cls': 'framed'}
&gt;&gt;&gt; bound_args = sig.bind(**my_tag)
&gt;&gt;&gt; bound_args
&lt;inspect.BoundArguments object at 0x...&gt;
&gt;&gt;&gt; for name, value in bound_args.arguments.items():
... print(name, '=', value)
...
name = img
cls = framed
attrs = {'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}
&gt;&gt;&gt; del my_tag['name']
&gt;&gt;&gt; bound_args = sig.bind(**my_tag)
Traceback (most recent call last):
...
TypeError: 'name' parameter lacking default value
</code></pre>
<p>很多 Framework 和 IDE 会利用 <code>inspect.Signature.bind()</code> 方法来判断用户输入的参数是否合理，从而给出错误提示。</p>
<h3 id="function-annotation-函数注解"><a class="header" href="#function-annotation-函数注解">Function Annotation: 函数注解</a></h3>
<p>Python3 中引入了函数注解，用于解释函数的参数和返回值等信息，函数注解存储在 <code>__annotations__</code> 中。</p>
<p>语法：</p>
<pre><code class="language-Python">def foo(html:str, num:&quot;int &gt; 0&quot;=10) -&gt; str:
    
    pass
</code></pre>
<p>输出函数注解：</p>
<pre><code class="language-Python">foo.__annotations__
{'html': &lt;class 'str'&gt;, 'num': 'int &gt; 0', 'return': &lt;class 'str'&gt;}
</code></pre>
<p>注意，Python 对于这些函数注解，只是将其放在了 <code>__annotations__</code> 中，其他就没有进行任何的操作，更不会进行代码的check。事实上，函数的注解 Annotation 更多的被 IDE 和 <strong>装饰器</strong> 使用，其对于 <strong>Python 的解释器来说，没有任何作用</strong>。</p>
<h3 id="packages-for-functional-programming"><a class="header" href="#packages-for-functional-programming">Packages for Functional Programming</a></h3>
<p>Python 语言的创立者 Guido 并没有想要 Python 成为一个函数式编程语言，但是通过两个标注库的帮助，我们可以实现 Python 的函数式编程：<code>operator, functools</code>。<strong>在函数式编程中，函数常常被当作参数进行传递</strong>，而 <code>operator</code> 中恰恰就提供了一些基础的函数操作，<code>operator</code> 中提供的<strong>操作符，实际上就是函数</strong>。</p>
<p><img src="reading/fluent-python/chapters/assets/1564369906979.png" alt="函数式编程相关包" /></p>
<h4 id="operator"><a class="header" href="#operator">operator</a></h4>
<p><code>operator</code> 提供了很多操作符，这些操作符实际上就是匿名函数。其中有两类操作符：</p>
<ul>
<li>算数操作符：<code>add, mul, sub</code></li>
<li>用来从 sequence 选取元素、从对象中读取属性的操作符：<code>itemgetter, attrgetter</code>，返回元素为 tuple 的 sequence。（itemgetter 使用了 [] operator，只要是实现了 <code>__getitem__()</code> 这个魔法方法的类型，都可以将 itemgetter 应用到其中）</li>
</ul>
<p>注意，itemgetter 和 attrgetter 这两个操作符，实际上都是函数，其返回的对象也是函数。</p>
<p><strong>算数操作符举例</strong>：</p>
<pre><code class="language-Python">from functools import reduce
from operator import mul
def fact(n):
    return reduce(mul, range(1, n+1))
	# 如果我们不适用 operator，则需要创建一个 lambda expression，(匿名函数)
    # return reduce(lambda x,y: x*y, range(1, n+1))
</code></pre>
<p><strong>选取元素操作符举例</strong>：(针对 sequence 数据结构，返回 sequence)</p>
<pre><code class="language-python">from operator import itemgetter

students = [
    (&quot;wansho&quot;, 23, &quot;lianyungang&quot;, (99, 100)),
    (&quot;wangkai&quot;, 25, &quot;qingdao&quot;, (99, 100)),
    (&quot;zhanganman&quot;, 24, &quot;xuzhou&quot;, (99, 100))
]

sorted_students_in_ages = sorted(students, key=itemgetter(1)) # 根据学生的年龄排序, sorted_by
print(sorted_students_in_ages)

print(list(map(itemgetter(0,1), students))) # 取 0，1列，此处的 itemgetter 定义了一个抓取数据的规则

</code></pre>
<p><strong>获取属性操作符</strong>：(针对键值对数据结构，返回属性对应的值)</p>
<pre><code class="language-python">from operator import attrgetter
from collections import namedtuple

Student = namedtuple(&quot;Student&quot;, &quot;name age home scores&quot;)
Score = namedtuple(&quot;Score&quot;, &quot;math, english&quot;)
students_namedtuple = [Student(name, age, home, Score(math, english))
    for (name, age, home, (math, english)) in students]
print(students_namedtuple)

attrgetter_name_score = attrgetter(&quot;name&quot;, &quot;scores.math&quot;) # 定义了一个函数
for item in students_namedtuple:
    print(attrgetter_name_score(item)) # 将 item(namedtuple) 作为参数传入预先定义好的规则
&quot;&quot;&quot; print
('wansho', 99)
('wangkai', 99)
('zhanganman', 99)
&quot;&quot;&quot;
</code></pre>
<p><strong>获取所有的操作符</strong></p>
<pre><code class="language-python">import operator
print([item for item in dir(operator) if not item.startswith(&quot;_&quot;)])

&quot;&quot;&quot;
['abs', 'add', 'and_', 'attrgetter', 'concat', 'contains', 'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 'truth', 'xor']

其中，以字母 i 为前缀的操作符，其都是 inplace 函数

&quot;&quot;&quot;

from operator import iadd
num1 = 10
num2 = 2
num1 = iadd(num1, num2) # 等价于 num1 += num2
</code></pre>
<p><strong>methodcaller</strong></p>
<p>methodcaller 可以对 method（classmethod）进行二次封装，然后返回封装后的函数，通常用于 freezing arguments。</p>
<p>应用场景：将参数冻结，然后复用这个函数</p>
<pre><code class="language-python">from operator import methodcaller

my_replace = methodcaller(&quot;replace&quot;, &quot; &quot;, &quot;-&quot;) # 注意：封装的函数名必须是 stringed method
print(my_replace(&quot;nihao hello world&quot;)) # nihao-hello-world
</code></pre>
<h4 id="functools"><a class="header" href="#functools">functools</a></h4>
<p>functools 中有很多 high-order functions，也就是说，可以传入函数参数或者返回函数的函数。</p>
<p>functools 中最常用的两个函数：reduce, partial, partialmethod</p>
<p>partial 和 partialmethod 通常用于对 function 和 classmethod 进行二次封装，其中 partialmethod 经常用于 classmethod 的重载。</p>
<pre><code class="language-python">from functools import partial, partialmethod
from operator import mul

my_mul = partial(mul, 3) # mul 是一个 function，freeze 好一个参数，剩下另一个参数
lst = [my_mul(num) for num in range(10)] 
print(lst)

&gt;&gt;&gt; class Cell(object):
...     def __init__(self):
...         self._alive = False
...     @property
...     def alive(self):
...         return self._alive
...     def set_state(self, state):
...         self._alive = bool(state)
...     set_alive = partialmethod(set_state, True)
...     set_dead = partialmethod(set_state, False)
...
&gt;&gt;&gt; c = Cell()
&gt;&gt;&gt; c.alive
False
&gt;&gt;&gt; c.set_alive()
&gt;&gt;&gt; c.alive
True

# 注意, functools.partial 的 operator.methodcaller 的不同之处在于，methodcaller 封装的函数名必须是 string method，而 functools.partial 封装的函数名必须是 function，functools.partialmethod 封装的函数名必须是 method
</code></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/3252228/python-why-is-functools-partial-necessary">Python: why is functools.partial necessary</a></p>
</li>
<li>
<p><a href="https://docs.python.org/3/howto/functional.html">Great introduction to functional programming in python</a></p>
</li>
<li>
<p><strong>Everything that is good in Python was stolen from other languages.</strong> ——Guido</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter6-design-patterns-with-first-class-functions"><a class="header" href="#chapter6-design-patterns-with-first-class-functions">Chapter6. Design Patterns with First-Class Functions</a></h1>
<p>[TOC]</p>
<p>当我们引入了 <strong>函数作为第一公民</strong> 的概念后，Peter Norvig 建议我们重新思考的几个设计模式为：</p>
<table><thead><tr><th>English</th><th>Chinese</th></tr></thead><tbody>
<tr><td>Strategy Pattern (policy pattern)</td><td>策略模式</td></tr>
<tr><td>Command Pattern</td><td>命令模式</td></tr>
<tr><td>Template Method Pattern</td><td>模板方法模式</td></tr>
<tr><td>Visitor Pattern</td><td>访问者模式</td></tr>
</tbody></table>
<p>在以上四种设计模式中，function 可以被用来替代某些类的实例。</p>
<h2 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h2>
<p><strong>函数作为第一公民后，其在某种程度上，就可以替代 class，函数和 class 同样重要</strong></p>
<h2 id="classic-strategy-pattern"><a class="header" href="#classic-strategy-pattern">Classic Strategy Pattern</a></h2>
<h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p><img src="reading/fluent-python/chapters/assets/1564454456022.png" alt="策略模式" /></p>
<p>当一个事情根据不同的情况，有多种方案时，例如：</p>
<ol>
<li>超市的折扣针对不同的 Context，有不同的打折方案</li>
<li>携程曾经针对不同的用户，有不同的付款策略，对于老顾客杀熟</li>
<li>饿了吗定外卖的时候，有多种不同的支付方式</li>
</ol>
<p>那么就可以联想到 Strategy Pattern。Strategy Pattern 的本质：<strong>具体问题具体分析</strong>。</p>
<h3 id="classic-implement"><a class="header" href="#classic-implement">Classic Implement</a></h3>
<p>经典的 Strategy Pattern 实现。从这个示例代码中，我们可以学到很多知识。</p>
<pre><code class="language-Python"># -*- coding: utf-8 -*-

from collections import namedtuple
from abc import ABC, abstractmethod

Customer = namedtuple(&quot;Customer&quot;, &quot;name fidelity&quot;) # 没有成员方法，可以直接用 namedtuple 来包装


class LineItem:
    &quot;&quot;&quot;商品&quot;&quot;&quot;
    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price

    def total(self):
        return self.price * self.quantity


class Order: # the Context
    &quot;&quot;&quot;订单&quot;&quot;&quot;
    def __init__(self, customer, cart, promotion=None): # promotion 是可选参数，默认为 None
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        &quot;&quot;&quot;计算商品总额&quot;&quot;&quot;
        if not hasattr(self, &quot;__total&quot;): # 判断是否有该属性，防止重复计算
            self.__total = sum(item.total() for item in self.cart)
        return self.__total

    def due(self):
        &quot;&quot;&quot;应付额&quot;&quot;&quot;
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion.discount(self) # 将当前类的对象传入
        return self.total() - discount

    def __repr__(self): # print(order)
        return &quot;&lt;Order tota:{:.2f} due:{:.2f}&gt;&quot;.format(self.total(), self.due())


class Promotion(ABC): # The Strategy: an abstract base class，抽象基类
    &quot;&quot;&quot;促销基类，定下契约&quot;&quot;&quot;
    @abstractmethod
    def discount(self, order):
        &quot;&quot;&quot;折扣&quot;&quot;&quot;
        pass


class FidelityPromotion(Promotion): # concrete strategy
    &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot;
    def discount(self, order):
        return 0 if order.customer.fidelity &lt; 1000 else order.total() * .05


class BulkItemPromotion(Promotion): # concrete strategy
    &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot;
    def discount(self, order):
        discount = 0
        for item in order.cart:
            if item.quantity &gt;= 20:
                discount += item.total() * .1 # Python 的小数可以不写 0
        return discount


class LargeOrderPromotion(Promotion): # concrete strategy
    &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot;
    def discount(self, order):
        discount = 0
        distinct_items = {item.product for item in order.cart}
        if len(distinct_items) &gt;= 10:
            discount = order.total() * .07
        return discount


if __name__ == &quot;__main__&quot;:

    joe = Customer(&quot;John Doe&quot;, 0)
    ann = Customer(&quot;Ann Smith&quot;, 1100)
    cart = [
        LineItem(&quot;banana&quot;, 4, .5),
        LineItem(&quot;apple&quot;, 10, 1.5),
        LineItem(&quot;orange&quot;, 5, 5.0)
    ]
    order1 = Order(ann, cart, promotion=FidelityPromotion()) # 传入一个策略：类的实例
    print(order1)  # &lt;Order tota:42.00 due:39.90&gt;

</code></pre>
<h3 id="function-oriented-strategy"><a class="header" href="#function-oriented-strategy">Function-Oriented Strategy</a></h3>
<p>现在分析一下上面的面向对象的代码，对于每一种策略，我们都要用一个类将其封装，这个步骤是不是很多余？是不是没有突出重点？我们只是想要创建一个轻量的策略哎</p>
<p>为什么不能直接传入一个策略呢？Python 的函数和 class 一样，都是一等公民啊</p>
<p><strong>重构原理</strong></p>
<p>因为 first-class object 的特性，function 可以和对象一样进行赋值。在很多时候，我们为了调用某个方法，需要实例化包装该方法的类，这是不必要的，有了 first-class function 后，我们不需要将功能性的方法包装在类中再调用，而是可以直接将 function 作为参数传入，<strong>A function is more light-weight than an instance of user-defined class</strong>。当我们需要实现某个接口的唯一方法时，我们可以用 function 来取代该 Class。</p>
<p>实际上，应用 Frist-class function 这一特性，function 可以重构很多设计模式在 Python 中的实现。Peter Norvig 说过，23 个设计模式中，有 16 个设计模式可以在动态语言中被重构，甚至已经被设计到了编程语言中。</p>
<p>Function-Oriented Strategy Pattern 实现。</p>
<pre><code class="language-Python"># -*- coding: utf-8 -*-

from collections import namedtuple
from operator import itemgetter

Customer = namedtuple(&quot;Customer&quot;, &quot;name fidelity&quot;)


class LineItem:
    &quot;&quot;&quot;商品&quot;&quot;&quot;
    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price

    def total(self):
        return self.price * self.quantity


class Order: # the Context
    &quot;&quot;&quot;订单&quot;&quot;&quot;
    def __init__(self, customer, cart, promotion=None): # promotion 是可选参数，默认为 None
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        &quot;&quot;&quot;计算商品总额&quot;&quot;&quot;
        if not hasattr(self, &quot;__total&quot;): # 判断是否有该属性，防止重复计算
            self.__total = sum(item.total() for item in self.cart)
        return self.__total

    def due(self):
        &quot;&quot;&quot;应付额&quot;&quot;&quot;
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.total() - discount

    def __repr__(self):
        return &quot;&lt;Order tota:{:.2f} due:{:.2f}&gt;&quot;.format(self.total(), self.due())


def fidelity_promotion(order): # concrete strategy
    &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot;
    return 0 if order.customer.fidelity &lt; 1000 else order.total() * .05


def bulk_item_promotion(order): # concrate strategy
    &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot;
    discount = 0
    for item in order.cart:
        if item.quantity &gt;= 20:
            discount += item.total() * .1
    return discount


def large_order_promotion(order): # concrate strategy
    &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot;
    discount = 0
    distinct_items = {item.product for item in order.cart}
    if len(distinct_items) &gt;= 10:
        discount = order.total() * .07
    return discount


def get_best_promotion(order, promotions):
    &quot;&quot;&quot;获取最大的 promotion&quot;&quot;&quot;
    promotion2discount = [(promotion, promotion(order)) for promotion in promotions]
    sorted_promotion2discount = sorted(promotion2discount, key=itemgetter(1))
    return sorted_promotion2discount[-1][0]


if __name__ == &quot;__main__&quot;:

    joe = Customer(&quot;John Doe&quot;, 0)
    ann = Customer(&quot;Ann Smith&quot;, 1100)
    cart = [
        LineItem(&quot;banana&quot;, 4, .5),
        LineItem(&quot;apple&quot;, 40, 1.5),
        LineItem(&quot;orange&quot;, 5, 5.0),
    ]

    existed_promotions = [globals()[name] for name in globals()
                  if name.endswith(&quot;_promotion&quot;) and not name.endswith(&quot;best_promotion&quot;)] # 遍历获取所有策略，进而兼容新加入的策略
    order1 = Order(ann, cart)
    order1.promotion = get_best_promotion(order1, existed_promotions)
    print(order1.total())
    print(order1.due())  # &lt;Order tota:42.00 due:39.90&gt;

</code></pre>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li>
<p><a href="http://norvig.com/design-patterns/">Design-Patterns</a></p>
</li>
<li>
<p><a href="https://docs.python.org/3/library/abc.html">ABC: Python Abstract Base Class</a></p>
</li>
<li>
<p><a href="ftp://ftp.rasla.ru/Books/_IT_/Python/Gennadiy_Zlobin_-_Learning_Python_Design_Patter.pdf">Learning Python Design Patterns</a></p>
</li>
<li>
<p><a href="http://norvig.com/design-patterns/">Design Patterns in Dynamic Languages</a></p>
</li>
<li>
<p><a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter7-function-decorators-and-closures"><a class="header" href="#chapter7-function-decorators-and-closures">Chapter7. Function Decorators and Closures</a></h1>
<p>[TOC]</p>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>装饰器和 function 是紧密结合在一起的。</p>
<p>装饰器是装饰设计模式的 Python 实现。</p>
<p>装饰器本质上是一个 High-Order Function，其输入是被装饰的 function（<strong>First-Class Object 思想</strong>），输出也是一个 function。装饰器根据返回的 function 可以分成如下两类装饰器：</p>
<ol>
<li>返回的 function 为输入的 function：装饰器不影响原 function，只是对原 function 进行一些计算，例如 PySnooper 就是这种类型的装饰器，其只是将 function 内的计算结果打印出来，并不会影响原 function</li>
<li>返回的 function 是新的 function：装饰器内创建一个新的 function （<strong>闭包</strong>）</li>
</ol>
<blockquote>
<p>A decorator is a callable that takes another function as argument (the decorated function). The decorator may perform some processing with decorated function, and returns it or replaces it with another function or callable object. —— Fluent-Python</p>
</blockquote>
<h2 id="demo-and-characteristic"><a class="header" href="#demo-and-characteristic">Demo and Characteristic</a></h2>
<p><strong>decorator_demo.py</strong></p>
<pre><code class="language-Python"># -*- coding: utf-8 -*-

def decorator_without_inner(func):
    print(&quot;print without inner&quot;)
    return func


def decorator_with_inner(func):
    def inner():
        print(&quot;print inner&quot;)
    return inner


@decorator_without_inner
def target1():
    print(&quot;target1&quot;)


@decorator_with_inner # 等价于 decorator_with_inner(target2)
def target2():
    print(&quot;target2&quot;)


if __name__ == &quot;__main__&quot;:
    target1() 
    &quot;&quot;&quot;
    print without inner # 先执行装饰器 有点 super 的味道
    target1  # 再执行本函数内的语句 
    &quot;&quot;&quot;
    print(target1) # &lt;function target1 at 0x000001E01B8F9A60&gt;
    
    target2()
    &quot;&quot;&quot;
    print without inner
    print inner  # 装饰器返回新的函数 inner(), inner() 取代了 target2()
    &quot;&quot;&quot;
    print(target2) # &lt;function decorator_with_inner.&lt;locals&gt;.inner at 0x000001E01B8F9F28&gt;

</code></pre>
<h3 id="返回的-function-为输入的-function"><a class="header" href="#返回的-function-为输入的-function">返回的 function 为输入的 function</a></h3>
<p>function 没有改变，那么先执行装饰器，再执行原 function。注意：如果返回的 function 还是输入的 function，那么被装饰的 function 的引用仍然指向原 function。</p>
<h4 id="策略设计模式的优化"><a class="header" href="#策略设计模式的优化">策略设计模式的优化</a></h4>
<p>Chapter6 中策略设计模式(function-oriented) 的缺点：</p>
<ol>
<li>所有策略必须用统一的后缀，进而获取所有的策略</li>
</ol>
<p>用装饰器优化后的策略设计模式的优点：</p>
<ol>
<li>策略 function 不需要使用统一的后缀</li>
<li>装饰器的名称可以清晰地表明该 function 的功能</li>
</ol>
<pre><code class="language-python">from collections import namedtuple
from operator import itemgetter

Customer = namedtuple(&quot;Customer&quot;, &quot;name fidelity&quot;)


class LineItem:
    &quot;&quot;&quot;商品&quot;&quot;&quot;
    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price

    def total(self):
        return self.price * self.quantity


class Order: # the Context
    &quot;&quot;&quot;订单&quot;&quot;&quot;
    def __init__(self, customer, cart, promotion=None): # promotion 是可选参数，默认为 None
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        &quot;&quot;&quot;计算商品总额&quot;&quot;&quot;
        if not hasattr(self, &quot;__total&quot;): # 判断是否有该属性，防止重复计算
            self.__total = sum(item.total() for item in self.cart)
        return self.__total

    def due(self):
        &quot;&quot;&quot;应付额&quot;&quot;&quot;
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.total() - discount

    def __repr__(self):
        return &quot;&lt;Order tota:{:.2f} due:{:.2f}&gt;&quot;.format(self.total(), self.due())


promotions = []

  
def promotion_strategy(promotion):
    promotions.append(promotion)
    return promotion


@promotion_strategy
def fidelity_promotion(order): # concrete strategy
    &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot;
    return 0 if order.customer.fidelity &lt; 1000 else order.total() * .05


@promotion_strategy
def bulk_item_promotion(order): # concrate strategy
    &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot;
    discount = 0
    for item in order.cart:
        if item.quantity &gt;= 20:
            discount += item.total() * .1
    return discount


@promotion_strategy
def large_order_promotion(order): # concrate strategy
    &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot;
    discount = 0
    distinct_items = {item.product for item in order.cart}
    if len(distinct_items) &gt;= 10:
        discount = order.total() * .07
    return discount


def get_best_promotion(order):
    &quot;&quot;&quot;获取最大的 promotion&quot;&quot;&quot;
    promotion2discount = [(promotion, promotion(order)) for promotion in promotions]
    sorted_promotion2discount = sorted(promotion2discount, key=itemgetter(1))
    return sorted_promotion2discount[-1][0]


if __name__ == &quot;__main__&quot;:

    joe = Customer(&quot;John Doe&quot;, 0)
    ann = Customer(&quot;Ann Smith&quot;, 1100)
    cart = [
        LineItem(&quot;banana&quot;, 4, .5),
        LineItem(&quot;apple&quot;, 40, 1.5),
        LineItem(&quot;orange&quot;, 5, 5.0),
    ]

    order1 = Order(ann, cart)
    order1.promotion = get_best_promotion(order1)
    print(order1.total())
    print(order1.due())  # &lt;Order tota:42.00 due:39.90&gt;
    
</code></pre>
<h3 id="返回的-function-为新的-function"><a class="header" href="#返回的-function-为新的-function">返回的 function 为新的 function</a></h3>
<p>新的 function 会<strong>替换</strong>掉旧的 function，然后只执行新的 function，实际上，此时的被装饰后的 function 的引用已经指向了 新的 function。</p>
<h3 id="装饰器的两大特征"><a class="header" href="#装饰器的两大特征">装饰器的两大特征</a></h3>
<ul>
<li>
<p>可以替换被装饰的 function</p>
</li>
<li>
<p><strong>在 module 被 import 的时候，就被执行，这一特性可以用于模块加载时候的初始化</strong>（类似于 Java 的静态代码块，随着类的加载而加载）</p>
<pre><code class="language-python">import decorator_demo

&quot;&quot;&quot;
print without inner
&quot;&quot;&quot;
</code></pre>
<p>被装饰的 function，在 import 之后就会执行装饰器function（注意并不会执行被装饰function）。</p>
</li>
</ul>
<h3 id="装饰器的实际应用"><a class="header" href="#装饰器的实际应用">装饰器的实际应用</a></h3>
<ul>
<li>一个实际应用中的装饰器，通常被定义在与被装饰 function 不同的 module 中</li>
<li>一个实际应用中的装饰器，通常会定义一个 inner function 用来替代原 function</li>
</ul>
<h2 id="python-function变量作用域"><a class="header" href="#python-function变量作用域">Python function变量作用域</a></h2>
<h3 id="function-local-variable"><a class="header" href="#function-local-variable">function local variable</a></h3>
<p>Demo:</p>
<pre><code class="language-Python">b = 6
def test():
    a = 9
    print(a)
    print(b)
    b = 8
    
test()

&quot;&quot;&quot;
Traceback (most recent call last):
9
  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;input&gt;&quot;, line 4, in test
UnboundLocalError: local variable 'b' referenced before assignment
&quot;&quot;&quot;

###########################################################################

a = 6

def test():
    a = 7
    print(a)

test()
print(a)

&quot;&quot;&quot;
7
6
&quot;&quot;&quot;

###########################################################################

a = 6

def test():
    print(a)
&quot;&quot;&quot;
6
&quot;&quot;&quot;
</code></pre>
<p>Python 解释器在编译上面的代码时，其看到变量 b 在 test 中进行了<strong>赋值</strong>，则判断 b 为 test function 中的 local variable，<strong>Python 会将在 function 进行赋值的变量判定为 局部变量。并且这个局部变量，和全局变量虽然名字相似，但却是两个完全不相关的变量，只有当 function 中没有定义局部变量 a 时，function 才会去全局变量中找匹配的变量。</strong></p>
<p>如何解决上面的报错：在 function 中使用 <strong>global</strong> 来引用全局变量</p>
<pre><code class="language-Python">b = 6


def test():
    global b
    a = 9
    print(a)
    print(b)
    b = 8


test()
print(b) # 8

&quot;&quot;&quot;
9
6
8
&quot;&quot;&quot;
</code></pre>
<h3 id="function-local-variable-in-python-and-javascript"><a class="header" href="#function-local-variable-in-python-and-javascript">function local variable in Python and Javascript</a></h3>
<p>Python 和 Javascript 都不要求对变量的类型进行声明，但是不同的是，<strong>Python 会把 function 中赋值或定义的变量自动判定为局部变量，而 JavaScript 的 function 中如果声明了一个变量，则默认为 global variable，需要加上 <code>var</code> 才能表示为 function 内的局部变量</strong>。</p>
<h2 id="closures闭包"><a class="header" href="#closures闭包">Closures(闭包)</a></h2>
<h3 id="闭包的介绍"><a class="header" href="#闭包的介绍">闭包的介绍</a></h3>
<p>A closure is a <a href="https://en.wikipedia.org/wiki/Record_(computer_science)">record</a> storing a <a href="https://en.wikipedia.org/wiki/Function_(computer_science)">function</a>[<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-1">a]</a> together with an environment.</p>
<p>闭包是一个绑定了 free variable 的 function，其可以看成是对 (function + environment/contex) 的封装/绑定。闭包实现了 function 对定义在 function 外的 nonglobal variable 的访问，其拓展了 function 的范围，将 function 外的 free variable 绑定。闭包返回的是封装后的 function。	</p>
<h3 id="闭包-demo"><a class="header" href="#闭包-demo">闭包 Demo</a></h3>
<pre><code class="language-python">
def get_average():
    nums = [] # environment / binded to avg
    
    def avg(num): # function
        nums.append(num)
        return sum(nums) / len(nums)
    return avg

# avg + nums 就是一个闭包

avg = get_average()
print(avg(10)) # 10
print(avg(8)) # 9
print(avg(6)) # 8

# 被绑定到 avg 上的 free variable: nums 可以通过 __closure__ 查看
print(avg.__closure__) # (&lt;cell at 0x0000029DB8F007F8: list object at 0x0000029DB8DA6248&gt;,)
print(avg.__closure__[0].cell_contents) # [10, 8, 6]
</code></pre>
<h3 id="闭包的应用场景"><a class="header" href="#闭包的应用场景">闭包的应用场景</a></h3>
<ul>
<li>
<p><strong>装饰器返回新的 function</strong></p>
<p>闭包经常用在装饰器中，用来返回一个新的 function。</p>
</li>
<li>
<p><strong>异步编程</strong></p>
</li>
<li>
<p><strong>函数式编程</strong></p>
</li>
</ul>
<p>我的一点小观察：闭包将 function 和 变量一起打包，这不就是一个内部类吗？？？有属性，有方法</p>
<h3 id="the-nonlocal-declaration"><a class="header" href="#the-nonlocal-declaration">The nonlocal Declaration</a></h3>
<p>由函数作用域，我们得知，<strong>变量一旦在函数中被赋值，就会被标记成局部变量，如此就会丧失闭包的特性</strong>，失去对free variable 的绑定。在 function 中，我们通过 <strong>global</strong> 关键字来绑定全局变量，在闭包中，我们使用 <strong>nonlocal</strong> 关键字对在闭包函数中进行赋值的 function 进行绑定。</p>
<p>Demo:</p>
<pre><code class="language-Python">def make_average():
    sum = 0
    count = 0
    def avg(num):
        nonlocal sum, count
        sum += num
        count += 1
        return sum / count
    return avg
</code></pre>
<h2 id="a-simple-decorator"><a class="header" href="#a-simple-decorator">A Simple Decorator</a></h2>
<p>一个典型的装饰器逻辑是这样的：</p>
<blockquote>
<p>it replaces the decorated function with a new function that accepts the same arguments and (usually) returns whatever the decorated function was supposed to return, while also doing some extra processing. </p>
</blockquote>
<p><strong>用新的函数覆盖旧函数后，旧函数的引用就会指向新的函数，导致旧函数的属性被隐藏</strong>，例如函数名 <code>__name__</code> 和注释 <code>__doc__</code> 都会变成新的函数。Python 提供了 <code>functools.wraps</code> 装饰器来将被装饰的 function 的属性 copy 到新的 function 上。</p>
<p>下面我们实现一个标准的装饰器，装饰器的目的是打印函数的执行时间：</p>
<pre><code class="language-Python">import time
from functools import wraps


def clock(func):
    @wraps(func) # 解决被装饰函数属性被屏蔽的问题
    def clocked(*args): # 不确定位置参数有几个，用 *args 来覆盖位置参数
        start = time.perf_counter()
        result = func(*args)
        elapsed = time.perf_counter() - start
        arg_str = &quot;, &quot;.join([repr(arg) for arg in args]) # 打印参数
        print(&quot;[%0.8fs] %s(%s) ——&gt; %r&quot; % (elapsed, func.__name__, arg_str, result))
        return result # 原函数返回什么，这里照常返回什么
    return clocked

@clock
def fibonacci(num):
    if num &lt; 2:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)

# @clock 等价于 clock(fibonacci)

fibonacci(10) # 比较耗时的计算，违反了递归的重复计算准则

&quot;&quot;&quot;
……
……
[0.00004190s] fibonacci(4) ——&gt; 3
[0.00013850s] fibonacci(6) ——&gt; 8
[0.00039610s] fibonacci(8) ——&gt; 21
[0.00363930s] fibonacci(10) ——&gt; 55
&quot;&quot;&quot;

print(fibonacci.__name__) # fibonacci
# 因为装饰器 wraps 将被装饰函数的属性 copy 到了新的函数上，所以 fibonacci 函数的引用仍然指向 clocked，但是 clocked 的属性变成了 fibonacci 的属性，所以我们从表面上来看，还是指向了 fibonacci
</code></pre>
<h2 id="built-in-decorators"><a class="header" href="#built-in-decorators">built-in Decorators</a></h2>
<p>介绍几个 Python 标准库自带的装饰器函数</p>
<h3 id="functoolswraps"><a class="header" href="#functoolswraps">functools.wraps</a></h3>
<p>已经在上一节介绍，用于 copy 被装饰 function 的属性到新的 function 中。</p>
<h3 id="functoolslru_cache"><a class="header" href="#functoolslru_cache">functools.lru_cache</a></h3>
<p>存储 function 的计算结果，减少重复计算，可用于 Fibonacci 的优化。</p>
<p>lru_cache 是一个<strong>装饰器工厂</strong>，其可以接收参数，然后返回定制后的装饰器。lru_cache 可以传入两个参数：</p>
<ul>
<li>maxsize: 表示 cache 的 size，能存储的结果数</li>
<li>typed: if true, 那么 cache 会区分不同的输入类型，例如区分 1 和 1.0，默认为 false</li>
</ul>
<pre><code class="language-Python">from functools import lru_cache

@lru_cache()
@clock
def fibonacci(num):
    if num &lt; 2:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)

fibonacci(10)

&quot;&quot;&quot;
[0.00000030s] fibonacci(1) ——&gt; 1
[0.00000020s] fibonacci(0) ——&gt; 0
[0.00003770s] fibonacci(2) ——&gt; 1
[0.00004400s] fibonacci(3) ——&gt; 2
[0.00005280s] fibonacci(4) ——&gt; 3
[0.00005840s] fibonacci(5) ——&gt; 5
[0.00006450s] fibonacci(6) ——&gt; 8
[0.00007010s] fibonacci(7) ——&gt; 13
[0.00007620s] fibonacci(8) ——&gt; 21
[0.00008190s] fibonacci(9) ——&gt; 34
[0.00008800s] fibonacci(10) ——&gt; 55
&quot;&quot;&quot;
</code></pre>
<h3 id="functoolssingledispatch"><a class="header" href="#functoolssingledispatch">functools.singledispatch</a></h3>
<p><strong>Python 用 装饰器 实现重载</strong>:</p>
<p><strong>为什么能够用装饰器实现重载？装饰器的本质，就是传入一个函数，然后返回一个函数，而重载，就是对函数的重载，所以两者天然是可以结合的</strong></p>
<pre><code class="language-Python">from functools import singledispatch
from collections import abc
import numbers
import html

@singledispatch
def htmlize(obj):
	content = html.escape(repr(obj))
	return '&lt;pre&gt;{}&lt;/pre&gt;'.format(content)

@htmlize.register(str)
def _(text): # 函数名无关紧要，用 _ 表示即可
    content = html.escape(text).replace('\n', '&lt;br&gt;\n')
    return '&lt;p&gt;{0}&lt;/p&gt;'.format(content)

@htmlize.register(numbers.Integral)
def _(n):
	return '&lt;pre&gt;{0} (0x{0:x})&lt;/pre&gt;'.format(n)

@htmlize.register(tuple)
@htmlize.register(abc.MutableSequence)
def _(seq):
    inner = '&lt;/li&gt;\n&lt;li&gt;'.join(htmlize(item) for item in seq)
    return '&lt;ul&gt;\n&lt;li&gt;' + inner + '&lt;/li&gt;\n&lt;/ul&gt;'
</code></pre>
<p><strong>Python 用 singledispatch 重载和 Java 重载， if/else 的区别</strong>：</p>
<p>Java 的重载或者 if/else 是由缺陷的，其将更多的注意力放在了一个<strong>代码单元</strong>中，class 或者是 function，singledispatch 的优点是，其可以<strong>支持模块化的扩展</strong>，每一个 module 都可以注册一个专门的 function，其屏蔽了实现细节（不管用类还是用if/else），将更多的注意力放在了重载本身。实际上，Python 对于很多语言特性的实现，都进行了更高层次的逻辑抽取，屏蔽了大量的语法细节，使得开发者能够更专注于业务和问题的解决。</p>
<h2 id="stacked-decorators"><a class="header" href="#stacked-decorators">Stacked Decorators</a></h2>
<pre><code class="language-Python">@d1
@d2
def func():
    print(&quot;test&quot;)
    
# 等价于 d1(d2(func))
</code></pre>
<h2 id="decorator-factory"><a class="header" href="#decorator-factory">Decorator Factory</a></h2>
<p>带参数 <code>()</code> 的装饰器，都是装饰器工厂</p>
<p>装饰器工厂，是传入装饰器参数，输入定制的装饰器，Demo:</p>
<pre><code class="language-Python">import time
DEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -&gt; {result}'
def clock(fmt=DEFAULT_FMT):
	def decorate(func):
		def clocked(*_args):
            t0 = time.time()
            _result = func(*_args)
            elapsed = time.time() - t0
            name = func.__name__
            args = ', '.join(repr(arg) for arg in _args)
            result = repr(_result)
            print(fmt.format(**locals()))
			return _result
		return clocked
	return decorate


if __name__ == '__main__':
    @clock() # 先返回一个装饰器：decorate,然后再传入 snooze: decorate(snooze)
    def snooze(seconds):
        time.sleep(seconds)
        for i in range(3):
        	snooze(.123)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter8-object-reference-multability-and-recycling"><a class="header" href="#chapter8-object-reference-multability-and-recycling">Chapter8 Object Reference, Multability, and Recycling</a></h1>
<p>从第八章开始，开始学习 Python 的面向对象特性。</p>
<p>[TOC]</p>
<h2 id="variable-are-not-boxes"><a class="header" href="#variable-are-not-boxes">Variable Are not Boxes</a></h2>
<p>Demo:</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
</code></pre>
<p>Description:</p>
<p><img src="reading/fluent-python/chapters/assets/1565684807557.png" alt="reference vs box" /></p>
<h2 id="identity-equality-aliases"><a class="header" href="#identity-equality-aliases">Identity, Equality, Aliases</a></h2>
<h3 id="id-和-is"><a class="header" href="#id-和-is">id() 和 is</a></h3>
<p>在 CPython 解释器中，<code>id()</code> 返回的是对象的内存地址(unique)，在其他 Python 解释器中，不一定。</p>
<h3 id="-vs-is"><a class="header" href="#-vs-is">== vs is</a></h3>
<p>is 比较的是对象的 id。<code>a == b</code> 本质上是一个语法糖，其会被解释成 <code>a.__eq__(b)</code>， 不同的对象，其 <code>__eq__()</code>方法会进行不同的重写，例如字符串会将其重写成对每个字符进行比较，list 会将其重写成对每个元素进行比较。<strong>由于 <code>==</code> 被不同的 built-in types 进行了不同的重写，所以其执行速度往往要慢于 is，is 只是通过 id() 获取内存地址，然后比较，是非常快的</strong>。</p>
<h2 id="shallow-copy-vs-deep-copy"><a class="header" href="#shallow-copy-vs-deep-copy">Shallow Copy vs Deep Copy</a></h2>
<h3 id="shallow-copy"><a class="header" href="#shallow-copy">Shallow Copy</a></h3>
<p>Demo: </p>
<pre><code class="language-Python">from copy import copy
l1 = [1, [2, 3], (4, 5, 6)]
# list 浅拷贝的三种方式
l2 = list(l1)
l3 = l1[:]
l4 = copy(l1)

l1 == l2 == l3
True
l1 is l2
False
l1 is l3
False

l1[1] is l2[1]
l2[1] is l3[1]
True

l1[1].append(7)
l2[1]
[2, 3, 7] # 引用指向的地址空间相同，变了

l1[2] += (8,9)
l2[2]
(4, 5, 6) # 没变，+= on tuple 会创建一个新的 tuple
</code></pre>
<p><strong>之所以 l1 is l2 结果为 False，是因为浅拷贝只是拷贝了容器，容器内的元素只是拷贝了其引用，这样可以节省内存</strong>。</p>
<p>浅拷贝只是拷贝了一个空壳，其内容都是引用：</p>
<p><img src="reading/fluent-python/chapters/assets/1565688253077.png" alt="深拷贝与浅拷贝" /></p>
<h3 id="deep-copy"><a class="header" href="#deep-copy">Deep Copy</a></h3>
<pre><code class="language-Python">from copy import deepcopy
</code></pre>
<h2 id="浅拷贝应用举例"><a class="header" href="#浅拷贝应用举例">浅拷贝应用举例</a></h2>
<p><strong>避免将 mutable objects 作为函数参数的默认值</strong></p>
<p>Demo:</p>
<pre><code class="language-Python">class HauntedBus:

    def __init__(self, passengers=[]): # 设置默认值为 mutable object
        self.passengers = passengers

    def pick(self, name):
        self.passengers.append(name)

    def drop(self, name):
        self.passengers.remove(name)


bus1 = HauntedBus([1,2])
print(bus1.passengers) # [1, 2]

bus2 = HauntedBus() # 启动默认值
bus2.pick(12) 
print(bus2.passengers) # [12]

bus3 = HauntedBus() 
print(bus3.passengers) # [12]，初始化后默认有了参数

bus4 = HauntedBus([1,2,3,4])
print(bus4.passengers) # [1, 2, 3, 4]

bus5 = HauntedBus()
bus5.pick(14)
print(bus5.passengers) # [12, 14]，不断增加

</code></pre>
<p>上面的做法，<strong>实际上 self.passengers 指向了外部的 list，导致类封装失败</strong>。</p>
<p>正确的做法，用浅拷贝将传入的参数进行封装，使得 Bus 拥有了自己的属性，我们对于 passenger 的操作，不会影响到初始化时传入的引用对应的内存地址，我们操作的只是其引用：</p>
<pre><code class="language-Python">class HauntedBus:
    def __init__(self, passengers=None): # 设置为 None
        if passengers is None:
            self.passenger = []
        else:
            self.passenger = list(passenger) # 用浅拷贝将传入的参数进行封装

    def pick(self, name):
        self.passengers.append(name)

    def drop(self, name):
        self.passengers.remove(name)
</code></pre>
<h2 id="del-和-python-垃圾回收机制"><a class="header" href="#del-和-python-垃圾回收机制">del 和 Python 垃圾回收机制</a></h2>
<h3 id="del"><a class="header" href="#del">del</a></h3>
<p>del 命令只会删除引用，并不会删除对象，也就是说，并不会回收地址空间。del 命令本质上也是一个语法糖，其会被 Python 解释器 CPython 解释成魔法方法: <code>__del__()</code></p>
<h3 id="garbage-collection-gc"><a class="header" href="#garbage-collection-gc">Garbage Collection (GC)</a></h3>
<p>Python 的垃圾回收算法主要为：reference counting(引用计数)，当一个对象对应的引用数为 0 时，也就是说，没有引用指向该内存空间时，则回收该对象的内存空间。每 del 一个 reference，引用数 - 1。</p>
<h2 id="interning-驻留"><a class="header" href="#interning-驻留">Interning 驻留</a></h2>
<p>Interning 现象是 Python 解释器的优化导致的，其目的应该是为了<strong>节约内存</strong>。</p>
<p>驻留现象告诉我们，对于 Python 的字符串和数值型类型的比较，应该用 ==，不能用 is 来比较。</p>
<h3 id="字符串驻留"><a class="header" href="#字符串驻留">字符串驻留</a></h3>
<pre><code class="language-Python">name1 = &quot;wansho&quot;
name2 = &quot;wansho&quot;

name1 is name2 # true，实际上这应该是两个完全不同的对象
</code></pre>
<h3 id="整型值驻留"><a class="header" href="#整型值驻留">整型值驻留</a></h3>
<pre><code class="language-Python">num1 = 1
num2 = 1

id(num1) == id(num2) # true

num1 = 100
num2 = 100

id(num1) == id(num2) # true

num1 = 1000
num2 = 1000

id(num1) == id(num2) # false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-pythonic-object"><a class="header" href="#a-pythonic-object">A Pythonic Object</a></h1>
<p>[TOC]</p>
<p>第九章衔接第一章，介绍如何实现一个 Python 风格的对象。本章会重点介绍 Python 的魔法方法。</p>
<h2 id="how-to-implement-a-pythonic-object"><a class="header" href="#how-to-implement-a-pythonic-object">How to Implement a Pythonic Object</a></h2>
<p>Python 并不是通过继承来实现某一个对象的特征，而是通过实现具体的魔法方法，来使一个对象具有某些特征。这就是 Python 的鸭子类型，实现了鸭子走和叫两个魔法方法，那么我们就拥有了鸭子的特征；实现了 <code>__len__()</code> 和 <code>__getitem__()</code> 这两个魔法方法，那么我们就拥有了 list 的特征，就可以调用 list 相关的标准库。</p>
<p>简单来说，<strong>我们想要我们自定义的类拥有什么样的特征，那么直接去实现去对应的魔法方法即可</strong>。</p>
<h2 id="object-representation-表示对象"><a class="header" href="#object-representation-表示对象">Object Representation 表示对象</a></h2>
<p>print(object) 会打印出啥？</p>
<h3 id="__repr__"><a class="header" href="#__repr__"><code>__repr__()</code></a></h3>
<p><code>print()</code> 方法会被 Python 解释器解释成 <code>__repr__()</code>，<code>__repr__()</code> 是<strong>面向开发者</strong>的</p>
<h3 id="__str__"><a class="header" href="#__str__"><code>__str__()</code></a></h3>
<p><code>str()</code> 方法会被 Python 解释器解释成 <code>__str__()</code>，<code>__str__()</code> 是<strong>面向用户</strong>的，如果 <code>__str__()</code> 没有被实现，那么就会调用 <code>__repr__()</code> 方法</p>
<h3 id="__bytes__"><a class="header" href="#__bytes__"><code>__bytes__()</code></a></h3>
<p>bytes() 会调用该魔法方法，返回 byte sequence，将对象字节化</p>
<h3 id="__format__"><a class="header" href="#__format__"><code>__format__()</code></a></h3>
<p>built-in function: <code>format()</code></p>
<p>str method: <code>str.format()</code></p>
<h2 id="创建一个-vector2d-类"><a class="header" href="#创建一个-vector2d-类">创建一个 vector2d 类</a></h2>
<h3 id="实现-iterable"><a class="header" href="#实现-iterable">实现 Iterable</a></h3>
<pre><code class="language-python">def __iter__(self):
    &quot;&quot;&quot;make a Vector2d iterable, make unpacking work
        vector = Vector2d(3, 4)
        x, y = vector
        iterable 是 tuple(this) 和 unpack 的基础
        返回一个 生成器表达式
        &quot;&quot;&quot;
    return (i for i in (self.x, self.y))
</code></pre>
<h3 id="实现-representation"><a class="header" href="#实现-representation">实现 Representation</a></h3>
<p>实现 <code>__repr__()</code> 方法的准则：</p>
<p>Note that in our <code>__repr__</code> implementation we used <code>!r</code> to obtain the standard repre‐sentation of the attributes to be displayed. This is good practice, as it shows the crucialdifference between Vector(1, 2) and Vector('1', '2') — the latter would not work in the context of this example, because the constructors arguments must be numbers, not str. </p>
<p>The string returned by <code>__repr__</code> should be unambiguous and, if possible, match the source code necessary to recreate the object being represented. That is why our chosen representation looks like calling the constructor of the class, e.g. Vector(3, 4).</p>
<pre><code class="language-python">def __repr__(self):
    &quot;&quot;&quot;实现 print(vector) 的自定义&quot;&quot;&quot;
    class_name = type(self).__name__
    # __repr__ builds a string by interpolating the components with {!r} to get their
    # repr; because Vector2d is iterable, *self feeds the x and y components to
    # format
    return &quot;{}({!r}, {!r})&quot;.format(class_name, *self)
</code></pre>
<p>判断 <code>__repr__()</code> 方法实现的效果：</p>
<pre><code class="language-python">v1 = Vector2d(3, 4)
v1_clone = eval(repr(v1))
v1 == v1_clone
</code></pre>
<h3 id="实现-print"><a class="header" href="#实现-print">实现 print</a></h3>
<pre><code class="language-python">def __str__(self):
    &quot;&quot;&quot;因为 Vector2d 是 iterable 的，所以其可以作为参数传入 tuple&quot;&quot;&quot;
    return str(tuple(self))
</code></pre>
<h3 id="实现比较功能"><a class="header" href="#实现比较功能">实现比较功能</a></h3>
<pre><code class="language-python">def __eq__(self, other):
    &quot;&quot;&quot;实现两个 vector 的可比性&quot;&quot;&quot;
    return tuple(self) == tuple(other)
</code></pre>
<h2 id="特征--魔法方法"><a class="header" href="#特征--魔法方法">特征 ——&gt; 魔法方法</a></h2>
<table><thead><tr><th>语法</th><th>魔法方法</th></tr></thead><tbody>
<tr><td>==</td><td><code>__eq__()</code></td></tr>
<tr><td>repr()</td><td><code>__repr__()</code></td></tr>
<tr><td>str()</td><td><code>__str__()</code></td></tr>
<tr><td>bool()</td><td><code>__bool__()</code></td></tr>
<tr><td>format(), str.format()</td><td><code>__format__()</code></td></tr>
<tr><td>list</td><td><code>__len__()</code> + <code>__getitem__()</code></td></tr>
<tr><td>Iterable (单个对象可迭代)</td><td><code>__iter__()</code></td></tr>
<tr><td>hashable (可 hash)</td><td>1. 私有化成员变量 2. <code>__hash__()</code> 3. <code>__eq__()</code></td></tr>
<tr><td>hash()</td><td><code>__hash__()</code></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="staticmethod-and-classmethod"><a class="header" href="#staticmethod-and-classmethod">staticmethod and classmethod</a></h2>
<p>classmethod is good for and staticmethod is not veryuseful.</p>
<p><strong>staticmethod</strong>: Sometimes, you'll write code that belongs to a class, but that doesn't use the object itself at all.</p>
<p><strong>classmethod</strong>: Class methods are methods that are not bound to an object, but to… a class!</p>
<p>Python 用两个内置的装饰器来实现静态方法。静态方法随着类的加载而加载，可以通过类名直接调用。</p>
<p>上面两个静态方法，不同点在于，classmethod 的第一个参数会传入类。Demos:</p>
<pre><code class="language-Python">@staticmethod
def count(nums):
    return len(nums)

@classmethod
def frombytes(cls, octets): # 该方法属于该类，而不是属于对象
    typecode = chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(*memv)
</code></pre>
<p>当我们在静态方法中，需要用到类时，就可以用 <code>@classmethod</code> 来修饰，例如上面的第二个例子中的 <code>cls(*memv)</code></p>
<p>The classmethod decorator is clearly useful, but I’ve never seen a compelling use case for staticmethod. If you want do define a function that does not interact with the class, just define it in the module. Maybe the function is closely related even if it never touches the class, so you want to them nearby in the code. Even so, defining the function right before or after the class in the same module is close enough for all practical purposes.</p>
<p>其他人对于 staticmethod 和 classmethod 的观点：</p>
<p><a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">[The definitive guide on how to use static, class or abstract methods in Python]</a></p>
<h2 id="格式化-format"><a class="header" href="#格式化-format">格式化 format</a></h2>
<p>官方教程：<a href="https://docs.python.org/3.4/library/string.html#format-string-syntax">Format String Syntax</a></p>
<p>三种特殊的格式化标记：</p>
<table><thead><tr><th>转换标记</th><th>解释成</th></tr></thead><tbody>
<tr><td><code>%s</code>, <code>!s</code></td><td><code>str()</code></td></tr>
<tr><td><code>%r</code>, <code>!r</code></td><td><code>repr()</code></td></tr>
<tr><td><code>%a</code>, <code>!a</code></td><td><code>ascii()</code></td></tr>
</tbody></table>
<p><strong>format 的两种用法</strong></p>
<p>fotmat 不仅可以对字符串进行格式化，还可以对很多对象进行格式化，时间对象，数值对象等</p>
<pre><code class="language-python">format(0.4115226337448559, '0.4f')
'1 BRL = {rate:0.2f} USD'.format(rate=brl)
</code></pre>
<p><strong>%</strong></p>
<pre><code class="language-Python">name = &quot;wansho&quot;
age = 25

&quot;age: %d&quot; % age

&quot;name: %s&quot; % name # # %s 会被 Python 解释器解释成 str(name)
&quot;name: %a&quot; % name # %r 会被 Python 解释器解释成 ascii(name)
&quot;name: %r&quot; % name # %r 会被 Python 解释器解释成 repr(name)

</code></pre>
<p><strong>format</strong></p>
<pre><code class="language-Python">name = &quot;wansho&quot;
age = 25

&quot;age: {}&quot;.format(age)
&quot;age: {age}&quot;.format(age = age)

'{2}, {1}, {0}'.format('a', 'b', 'c') # 'c, b, a'
'{2}, {1}, {0}'.format(*'abc') # 'c, b, a', * 用于将 字符串 解包
'{0}{1}{0}'.format('aa', 'bb') # aabbaa
&quot;{:,}&quot;.format(6000000) # 6,000,000 https://www.cnblogs.com/lovejh/p/9201219.html

&quot;name: {!r}&quot;.format(name)
&quot;name: {!s}&quot;.format(name)
&quot;name: {!a}&quot;.format(name)
</code></pre>
<p><strong>数字格式化</strong></p>
<p>下表展示了 str.format() 格式化数字的多种方法：</p>
<pre><code class="language-python">print(&quot;{:.2f}&quot;.format(3.1415926));
# 3.14
</code></pre>
<table><thead><tr><th style="text-align: left">数字</th><th style="text-align: left">格式</th><th style="text-align: left">输出</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">3.1415926</td><td style="text-align: left">{:.2f}</td><td style="text-align: left">3.14</td><td style="text-align: left">保留小数点后两位</td></tr>
<tr><td style="text-align: left">3.1415926</td><td style="text-align: left">{:+.2f}</td><td style="text-align: left">+3.14</td><td style="text-align: left">带符号保留小数点后两位</td></tr>
<tr><td style="text-align: left">-1</td><td style="text-align: left">{:+.2f}</td><td style="text-align: left">-1.00</td><td style="text-align: left">带符号保留小数点后两位</td></tr>
<tr><td style="text-align: left">2.71828</td><td style="text-align: left">{:.0f}</td><td style="text-align: left">3</td><td style="text-align: left">不带小数</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left">{:0&gt;2d}</td><td style="text-align: left">05</td><td style="text-align: left">数字补零 (填充左边, 宽度为2)</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left">{:x&lt;4d}</td><td style="text-align: left">5xxx</td><td style="text-align: left">数字补x (填充右边, 宽度为4)</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left">{:x&lt;4d}</td><td style="text-align: left">10xx</td><td style="text-align: left">数字补x (填充右边, 宽度为4)</td></tr>
<tr><td style="text-align: left">1000000</td><td style="text-align: left">{:,}</td><td style="text-align: left">1,000,000</td><td style="text-align: left">以逗号分隔的数字格式</td></tr>
<tr><td style="text-align: left">0.25</td><td style="text-align: left">{:.2%}</td><td style="text-align: left">25.00%</td><td style="text-align: left">百分比格式</td></tr>
<tr><td style="text-align: left">1000000000</td><td style="text-align: left">{:.2e}</td><td style="text-align: left">1.00e+09</td><td style="text-align: left">指数记法</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left">{:&gt;10d}</td><td style="text-align: left">13</td><td style="text-align: left">右对齐 (默认, 宽度为10)</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left">{:&lt;10d}</td><td style="text-align: left">13</td><td style="text-align: left">左对齐 (宽度为10)</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left">{:^10d}</td><td style="text-align: left">13</td><td style="text-align: left">中间对齐 (宽度为10)</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><code>'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)</code></td><td style="text-align: left"><code>1011 11 13 b 0xb 0XB</code></td><td style="text-align: left">进制</td></tr>
</tbody></table>
<h2 id="hashable"><a class="header" href="#hashable">Hashable</a></h2>
<p>一个自定义的类型，如何才能 hashable？</p>
<ol>
<li>首先要实现 <code>__hash__()</code> 的魔法方法</li>
<li>如果实现了 <code>__eq__()</code> 方法，那么需要私有化成员变量</li>
</ol>
<h3 id="私有化成员变量--hash"><a class="header" href="#私有化成员变量--hash">私有化成员变量 / hash</a></h3>
<p>通过加<strong>双下划线</strong>，实现成员变量的<strong>私有化</strong>；通过 @property 装饰器，用来装饰<strong>只读方法</strong>。</p>
<p>Demo:</p>
<pre><code class="language-Python">class Vector2d:
    typecode = 'd'

    def __init__(self, x, y):
        self.__x = float(x)
        self.__y = float(y)

    @property
    def x(self):
        return self.__x

    @property
    def y(self):
        return self.__y

    def __iter__(self):
        return (i for i in (self.x, self.y))  # 虽然私有化，但是内部仍然可以直接通过 self.x, self.y 调用

    def __hash__(self):
        return hash(self.x) ^ hash(self.y)
</code></pre>
<p>从上面这个例子可以看出，装饰器可以用来隐藏一些实现的细节，简化 function，使得语法更加简练，装饰器也可以用来表明一个 function 的作用。</p>
<h2 id="private-attributes-in-python"><a class="header" href="#private-attributes-in-python">private attributes in Python</a></h2>
<p>截止到本章本知识点，本书没有提及私有方法的实现，只在本章提到了私有属性。</p>
<pre><code class="language-Python">vector = Vector2d(3, 4)
print(vector.__dict__)
vector._Vector2d__x = 6
print(vector.__dict__)
vector.y = 8
&quot;&quot;&quot;
{'_Vector2d__x': 3.0, '_Vector2d__y': 4.0}
{'_Vector2d__x': 6, '_Vector2d__y': 4.0}
Traceback (most recent call last):
  File &quot;D:/Github-Code/test/hashable.py&quot;, line 29, in &lt;module&gt;
    vector.y = 8
AttributeError: can't set attribute
&quot;&quot;&quot;
</code></pre>
<p>从上面的例子我们可以看出，虽然我们已经设置了 Python 对象成员变量的私有，但是我们还是可以在该类对象的 <code>__dict__</code> 中看到该对象的私有变量，并且对其进行修改。</p>
<p>实际上，<strong>Python 不能实现真正的变量私有化</strong>，Python 的私有变量并不是 Java 的 private。我们从上面的例子可以看到，在进行 Python 所谓的私有化之后，<strong>Python 对私有变量加入了 <code>_classname</code> 的前缀，从而使得外部的写操作因为找不到真正的变量而失效</strong>，但是我们仍然可以通过加入前缀进行写的操作，这个无法避免，也是 Python 私有化和 Java 私有化的一个很大的区别。</p>
<h2 id="protected-attribute-in-python"><a class="header" href="#protected-attribute-in-python">protected attribute in Python</a></h2>
<p>在 Python 的编码传统里，习惯将单下划线 <code>_</code> 作为 protect 标记，表示我们不能在类外获取该属性，即该属性是类私有的，只能在类或者子类中使用。但是单下划线对于 Python 解释器来说，没有任何意义，只是一个约定俗成的规定。</p>
<p>另外，单下划线前缀在 module 的最上层变量确实有一个作用，如果我们通过 <code>from my_module import *</code>，那么以单下划线 <code>_</code> 为前缀的变量并不会被导入。</p>
<h2 id="saving-space-with-__slots__-class-attribute"><a class="header" href="#saving-space-with-__slots__-class-attribute">saving space with <code>__slots__</code> class attribute</a></h2>
<p>Python 默认将类的成员变量存储在 <code>__dict__</code> 中，其实际上是将属性存储了字典中，那么如果属性太多，那么就会占用太多的空间，<code>__slots__</code> 可以对其进行优化，不再详述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-hacking-hashing-and-slicing"><a class="header" href="#sequence-hacking-hashing-and-slicing">Sequence-Hacking-Hashing-and-Slicing</a></h1>
<p>Python 自定义一个向量类。</p>
<p>第九章和第十章，都是在教我们如何创建一个 Python 风格 (Pythonic) 的类。尤其本章，是手把手教我们创建一个多维向量。讲了很多 Python 类型的实现细节，本章暂时不深入学习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces-from-protocols-to-abcs"><a class="header" href="#interfaces-from-protocols-to-abcs">Interfaces: From Protocols to ABCs</a></h1>
<blockquote>
<p>An abstract class represents an interface. —— Bjarne Stroustrup Creator of C++</p>
</blockquote>
<p>[TOC]</p>
<p>11，12，13 章都在讨论 Python 的接口和继承，比较晦涩，就算看懂了，到了用的时候也忘了，所以这几章暂时不学了，等用到的时候再看。</p>
<h2 id="protocols--interface"><a class="header" href="#protocols--interface">Protocols / Interface</a></h2>
<p>Python 有两种接口（协议），一种是<strong>隐式</strong>的：魔法方法协议（鸭子类型），一种是<strong>显式</strong>的：ABCs。</p>
<p>Python 可以和 Java 一样，实现多继承（Java 实现多个接口）。</p>
<h2 id="隐式魔法方法协议"><a class="header" href="#隐式魔法方法协议">隐式：魔法方法协议</a></h2>
<p>只要某一个类型走起路来像一直鸭子，叫声也像一只鸭子，那么这个类型就是鸭子的子类，即使这个类型并没有显式的继承自鸭子类。例如：</p>
<pre><code class="language-python">class Struggle:
    def __len__(self): return 23
    
isinstance(Struggle(), abc.Sized)
True
</code></pre>
<p>只要实现了 <code>__len__</code> 的魔法方法，那么其就是 <code>abc.sized</code> 的子类，即使该类并没有显式的进行继承。这也从侧面反映出，<code>isinstance</code> 和 <code>issubclass</code> 这两个个方法在 Python 中是一个比较<strong>鸡肋</strong>的存在。</p>
<p>实际上，Python 很多的协议都是根据魔法方法来体现的。我实现了某个魔法方法，就相当于继承了某个类，拥有了该类的特性。</p>
<h3 id="monkey-patching-猴子补丁"><a class="header" href="#monkey-patching-猴子补丁">Monkey-Patching 猴子补丁</a></h3>
<p>Monkey-Patching 用于在<strong>运行时</strong>修改类或者模块，其并不会改变源码。</p>
<p>Demo:</p>
<p>对于一个自定义的 Sequence，只有实现了 <code>__setitem__()</code> 方法，才能实现 shuffle，有时候我们在源码中可能会忘记加这一方法，在交互式 Console 中执行时，我们意识到了需要实现该方法时，我们可以不需要改动源码，通过动态加入该方法的方式，完成补丁。</p>
<pre><code class="language-Python">&gt;&gt;&gt; from random import shuffle
&gt;&gt;&gt; from frenchdeck import FrenchDeck
&gt;&gt;&gt; deck = FrenchDeck()
&gt;&gt;&gt; shuffle(deck)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;.../python3.3/random.py&quot;, line 265, in shuffle
x[i], x[j] = x[j], x[i]
TypeError: 'FrenchDeck' object does not support item assignment

&gt;&gt;&gt; def set_card(deck, position, card): # 动态的创建出一个 function
... 	deck._cards[position] = card
...
&gt;&gt;&gt; FrenchDeck.__setitem__ = set_card # 将补丁赋值给该类
&gt;&gt;&gt; shuffle(deck)
&gt;&gt;&gt; deck[:5]
</code></pre>
<h2 id="interfaces-and-protocols-in-python-culture"><a class="header" href="#interfaces-and-protocols-in-python-culture">Interfaces and protocols in Python culture</a></h2>
<p><strong>protected and private attributes</strong></p>
<p>By definition, protected and private attributes are not part of an interface, even if “protected” is merely a naming convention (the single leading underscore) and private attributes are easily accessed.</p>
<p><strong>Python 对 Interface 的理解</strong></p>
<p>Python 的接口，其侧重点在：像不像（鸭子类型），而 Java 的接口，则遵循严格的协议。</p>
<p>A useful complementary definition of interface is: the subset of an object’s public methods that enable it to play a specific role in the system. That’s what is implied when the Python documentation mentions “a file-like object” or “an iterable”, without specifying a class. An interface seen as a set of methods to fulfill a role is what Smalltalkers called a procotol, and the term spread to other dynamic language communities. Protocols are independent of inheritance. A class may implement several protocols, enabling its instances to fulfill several roles. </p>
<p>Protocols are interfaces, but because they are informal — defined only by documentation and conventions — protocols cannot be enforced like formal interfaces can (we’ll see how ABCs enforce interface conformance later in this chapter). A protocol may be partially implemented in a particular class, and that’s OK.  I point this out to emphasize that “X-like object”, “X protocol” and “X interface” are synonyms in the minds of Pythonistas.</p>
<h2 id="显式abcs"><a class="header" href="#显式abcs">显式：ABCs</a></h2>
<p>当 ABCs(Abstract Base Classes) 被引入 Python（Python2.6） 的时候，Python 已经 15 岁了。</p>
<h3 id="python-内置的-abcs-及使用"><a class="header" href="#python-内置的-abcs-及使用">Python 内置的 ABCs 及使用</a></h3>
<p>Python 内置的 ABCs 主要分布在两个 module 中：</p>
<ul>
<li>collections.abc
<ul>
<li>collections.abc.Sequence</li>
<li>collections.abc.Size</li>
<li>……</li>
</ul>
</li>
<li>numbers
<ul>
<li>Complex</li>
<li>Real</li>
<li>Integral</li>
<li>……</li>
</ul>
</li>
</ul>
<h4 id="collectionsabc"><a class="header" href="#collectionsabc">collections.abc</a></h4>
<pre><code class="language-python">from collections.abc import Sequence
</code></pre>
<h4 id="numbers"><a class="header" href="#numbers">numbers</a></h4>
<pre><code class="language-Python">import numbers
isinstance(3, numbers.Real) # True
isinstance(3.3, numbers.Real) # True
isinstance(True, numbers.Real) # True
isinstance(3, numbers.Integral) # True
</code></pre>
<h3 id="如何定义自己的-abcs-并使用"><a class="header" href="#如何定义自己的-abcs-并使用">如何定义自己的 ABCs 并使用</a></h3>
<p>继承 abc.ABC，然后抽象函数用装饰器：<code>@abstractmethod</code> 来装饰</p>
<p>策略设计模式的例子：</p>
<pre><code class="language-Python">
from abc import ABC, abstractmethod

class Promotion(ABC): # The Strategy: an abstract base class，抽象基类
    &quot;&quot;&quot;促销基类，定下契约&quot;&quot;&quot;
    @abstractmethod
    def discount(self, order):
        &quot;&quot;&quot;折扣&quot;&quot;&quot;
        pass


class FidelityPromotion(Promotion): # concrete strategy
    &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot;
    def discount(self, order):
        return 0 if order.customer.fidelity &lt; 1000 else order.total() * .05


class BulkItemPromotion(Promotion): # concrete strategy
    &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot;
    def discount(self, order):
        discount = 0
        for item in order.cart:
            if item.quantity &gt;= 20:
                discount += item.total() * .1 # Python 的小数可以不写 0
        return discount
</code></pre>
<p>注意：abc.ABC 是 Python3.4 以后才引入的，Python3.4 之前要创建 ABCs，应该使用 metaclass</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-1"><a class="header" href="#questions-1">Questions</a></h1>
<p>创建 Questions 的目的：用来快速回顾 Python 的重点。</p>
<p>[TOC]</p>
<h2 id="python-总结"><a class="header" href="#python-总结">Python 总结</a></h2>
<p>Python 是一种动态强类型的语言，采用鸭子类型来实现多态。</p>
<h2 id="chapter1-the-python-data-model-1"><a class="header" href="#chapter1-the-python-data-model-1">Chapter1. The Python Data Model</a></h2>
<ul>
<li>Python 语言最大的特性</li>
<li>魔法方法的优点 — 3个</li>
<li>魔法方法 <code>in</code> 和 <code>__contains__()</code> 的关系</li>
<li>魔法方法 <code>bool()</code> 和 <code>__bool__()</code>,  <code>__len__()</code> 的关系</li>
<li><code>__repr__()</code> 和 <code>__str__()</code> 的区别，<code>__repr__()</code> 和 <code>%r</code> 的关系</li>
<li>解释 Duck Typing（鸭子模型），鸭子类型与多态的关系</li>
</ul>
<h2 id="chapter2-an-array-of-sequences-1"><a class="header" href="#chapter2-an-array-of-sequences-1">Chapter2. An Array of Sequences</a></h2>
<ul>
<li>Builted-in Sequence 的两种分类</li>
<li>Slice 不包含最后一个元素的原因</li>
<li>通过 Slice 进行逆序 sequence 的方法</li>
<li>Slice Object 及其作用（Slice 对象）</li>
<li>Sequence 的 Slice 赋值及其妙用</li>
<li><code>+ *</code> 和 <code>+=, *=</code> 的区别</li>
<li>生成器表达式 和 列表推导式 的区别</li>
<li>生成器表达式的语法</li>
<li>tuple 的两个作用</li>
<li>tuple 的两种定义方式，有一种特殊的定义方式</li>
<li>tuple 是否完全是 immutable，是否任意 tuple 都可以 hash</li>
<li>tuple 的拆包（unpacking）和 常见的应用场景</li>
<li>namedtuple 和 tuple 的区别，namedtuple 的使用场景</li>
<li><code>*</code> 的作用</li>
<li>字符串格式化的两种方式，解释 <code>%r</code> 和 <code>{!r}</code></li>
<li>解释字符串格式化的三种特殊的格式化标记: <code>%r</code>,<code>%s</code>,<code>%a</code></li>
<li>解释 <code>enumerate()</code> 及其作用</li>
<li><code>lst.sort()</code> 和 <code>sorted()</code> 的区别</li>
<li>inplace 方法的优点和缺点</li>
<li><code>bisect</code> 模块的使用场景</li>
<li><code>array.array</code> 的特性及其优点</li>
<li><code>deque</code> 的特性及其使用场景</li>
<li>Python 哑变量</li>
</ul>
<h2 id="chapter3-dictionaries-and-sets-1"><a class="header" href="#chapter3-dictionaries-and-sets-1">Chapter3. Dictionaries and Sets</a></h2>
<ul>
<li>可以 hashable 的类型</li>
<li>hash 表的原理</li>
<li>为什么 list 不能 hash</li>
<li>dict 的特点和使用情境</li>
<li>dict 的常见构造方法 / 弹出数据 / 随机弹出数据的方法</li>
<li>如何创建带有默认 value 的 dict </li>
<li>dict 的 <code>update()</code> 方法具体步骤</li>
<li>dict 如何对 key-value 同时遍历</li>
<li>dict 查找时，处理 missing key 的 几种方式，哪两种方式更高效？原理是什么</li>
<li>dict 的变体：OrderDict / Counter 的特性，如何对字符串中的字符进行统计</li>
<li>Set 有哪些特性</li>
<li>Set 的比较运算符/算数运算符/ inplace operator</li>
<li>Set 和 Dict 的区别在哪里，速度上有差距吗，差在哪里</li>
<li>dict in JSON Style 的弊端，如果只是想用 dict 单纯的存储数据，那么用什么来替代 dict</li>
</ul>
<h2 id="chapter4-text-versus-bytes-1"><a class="header" href="#chapter4-text-versus-bytes-1">Chapter4. Text versus Bytes</a></h2>
<ul>
<li>byte，unicode 的定义，Unicode sequence 和 byte sequence 的区别是什么</li>
<li>byte 和 Unicode 如何互相转换</li>
<li>Python2/Python3 默认的字符串类型，Python 2如何定义 Unicode 字符串</li>
<li>Python3 如何定义 Byte sequence</li>
<li>Python 默认的编码器</li>
<li>Python 如何判断文本的编码格式，如何对文本进行 byte 字节流的读写</li>
<li>Python 为何要 Encode</li>
<li>解释 大端和小端，BOM，utf-8 和 utf-8 BOM，Unicode Sandwich</li>
<li>正则表达式对 byte 进行匹配</li>
</ul>
<h2 id="chapter5-first-class-functions-1"><a class="header" href="#chapter5-first-class-functions-1">Chapter5. First-Class Functions</a></h2>
<ul>
<li>解释 First-Class Functions</li>
<li>解释 High-Order Functions，有哪些常用的 High-Order Function</li>
<li>reduce 的思想，Python 中有哪些可以取代 reduce 的 built-in function ？</li>
<li>Function Object 有哪些重要的 attribute 和 method</li>
<li>map/filter 的思想，其返回的类型是什么，是否可以被替换</li>
<li>Lambda 表达式本质上是什么，其优点有哪些</li>
<li>什么是 callable object，最简单的 callable object 是什么，如何判断一个对象是否是 callable object</li>
<li>Python 中有哪几种 callable object</li>
<li>如何实现一个对象的 callable，要在该类中实现哪个方法</li>
<li>Python 中 method 和 function 分别指代的是什么</li>
<li>Python 中 built-in method/function 指的是什么，举个例子</li>
<li>如何获取一个函数对象的所有属性</li>
<li>Python 的 函数能否赋予自定义的属性，该属性存储在哪里</li>
<li>关键字参数和位置参数</li>
<li>如何在只有函数接口的情况下，了解函数的所有参数和默认值情况，传统的方法是什么，最快速的方法是什么</li>
<li>如何预判断传入的参数，是否符合函数的要求？</li>
<li><code>functools</code> 和 <code>operator</code>两个 package 的作用和使用场景</li>
<li>如何用 sorted function 对 list 进行不同要求的排序，例如按照长度/首字母/元组的第 n 个元素</li>
<li>instance，internal state 在 Python 中指代什么</li>
</ul>
<h2 id="chapter6-design-patterns-with-functions"><a class="header" href="#chapter6-design-patterns-with-functions">Chapter6. Design-Patterns with Functions</a></h2>
<ul>
<li>设计模式一书中一共定义了多少种设计模式，有多少种设计模式在动态语言中可能被重构</li>
<li>解释 Strategy Pattern，策略模式的经典例子是什么</li>
<li>策略模式在 Python 中可以怎么重构，其核心思想是什么</li>
<li>Python 中创建抽象基类的步骤</li>
<li>Python 中判断类中是否包含某属性的方法</li>
<li>Python 中对象和 None 怎么比较</li>
<li>Python 中小于 1 的小数，可以怎么写</li>
<li>Python 类中如何获取类中的符号表，包括属性和方法</li>
</ul>
<h2 id="chapter7-function-decorators-and-closures-1"><a class="header" href="#chapter7-function-decorators-and-closures-1">Chapter7. Function Decorators and Closures</a></h2>
<ul>
<li>number 是 immutable 类型还是 mutable 类型</li>
<li>Python 输出小数的方式，print 中 %r 被解释成哪一个函数</li>
<li>解释 abc module </li>
<li>不需要函数名的函数，可以取什么样的函数名</li>
<li>解释一下装饰器，装饰器和 first-class function / 闭包的关系，装饰器可以分成哪两类</li>
<li>如何用装饰器对策略设计模式进行优化</li>
<li>介绍装饰器的几个特征</li>
<li>装饰器在实际工程中，通常如何应用</li>
<li>Python function 内变量的作用域，function 如何界定局部变量，如何对 function 外的变量进行赋值引用</li>
<li>Python local variable 和 Javascript 的区别</li>
<li>解释一下闭包，闭包的作用</li>
<li>如何查看闭包函数绑定的 free variable</li>
<li>闭包如何对绑定的变量进行重新赋值</li>
<li>解释 Python 自带的三个装饰器 functools.wraps, functools.lru_cache, functools.singledispatch</li>
<li>Python 如何实现 function 的重载，其和 Java 重载，if/else 的区别</li>
<li>解释 stack decorator</li>
<li>解释装饰器工厂</li>
</ul>
<h2 id="chapter8-object-reference-multability-and-recycling-1"><a class="header" href="#chapter8-object-reference-multability-and-recycling-1">Chapter8. Object Reference, Multability, and Recycling</a></h2>
<ul>
<li>解释 dir() 方法</li>
<li>解释 <code>==</code> 符号，其被解释成什么方法，其与 is 的区别是什么，两者速度谁更快</li>
<li>list 浅拷贝的三种方式</li>
<li>任意 object 如何进行深拷贝和浅拷贝</li>
<li>解释 Python 浅拷贝和深拷贝</li>
<li>为什么要避免将 mutable objects 作为函数参数的默认值</li>
<li>当类的构造函数参数需要传入 mutable sequence 时，如何使得该类有良好的封装性，进而减小对传入参数的影响</li>
<li>解释 del 的作用和 垃圾回收机制</li>
<li>解释一个 Python 字符串和数值驻留现象，驻留现象带来了什么启发</li>
</ul>
<h2 id="chapter9-a-pythonic-object"><a class="header" href="#chapter9-a-pythonic-object">Chapter9. A Pythonic Object</a></h2>
<ul>
<li>如何实现一个 Pythonic 风格的对象</li>
<li>Python 如何实现一个对象内部的迭代</li>
<li>Python 如何定义类的静态方法，staticmethod 和 classmethod 有什么区别</li>
<li>Python 自定义类型如何实现 hashable</li>
<li>Python 如何实现成员变量的私有，其原理是什么，能否实现真正的私有，能否进行写操作</li>
<li>Python 成员变量私有化是否能实现真正的私有化</li>
<li>如何查看 Python 类的成员变量</li>
<li>Python 如何实现成员变量的 protect，这种方法是否是官方规定的</li>
<li>单下划线在 Python  中一个官方规定的作用是什么</li>
<li>Python 是如何存储成员变量的，有何缺陷</li>
</ul>
<h2 id="chapter11-interfaces-from-protocols-to-abcs"><a class="header" href="#chapter11-interfaces-from-protocols-to-abcs">Chapter11. Interfaces: From Protocols to ABCs</a></h2>
<ul>
<li>Python 有哪两种接口（协议）</li>
<li>解释一下魔法方法定义的协议</li>
<li>为什么 isinstance 和 issubclass 两个方法比较鸡肋，是什么原因导致的</li>
<li>Monkey-Patching 是什么，有什么作用</li>
<li>自定义的 sequence 想要 shuffle，需要实现哪一个魔法方法</li>
<li>Python 内置的 ABCs 大多位于哪两个 module</li>
<li>如何定义自己的 ABCs</li>
<li>Python 是强类型语言还是弱类型语言</li>
</ul>
<h2 id="other-questions"><a class="header" href="#other-questions">Other Questions</a></h2>
<ul>
<li>all() 的复杂逻辑实现方法，with 是否可以用于 for / while</li>
<li>如何编写地道的带有 index 的遍历（enumerate）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-code-optimization"><a class="header" href="#python-code-optimization">Python-Code-Optimization</a></h1>
<p>[TOC]</p>
<h2 id="为什么要看-fluent-python"><a class="header" href="#为什么要看-fluent-python">为什么要看 Fluent-Python</a></h2>
<p>深入的学习 Python，才能了解这门语言的精髓，才能优雅的使用 Python。</p>
<p>Python 是一门高效的语言，但其也是一把双刃剑，使用不当的话，会耗费大量的内存和计算资源。</p>
<p>通过学习书中提高的指针和各种优化措施，我们能避免在编程中创建不必要的副本，帮助我们节约程序运行所占的内存。</p>
<p>例如，当我们想要扩展一个字符串时，我们应该</p>
<pre><code class="language-python">ss = &quot;Hello&quot;
print(id(ss)) # 1746944705792
ss += &quot;world&quot; 
print(id(ss)) # 1746944705792
</code></pre>
<p>这样可以在 ss 原来所占内存的基础上进行内存的扩充，如果是图方便：</p>
<pre><code class="language-python">ss = &quot;Hello&quot;
print(id(ss)) # 1746944705792
ss = ss + &quot;world&quot; 
print(id(ss)) # 1746961939120
</code></pre>
<p>那么就会重新开辟一块空间。这是一个小得不能再小的细节，很多人并不会很在意，毕竟一个小小的字符串并不会占用很大的内存空间。但是，如果我们在工作中，遇到了很长的 ss 呢（假设1KB）？而且需要频繁对 ss 进行扩展呢(一万次)？如果按照我们平时的第二种写法，那么我们每一次扩展，都是对原字符串的一次深拷贝，那么第一次拷贝内存成本都会上升，即使每次添加的字符并不多，那么拷贝一万次后，内存里至少会产生 10MB 的垃圾。如果这个脚本每隔 10 分钟就要跑一次，那么每隔 10 分钟就会产生 10MB 的垃圾（这里不考虑垃圾回收机制）。长此以往，计算机的内存就会被吃空。</p>
<h2 id="内存优化"><a class="header" href="#内存优化">内存优化</a></h2>
<h3 id="python-内存优化工具-memory_profiler"><a class="header" href="#python-内存优化工具-memory_profiler">Python 内存优化工具 memory_profiler</a></h3>
<p><a href="https://pypi.org/project/memory-profiler/%3E">pypi</a></p>
<p><strong>安装</strong></p>
<pre><code class="language-text">pip install memory_profiler
</code></pre>
<p><strong>使用</strong></p>
<p><a href="https://pypi.org/project/memory-profiler/%3E">pypi</a> 上有详细介绍，这里记录一下最常用的方法: 在程序内导入该包，然后加 <code>@profile</code> 的 flag</p>
<pre><code class="language-python">from memory_profiler import profile

@profile
def my_func():
    a = [1] * (10 ** 6)
    b = [2] * (2 * 10 ** 7)
    del b
    return a
</code></pre>
<p>执行完 <code>my_func</code> 后，就会将该函数的每一条语句的内存情况展示出来。</p>
<h3 id="字符串-和-sequence-优化"><a class="header" href="#字符串-和-sequence-优化">字符串 和 sequence 优化</a></h3>
<p>字符串 和 sequence 的扩展，可以通过 <code>+</code> 或 <code>*</code> 实现，但是怎么用还是有讲究的。</p>
<p><strong>优化后</strong></p>
<pre><code class="language-python"># 标准的字符串和 sequence 的扩展
ss = &quot;hello&quot;
ss += &quot;world&quot;
ss *= 5

list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
# extend 等价于 +=
list1 += list2
list1 *= 5
</code></pre>
<p><strong>优化前</strong></p>
<pre><code class="language-python">ss = &quot;hello&quot;
ss = ss + &quot;world&quot;
ss = ss * 5

list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1 = list1 + list2
list1 = list1 * 2
</code></pre>
<p>注意：<code>+=</code>， <code>*=</code> 的优化，其只对于 mutable(可更改) 的 sequence 生效，对于 tuple 这样的 immutable sequence，<code>+=</code> 和 <code>+</code> 的效果是一样的。但是 <code>str</code> 是一个例外，由于 str 使用频率太高，所以 Python 专门针对 str 进行了优化。Fluent-Python的原文是：</p>
<blockquote>
<p>str instance are allocated in memory with room to spare, so that concatenation does not require copying the whole string every time.</p>
</blockquote>
<p><strong>优化原理</strong></p>
<p><code>+=</code>， <code>*=</code> 两个运算符在 Python 中被定义为 magic operator，其会被 Python 解释器解释成 <code>__iadd__()</code> 和 <code>__imul__()</code> （其中 i 是 in-place 的意思，也就是 <code>就地</code> 的意思）两个魔法方法，而普通的 <code>+</code> 和 <code>*</code> 两个运算符，则是被 Python 解释器解释成了 <code>__add__()</code> 和 <code>__mul__()</code>，所以本质上，两个被解释成了不同的魔法方法，然后执行。</p>
<h3 id="用生成器genexps替换列表推导式listcomp"><a class="header" href="#用生成器genexps替换列表推导式listcomp">用生成器(genexps)替换列表推导式(listcomp)</a></h3>
<p>Demo: 生成一个 7000 万长度的 array。</p>
<pre><code class="language-python">floats = array(&quot;d&quot;, (random() for i in range(10**7))) # 此处用生成器的好处在于，我们并不会直接生成一个 10**7 长度的数组，这样的话，相当于占用了 double 的内存，而改用生成器的话，在生成 array 的时候，就不需要占用多余的内存，因为元素是一个一个生成的。
</code></pre>
<h3 id="用-tuple-namedtuple-替换-dict-in-json-style"><a class="header" href="#用-tuple-namedtuple-替换-dict-in-json-style">用 tuple, namedtuple 替换 dict in JSON style</a></h3>
<p>dict 的底层是 hashtable，其稀疏的存储会浪费大量的内存，如果我们只是暂存 record，对于查询效率没有特殊需求的话，就不能使用 dict，不仅是因为 hashtable 占用大量的内存，JSON Style 重复的 key 存储也会耗费很多不必要的空间，这种内存的消耗，在从数据库中读取数据存储成 dict in json style 时尤为明显。</p>
<p>事实上，当我们在使用 dict 的时候，就应该下意识地考虑内存问题，是不是应该用 tuple 来替代，而不是不假思索的使用 dict。在使用 mapping types 的时候，应该始终考虑内存的效率问题。Dict 是设计被用来高效查找的，其并不适合存储，在存储的时候，考虑用 tuple 来代替！</p>
<h3 id="用-__slots__-优化对象属性存储"><a class="header" href="#用-__slots__-优化对象属性存储">用 <code>__slots__</code> 优化对象属性存储</a></h3>
<p>Python 默认将类的成员变量存储在 <code>__dict__</code> 中，其实际上是将属性存储了字典中，那么如果属性太多，那么就会占用太多的空间，<code>__slots__</code> 可以对其进行优化，不再详述。</p>
<h2 id="计算优化"><a class="header" href="#计算优化">计算优化</a></h2>
<h3 id="频繁进行-containment-check-的优化"><a class="header" href="#频繁进行-containment-check-的优化">频繁进行 containment check 的优化</a></h3>
<p>如果我们需要频繁的检查某个元素是否在一个 list 中，我们可以用 set 来取代 list</p>
<p><strong>优化后</strong></p>
<pre><code class="language-python">if to_check_str in set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]):
</code></pre>
<p><strong>优化前</strong></p>
<pre><code class="language-python">if to_check_str in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]:
</code></pre>
<p>注意：set 并不是 sequence，实际上，这是利用空间来优化时间复杂度的一个算法。</p>
<h3 id="dict-查找为空的优化-setdefault--defaultdict"><a class="header" href="#dict-查找为空的优化-setdefault--defaultdict">dict 查找为空的优化 setdefault() / defaultdict</a></h3>
<p>Python 有三种通过 key 获取值的方式：</p>
<pre><code class="language-python"># 第一种
my_dict[&quot;students&quot;]
# 第二种
my_dict.get(&quot;students&quot;, [])
# 第三种
my_dict.setdefault(&quot;students&quot;, [])

# 第四种
import collections
my_dcit = collections.defaultdict(list) # 默认缺失值为 list，list 为 default_factory
my_dict[&quot;students&quot;].append(&quot;wansho&quot;)
</code></pre>
<p>其中，第二种和第三种都有处理 missing key 的方式，第二种方式常见的代码逻辑为：</p>
<pre><code class="language-python">student_list = my_dict.get(&quot;students&quot;, []) # 第一次搜索
student_list.append(&quot;wansho&quot;)
my_dict[&quot;students&quot;] = student_list # 插入数据，实际上是第二次搜索
</code></pre>
<p>实际上，第二种方式进行了两次搜索，我们再来看一下第三种方式：</p>
<pre><code class="language-python">my_dict.setdefault(&quot;students&quot;, []).append(&quot;wansho&quot;)
# setdefault 方法先按照 key 进行搜索 value，如果 key 不存在，则就地插入 (key, default_value)并返回 default_value 的引用，这样就避免了插入时的第二次搜索。
</code></pre>
<p>第四种方式的效率和第三种一样，不同的是其采用了 <code>collections.defalutdict</code> 来处理缺失值，下面拆解一下插入语句：</p>
<pre><code class="language-python">my_dict[&quot;students&quot;].append(&quot;wansho&quot;)
# 1. 执行一遍搜索，发现 students 是 missing key
# 2. 按照默认的缺失值类型，生成一个 list，并将 (key, default_value) 就地插入到 my_dict 中，然后返回 default_value 的引用
# 3. default_value 加入新的数据
</code></pre>
<h3 id="set-算数运算符优化-1"><a class="header" href="#set-算数运算符优化-1">Set 算数运算符优化</a></h3>
<p>灵活运用 Set 的算数运算符，比写 for 循环的效率高很多，Demo:</p>
<pre><code class="language-python">found = len(needless &amp; haystack)

for n in needless:
    if n in haystack:
        found += 1
</code></pre>
<p>以上的两个块代码，在效果上等价，但是前者运用了算数运算符，其速度远大于 for 循环。</p>
<h2 id="语法优化"><a class="header" href="#语法优化">语法优化</a></h2>
<h3 id="换行"><a class="header" href="#换行">换行</a></h3>
<p>在括号 <code>[]{}()</code>类的换行，都不需要加入换行符 <code>\</code>，所以我们可以通过在括号内换行，写出更有层次感和可读性的列表推导式。</p>
<h3 id="文件-io"><a class="header" href="#文件-io">文件 IO</a></h3>
<p>with 相对于传统的 IO 语法，其<strong>优势</strong>在于：</p>
<ol>
<li>无论文件打开是否成功，都会自动关闭文件流</li>
</ol>
<pre><code class="language-python">with open(&quot;file.txt&quot;, encoding=&quot;utf-8&quot;) as fr:
    content = fr.read()
</code></pre>
<h2 id="api-convention"><a class="header" href="#api-convention">API Convention</a></h2>
<h3 id="in-place-method"><a class="header" href="#in-place-method">In-place method</a></h3>
<p>Functions or methods that change an object in place should return None to make it clear to the caller that the object itself was changed and no new object was created. 这也是一个内存优化点。</p>
<p>For example:</p>
<pre><code class="language-python">list1 = [2,3,5,7,7,8]
list1.sort()
list1.shuffle()
</code></pre>
<p>但是，inplace 方法有一个缺点，就是无法实现 cascade operation.</p>
<h3 id="inplace-operations"><a class="header" href="#inplace-operations">Inplace Operations</a></h3>
<p>对于数学运算符，例如:</p>
<pre><code class="language-text">+, -, *, &amp;, |
</code></pre>
<p>都可以利用 inplace 实现内存的节约：</p>
<pre><code class="language-python">lst1 = []
lst2 = []

lst1 += lst2

set1 = set()
set2 = set()

set1 |= set2
set1 &amp;= set2
</code></pre>
<h2 id="性能优化工具"><a class="header" href="#性能优化工具">性能优化工具</a></h2>
<h3 id="python-内存优化工具-memory_profiler-1"><a class="header" href="#python-内存优化工具-memory_profiler-1"><a href="reading/fluent-python/summary/python-code-optimization.html#Python%20%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%20memory_profiler">Python 内存优化工具 memory_profiler</a></a></h3>
<h3 id="python-bytecode-disassember"><a class="header" href="#python-bytecode-disassember">Python Bytecode disassember</a></h3>
<p><strong>What is Bytecode</strong></p>
<blockquote>
<p>Python source code is compiled into bytecode. The bytecode is also cached in <code>.pyc</code> files so that executing the same file is faster the second time (recompilation from source to bytecode can be avoided). This “intermediate language” is said to run on a <a href="https://docs.python.org/3/glossary.html#term-virtual-machine">virtual machine</a> that executes the machine code corresponding to each bytecode. Do note that bytecodes are not expected to work between different Python virtual machines, nor to be stable between Python releases.</p>
</blockquote>
<p>Python 源码被编译成 bytecode，并缓存在 <code>.pyc</code> 文件中。我们在执行 Python 源码时，第二次执行往往比第一次执行要快，原因在于第二次执行的时候，不需要对源码重新编译了。Bytecode 是一个中间状态，其需要 Python 的虚拟机去翻译 Bytecode 为机器码。</p>
<p>需要注意的是，bytecode 并不是跨 python 虚拟机平台 和 跨 Python 版本的，也就是说，bytecode(.pyc) 一旦生成，就只能在当前环境下执行。换了一个 python 虚拟机，换了一个 python 版本，那么 bytecode 就会失效。</p>
<p><strong>Analysis bytecode: disassember</strong></p>
<p>disassmber(dis) 用来翻译 bytecode，了解一个 Python 解释器的执行过程。</p>
<p>Demo1:</p>
<pre><code class="language-python">import dis

def myfunc(alist):
    return len(alist)

dis.dis(myfunc)
&quot;&quot;&quot;
  2           0 LOAD_GLOBAL              0 (len)
              2 LOAD_FAST                0 (alist)
              4 CALL_FUNCTION            1
              6 RETURN_VALUE
&quot;&quot;&quot;
</code></pre>
<p>Demo2:</p>
<pre><code class="language-python">import dis
dis.dis(&quot;set([1])&quot;) # 单独的 Python 语句，需要用引号括起来

&quot;&quot;&quot;
  1           0 LOAD_NAME                0 (set)
              2 LOAD_CONST               0 (1)
              4 BUILD_LIST               1
              6 CALL_FUNCTION            1
              8 RETURN_VALUE
&quot;&quot;&quot;
</code></pre>
<p>dis 模块可以用来洞察 python 解释器对于程序的解释过程，进而优化代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-30-seconds"><a class="header" href="#python-30-seconds">Python-30-Seconds</a></h1>
<p>[TOC]</p>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>Note for python knowledges that you may not know, or you may not really know.</p>
<p>Inspired by <a href="https://github.com/30-seconds/30-seconds-of-code%3E">30-seconds-of-code</a></p>
<h2 id="you-may-not-know"><a class="header" href="#you-may-not-know">You May not Know</a></h2>
<h3 id="python-sys"><a class="header" href="#python-sys">Python sys</a></h3>
<p><code>stdin</code> is used for all interactive input</p>
<pre><code class="language-Python">import sys

for line in sys.stdin:
	print(line)
</code></pre>
<h3 id="pep"><a class="header" href="#pep">PEP</a></h3>
<p>Python Enhancement Proposals. Python 增强提案。</p>
<p>Demo: </p>
<p>PEP20: <a href="https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a></p>
<h3 id="中文做变量"><a class="header" href="#中文做变量">中文做变量</a></h3>
<p>Python3 允许 non-ASCII identifiers in source code，任何 Unicode 字符，都可以作为变量，也就是说，<strong>中文也可以作为变量</strong>！</p>
<pre><code class="language-python">姓名 = &quot;wansho&quot;
年龄 = 25
print(姓名)
</code></pre>
<h3 id="deep--shallow-copy"><a class="header" href="#deep--shallow-copy">deep / shallow copy</a></h3>
<p><strong>What is shallow copy:</strong></p>
<pre><code class="language-python">lst1 = [1, 2, 3]

def func(lst):
    lst[0] += 1

print(id(lst1)) # 1499657981640
func(lst1)
print(id(lst1)) # 1499657981640
print(lst1) # [2, 2, 3]

&quot;&quot;&quot;
由于只传入了 lst1 的引用，所以 func 内 lst 就是 lst1，并没有创建一个新的对象（内存）
&quot;&quot;&quot;
</code></pre>
<p><strong>What is deep copy:</strong></p>
<pre><code class="language-python">lst1 = [1, 2, 3]
lst2 = list(lst1)

print(id(lst1)) # 1499658012360
print(id(lst2)) # 1499658044872

&quot;&quot;&quot;
list() 开辟了一个新的内存，创建了一个新的对象，此为深拷贝，类似的构造方法为 深拷贝的 built-in class 还有很多
&quot;&quot;&quot;
</code></pre>
<p><strong>deep copy built-in classes：</strong> </p>
<pre><code class="language-python">list()
dict()
# 这些 callable object 实际上都是在调用构造方法进行对象的创建，其肯定为 深拷贝
</code></pre>
<h3 id="method-vs-function"><a class="header" href="#method-vs-function">method vs function</a></h3>
<p>What is method: Class 中定义的函数叫做 method</p>
<pre><code class="language-Python">class MyClass():
	def first_method():
        return &quot;first_method&quot;
</code></pre>
<p>What is function: 最外层定义的函数叫做 function</p>
<pre><code class="language-Python">import pandas as pd

def get_columns(pd_data):
    return pd_data.columns.tolist()
</code></pre>
<h3 id="built-in-functions-1"><a class="header" href="#built-in-functions-1">built-in functions</a></h3>
<h4 id="ord"><a class="header" href="#ord">ord()</a></h4>
<p>get the unicode code point of given char. <a href="https://docs.python.org/3/library/functions.html?highlight=ord#ord">DOC</a></p>
<pre><code class="language-python">print(ord(&quot;a&quot;)) # 97
print(ord('€')) # 8364
</code></pre>
<h4 id="divmod"><a class="header" href="#divmod">divmod()</a></h4>
<p>除法，返回倍数和余数。</p>
<pre><code class="language-python">divmod(20, 8) # return (2, 4)
divmod(21.2, 8) # return (2.0, 5.199999999999999)
</code></pre>
<h4 id="enumerate"><a class="header" href="#enumerate">enumerate()</a></h4>
<p>enumerate() 用于给 sequence 生成 index</p>
<pre><code class="language-python"># enumerate 方法会对 sequence 进行封装，并返回一个可迭代的对象，其中的每一个 item 都是 tuple (index, sequence[index])
for index, value in enumerate([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]):
    print(index, value)

&quot;&quot;&quot;
0 a
1 b
2 c
&quot;&quot;&quot;
</code></pre>
<h4 id="functoolsreduce-all-any"><a class="header" href="#functoolsreduce-all-any">functools.reduce(), all(), any()</a></h4>
<p>The common idea of <strong>reduce</strong> is to apply some operation to successive items in a sequence, accumulating previous result, thus reducing a sequence of values to a single value.</p>
<p>reduce 用于对一个 sequence 进行 successive compute，从而得到一个 single value。也就是通常所说的：降维（从 二维 到 一维）。</p>
<p><img src="reading/fluent-python/summary/assets/1558443265331.png" alt="reduce" /></p>
<pre><code class="language-python">from functools import reduce
from operator import add, sub

reduce(add, range(10)) # 等价于 0 + 1 + 2 + ……  + 9
reduce(sub, [1,2,3]) # 等价于 1 - 2 - 3
</code></pre>
<p>Other reducing built-ins:</p>
<pre><code class="language-python">all(iterable) # return true if all value is true
any(iterable) # return true if one value is true

all([&quot;1&quot;, [1], (1), {1:2}]) # true
all([&quot;1&quot;, [1], (1), {}]) # false

any([&quot;1&quot;, [1], (1), {}]) # true
</code></pre>
<h4 id="callable"><a class="header" href="#callable">callable()</a></h4>
<p>How to determine whether an object is callable?</p>
<pre><code class="language-Python">[callable(obj) for obj in (abs, str, 13)]
# print [True, True, False]
</code></pre>
<h4 id="dir"><a class="header" href="#dir">dir()</a></h4>
<p>Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.</p>
<pre><code class="language-PYthon">dir([1,2,3])
# ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre>
<p><code>dir()</code> 通常用于窥探一个对象的属性或者当前环境。</p>
<h3 id="built-in-operators"><a class="header" href="#built-in-operators">built-in operators</a></h3>
<h4 id="指数-"><a class="header" href="#指数-">指数^: **</a></h4>
<pre><code class="language-python">print(10 ** 2) # 10^2 = 100
print(2 ** 10) # 2^10 = 1024
</code></pre>
<h3 id="built-in-modules"><a class="header" href="#built-in-modules">built-in modules</a></h3>
<h4 id="arrayarray-1"><a class="header" href="#arrayarray-1">array.array</a></h4>
<p>array.array is a mutable, flat sequence sequence in python. 其适合用来存储数值。</p>
<pre><code class="language-python">from array import array
from random import random

# 用生成表达式生成一个双精度的 float 类型 array, 其中包含有 1000 万个元素
# array 接受两个参数，第一个参数是存储的数据类型，第二个参数是存储的数据
# array 目前接受的存储类型为：
# I: integer 整形
# u: unicode 类型
# d: double 类型
floats = array(&quot;d&quot;, (random() for i in range(10**7))) 
print(&quot;the last number: &quot; + str(floats[-1]))
fw = open(&quot;array.bin&quot;, &quot;wb&quot;)
floats.tofile(fw) # 讲数据写入二进制文件中
fw.close()

# 构建一个空的 array，然后从二进制文件中读取数据
floats2 = array(&quot;d&quot;) 
fr = open(&quot;array.bin&quot;, &quot;rb&quot;)
floats2.fromfile(fr, 10**7) # 读取的时候，指定读取多少个数据
fr.close()
print(&quot;the last number: &quot; + str(floats2[-1]))

print(id(floats))
print(id(floats2))
print(floats == floats2)

&quot;&quot;&quot;
the last number: 0.40830065649386416
the last number: 0.40830065649386416
1547450711472
1547450138096
True
&quot;&quot;&quot;
</code></pre>
<h4 id="collectionsdeque"><a class="header" href="#collectionsdeque">collections.deque</a></h4>
<p>Python 内置的双端队列</p>
<pre><code class="language-python">from collections import deque
dq = deque(range(10), maxlen=10) # 初始化一个 双端队列，可以不给出 maxlen
print(dq) # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)

# rotate(n) 当 n &gt; 0 时，其功能为从 deque 的右边取出 n 个数，移动到左边，当 n&lt;0时，其功能为从左边取出 -n 个数，移动到右边
dq.rotate(3) 
print(dq) # deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
dq.rotate(-4)
print(dq) # deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)

# 从左端插入，append() 是默认右端插入
dq.appendleft(-1) 
print(dq) # deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
# 默认从右端扩展
dq.extend([11,12,13,14])
print(dq) # deque([4, 5, 6, 7, 8, 9, 11, 12, 13, 14], maxlen=10)

# 从左端扩展，要注意的是，extendleft 是 iterate 的操作，所以插入后是逆序的
dq.extendleft([10,20,30,40])
print(dq) # deque([40, 30, 20, 10, 4, 5, 6, 7, 8, 9], maxlen=10)

# 双端弹出数据的操作，
print(dq.pop()) # 右端弹出数据
print(dq.popleft()) # 左端弹出数据

&quot;&quot;&quot;
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)
deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
deque([4, 5, 6, 7, 8, 9, 11, 12, 13, 14], maxlen=10)
deque([40, 30, 20, 10, 4, 5, 6, 7, 8, 9], maxlen=10)
9
40
&quot;&quot;&quot;
</code></pre>
<h4 id="operator-1"><a class="header" href="#operator-1">operator</a></h4>
<p>operator 通常用于 reduce, 详见 [functools.reduce()](#functools.reduce())</p>
<h4 id="json"><a class="header" href="#json">json</a></h4>
<p>json module 用于处理 json 字符串和 json 文件。下面解释一下 json 包几个常见的方法：load()/dump()/loads()/dumps()</p>
<p>dumps(): 将 dict 转成 json 字符串, dumps2string</p>
<pre><code class="language-python">import json
data = {
    'name' : 'ACME',
    'shares' : 100,
    'price' : 542.23
}

json_str = json.dumps(data)
# '{&quot;price&quot;: 542.23, &quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 100}'
</code></pre>
<p>loads(): 将 json 字符串转成 dict, loads2dict</p>
<pre><code class="language-text"># 将 json 编码的字符串转换成一个 python 的数据结构，往往是 dict
</code></pre>
<p>dump(), load(): 用于 读取 和 写入 json 文件。</p>
<pre><code class="language-python"># 如果你要处理的是文件而不是字符串，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。
# Writing JSON data
with open('data.json', 'w') as f:
    json.dump(data, f)

# Reading data back
with open('data.json', 'r') as f:
    data = json.load(f)
</code></pre>
<h2 id="you-may-not-really-konw"><a class="header" href="#you-may-not-really-konw">You May not Really Konw</a></h2>
<h3 id="strip"><a class="header" href="#strip">strip()</a></h3>
<p>strip() 方法并不是整个字符串进行前缀后缀的匹配，其更像是正则匹配的 [abcd] 规则。<a href="https://docs.python.org/3/library/stdtypes.html?highlight=strip#str.strip%3E">DOC</a></p>
<pre><code class="language-python">print('www.example.com'.strip('cmowz.'))
print('#....... Section 3.2.1 Issue #32 .......'.strip('.#! '))

&quot;&quot;&quot;
example
Section 3.2.1 Issue #32
&quot;&quot;&quot;
</code></pre>
<h3 id="else-with-for-and-while"><a class="header" href="#else-with-for-and-while">else with for and while</a></h3>
<p>如果 for 没有 break(sequence 遍历完毕)，则执行 else，功能类似于 <code>all()</code>，是 <code>all()</code> 方法的复杂逻辑实现。</p>
<pre><code class="language-Python">sentence = [&quot;nihao&quot;, &quot;woshi&quot;, &quot;cxk&quot;]

for word in sentence:
    if word == &quot;quit&quot;:
        print(&quot;Time to quit&quot;)
        break
    else:
        print(&quot;no quit&quot;)
else:
    print(&quot;There was no 'quit' in the sentence&quot;)

&quot;&quot;&quot;
no quit
no quit
no quit
There was no 'quit' in the sentence
&quot;&quot;&quot;

###################################################

for i in range(10):
	pass
else:
    print(&quot;over&quot;)
# over

##################################################

for i in range(10):
    if i == 3:
        break
else:
    print(&quot;over&quot;)
# 无 over
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="computer-networks-and-the-internet"><a class="header" href="#computer-networks-and-the-internet">Computer Networks and the Internet</a></h1>
<p>[TOC]</p>
<h2 id="有哪些网络"><a class="header" href="#有哪些网络">有哪些网络</a></h2>
<ul>
<li>
<p>互联网 Internet</p>
<p>以 TCP/IP 这一簇协议支撑工作的网络。</p>
<p>互联网中有几十亿台设备，伴随着物联网的发展，以后会有上百亿设备，几百万个网络。</p>
</li>
<li>
<p>军用网络</p>
</li>
<li>
<p>专用网络：银行，通信服务商</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<h2 id="分层协议"><a class="header" href="#分层协议">分层协议</a></h2>
<ul>
<li>
<p>物理层</p>
<p>在媒体之上，传输电信号和光信号，把链路层传过来的 0,1 信号转换，发走。</p>
</li>
<li>
<p>链路层</p>
<p>点到点 peer to peer。相邻两点之间，传输以帧为单位的数据。一个交换机连接的两个点，就是相邻的两个点。</p>
<p>常见协议：PPP，WiFi，Ethernet</p>
</li>
<li>
<p>网络层</p>
<p>端到端 end to end。在链路层提供的相邻两点传输的基础上，实现源主机到目标主机之间数据的传输。端到端之间会经过很多点到点。转发和路由。</p>
<p>网络层端到端的传输比较粗糙，不可靠，best ever 尽力而为。</p>
<p>主要协议：IP，路由选择协议</p>
</li>
<li>
<p>传输层</p>
<p>传输层在网络层的基础上，加强了可靠性，细分了服务。将端到端细分到进程到进程，将不可靠变成了可靠。实现了进程到进程的通信。</p>
<p>两个协议：TCP（在吗，在。一起吃饭去，好的。） / UDP （一起吃饭去，好的。）</p>
<p>传输层向应用层提供 socket api，使得应用层能够方便地使用 TCP 和 UDP 协议。</p>
</li>
<li>
<p>应用层</p>
<p>按照应用层协议，在 TCP 和 UDP 两种连接的基础上，交换应用报文。</p>
<p>基于 TCP 的应用：HTTP，Telnet，FTP，SMTP</p>
<p>基于 UDP 的应用：DNS，流媒体，远程电话</p>
</li>
</ul>
<p><img src="reading/computer-networking/assets/kOrOP.png" alt="enter image description here" /></p>
<h2 id="sdu-和-pdu"><a class="header" href="#sdu-和-pdu">SDU 和 PDU</a></h2>
<p>SDU：Service Data Unit 服务数据单元</p>
<p>PDU：Protocol Data Unit 协议数据单元</p>
<p>层与层之间的数据交换：上层往下层传递的数据是 SDU，下层拿到 SDU 后，再在 SDU 的基础上，加上本层的附加的一些控制信息，形成了本层的 PDU。</p>
<p><img src="reading/computer-networking/assets/image-20220423221438987.png" alt="image-20220423221438987" /></p>
<p>货物装在卡车上，卡车头就是 header，货物就是 SDU，卡车就是 PDU。</p>
<p>对等的实体在进行信息交换的时候，交换的是 PDU。每一层的 PDU 都有不同的名字，应用层的 PDU，叫做应用报文 message，传输层的 PDU，叫做报文段，segment，网络层的 PDU 叫做分组，链路层的 PDU 叫做数据帧。 </p>
<h2 id="服务和协议"><a class="header" href="#服务和协议">服务和协议</a></h2>
<p>在一个 TCP 的实体上，可以跑 web 应用，可以跑 Telnet 应用，可以跑 SMTP 应用。TCP 实体就是服务提供者，这些应用层的应用就是 TCP 实体的用户。服务访问点 SAP 用于区分运行在一个 TCP 实体上的多个应用（用户）。Socket 就是对应用层的应用传下来信息加以标注。应用通过 SAP 告诉服务提供者，我要使用什么服务。服务提供者通过原语，来告诉其所服务的用户，我能提供什么服务。</p>
<p>服务是通过通过层间的接口，在系统的内部，在 SAP 上，通过原语的形式，向上层提供服务。是底层实体向上层实体提供它们之间通信的能力，是通过原语来操作的，是计算机网络相邻层间的垂直关系。</p>
<p>协议是对等的实体，在通信过程中，应该遵守的规则的集合。是水平关系。</p>
<p>服务和协议的关系：本层协议的实现要靠下层提供的服务来实现。本层实体通过协议为上层提供更高级的服务。</p>
<h2 id="socket-api"><a class="header" href="#socket-api">Socket API</a></h2>
<p>应用层使用传输层（TCP/IP 协议簇）提供的服务的一种形式。</p>
<h2 id="internet-标准的制定"><a class="header" href="#internet-标准的制定">Internet 标准的制定</a></h2>
<ul>
<li>
<p>RFC：Request for Comment 请求评述。</p>
</li>
<li>
<p>IETF ：Internet Engineering Task Force 互联网工程任务组，非盈利组织。</p>
</li>
</ul>
<p>任何一名工程师，关于任何关于互联网的观点和演化，都可以向 IETF 提交文档，IETF 觉得靠谱的话，就将文档编号放到网上，让全球的工程师对其评价，评价的文档也被提交给 IETF，并被编号。互联网所有标准的指定，都是以 RFC 文档的形式在 IETF 网站上发布。包括 TCP，UDP。</p>
<h2 id="p2p"><a class="header" href="#p2p">P2P</a></h2>
<p>peer to peer 对等。</p>
<p>P2P 不同于 Client Server 模式，P2P 是没有服务端的。P2P 应用既是客户端，也是服务端。</p>
<p>迅雷就是一个 P2P 软件，他在下载文件的时候，是从其他的迅雷客户端（其他人的电脑）获取一段一段的文件，最后再拼凑成一个文件。同时，自己的迅雷客户端，也被其他客户端请求获取本地的资源。</p>
<h2 id="网速单位"><a class="header" href="#网速单位">网速单位</a></h2>
<p>100M，实际上是 100Mbps，bps 是比特率，指的是单位时间内传输的比特数。</p>
<p>100M 高速网络，就是 1s 最多传输 100M 个比特，实际上是 1s 传输 100/8 = 12.5M 个字节，即 100Mbps = 12.8MByte </p>
<p>计算机网络中数据单位通常是比特，和通常的数据计量单位 Byte 不一样。</p>
<p>网速也不单单看我们进入运营商（ISP Internet Service Provider）的网速，也要看整个小区接入网络的网速。假设我们和通信服务商买了 100Mbps 的宽带，也就是说，我们接入小区的交换机的带宽是 100Mbps，但是如果我们小区接入主网的带宽也是 100Mbps，那么就是我们整个小区在共享这 100Mbps 的带宽，运营商 (ISP) 承诺得高带宽，就是文字游戏。</p>
<h2 id="isp"><a class="header" href="#isp">ISP</a></h2>
<p>Internet Service Provider 提供接入互联网的服务（移动，联通，电信，学校）。</p>
<p>普通人想要接入互联网，都要通过 ISP 进行接入。互联网公司也要通过 ISP 接入互联网。</p>
<h2 id="icp"><a class="header" href="#icp">ICP</a></h2>
<p>Internet Content Provider 互联网内容提供商（百度，Google，字节，腾讯），提供互联网内容的。</p>
<h2 id="数据中心"><a class="header" href="#数据中心">数据中心</a></h2>
<p>DC DataCenter</p>
<p>很多大的互联网公司，在全球各地建立大量的机房，而且机房的位置，通常都靠近核心 ISP。主要是因为 ISP 提供的服务不稳定，很难给用户带来高质量的服务，而且收费还很贵。所以 Google 在全球自己搭建机房，机房和机房之间，采用自己搭建的专用网络进行连接（自己铺设太平洋光缆），进而给用户提供高质量的服务，而且很便宜。</p>
<h2 id="socket-编程"><a class="header" href="#socket-编程">socket 编程</a></h2>
<p>传输层向应用层提供的 API，应用程序借助应用程序接口来跟对方的应用实体交换报文，实现各种各样的网络应用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构与算法分析--c语言描述"><a class="header" href="#数据结构与算法分析--c语言描述">数据结构与算法分析 — C语言描述</a></h1>
<p>第二次读这本书 <a href="https://book.douban.com/subject/1139426/">数据结构与算法分析 - C 语言描述</a> ，希望能收获更多。</p>
<p>作者：<a href="https://users.cs.fiu.edu/%7Eweiss/">Mark Allen Weiss</a> Knuth 的徒孙。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h1>
<p>[TOC]</p>
<h2 id="本书讨论的内容"><a class="header" href="#本书讨论的内容">本书讨论的内容</a></h2>
<p>为什么要学习数据结构与算法？</p>
<p>写出一个可以工作的算法并不够，我们要保证该算法在数据集扩大后依然适用。</p>
<h2 id="递归"><a class="header" href="#递归">递归</a></h2>
<h3 id="什么是递归-fibonacci-sequence"><a class="header" href="#什么是递归-fibonacci-sequence">什么是递归: Fibonacci sequence</a></h3>
<p>$$
f(x) = \begin{cases}
&amp; 1 \text{ if } x=0,1 \ 
&amp; f(x-1) + f(x-2)\text{ if } x &gt; 1 
\end{cases}
$$</p>
<h3 id="递归的三个基本法则"><a class="header" href="#递归的三个基本法则">递归的三个基本法则</a></h3>
<ul>
<li>基准情形(<strong>base case</strong>)：不用递归就可以求解的情形</li>
<li>不断推进(<strong>making progress</strong>): 递归的方向，要朝着基准情形推进</li>
<li>合成效益法则(<strong>compound interest rule</strong>): 递归切忌做重复的计算</li>
</ul>
<h3 id="递归的弊端"><a class="header" href="#递归的弊端">递归的弊端</a></h3>
<ul>
<li>可能违背 compound interest rule，导致重复计算，例如 Fibonacci 数列的计算</li>
<li>递归层数太深可能导致栈溢出</li>
</ul>
<h3 id="fibonacci-数列的计算优化"><a class="header" href="#fibonacci-数列的计算优化">Fibonacci 数列的计算优化</a></h3>
<p>Fibonacci 数列递归实现的弊端为重复计算：</p>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1564407234324.png" alt="斐波那契数列递归计算的弊端" /></p>
<p>如何优化？将之前的计算存储，减少重复计算。</p>
<pre><code class="language-C">int fibonacciNotRecursive(int num){
    if(num &lt;= 2){
        return 1;
    }
    int nums[N] = {1, 1}; // C 语言 int 类型的数组如果不初始化，那么元素默认为 0
    for(int i=2; i&lt;N; i++){
        nums[i] = nums[i-1] + nums[i-2];
        if((i+1) == num){
            return nums[i];
        }
    }
    return 0;
}
</code></pre>
<h3 id="汉诺塔问题"><a class="header" href="#汉诺塔问题">汉诺塔问题</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法分析"><a class="header" href="#算法分析">算法分析</a></h1>
<p>[TOC]</p>
<h2 id="如何判断一个算法的好坏"><a class="header" href="#如何判断一个算法的好坏">如何判断一个算法的好坏</a></h2>
<p>评价一个算法的好坏，应该<strong>具体问题具体分析</strong>。我们需要考察的因素有：</p>
<ul>
<li>
<p><strong>数据量的大小 / 业务需求</strong></p>
<p>如果业务的数据量很少，不同复杂度的算法，其运行时间差别不大，那么我们其实不需要花太多时间在算法的设计上，也许设计一个快速实现的算法，完成业务需求，是当务之急；如果数据量很大，并且对算法要求很高的话，就需要多花心思在算法的设计上。要具体问题具体分析。</p>
</li>
<li>
<p><strong>算法的复杂度</strong></p>
<p>在条件允许的情况下，算法的复杂度（<strong>时间复杂度/空间复杂度</strong>）肯定是越低越好，最好是 O(n) 的算法</p>
</li>
<li>
<p><strong>算法实现的难度</strong></p>
<p>如果一个优秀的算法，实现起来非常难，那么也要考虑现实的条件，是否值得花时间去解决这样一个复杂的问题。</p>
</li>
</ul>
<h2 id="最大子序列和问题"><a class="header" href="#最大子序列和问题">最大子序列和问题</a></h2>
<p><strong>最直觉的解法：对所有的子序列进行遍历</strong></p>
<p>算法时间复杂度：$O(N^3)​$</p>
<p>用两次遍历确定一个上界和下界，然后再用一次遍历找最大和。</p>
<p><strong>最直觉算法的优化：如何对所有的子序列进行遍历</strong></p>
<p>算法时间复杂度：$O(N^2)​$</p>
<p>用两次遍历确定一个上界和下界，然后对上界和下届确定的子序列求和。（两层遍历确定的上下界，能涵盖所有的子序列）</p>
<p><strong>最优解：Online Algorithm联机算法</strong></p>
<p>算法时间复杂度：$O(N)​$</p>
<pre><code class="language-C">// process its input piece-by-piece in a serial fashion，一次遍历就可以得到结果的算法
int maxSequenceSum(int nums[]){
    int index, sum, maxSum;
    maxSum = sum = 0;
    for(index=0; index&lt;N; index++){
        sum += nums[index];
        if(sum &lt; 0){
            sum = 0;
        }else{
            maxSum = sum &gt; maxSum ? sum : maxSum;
        }
    }
    return maxSum;
}
</code></pre>
<h2 id="欧几里得算法辗转相除法"><a class="header" href="#欧几里得算法辗转相除法">欧几里得算法（辗转相除法）</a></h2>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1564714532993.png" alt="辗转相除法" /></p>
<pre><code class="language-C">int euclideanAlgorithm(int a, int b){
    int result;
    int r = 1; // 余数
    while(r != 0){
        r = a % b;
        a = b;
        b = r;
    }
    return a;
}
</code></pre>
<h2 id="排列组合"><a class="header" href="#排列组合">排列组合</a></h2>
<p>排列：
$$
A_{n}^{m} = n * (n-1)<em>\cdots  * (n-m+1) \
A_{6}^{2} =  6 * 5
$$
组合：
$$
C_{n}^{m} = \frac{n * (n-1)</em>\cdots  * (n-m+1)}{m!} \
C_{6}^{2} = \frac{6 * 5}{2!}
$$</p>
<h2 id="任意进制的转换"><a class="header" href="#任意进制的转换">任意进制的转换</a></h2>
<p>如何实现不同进制的转换？例如 2 进制，3 进制，4 进制 ？</p>
<p>Demo: 4 进制的转换</p>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1566178722620.png" alt="任意进制转换" /></p>
<p>循环结束条件：除数结果（2） &lt; 进制数（4）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter3-list-stack-queue"><a class="header" href="#chapter3-list-stack-queue">Chapter3. List Stack Queue</a></h1>
<p>[TOC]</p>
<h2 id="线性表和非线性表"><a class="header" href="#线性表和非线性表">线性表和非线性表</a></h2>
<p><strong>线性表</strong>：顺序表/链表/栈/队列</p>
<p><strong>非线性表</strong>：二叉树/图</p>
<p>线性表和非线性表的划分，是根据其逻辑来划分的，而不是根据其存储结构来划分的。每个线性表上的数据最多只有前后两个方向。</p>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<h3 id="list-的分类"><a class="header" href="#list-的分类">List 的分类</a></h3>
<ul>
<li>ArrayList: 顺序表</li>
<li>LinkList: 链表</li>
</ul>
<h3 id="顺序表和链表的区别"><a class="header" href="#顺序表和链表的区别">顺序表和链表的区别</a></h3>
<p><strong>最本质的区别</strong>：顺序表在内存是<strong>连续存储</strong>的，而链表在内存中是<strong>离散存储</strong>的。</p>
<p>顺序表：<strong>连续存储</strong> —&gt; <strong>索引</strong>，顺序表要根据索引进行查找</p>
<p>链表：<strong>离散存储</strong> —&gt; <strong>指针</strong>，链表要根据指针进行查找</p>
<p>其他所有的区别，都源于这个最本质的区别，由于顺序表是连续存储的，所以可以根据<strong>索引</strong>进行快速查找，但是如果想要插入和删除，为了保持顺序表的连续性，部分元素就需要移位，而这正是链表所擅长的，链表的离散存储特性决定了其无法快速的查找，但是可以快速的进行插入/删除操作。</p>
<p>链表由于其需要另外开辟空间存储下一个节点的指针，所以其比顺序表要耗费更多的内存。并且由于链表的空间是离散分配的，在内存回收后，会产生更多的内存碎片，不方便利用。</p>
<p>线性表的使用场景更多一些，其相较于链表，更节省内存，而且可以借助 CPU 的缓存机制，加速线性表的访问速度。但是其缺点也很明显，其需要占用连续的存储空间，一旦申请的空间很大，就会导致申请失败；另外，如果申请的空间不够用，那么就得向操作系统申请一个更大的连续空间，然后将顺序表中的内容 copy 过去，而 copy 的操作是非常耗时的。</p>
<h3 id="顺序表刷题总结"><a class="header" href="#顺序表刷题总结">顺序表刷题总结</a></h3>
<ul>
<li>顺序表的最大特点是其内存空间是连续的，可以通过 index 进行快速查找，所以顺序表的最大特点</li>
</ul>
<h3 id="用链表实现-lru-算法"><a class="header" href="#用链表实现-lru-算法">用链表实现 LRU 算法</a></h3>
<p>LRU(Least recently used) 算法需要频繁的插入删除，所以不适合用顺序表，可以使用链表来实现。</p>
<ol>
<li>插入：头插法</li>
<li>查找：从头开始查找，查找到后将节点移到头节点后</li>
<li>删除：cache 满后，删除链尾</li>
</ol>
<h3 id="如何判断两个链表相交"><a class="header" href="#如何判断两个链表相交">如何判断两个链表相交</a></h3>
<p>$O(n^2)$: 两层遍历，总能发现是否相交</p>
<p>$O(n)$: 一层遍历，遍历完两个链表，如果两个链表的最后一个结点指针相同，则相交，否则不相交</p>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<p>栈的特点：先进后出</p>
<h3 id="链式栈"><a class="header" href="#链式栈">链式栈</a></h3>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1564732280936.png" alt="链式栈" /></p>
<p>链式栈的优点：不存在栈满上溢的情况。</p>
<h3 id="用栈实现队列"><a class="header" href="#用栈实现队列">用栈实现队列</a></h3>
<p>两个栈实现队列：</p>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1565079298078.png" alt="两个栈实现队列" /></p>
<p>队列的四个基本操作：</p>
<ul>
<li>
<p>入队</p>
<p>入栈 1，栈 1 满后，如果栈 2 为空，则栈 1 内元素全部入栈 2，如果栈 2 不为空，则队满</p>
</li>
<li>
<p>出队</p>
<p>栈 2 出队，如果栈 2 为空，则栈 1 元素全部入栈 2，如果栈 1 也为空，则队列为空</p>
</li>
<li>
<p>判断队列是否为空</p>
<p>如果栈 1 和栈 2 都为空，则队列为空</p>
</li>
</ul>
<p>用两个栈实现队列，代码实现：</p>
<h3 id="后缀表达式表达式求值"><a class="header" href="#后缀表达式表达式求值">后缀表达式，表达式求值</a></h3>
<p>后缀表达式，表达式求值用到了栈，但是为什么要用到栈呢？栈的先进后出的思想到底体现在什么地方呢?</p>
<p>对于一个表达式，例如 $2 + 4 * 5$，这个问题到底哪里有栈的特点？细细品位，我们会发现，先进来的数 2 和操作符 + 并没有先参与运算，反而是后进来的 4 和 5 先进行了运算，这里就有用到栈的地方。</p>
<p>Leetcode: 150, </p>
<h3 id="汉诺塔问题hannoi"><a class="header" href="#汉诺塔问题hannoi">汉诺塔问题(hannoi)</a></h3>
<h2 id="queue"><a class="header" href="#queue">Queue</a></h2>
<h3 id="用顺序表实现-queue"><a class="header" href="#用顺序表实现-queue">用顺序表实现 Queue</a></h3>
<p>顺序表实现 Queue 的关键在于：队首的索引 &lt; 队尾的索引</p>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1567941024809.png" alt="顺序表实现 Queue" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree"><a class="header" href="#tree">Tree</a></h1>
<p>[TOC]</p>
<h2 id="二叉树的性质"><a class="header" href="#二叉树的性质">二叉树的性质</a></h2>
<p><strong>度数</strong>：度数就是一个节点的孩子数，也就是分支数，如果一个节点有两个孩子，那么该节点就是一个度为 2 的节点，如果一个节点是叶子节点，那么该节点的度为 0，(<strong>度数 + 1 = 节点数</strong>​)</p>
<p>设度为 0 的节点(叶子节点)的个数为 a，度为 1 的节点个数为 b，度为 2 的节点个数为 c，则</p>
<p>$a + b + c = b + 2*c + 1$ </p>
<p>结果就是：$a = c + 1$，也就是说，度数为 0 的节点数 = 度数为 2 的节点数 + 1</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优先队列-二叉堆"><a class="header" href="#优先队列-二叉堆">优先队列-二叉堆</a></h1>
<p>优先队列 / 二叉堆</p>
<p>注意：二叉堆的一次建堆，只能保证堆的最值位于堆顶，不能保证顺序表整体有序。</p>
<h2 id="二叉堆原理"><a class="header" href="#二叉堆原理">二叉堆原理</a></h2>
<p><img src="reading/data-structures-and-algorithm-analysis-in-c/chapters/assets/1566290638817.png" alt="二叉堆 / 优先队列" /> </p>
<h2 id="代码实现"><a class="header" href="#代码实现">代码实现</a></h2>
<pre><code class="language-python">

def init_heap(nums):
    &quot;&quot;&quot;给定一个序列，将其初始化为一个小根堆
    init 过程：从最后一个父节点 (length / 2) 到第一个父节点进行二叉堆的 adjust
    &quot;&quot;&quot;
    # 首先加入一个哑信息，进而方便计算，类似于链表加入头节点一样
    length = len(nums)
    nums.insert(0, 0)
    index = int(length / 2)
    while index &gt;= 1: # 从最后一个父节点到第一个父节点进行遍历，调整
        adjust_heap(nums, index, length)
        index -= 1
    nums.pop(0)
    pass


def adjust_heap(nums, index, length):
    &quot;&quot;&quot;调整子堆&quot;&quot;&quot;
    nums[0] = nums[index]
    # 找到子节点地最小值，然后与父节点比较
    while True:
        left_chind_index = index * 2
        min_index = left_chind_index
        if min_index &gt; length: # 无孩子
            break
        if left_chind_index &lt; length and nums[left_chind_index + 1] &lt; nums[left_chind_index]:
            min_index = left_chind_index + 1
        if nums[min_index] &gt;= nums[0]: # 两个子节点都比父节点大，已经构成了小根堆
            break
        nums[index] = nums[min_index]
        index = min_index # 向下继续调整，直到出界
    nums[index] = nums[0]


def insert(nums, num):
    &quot;&quot;&quot;二叉堆插入&quot;&quot;&quot;
    nums.append(num)
    length = len(nums)
    nums.insert(0, -10000)
    parent_index = length // 2
    prev_index = length
    while nums[parent_index] &gt; num:
        nums[prev_index] = nums[parent_index]
        prev_index = parent_index
        parent_index = parent_index // 2
    nums[prev_index] = num
    nums.pop(0)


def delete(nums):
    &quot;&quot;&quot;二叉堆删除&quot;&quot;&quot;
    delete_num = nums[0]
    nums[0] = nums.pop()
    length = len(nums)
    nums.insert(0, -10000)
    adjust_heap(nums, 1, length)
    nums.pop(0)
    return delete_num


if __name__ == &quot;__main__&quot;:
    lst = [15, 9, 7, 8, 20, -1, 7, 4] # result: -1, 4, 7, 8, 20, 15, 7, 9
    init_heap(lst)
    print(lst)
    insert(lst, -2)
    print(lst)
    delete(lst)
    print(lst)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<h2 id="排序的分类"><a class="header" href="#排序的分类">排序的分类</a></h2>
<h3 id="插入型排序"><a class="header" href="#插入型排序">插入型排序</a></h3>
<p>遍历列表，将元素依次插入已经排好序的字序列中。Leetcode: 147</p>
<p>Demo: 	4	2	1	3</p>
<pre><code>1: 2	4	1	3
2: 1	2	4	3
3: 1	2	3	4
</code></pre>
<p>简单插入排序 ——&gt; 希尔排序</p>
<h3 id="选择型排序"><a class="header" href="#选择型排序">选择型排序</a></h3>
<p>每一趟（第 i 趟）在后面 n - i + 1 个待排元素中选择最值元素，成为有序子序列的第 i 个元素。Leetcode:</p>
<p>简单选择排序 ——&gt; 堆排序</p>
<p>Demo:  4	2	1	3</p>
<pre><code>1: 1	2	4	3
2: 1	2	4	3
3: 1	2	3	4
4: 1	2	3	4
</code></pre>
<h3 id="交换型排序"><a class="header" href="#交换型排序">交换型排序</a></h3>
<p>冒泡排序 ——&gt; 快速排序</p>
<h2 id="排序的稳定性"><a class="header" href="#排序的稳定性">排序的稳定性</a></h2>
<p>**选择排序（Demo: 2, 2, 1），希尔排序，堆排序，快速排序（后3个都是高效排序算法，有得必有失）**都是不稳定的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>[TOC]</p>
<h2 id="学习思路"><a class="header" href="#学习思路">学习思路</a></h2>
<ul>
<li>对于一个算法和数据结构，只有把每一个详细的步骤都想清楚了，才能实现该算法，如果算法或者数据结构都不理解，那么谈何实现？举个例子，如果我们都不知道二叉堆的特性，不了解二叉堆的构建，插入，删除，那么谈何实现呢？</li>
<li>有时候，我们会对一道题或者一类题的解法形成思维定势，例如，表达式求值的方法，就应该用栈，但是，你知道为什么用栈吗？栈的先进后出的特性，到底在表达式求值中起到了什么作用？</li>
</ul>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<p>拿到一个问题，我们的解题步骤可以归纳为：</p>
<ol>
<li>
<p><strong>审题</strong></p>
<ol>
<li>
<p>归纳出题目的特点，确定使用的数据结构</p>
</li>
<li>
<p>从该数据结构的特点出发，结合题目的特点，寻找算法思路</p>
<p>例如将<strong>顺序表</strong>进行<strong>逆</strong>置的问题，审题后，关键词是 顺序表 和 逆。顺序表就要想到根据 index 在 $O(1)$ 时间内获取值和长度已知的特性；逆置就要想到栈的特性。</p>
<p>还要考虑，是对时间复杂度要求高，还是空间复杂度要求高。</p>
</li>
<li>
<p>在草稿纸上演算寻找规律，寻找直觉这一过程非常重要</p>
</li>
</ol>
</li>
<li>
<p><strong>编码</strong></p>
<ol>
<li>返回值是什么？</li>
<li>输入输出是什么？</li>
<li>考虑边界</li>
<li>……</li>
<li>能不能用 Python 调包直接解决问题，不行的话，再考虑优化</li>
</ol>
</li>
</ol>
<h3 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h3>
<ul>
<li><strong>位置互换</strong>，利用 index 进行<strong>逆置</strong></li>
</ul>
<h3 id="linklist"><a class="header" href="#linklist">LinkList</a></h3>
<ul>
<li><strong>头插法</strong>逆置单链表</li>
<li><strong>快慢指针</strong></li>
<li>链表节点最有价值的是<strong>节点值</strong>，而不是整个节点，这是个可以变通的地方，在不依赖前驱节点删除链表节点的时候，就用到了这个思想</li>
<li>链表真正可以有所作为的地方，在于链表的<strong>头部</strong>，链表头部的操作，复杂度最低</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-2"><a class="header" href="#questions-2">Questions</a></h1>
<p>[TOC]</p>
<h2 id="chapter1-introduction"><a class="header" href="#chapter1-introduction">Chapter1-Introduction</a></h2>
<ul>
<li>为什么要学习数据结构与算法</li>
<li>什么是递归，最经典的递归Demo是什么</li>
<li>递归的三要素是什么，递归可能导致的问题是什么</li>
<li>递归的可能导致的弊端是什么</li>
</ul>
<h2 id="chapter2-algorithm-analysis"><a class="header" href="#chapter2-algorithm-analysis">Chapter2-Algorithm-Analysis</a></h2>
<ul>
<li>什么是 Online Algorithm</li>
<li>二分查找的前提是什么</li>
<li>如何求两个数的最大公约数</li>
</ul>
<h2 id="chapter3-list-stack-queue-1"><a class="header" href="#chapter3-list-stack-queue-1">Chapter3-List-Stack-Queue</a></h2>
<ul>
<li>链式栈如何实现，链式栈的优点</li>
</ul>
<h2 id="chaptern-search"><a class="header" href="#chaptern-search">ChapterN-Search</a></h2>
<ul>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="经典问题"><a class="header" href="#经典问题">经典问题</a></h1>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<ul>
<li>top-K 问题</li>
<li>最大子序列和问题</li>
<li>欧几里得算法</li>
<li>二分查找算法</li>
<li>逆置 Arraylist</li>
<li>将两个 ArrayList: a1, a2, …, an, b1, b2, …, bn 逆置为 b1, b2, …, bn, a1, a2, …, an</li>
<li>在没有前驱节点的情况下，删除链表的节点，该方法有缺陷</li>
<li>二分查找</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="books"><a class="header" href="#books">Books</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bookshelf"><a class="header" href="#bookshelf">Bookshelf</a></h1>
<p>[TOC]</p>
<h2 id="计算机科学与技术"><a class="header" href="#计算机科学与技术">计算机科学与技术</a></h2>
<h3 id="系统类"><a class="header" href="#系统类">系统类</a></h3>
<h3 id="图形类"><a class="header" href="#图形类">图形类</a></h3>
<ul>
<li><a href="https://gabrielgambetta.com/computer-graphics-from-scratch/">《计算机图形学从零讲起》</a></li>
</ul>
<h3 id="编程类"><a class="header" href="#编程类">编程类</a></h3>
<ul>
<li><a href="https://modernc.gforge.inria.fr/">Modern C</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/c_programming_language_textbooks.html">阮一峰-学习C语言的教材</a></li>
<li><a href="https://docs.python-guide.org/">Python 最佳实践</a></li>
<li><a href="https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf">解决算法和数据结构问题（Python 版）</a></li>
<li><a href="https://github.com/go101/go101">go-101</a> </li>
<li><a href="https://github.com/LingCoder/OnJava8">Java 编程思想</a></li>
<li><a href="https://poignant.guide/book/">Ruby 学习指南</a></li>
</ul>
<h3 id="机器学习"><a class="header" href="#机器学习">机器学习</a></h3>
<ul>
<li><a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers">Probabilistic-Programming-and-Bayesian-Methods-for-Hackers</a> </li>
</ul>
<h3 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h3>
<ul>
<li>信息系统项目管理师教程（第3版）</li>
</ul>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<ul>
<li><a href="https://book.douban.com/subject/3609132/">把时间当作朋友</a></li>
<li>新媒体研究书籍：<strong>弱传播</strong></li>
<li>温铁军：八次危机</li>
<li>波伏娃 - 《第二性》</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="禅与摩托车维修艺术"><a class="header" href="#禅与摩托车维修艺术">禅与摩托车维修艺术</a></h1>
<p>[TOC]</p>
<p>上周读了一本书，感觉挺不错的，在这里 po 一下作者有意思的观点，顺便给每个章节做个总结</p>
<h2 id="读书笔记"><a class="header" href="#读书笔记">读书笔记</a></h2>
<h3 id="第一章-面对问题"><a class="header" href="#第一章-面对问题">第一章 面对问题</a></h3>
<p>骑摩托车旅游和其他的方式完全不同。坐在汽车里，你只是被局限在一个小空间之内，因为已经习惯了，你意识不到从车窗向外看风景和看电视差不多。你只是个被动的观众，景物只能呆板地从窗外飞驰而过。骑摩托车可就不同了。它没有什么车窗玻璃在面前阻挡你的视野，你会感到自己和大自然紧密地结合在了一起。你就处在景致之中，而不再是观众，你能感受到那种身临其境的震撼。脚下飞驰而过的是实实在在的水泥公路，和你走过的土地没有两样。它结结实实地躺在那儿，虽然因为车速快而显得模糊，但是你可以随时停车，及时感受它的存在，让那份踏实感深深印在你的脑海中。</p>
<p>这些乡间小路和一般的干道迥然不同，就连沿线居住的居民的生活步调和个性也不一样。他们一直都没有离开过本地，所以可以很悠闲地和你寒暄问候、谈天说地，那感觉好极了。反而是那些早就搬到城市里的人和他们的子子孙孙迷失了，忘记了这种情怀。这实在是一个宝贵的发现。我在想，为什么我们这么久之后才对其着迷。我们早已看过却仿佛没有看到，或者说是环境使我们视而不见，蒙骗了我们，让我们以为真正的生活是在大都市里，而这里只不过是落后的穷乡僻壤。</p>
<p>日子就是这样随意，忘掉时间，没有人会催促你，也不会担心浪费时间。</p>
<p>我们常常太忙而没有时间好好聊聊，结果日复一日地过着无聊的生活，单调乏味的日子让人几年后想起来不禁怀疑，究竟自己是怎么过的，而时间已悄悄溜走了。</p>
<p>和科技有关的怪物已吞噬了大片的土地，污染了空气和湖泊，人类既无法打击它们，也无法逃避。</p>
<p>佛陀或是耶稣坐在电脑和变速器的齿轮旁边修行会像坐在山顶和莲花座上一样自在。如果情形不是如此，那无异于亵渎了佛陀——也就是亵渎了你自己。</p>
<h3 id="第二章-热爱活在当下"><a class="header" href="#第二章-热爱活在当下">第二章 热爱，活在当下</a></h3>
<p>一边工作一边听音乐是没有办法真正思考的。虽然他们看起来很随和、友善、轻松自在，但是却没有投入工作之中，他们就像旁观者一样，你会觉得他们只是在那儿晃来晃去，然后接过别人递给他们的扳手。他们对自己的工作没有认同感，不会说：“我是师傅。”一旦到了下午五点，八个小时一满，你知道他们会立刻放下手中的工作，即刻离开，然后尽可能地不去想他们的工作。在这一方面，他们与约翰和思薇雅一样，虽然想运用科技的成果，但是却不愿和它发生任何关系。</p>
<p>仓促本身就是 20 世纪最要不得的态度，当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</p>
<h3 id="第三章-鱼不知水"><a class="header" href="#第三章-鱼不知水">第三章 鱼不知水</a></h3>
<p>暴风雨的云层似乎非常厚实，虽然整个草原辽阔无际，但是头上这一片正要袭来的雨云却更教人害怕。现在我们只能看它的脸色行驶。它什么时候下来，我们无法掌握，唯一能做的只是看着它愈来愈近。</p>
<p>就在回旅馆的路上，一整天下来的劳累突然侵袭而来，于是我们停下来休息，浑身酥软无力。坐在汽车旅馆院子里的铁椅上，约翰从冰箱里拿出混着其他饮料的威士忌酒，我们慢慢地啜饮，心旷神怡，白杨树排在道路两旁，晚风轻轻袭来，叶子沙沙作响。</p>
<p>完全科学的态度就是既不相信鬼，也不相信科学，这样你就安全了。然而这样一来，你就没有多少可以相信的了，但是唯有这样才是科学的态度。</p>
<p>对于别人所相信的鬼魂，我们很容易无知而且自负地就进行攻击，但是对于我们自己心中的鬼魂，我们却非常无知而且盲目地信仰着。大家被催眠了，用比较正统的说法是，大家受了教育。</p>
<p>自然的法则是人类发明的，就像鬼的存在一样。逻辑学、数学也都是如此，所有值得赞美的事，也都是人类的发明。这个世界也是人类所想象出来的，整体来说也就是一种灵界的存在。我们之所以能看到这个世界，就是因为鬼神让我们看见，他们是摩西、耶稣基督、释迦牟尼、柏拉图、卢梭、杰弗逊、林肯等等，牛顿是非常好的一位，可算其中最好的一位，所以我们的常识就是由过去成百上千的鬼神所构成的，他们企图在人的生命当中找到他们的地位。</p>
<h3 id="第四章-真味只是淡-应无所住而生其心"><a class="header" href="#第四章-真味只是淡-应无所住而生其心">第四章 真味只是淡 应无所住而生其心</a></h3>
<p>我喜欢用军人穿的工作服，因为便宜、耐穿而且耐脏。</p>
<p>我关心这副皮手套，我微笑着看它们被风吹拂，因为它们已经在那儿陪伴了我这么多年。它们已经磨损老旧了，但我却在它们身上发现了一种幽默感。整副手套都沾满了油渍、汗水、灰尘，而且还有地方发霉了。现在把它们放在桌上，即使天气不冷，它们也没有办法平平地躺着。它们似乎有属于自己的往事。虽然只值三块美金，而且已经补到无法再补，但是我仍然花了许多时间和精力去清理它们。我不能想象戴一副新手套的感觉。这种想法似乎很不实际，但是手套并不仅仅需要实际，其他事情也是如此。</p>
<p>一旦一辆车陪伴过你许多时光，那么对你来说它就是独一无二的，是别的车子无法取代的。</p>
<p>如果有人不懂心存感激，而你当面告诉他，那么你就等于是在骂他，这样你什么事都解决不了。</p>
<p>风和太阳让你觉得很舒服，让这一切显得很真实。</p>
<p>你看着这样一片风景，然后看看地上的草，一切都妙不可言。但是一旦你用框子框住，美感就都不见了。</p>
<p>我不想拥有这些草原，或是把它们拍下来，我也不想改变它们，甚至也不想停下来，或是继续走下去。我们只是沿着空旷的路继续骑下去。</p>
<h3 id="第五章-写代码也是如此"><a class="header" href="#第五章-写代码也是如此">第五章 写代码也是如此</a></h3>
<p>骑在这些过山车道一样的山路上，下坡的时候会突然地向下疾冲，然后又得慢慢地往上爬。这样一来我们就没有办法看得很远，因而变得有些紧张。</p>
<p>我应该偷偷地走到工作台，切下一部分啤酒罐，把上面的印刷除掉，然后回来告诉他，我们很幸运，只剩下一片了，还是由德国进口的。这样就成了。它是由德国巴伦·艾佛德·克鲁普公司制造的，我以特价买到了。这样他就搞不清楚究竟是怎么一回事儿了。</p>
<p>在从事机械方面的工作时，常常会有这种情况出现，一旦遇到瓶颈，你只好停下来，仔细思考一番，看看是否有新的信息，然后出去逛逛，等你再回来时，原先隐而未显的原因就会浮现出来。</p>
<p>我从理智、知识的角度去看修理把手的问题，其中牵涉到金属的所有科学上的特性。而约翰却从直觉和当下的角度去看待它。我是从内涵着手，而他却是从物的表象开始。我看到的是这个铝片的意义，而他看到的却是这个铝片的外观。</p>
<p>我走过去把摩托车骑过来，把头灯打开，这样就可以找到手电筒了。我一样一样地翻，想找到手电筒，过了很长时间我才突然意识到，我不需要手电筒，我需要的是弯刀，而弯刀就在我眼前。</p>
<p>他们对他没有真正的关心，因为不是自己人。事实上现在大部分的时候，这只是一种虚伪的态度，就像第一天上课的老师一样。但是那些不是自己人的人，又怎么会知道友好究竟是怎么一回事儿呢？</p>
<p>我一旦用任何手势或是行动去和他接触，就等于把他给变得实在了。而他并没有实体，但是我认识他，他就是斐德洛。</p>
<h3 id="第六章-一一"><a class="header" href="#第六章-一一">第六章 一一</a></h3>
<p>为了让他明白我的想法，就必须向前追溯，愈向前追溯，你就愈需要继续追溯下去，一直到原先只是沟通上的一个小问题，最后变成哲学上的大问题。</p>
<p>人在思考和感觉的时候往往会偏向于某一种形式，而且会误解和看轻另一种形式。</p>
<h3 id="第七章-佛法在世间不离世间觉"><a class="header" href="#第七章-佛法在世间不离世间觉">第七章 佛法在世间，不离世间觉</a></h3>
<p>要排除解剖摩托车时心中的佛性，就等于完全排除了佛性。</p>
<p>有一个一直存在的古典问题，就是摩托车的哪一部分、沙堆中的哪一粒沙才是佛陀呢？很明显，问这个问题是找错了方向，因为佛是无所不在的。</p>
<p>马克·吐温在掌握通过密西西比河的方法之后，发现这条河已经失去了它的美丽——总会丢掉一些东西。</p>
<p>他是一个疯子，如果你直接面对疯子，你所了解的就是他疯了，这等于是根本不了解他。</p>
<p>他所探索的就是隐身在一切科技的背后，在所有现代科学、所有西方思想背后的鬼魂——也就是理性本身。</p>
<p>现在我想有愈来愈多的人看见了，或者在人生低潮的时候瞥见了它，它就是所谓的理性。</p>
<h3 id="第八章-理性"><a class="header" href="#第八章-理性">第八章 理性</a></h3>
<p>真正的系统、真实的系统，就是我们当前的系统观，也就是理性自身。如果把整个工厂拆毁了，而架构它的理性仍然存在，那么靠着这个理性很容易就可以建造另一座工厂。如果革命能够摧毁一个政府，但是政府背后的理性仍然完整地保存着，那么很快地又可以再建立同样的政府。</p>
<h3 id="第九章-逻辑"><a class="header" href="#第九章-逻辑">第九章 逻辑</a></h3>
<p>在研究科学的时候，一个人必须非常地谨慎，而且严守逻辑的法则。不要在逻辑上面摔跤，否则整个科学结构很快就会垮下来。只要你的推论稍有差错，你就会陷入无底的深渊当中。</p>
<h3 id="第十章-理性的缺憾"><a class="header" href="#第十章-理性的缺憾">第十章 理性的缺憾</a></h3>
<p>人类用最适合自己的方式，描绘了一幅最简洁、最容易了解的世界图像。然后试着用经验取代某种层次的世界，然后征服它……他创造了这个宇宙和他感情生活的支柱，这样才能由中找到安宁，而这安宁是无法从个人狭窄的经验当中获得的……最崇高的工作……就是要建立这些宇宙基本的法则，这些法则经过演绎就能创造出现今的世界。而要通往这些法则没有合乎逻辑的路；只有靠着直觉和对经验的体谅才能进入其中……</p>
<p>引起我们目前社会种种危机的原因是理性天生的一种缺憾。我们目前所谓的理性模式并没有把社会带向更美好的世界，反而离它愈来愈远。自从文艺复兴以来，这些模式就一直存在。只要人们主要的需求还在于衣食住行，这些模式就会存在下去，而且还会继续运作。但是对现在大部分的人来说，这些基本的需要不再是主要的问题，因而从古代流传下来的理性结构已经不符合所需，从而显露出它真正的面目——在情感上是空虚的，在美学上没有任何表现，而在灵性上更是一片空白。这就是它的现状，而且它还会持续很长的一段时间。</p>
<h3 id="第十一章-真理"><a class="header" href="#第十一章-真理">第十一章 真理</a></h3>
<p>来到心灵的高山地带，一个人必须习惯不稳定的稀薄空气，还有大量的问题以及各种假设的答案。这种情形会不断地扩大，一直到这个人几乎无法控制，因而迟疑是否要接近它，因为他害怕很可能会在其中迷失，而且永远找不到出路。</p>
<p>而真理究竟是什么？你怎样知道自己拥有它？我们究竟如何能有真实的认知呢？是由一个我或者是灵魂去认知的吗？或者这个灵魂仅仅等于另外一种感官？现实基本上是在不断地改变吗？或者是永远不变……当你说这个东西就表示这个东西的时候，这又是怎样的意思呢？虽然他们都声称自己的答案是永存的，而且放之四海皆准，然而文化上的差异，使我们对于同样的问题有着截然不同的答案。这些答案在他们自己的体系之内可说是正确的，但即使在同样的文化之内，旧的思想仍然
会被新的思想取代。</p>
<p>不能由感官认知摩托车并不能证明摩托车就不存在。在我们心中有一种直觉能认知摩托车。它在时间和空间上有一种连续性，所以当一个人转头的时候，摩托车的形象也跟着改变，所以它和我们在感官上所接收到的讯息并不冲突。</p>
<p>感官所得到的讯息只能证实它的存在，但是这些讯息并不等于它。我通过直觉所了解到的摩托车，就像我存在银行里面的钱。如果我到银行要求看我的钱，他们一定会很奇怪地看着我。因为我的钱并没放在他们的抽屉里，他们没法拿出来给我看，我的钱其实只是电脑存档里面的一个数字。但是这样就够了，因为我相信如果我需要钱的时候，银行会通过他们的系统让我取到钱。</p>
<h3 id="第十二章-主题对客体"><a class="header" href="#第十二章-主题对客体">第十二章 主题对客体</a></h3>
<p>他们是我的朋友，并不是书中的人物，就像思薇雅有一次说的，“我不想被当成物体”，所以我知道的许多事情都没有写出来。</p>
<p>由于人类知识的范围太过复杂，结果每一个人都变成专家，然而却造成了彼此之间的疏离感。</p>
<h2 id="拓展阅读"><a class="header" href="#拓展阅读">拓展阅读</a></h2>
<p><a href="https://www.bilibili.com/video/BV1Qf4y177Ko">复旦大学王德峰讨论休谟问题</a></p>
<ul>
<li>
<p>How to derive ought from is?</p>
<p>我们如何从「存在」中推出「应当」来</p>
<p>我们能否从关于世界的客观知识当中，关于世界之存在的知识当中，推出我们应当做，不应当做什么的价值标准呢？理性能否用来论证一种价值，一种唯一真实的价值，理性能否推出「真理」？ought 和应当是通过理性来确立的，理性迄今为止所有的成功只表明一点：理性是工具。理性能够引导自然科学，但是却退不出人类生活的价值标准。</p>
<p>理性不能担保明天太阳照常升起，太阳照常升起是经验的总结。</p>
</li>
</ul>
<p><img src="reading/books/assets/s29865712.jpg" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-road-less-traveled"><a class="header" href="#the-road-less-traveled">The-Road-Less-Traveled</a></h1>
<p>面对问题，承担责任，忠于事实，保持平衡</p>
<ul>
<li>
<p>不成熟的人最大的特征是，他们总是坐在那里抱怨生命没有满足他们的需要。<strong>而少数成熟的人将生命视为自己的责任，努力满足生命的需要</strong></p>
<p>实际上，<strong>当我们明白发生在自己身上的一切事情，都可以成为锻炼的机会时</strong>，我们也就可以用截然不同的态度来看待生命了</p>
</li>
<li>
<p>没有人每次都能正确的做事，完美无缺的击中靶心，这是我们自身的缺陷，毕竟我们不可能永远正确，永远完美，所以我们每个人都或多或少做错过很多事情，甚至犯下<strong>罪过</strong></p>
</li>
<li>
<p>外面发生的事情并不能决定一个人的命运，如何看待和思考那些事情，才是决定命运的关键。所以，<strong>命运并不是从外面走进来的，而是从内部走出来的</strong></p>
</li>
<li>
<p>一个人也许能够做出惊人的伟业，了解深奥的知识，但是对自己却一无所知。而失败与痛苦则能够引导一个人向内心省察，让他在内心真正的学习</p>
</li>
<li>
<p>宏观是我们必须接受的，微观才是我们能有所作为的</p>
</li>
<li>
<p>人生苦难重重，这是真理，也是现实</p>
</li>
<li>
<p>提防自己内心中隐藏的懒惰</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-as-a-friend"><a class="header" href="#time-as-a-friend">Time-as-a-Friend</a></h1>
<p>GitHub: <a href="https://github.com/xiaolai/time-as-a-friend">Time-as-a-Friend</a></p>
<h2 id="阅读说明"><a class="header" href="#阅读说明">阅读说明</a></h2>
<ul>
<li><strong>时间不可管理，一切都靠积累</strong></li>
<li>很多“时间管理技巧”并非无用，但往往由于使用者心智能力低下甚至尚未开启心智，致使那些技巧只能治标，不能治本，甚至既不治标，也不治本</li>
<li>基于比较的成功观，是伤人的、害人的。事实上，对年轻人来说，<strong>成长比成功更重要</strong>，而且，这才是人人都可以做到的事情，才是人人都值得追求的事情。而<strong>成长其实只有一条路——积累</strong></li>
<li>人的理性建立在接受现实的基础上，不能接受现实，一切成长都是虚妄</li>
</ul>
<h2 id="第-0-章困境"><a class="header" href="#第-0-章困境">第 0 章：困境</a></h2>
<p><strong>时间无法管理，我们能管理的，只有自己</strong></p>
<ul>
<li>我教过很多学生。他们中的绝大多数都一样，压力刻在额头，匆忙写在脸上。他们身上充满了矛盾——他们“<strong>既勤奋又懒惰</strong>”</li>
<li>只有学会正确地思考，才意味着真正进化成人，没有人愿意做猴子</li>
<li>“没时间了”，是“时间恐慌症”患者脑子里唯一反复闪现的一句话。巨大的压力，极度的恐慌，使“患者”身上综合了一切矛盾：他们既勤奋又懒惰，既聪明又愚蠢，既勇敢又懦弱，既满怀希望又分分秒秒面临绝望，既充满自信又随时随地体会自卑</li>
<li>战略上藐视，战术上重视</li>
<li>生活中明显有另外一些人——尽管数量上并不占优——在用另外一种状态生活。他们从容，他们优雅，他们善于化解各种压力，安静地去做他们认为应该做的事情，并总能有所成就。他们甚至可以达到常人无法想象的境界——不以物喜，不以己悲</li>
<li>很少有人会注意，所谓“管理时间”抑或“时间管理”是虚假的概念，是不可能完成的任务。时间不会服从任何人的管理，它只会自顾自地流逝</li>
<li>问题出在我们自己身上，我们无法管理时间。<strong>我们真正能够管理的，是我们自己</strong></li>
<li><strong>人们很难接受与已有知识和经验相左的信息或观念</strong>，因为一个人已有的知识和观念都是经历过反复筛选的。尽管很多知识和观念是被灌输的，但知识的持有者对“被灌输”这一事实往往毫无察觉，就算察觉，也可能拒绝承认。人们更愿意相信自己拥有一定的判断能力，不会被轻易糊弄。即使是一些“想当然”的观念，人们也倾向于认为那是“思考过后的结论”</li>
</ul>
<h2 id="第一章醒悟"><a class="header" href="#第一章醒悟">第一章：醒悟</a></h2>
<p><strong>学会独立的思考，成为大脑的主人</strong></p>
<ul>
<li>
<p>我们用自己的大脑进行思考，然而我们思考的方式和结果往往受上一次思考的方式和结果影响，同时也会影响下一步思考的方式和结果</p>
</li>
<li>
<p><strong>我们甚至可以思考我们的思考方式和思考结果是否确实是合理的思考方式和思考结果</strong></p>
</li>
<li>
<p><strong>你的大脑并不是你，你的大脑是（属于）“你的”大脑</strong>，我究竟是被大脑控制，还是在控制自己的大脑</p>
</li>
<li>
<p>你“可以控制你的大脑”——分清主仆很重要</p>
<p><img src="reading/books/assets/1559003611392.png" alt="被大脑控制，还是控制自己的大脑" /></p>
</li>
<li>
<p>在最为艰苦的岁月里，他选择了积极向上的态度。他没有悲观、绝望，相反，他在脑海中设想，自己重获自由之后该如何站在讲台上，把“关于集中营的心理学”讲给来宾们听。凭着这种积极、乐观的思维方式，尽管身处集中营，弗兰克却可以让自己的心灵越过牢笼的禁锢，在自由的天地里任意翱翔</p>
</li>
<li>
<p>“<strong>运用心智获得解放</strong>”。不要再让自己“跟着感觉走”，成为大脑的奴隶，而是翻身做大脑的主人</p>
</li>
<li>
<p>一个人的心智就是其过往获得的一切知识及经验的总和（包括基于这些知识和经验造就的思考方法、思考模式）。心智与智商不同。大多数人都拥有正常的智商，但并非每个拥有正常智商的人都拥有正常的心智</p>
</li>
<li>
<p>骗子想要成功行骗,必须把想让别人相信的谎言掺到大量的真理之中。鬼话连篇是骗不了人的</p>
</li>
<li>
<p>我的成长轨迹，和笑来极其的相似。笑来因为编写教材，赚得了<strong>第一桶金</strong>，而我因为编写了考研辅导资料，赚得了第一桶金</p>
</li>
<li>
<p>技多不压身，只管学习，剩下的交给时间</p>
</li>
<li>
<p>之所以觉得听了很多道理，却依然过不好这一生，原因在于，我并没有把这些道理应用到实践，并应用到实践中</p>
</li>
</ul>
<h2 id="第二章现实"><a class="header" href="#第二章现实">第二章：现实</a></h2>
<p><strong>面对问题，接受现实，一分耕耘，一分收获</strong></p>
<ul>
<li>
<p><strong>一分耕耘，一分收获</strong>，No pain, no gain ——&gt; 推迟满足感</p>
</li>
<li>
<p>酗酒疯狂无度的、嫖娼乐此不疲的、吸毒罔顾死活的，都是这种“希望自己的欲望马上得到满足的天性”使然。更要命的是，几乎整个社会都在用各种各样的方式<strong>刺激人们发挥这种天性</strong>，并愈演愈烈。电视上的减肥广告告诉你，减肥药都功能神奇，当天见效。报纸上的医疗广告告诉你，无论得了什么病都不要怕，找他一准手到病除。公交上的培训广告告诉你，不管学什么都要速成，因为人生苦短</p>
</li>
<li>
<p>接受现实。<strong>告诉自己：我有不足，我需要时间，我没办法一蹴而就</strong></p>
</li>
<li>
<p><a href="http://goo.gl/uyr9E">大不列颠语料库</a>的统计数据表明，最常与“完美主义者”（perfectionist） 这个词一并出现的是“脆弱的”（<strong>vulnerable</strong>）。没有人能够做到完美。我们至多能做到接近完美，或者更接近完美</p>
<p><img src="reading/books/assets/1559093952561.png" alt="接受不完美" /></p>
</li>
<li>
<p>人就是这样，装得久了，就装得像了；装得太像、太久，不管事实怎样，自己倒是先信了</p>
</li>
<li>
<p>这些人所说的“做不好”，其实是“不能一下子做好”，但问题在于，没有什么事情是一下子就能做好的</p>
</li>
<li>
<p>一些真正优秀的人，也会被别人称作“完美主义者”。事实上，这种描述并不准确。比较准确的说法应该是“他们是有能力做到更接近完美的人，并且，他们一直在努力” ——&gt; Follow Excellence，Success will Follow you.</p>
</li>
<li>
<p>我们必须接受这个现实——未知永远存在。而后，我们只能不断地尝试着去适应“在未知中不断前行”，如果不能接受这个现实，就无法忍受未知的存在，也会平添无数的焦虑。焦虑是导致时间浪费、效率低下的根源之一</p>
</li>
</ul>
<h2 id="第三章管理"><a class="header" href="#第三章管理">第三章：管理</a></h2>
<ul>
<li>
<p>诺维格表示，人们购买那种名字类似“7天自学Java语言”的书是无知的表现，他认为，用10年时间学习程序设计才真正现实，也非常值当</p>
</li>
<li>
<p>任何领域的卓越成就都必须用一生的努力才能取得；稍微低一点代价都无法换来</p>
</li>
<li>
<p>为什么随着年龄的增长每个人都会觉得时间过得越来越快</p>
<p>对一个5岁的孩子来讲，未来的1年相当于他已经度过的人生的¹⁄₅，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的¹⁄₅₀，即2%。所以，随着年龄的增加，人们会觉得时间运动得越来越快</p>
</li>
<li>
<p>明知自己拖延的人很痛苦，因为他们不是不知道该做什么，而是不知道为什么“<strong>无法进入状态</strong>”——这是他们能够想出来的对自己的行为最拿得出手的描述</p>
</li>
<li>
<p>一个人一旦开始认真做事，被嘲弄、被耻笑的几率将远远高于被夸奖、被鼓励的几率——这几乎是肯定的</p>
</li>
<li>
<p>如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会像那些极少数已经做对、做好的人一样，给予别人真诚的鼓励而非嘲弄</p>
</li>
<li>
<p>很多人实际上根本不知道自己所谓的“喜欢做某件事情”很可能只是因为那件事情相对简单、容易获得奖励而已</p>
</li>
<li>
<p>他们每次回避困难的时候，都不是故意的，并且往往已经给自己找了恰当的借口。这借口太强大、太有力，以至他们真诚地相信：“我喜欢做有创意的事情，而现在手上的这些事情太枯燥，我确实提不起兴趣……”</p>
</li>
</ul>
<h2 id="第四章学习"><a class="header" href="#第四章学习">第四章：学习</a></h2>
<ul>
<li>学习是投资回报率最高的行为</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reborn"><a class="header" href="#reborn">reborn</a></h1>
<p>Github: <a href="https://github.com/xiaolai/reborn">reborn from xiaolai</a></p>
<p>种一棵树最好的时候是十年前，其次是现在。</p>
<p><img src="reading/books/assets/heres-sth-wrong.jpg" alt="heres-sth-wrong" /></p>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>笑来的三观，和我特别契合，我也是学习置上主义者，我坚信学习可以改变命运。</p>
<ul>
<li>学习其实很简单：<strong>理解主干，然后不断拓展枝叶。</strong> ——&gt; 思维导图的价值所在</li>
<li>我们一生可以活很多辈子</li>
<li>重生的手段：进入新的领域，学习新的知识</li>
</ul>
<h2 id="chapter1-人生最重要的概念复利"><a class="header" href="#chapter1-人生最重要的概念复利">Chapter1. 人生最重要的概念：复利</a></h2>
<p>复利就是不断精进，不断学习，不断实践，不积跬步无以至千里，不积小流无以成江海。</p>
<p>可以复利的对象：资产 / 知识 / 经验，我没有资产，我只能不断学习，不断迭代、总结经验。</p>
<p>复利可以使我们对一个领域彻底的精通，但是这需要不断地积累，不断地精进，最忌精力分散，半途而废。</p>
<p>复利是一个量变引起质变地过程。</p>
<h2 id="chapter2-最根本的学习方式践行"><a class="header" href="#chapter2-最根本的学习方式践行">Chapter2. 最根本的学习方式：践行</a></h2>
<ul>
<li><strong>时间是不可管理</strong>的，我们能做的，就是提高自己的工作效率和生活质量</li>
<li><strong>我这哪里是对自己狠啊？这根本就是对自己的爱惜啊！</strong></li>
<li><strong>每个人都是出生的时候，都只能是原创</strong>。结果，绝大多数人活着活着就一不小心把自己活成了盗版</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="射雕英雄传"><a class="header" href="#射雕英雄传">射雕英雄传</a></h1>
<ul>
<li>牛家村风雪夜
<ul>
<li>郭家
<ul>
<li>梁山泊郭胜(家传戟法)
<ul>
<li>郭啸天</li>
<li>李萍</li>
<li>郭靖(靖康之耻，丘处机)</li>
</ul>
</li>
</ul>
</li>
<li>杨家
<ul>
<li>岳飞名将杨再兴(杨家枪)
<ul>
<li>杨铁心（穆易）</li>
<li>包惜弱(私塾先生女儿)</li>
<li>杨康</li>
<li>穆念慈（义女）</li>
</ul>
</li>
</ul>
</li>
<li>完颜洪烈(大金国六王子)
<ul>
<li>包惜弱</li>
<li>完颜康</li>
</ul>
</li>
<li>丘处机(害了郭杨两家)</li>
<li>结局：郭杨被段天德所杀，李萍被段天德掳走，包惜弱被完颜洪烈骗走</li>
</ul>
</li>
<li>嘉兴醉仙楼斗酒
<ul>
<li>江南七怪
<ul>
<li>飞天蝙蝠柯镇恶</li>
<li>妙手书生朱聪</li>
<li>马王神韩宝驹</li>
<li>南山樵子南希仁</li>
<li>笑弥陀张阿生</li>
<li>闹市侠隐全金发</li>
<li>越女剑韩小莹</li>
</ul>
</li>
<li>丘处机(寻找段天德和李莹)</li>
<li>焦木大师(窝藏段天德)</li>
<li>完颜洪烈(带包惜弱停宿嘉兴)</li>
<li>结局：丘处机斗酒斗输，金兵乱场</li>
</ul>
</li>
<li>法华寺恶战
<ul>
<li>对线双方：江南七怪 + 焦木大师，丘处机</li>
<li>对线结果：两败俱伤，段天德北上逃走</li>
<li>约定：十八年之约，江南七怪培养郭靖，丘处机培养杨康</li>
</ul>
</li>
<li>大漠篇
<ul>
<li>
<p>李萍大漠生子，段天德趁乱逃走，七怪苦寻母子</p>
</li>
<li>
<p>母子扎根大漠，小郭靖勇救哲别，郭靖托雷结拜</p>
</li>
<li>
<p>完颜洪烈册封铁木真，江南七怪寻得小郭靖</p>
</li>
<li>
<p>七怪大漠恶战黑风双煞，郭靖匕首巧杀陈玄风</p>
</li>
<li>
<p>躲猎豹小郭靖救华筝</p>
</li>
<li>
<p>郭靖十年苦学成少年，铁木真纵横大漠无人敌</p>
</li>
<li>
<p>十八之约余两年，尹志平初试郭靖</p>
</li>
<li>
<p>悬崖边郭靖一箭双雕，攀岩拜师学内功，施轻功训得汗血宝马</p>
</li>
<li>
<p>郭靖崖顶惊遇梅超风，大漠马钰现真身，&quot;全真七子&quot;斗铁尸</p>
</li>
<li>
<p>全真教</p>
<ul>
<li>创教祖师王重阳
<ul>
<li>全真七子</li>
<li>丹阳子马钰</li>
<li>长真子谭处端</li>
<li>长生子刘处玄</li>
<li>长春子丘处机
<ul>
<li>尹志平</li>
<li>杨康</li>
</ul>
</li>
<li>玉阳子王处一</li>
<li>广宁子郝大通</li>
<li>清净散人孙不二</li>
</ul>
</li>
<li>老顽童周伯通</li>
</ul>
</li>
<li>
<p>桃花岛</p>
<ul>
<li>黄药师（桃花影落飞神剑，碧海潮声按玉箫）
<ul>
<li>陈玄风（铜尸）</li>
<li>梅若华（梅超风，铁尸）
<ul>
<li>杨康</li>
</ul>
</li>
<li>陆乘风(归魂庄庄主)</li>
<li>黄蓉</li>
</ul>
</li>
</ul>
</li>
<li>
<p>郭靖策马救大汗，成吉思汗一统蒙古</p>
</li>
<li>
<p>大汗许郭靖金刀驸马，郭靖随师父南下赴约</p>
</li>
<li>
<p>兵分两路郭靖独赴约，张家口郭靖遇黄蓉，宝马黄金赠蓉儿，清风竹林斗四鬼</p>
</li>
<li>
<p>比武招亲杨康胜穆念慈，打抱不平郭靖打杨康</p>
</li>
<li>
<p>杨铁心惊遇包惜弱，王处一险中救郭靖</p>
</li>
<li>
<p>赵王府“群英”聚集，各显神通，王处一中毒危在旦夕</p>
</li>
<li>
<p>舟中叫花变仙女，郭靖黄蓉见真情</p>
</li>
<li>
<p>完颜洪烈密会各路高手寻武穆遗书，取药斗蛇郭靖险脱身</p>
</li>
<li>
<p>为逃生郭靖吸蛇血，杨铁心识得郭靖</p>
</li>
<li>
<p>杨铁心包惜弱相认，包惜弱教子认亲爹</p>
</li>
<li>
<p>黄蓉智斗各大高手，掉洞穴郭靖遇铁尸</p>
</li>
<li>
<p>铁尸走火入魔杀郭靖，黄蓉师姐手中救哥哥</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="亮剑"><a class="header" href="#亮剑">亮剑</a></h1>
<p>前半部讲英雄，后半部讲悲剧。</p>
<p>背景：wg</p>
<p>结局：</p>
<ul>
<li>丁伟反对对彭帅的指控，被逮捕</li>
<li>田墨轩和其夫人被下放到农场劳改，田墨轩最终在三年大饥荒中饿死</li>
<li>赵刚和冯楠一家在北京被迫害，四个孩子托给李云龙抚养</li>
<li>李云龙在家中自杀，田雨在狱中割腕，将其六个孩子托给孔捷，楚云飞在金门岛上通过广播哀悼李云龙，段鹏带领特种部队夺走李云龙遗物中的将星</li>
<li>孔捷镇守东北边境，逃过一劫</li>
<li>1978 年，李云龙被平反</li>
<li>楚云飞来大陆投资，并住在了李云龙在福建的故居</li>
<li>李云龙和赵刚的六个孩子，均参军，一少将，其余皆大校上校</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="万历十五年"><a class="header" href="#万历十五年">万历十五年</a></h1>
<p>[TOC]</p>
<p><img src="reading/books/assets/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4.png" alt="万历十五年时间轴" /></p>
<h2 id="择偶准则"><a class="header" href="#择偶准则">择偶准则</a></h2>
<p>皇帝虽贵为一国之君，但是并不自由，情感上的需求也并不能得到满足；</p>
<p>就像我和前任在一起的时候，情感上无法交融到一块，激情之后，留下的却是无尽的空虚。</p>
<p>所以，对于另一半，我并不会要求其样貌有多么好看，而是要有情感上的共鸣。</p>
<h2 id="皇帝的悲哀"><a class="header" href="#皇帝的悲哀">皇帝的悲哀</a></h2>
<p>&quot;他们决心不再让朝廷的大全掌握在一个年轻人手里，听凭他任意使用，而实要设法把皇帝引进他们所崇奉的规范里&quot;</p>
<p>“她看透了他虽然贵为天子，富有四海，但在实际上却既柔且弱，也没有人给他同情和保障”</p>
<p>万历皇帝——溥仪皇帝</p>
<p>皇帝更多时候是封建制度的牺牲品，其并没有绝对的权威，受制于群臣，受制于道德，受制于祖宗留下来的规章制度。</p>
<h2 id="阴阳之道-keep-balance"><a class="header" href="#阴阳之道-keep-balance">阴阳之道 Keep balance</a></h2>
<p>“申时行不是理想家，他深知人类的弱点不能完全避免，当务之急是增加文官之间的相互信赖，与其暴露各人的阴，毋宁提倡他们的阳”</p>
<p>满口仁义道德，实际上却是在维护自己的利益。</p>
<p>即使是在朝廷上身居高位的文臣，也有其阴暗的一面。一方面，其受儒家思想的熏陶，守君子之道；一方面，出于求生的本能，又不得不干一些见不得人的事情，这种矛盾的心理，是万历年间群臣的内心写照。</p>
<p>所以，看待事情，我们不能只看其中的一面。看一个人，既不能因为片面的第一印象将其一棒子打死；也不能对一个人期望太高，人非圣贤，孰能无过？做人应当学习申时行，认识到有阳即有阴，然后去调和阴阳（做李老师和师弟师妹之间的调和者，哈哈），调和自己的内心，切不可走极端。</p>
<p>脱离社会是不可能的，单靠技术活一辈子也是不可能的，还是要学会一些阴阳之道，做人之法的。不要做一个绝对的“好人”。</p>
<h2 id="知其可为而为之知其不可而不为"><a class="header" href="#知其可为而为之知其不可而不为">知其可为而为之，知其不可而不为</a></h2>
<p>做人，最重要的是要有自知之明，然后就是事实就是。在万历年间的大环境下，诸如张居正的经济改革、海瑞的廉洁为公、李贽的标新立异，都是违背了历史的大环境。像申时行和戚继光懂得阴阳之道的人，才是识时务者。</p>
<h2 id="人不止有眼前路"><a class="header" href="#人不止有眼前路">人不止有眼前路</a></h2>
<p>“张居正的根本错误在自信过度，不能谦虚谨慎，不肯对事实作必要的让步”</p>
<p>战战兢兢，如临深渊，如履薄冰。</p>
<p>人活着，不止有眼前路，更要看的长远一些。张居正，戚继光，李贽等人在最后都没有落得好的下场，是因为他们在某些事情的时候并没有考虑后果和这些事情的深远影响。就像万历十五年前后发生的很多事情一样，看似一个很小的事情，甚至是一个小的决策，如果不加小心，就可能埋下了恶果。</p>
<h2 id="其他思考"><a class="header" href="#其他思考">其他思考</a></h2>
<h3 id="性本善恶"><a class="header" href="#性本善恶">性本善/恶？</a></h3>
<p>人本身就是一个矛盾的综合体，怎么可能只有一种？</p>
<h3 id="先富带动后富"><a class="header" href="#先富带动后富">先富带动后富？</a></h3>
<p>先富带动后富是不可能的，这不是政治经济问题，这是人性的问题。大多数富起来的人，是不会帮助穷人的，他们反而会巩固自己的富人阶级，与穷人划清界限。最简单的例子就是教育了，富人肯定不会让自己的孩子，和穷人的孩子上一样的学校。</p>
<h3 id="熵增与朝代的灭亡"><a class="header" href="#熵增与朝代的灭亡">熵增与朝代的灭亡</a></h3>
<p>一个朝代就是一个系统，如果这个朝代没有改革，没有创新，那么熵就会不断的增加，直到灭亡。</p>
<p>逆水行舟，不进则退，说的也是这个道理，就算止步不前，熵也会悄悄的增加。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-life-should-mean-to-you"><a class="header" href="#what-life-should-mean-to-you">What life should mean to you</a></h1>
<p>[TOC]</p>
<h2 id="读本书的目的"><a class="header" href="#读本书的目的">读本书的目的</a></h2>
<ul>
<li>暴露自身的缺点，追踪这些缺点形成的原因</li>
<li>明白如何教育一个孩子</li>
<li>与自己和解，提升自己</li>
</ul>
<h2 id="生活的意义"><a class="header" href="#生活的意义">生活的意义</a></h2>
<ul>
<li>由身体缺陷或其他原因所引起的自卑，有可能摧毁一个人，使人自甘堕落或发生精神病，但另一方面，也有可能使人发奋图强，力求振作，以补偿自己的弱点。（例如美国总统—富兰克林，这是生活的两面性，看你如何去看待这些困难）</li>
<li>每个人都努力地使自己变得重要，但是如果他不能认识到人类的重要性，使依赖他们对别人地生活所作出地共享而定地，那么他必定会踏上错误的道路。</li>
<li>生活的意义在于为团体贡献力量，在于为个人、为团体创造价值，做有价值的事情</li>
</ul>
<h2 id="行为和解释"><a class="header" href="#行为和解释">行为和解释</a></h2>
<table><thead><tr><th>行为</th><th>解释</th></tr></thead><tbody>
<tr><td>自闭/守旧</td><td>自卑</td></tr>
<tr><td>哭/尿床</td><td>寻求父母的注意力/驾驭父母</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="家庭教育"><a class="header" href="#家庭教育">家庭教育</a></h2>
<ul>
<li>
<p>经验在被接受之前，即已被预先做了解释，而这种解释又是依照最先赋予生活的意义进行的。即使这种意义一塌糊涂，即使这种处理问题和事物的方式会不断带来不幸和痛苦，它们也不会轻易地被放弃。只有重新审视造成这种错误解释的情境，找出谬误所在，并修正世界观，这种错误的生活意义才能被矫正过来</p>
<p>古话说：三岁定八十。我们看待这个世界，都是带着自己的经验，透过自己的有色眼镜去看的。</p>
</li>
<li>
<p>合作是婚姻的首要条件，恋爱也是。</p>
</li>
<li>
<p>不能过早的向孩子解释性，而是应该等孩子较为成熟、有自我保护意识的时候，再适当引导。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命理学"><a class="header" href="#命理学">命理学</a></h1>
<p>https://www.bilibili.com/video/BV1R54y1D7ic</p>
<h2 id="笔记"><a class="header" href="#笔记">笔记</a></h2>
<p>知止而后能定，定而后能静，静而后能安，安而后能虑，虑而后能得</p>
<h2 id="王德峰-中国古代命理学要义"><a class="header" href="#王德峰-中国古代命理学要义">王德峰-中国古代命理学要义</a></h2>
<p><strong>三本书</strong>：穷通宝鉴 滴天髓 三命通会</p>
<p>信力不信命？</p>
<p>人活着要有意义，follow excellence，success will follow you.</p>
<p>唐山大地震：国运大于个人的命运。</p>
<p>出生的位置不一样，也会影响一个人的命。</p>
<p>八字只能看 60 — 70%，看个大概。</p>
<p>五行学说基础（每一个国人都该会的）：</p>
<pre><code>五行：金木水火土
十天干：甲、乙、丙、丁、戊、己、庚、辛、壬、癸
十二地支：子、丑、寅(yín)、卯(mǎo)、辰、巳(sì)、午、未、申、酉、戌、亥

生：水 —— 木 —— 火 —— 土 —— 金 —— 水 
克：水 —— 火 —— 金 —— 木 —— 土 —— 水

天干与五行对应关系：
    甲乙 —— 木
    丙丁 —— 火
    戊己 —— 土
    庚辛 —— 金
    壬癸(gui) —— 水
    
地支与五行对应关系（地支有杂气，这里列举的是本气）：
	子 —— 水
	丑 —— 木
	寅 —— 木
	卯 —— 木
	辰 —— 土
	巳 —— 火
	午 —— 火
	未 —— 土
	申 —— 金
	酉 —— 金
	戌 —— 土
	亥 —— 水

北方属水-水地，南方属火-火地

五行与生活的关系（以土举例）：
	财(日主所克)：土克水(妻子水命最好)
	官(子女)：木克土(孩子木命最好)
	印(母亲)：火生土(母亲火命最好)
	
十神：
	生我者：
		正印：母亲
		偏印：母亲
	我生者：
		伤官：阳土生的阴金，有一定的才华，女命遇到伤官，是儿子
		食神：阳土生的阳金，有一定的才华，好美食，女命遇到食神，是女儿
	我克者：
        正财：阳克阴，阴克阳
        偏财：阳克阳，阴克阴
    克我者：
    	正官：男命的儿子
		偏官：男命的女儿，七煞，女命看到官就是看到丈夫
	同类：
        比肩：同类同性，兄弟姐们同事
        劫财：同类异性
        
六冲，六合，三合：
	六冲：子午(鼠马)相冲、丑未(牛羊)相冲、寅申(虎猴)相冲、卯酉(鸡兔)相冲、辰戌(龙狗)相冲、巳亥(蛇猪)相冲
	太岁：每一年的属相都叫太岁，如果与当前相冲，需要去拜太岁
	本命年要注意的属相：辰酉午亥
	
	三合：申子辰合、亥卯未合、寅午戍(虎马狗)合、已酉丑(蛇鸡牛)合
	六合：子丑(牛鼠)合，卯戌(兔狗)合，巳申(蛇猴)合，寅亥(虎猪)合，辰酉(龙鸡)合，午未(马羊)合 
	
排八字：
	年：
	月：
	日：
	时：

用神：找到让八字平衡的字

有大任的人，通常八字有缺陷

虚岁怎么算？出生算一岁，每过一个春节长一岁。
</code></pre>
<pre><code>八字举例：
	乙巳(年，幼年，祖上) 壬午(月，少年，父母) 壬戌(日，独立成家，自己家庭) 乙巳(时，万年，子女)
	
对应五行：
	木火 水火 水土 木火
	
八字分析：
	水命(八字的第五个)，五行缺金，火旺(土也强，火生土)，缺水
</code></pre>
<p>了解八字的基本状况，然后趋避。</p>
<img align="left" src="reading/books/assets/image-20210112213407353.png" alt="image-20210112213407353" style="zoom:50%;" />
<p>2021 是辛丑年，是金年</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="人类简史"><a class="header" href="#人类简史">人类简史</a></h1>
<p>由瓦尔-赫拉利</p>
<h2 id="冠状病毒之后的世界"><a class="header" href="#冠状病毒之后的世界">冠状病毒之后的世界</a></h2>
<p><a href="http://www.ruanyifeng.com/blog/2020/03/the-world-after-coronavirus.html">冠状病毒之后的世界</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="毛选"><a class="header" href="#毛选">毛选</a></h1>
<p>[TOC]</p>
<h2 id="第一卷"><a class="header" href="#第一卷">第一卷</a></h2>
<h3 id="中国社会各阶级的分析"><a class="header" href="#中国社会各阶级的分析">中国社会各阶级的分析</a></h3>
<p>1925 年</p>
<p><strong>谁是我们的敌人？ 谁是我们的朋友？</strong> </p>
<p>团结真正的朋友， 以攻击真正的敌人 。</p>
<p>中间阶级， 必定很快地分化。</p>
<p>小资产阶级。 如自耕农， 手工业主， 小知识阶层—— 学生界、中小学教员、小员司、小事务员、小律师， 小商人等都属于这一类 。</p>
<p>工业无产阶级人数虽不多， 却是中国新的生产力的代表者， 是近代中国最进步的阶级， 做了革命运动的领导力量。</p>
<p>工业无产阶级是我们革命的领导力量。 一切半无产阶级、 小资产阶级， 是我们最接近的朋友。 那动摇不定的中产阶级， 其右翼可能是我们的敌人， 其左翼可能是我们的朋友—— 但我们要时常提防他们， 不要让他们扰乱了我们的阵线。</p>
<p>我的思考：</p>
<p>多思考，看清事情的本质，再做判断。</p>
<h3 id="湖南农民运动考察报告"><a class="header" href="#湖南农民运动考察报告">湖南农民运动考察报告</a></h3>
<p>在农会威力之下，土豪劣绅们头等的跑到上海， 二等的跑到汉口， 三等的跑到长沙， 四等的跑到县城， 五等以下土豪劣绅崽子则在乡里向农会投降。</p>
<p>打翻这个封建势力， 乃是国民革命的真正目标。孙中山先生致力国民革命凡四十年， 所要做而没有做到的事，农民在几个月内做到了。</p>
<p>一切革命同志须知： 国民革命需要一个大的农村变动。 辛亥革命没有这个变动， 所以失败了。</p>
<p><strong>农民的眼睛，全然没有错的。</strong></p>
<p><strong>革命不是请客吃饭， 不是做文章， 不是绘画绣花， 不能那样雅致， 那样从容不迫， 文质彬彬， 那样温良恭俭让。 革命是暴动， 是一个阶级推翻一个阶级的暴烈的行动。</strong> 农村革命是农民阶级推翻封建地主阶级的权力的革命。 农民若不用极大的力量， 决不能推翻几千年根深蒂固的地主权力。 农村中须有一个大的革命热潮， 才能鼓动成千成万的群众， 形成一个大的力量。 上面所述那些所谓“过分”的举动， 都是农民在乡村中由大的革命热潮鼓动出来的力量所造成的。 这些举动， 在农民运动第二时期（革命时期） 是非常之需要的。 在第二时期内， 必须建立农民的绝对权力。 必须不准人恶意地批评农会。 必须把一切绅权都打倒， 把绅士打在地下， 甚至用脚踏上。 所有一切所谓“过分”的举动， 在第二时期都有革命的意义。 质言之， 每个农村都必须造成一个短时期的恐怖现象， 非如此决不能镇压农村反革命派的活动， 决不能打倒绅权。 矫枉必须过正， 不过正不能矫枉。</p>
<p>我的思考：</p>
<p><strong>中国革命的胜利，是农民的胜利，是农民的功劳。</strong></p>
<h3 id="实践论"><a class="header" href="#实践论">实践论</a></h3>
<p>**实践是检验真理的唯一标准。**是骡子是马，拉出来溜溜。</p>
<h2 id="语录"><a class="header" href="#语录">语录</a></h2>
<ul>
<li>事物总是要走向反面的，吹得越高，跌得越重，我是准备跌得粉碎的。那也没有什么要紧，物质不灭，不过粉碎罢了。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="天道"><a class="header" href="#天道">天道</a></h1>
<ul>
<li>男人和女人的对话方式，要么站着，要么躺着</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraylist-vs-linklist"><a class="header" href="#arraylist-vs-linklist">ArrayList-vs-LinkList</a></h1>
<p>[TOC]</p>
<h2 id="线性表和非线性表-1"><a class="header" href="#线性表和非线性表-1">线性表和非线性表</a></h2>
<p><strong>线性表</strong>：顺序表/链表/栈/队列</p>
<p><strong>非线性表</strong>：二叉树/图</p>
<p>线性表和非线性表的划分，是根据其逻辑来划分的，而不是根据其存储结构来划分的。每个线性表上的数据最多只有前后两个方向。</p>
<h2 id="顺序表与链表的区别"><a class="header" href="#顺序表与链表的区别">顺序表与链表的区别</a></h2>
<p><strong>最本质的区别</strong>：顺序表在内存是<strong>连续存储</strong>的，而链表在内存中是<strong>离散存储</strong>的。</p>
<p>其他所有的区别，都源于这个最本质的区别，由于顺序表是连续存储的，所以可以根据索引快速的进行查找，但是如果想要插入和删除，为了保持顺序表的连续性，部分元素就需要移位，而这正是链表所擅长的，链表的离散存储特性决定了其无法快速的查找，但是可以快速的进行插入/删除操作。</p>
<p>链表由于其需要另外开辟空间存储下一个节点的指针，所以其比顺序表要耗费更多的内存。并且由于链表的空间是离散分配的，在内存回收后，会产生更多的内存碎片，不方便利用。</p>
<p>线性表的使用场景更多一些，其相较于链表，更节省内存，而且可以借助 CPU 的缓存机制，加速线性表的访问速度。但是其缺点也很明显，其需要占用连续的存储空间，一旦申请的空间很大，就会导致申请失败；另外，如果申请的空间不够用，那么就得向操作系统申请一个更大的连续空间，然后将顺序表中的内容 copy 过去，而 copy 的操作是非常耗时的。</p>
<h2 id="例题分析"><a class="header" href="#例题分析">例题分析</a></h2>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/%3E">palindrome-linked-list</a></p>
<ul>
<li>解法一：将链表的数据 copy 到数组中解决</li>
<li>解法二：头插法(逆序)新建一个链表，然后等值匹配</li>
</ul>
<p>两者的时间复杂度相同，都是 O(n)，但是空间复杂度，差距特别大，采用新建链表的方式，其耗费了 12.6M 的内存，比解法一多用 1MB 的内存，这说明，链表的指针，是比较耗费内存的，同样的需求，还是优先考虑用顺序表实现。</p>
<p>该题的最佳空间复杂度是 O(1)，以上的两个解法，实际上是在拿空间复杂度换取时间复杂度。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信息熵"><a class="header" href="#信息熵">信息熵</a></h1>
<h2 id="直觉与信息"><a class="header" href="#直觉与信息">直觉与信息</a></h2>
<h3 id="一个实际问题"><a class="header" href="#一个实际问题">一个实际问题</a></h3>
<p>一个程序更新要上线 8 个机房，其中有一个是用来做 分级发布 的机房，剩余 7 个是服务线上的机房，简称线上机房。一个程序包中有8个配置文件，分别对这8个机房进行了配置。由于分级机房前期不够重视，导致分级的配置文件中，很多配置没有及时和其他机房同步，现在需要 diff 分级机房的配置文件和其他 7 个线上机房的配置文件，然后找出 分级机房中没有及时同步的配置。我们定下规则，只要有一个线上机房的conf值与分级机房的 conf 值相同，那么就默认分级机房的值与线上机房的值是同步的。下面举几个例子：
如图，我们可以看到，对于大多数的 conf，分级机房的值和所有线上机房的值都相同，diff_result 设置为 Y；</p>
<p><img src="computer-science-notebook/algorithms/assets/1539159702572.png" alt="1539159702572" /></p>
<p>之前已经说过，只要 分级 机房的 conf 值在其他机房中存在，那么就默认分级机房该值与线上机房同步。那么，如果分级机房的 conf 值不在其他机房中呢？我们来看下一个例子：</p>
<p><img src="computer-science-notebook/algorithms/assets/1539159712909.png" alt="1539159712909" /></p>
<p>线上机房的值都是 OFF，只有分级机房的值是 ON，那么显然，分级机房的值并没有和线上机房同步，diff_result 为 N。
还有一种情况没有考虑，虽然分级机房的值并不在线上机房，但是每个线上机房的值都是不同的，或者大多数线上机房的值都是不同的，例如：</p>
<p><img src="computer-science-notebook/algorithms/assets/1539159723463.png" alt="1539159723463" /></p>
<p>分级机房 wiseus_rtimeout 的值为 6200，与其他线上机房的值都不相同，而且所有线上机房的 wise_rtimeout 的值基本上都不相同，这种情况，就可以认为每个机房都有自己的特有配置，所有分级机房的值也是合理的，与线上机房的同步的，diff_result 为 Y。而如果大多数线上机房的值都相同，那么分级机房就可能与线上机房不同步，如下图所示，分级机房的值是 6200，而其他大多数线上机房的值都是 6000，只有一个线上机房的值为 5900.我们直观的感觉到：大多数线上机房的值都是相同的，只有分级机房的值例外，那么分级机房的值可能就没有和线上机房同步，diff_result 标记为 N</p>
<p><img src="computer-science-notebook/algorithms/assets/1539159736592.png" alt="1539159736592" /></p>
<p>事实上，上面这个问题可以抽象成如下一个数学问题：
给定一个固定长度（不妨设置长度为8，8个线上机房）的列表 L，列表中的字符串是任意值的。现在有一个字符串 S（一个分级机房）要和列表中的 8 个字符串进行比较，看看 S 与列表中的字符串是否存在diff，diff规则如下：
如果存在列表 L 中的值与 S 值相同，那么 S 与 L 无 diff
如果 S 值不存在于 L 中，那么就要看 L 中值的混乱度，如果 L 中值的混乱度越大，那么 L 中的值大多数都是互不相同的，那么可以认为 S 与 L 无 diff，如果 L 中的值大多数都是相同的，那么 S 与 L 就是有 diff 的。
现在问题来了，如何来衡量数组 L 的混乱度呢，如何来计算这种靠感觉一眼就可以分辨的混乱度呢？</p>
<h3 id="信息熵-1"><a class="header" href="#信息熵-1">信息熵</a></h3>
<p>为了更深刻的理解这个问题，我们把问题再抽象一点，并尝试在举一些例子，寻找解题思路。
我们以一个长度为 8 的列表举例，分别用 8 个数（1—8）来表示 8 个可能装入该列表的数字。</p>
<p><img src="computer-science-notebook/algorithms/assets/1539159779823.png" alt="1539159779823" /></p>
<p>到了这一步，我们已经看到，靠硬编码似乎并不能量化直觉，也就是靠硬编码似乎不能衡量列表的混乱度。
这个时候，我联想到了在《数学之美》上读过的信息熵算法，熵是一个系统的混乱度，熵越大，系统越混乱，从信息论角度上讲，熵就是信息量，即混乱度就是信息熵。列表内的元素越混乱，说明该列表传递的信息量越大。这与我们的直觉正好符合，如果列表内的所有值都相同，那么该列表就是有序的，其传递的信息就很少，如果列表内的值互不相同，那么此时的列表就最混乱，其信息量也最大。
在上图中，我已经算出了每一个情况的信息熵，第一个列表最混乱，其信息熵也最大，同时 3 也是最大信息量；随着列表变得有序，信息熵也在逐渐变小。最后再比较一下最后两个列表，如果按照之前提出的算法，根据列表中互不相同的元素的个数，来衡量列表的混乱度，那么这两个列表的混乱度是一样的（都是3），但是直觉告诉我们，最后一个列表明显更混乱，而信息熵确实反映出了这个差别（最后一个列表的信息熵稍大）。
如此，将一个实际问题抽象成 混乱度的衡量，再将混乱度与信息熵挂钩，实现了数学建模。</p>
<h3 id="几点感悟"><a class="header" href="#几点感悟">几点感悟</a></h3>
<p><strong>直觉</strong>
对于一个问题，如果用硬编码的方式很难编码，而靠直觉，又很容易解决，那么可以往信息论、概率论和数理统计上多想想
<strong>建模的步骤</strong>
对于一个实际问题的解决，往往要先把该问题转换成一个数学问题（将问题转换成列表混乱度的衡量），然后再针对这个数学问题，找对应的解决方法
<strong>读研的意义</strong>
当我看到我的本科同学在群里讨论各种技术难题，当我来百度后发现很多双非学校的学生技术比我还要好的时候，我都会有点怀疑读研的价值。但是，值得欣慰的是，考研和读研的这段时间，我总会有一些意外的收获，让我感觉，读研是很有意义的。例如这一次利用信息论来解决问题，这是我第一次用在学校科研学到的知识来解决实际的问题，单纯的学技术，对信息熵没有进行深入研究的人，是很难想到用这个方法来解决问题的。读研还是很有意义的， 虽然短期来看收益不是很大，但是它总会时不时的给我一个惊喜，而这份惊喜，就是读研最好的馈赠。
<strong>如何学习算法</strong>
学习算法的意义在于运用，在于遇到实际问题时能想到用某个算法来解决。想要灵活运用某种算法，就要深刻了解该算法的本质，该算法的推导和来龙去脉。学习算法，在质而不在量，吃透一种算法，比蜻蜓点水地看十种算法，要有用的多。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>[TOC]</p>
<h2 id="解题思路-1"><a class="header" href="#解题思路-1">解题思路</a></h2>
<p>拿到一个问题，我们的解题步骤可以归纳为：</p>
<ol>
<li>
<p><strong>审题</strong></p>
<ol>
<li>
<p>归纳出题目的特点，确定使用的数据结构</p>
</li>
<li>
<p>从该数据结构的特点出发，结合题目的特点，寻找算法思路</p>
<p>例如将<strong>顺序表</strong>进行<strong>逆</strong>置的问题，审题后，关键词是 顺序表 和 逆。顺序表就要想到根据 index 在 $O(1)$ 时间内获取值和长度已知的特性；逆置就要想到栈的特性。</p>
<p>还要考虑，是对时间复杂度要求高，还是空间复杂度要求高。</p>
</li>
</ol>
</li>
<li>
<p><strong>编码</strong></p>
<ol>
<li>返回值是什么？</li>
<li>输入输出是什么？</li>
<li>考虑边界</li>
<li>……</li>
</ol>
</li>
</ol>
<h3 id="arraylist-1"><a class="header" href="#arraylist-1">ArrayList</a></h3>
<ul>
<li><strong>位置互换</strong>，利用 index 进行<strong>逆置</strong></li>
</ul>
<h3 id="linklist-1"><a class="header" href="#linklist-1">LinkList</a></h3>
<ul>
<li><strong>头插法</strong>逆置单链表</li>
<li><strong>快慢指针</strong></li>
<li>链表节点最有价值的是<strong>节点值</strong>，而不是整个节点，这是个可以变通的地方，在不依赖前驱节点删除链表节点的时候，就用到了这个思想</li>
<li>链表真正可以有所作为的地方，在于链表的<strong>头部</strong>，链表头部的操作，复杂度最低</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zen-of-db"><a class="header" href="#zen-of-db">Zen-of-DB</a></h1>
<p>[TOC]</p>
<h2 id="zens"><a class="header" href="#zens">Zens</a></h2>
<h3 id="simplify-move-code-into-database-functions"><a class="header" href="#simplify-move-code-into-database-functions"><a href="https://sivers.org/pg">Simplify: move code into database functions</a></a></h3>
<p>将计算迁移到数据库端。</p>
<h2 id="数据库工具"><a class="header" href="#数据库工具">数据库工具</a></h2>
<ul>
<li>Navicat: 收费</li>
<li>DBeaver: 开源，功能强大</li>
<li>建模工具：PDMan</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-入门"><a class="header" href="#mysql-入门">Mysql 入门</a></h1>
<p>[TOC]</p>
<h2 id="经验总结"><a class="header" href="#经验总结">经验总结</a></h2>
<ul>
<li>多表连接查询是一个特别耗时的操作，涉及到笛卡尔积</li>
<li>varchar varchar 用来存储变长的字符串。varchar 可以节省空间，存入多少个字符（ASCII）字符，就占用多少字节的空间。MySQL4.1 之前，varchar所支持的最大长度为 255 个字符，MySQL5.0 以上的版本能够存储 65535个字节，utf8编码下，最多存储21843个字符</li>
<li>使用 Mysql 进行项目优化 对于一个负载很大的线上系统，是很怕慢查询的，一个原则：<strong>把更多的计算放在本地，而不是放在数据库。</strong>，例如，宁愿进行两次单表数据库，然后在本地处理数据，也不要进行联合查询。</li>
</ul>
<h2 id="数据库名词解释"><a class="header" href="#数据库名词解释">数据库名词解释</a></h2>
<ul>
<li>DBA: Database Administrator</li>
<li>数据库与文件的本质区别 db 实现了整体数据的结构化，体现了数据之间的相关性。</li>
<li>域 Domain 属性的取值范围</li>
<li>候选码 和 主键 能够唯一标识一个元组的属性组（如果属性组只有一个属性，那么该属性就是 主键）</li>
<li>E-R 图 Entity-Relationship</li>
<li>关系数据模型 1. 实体和实体间的联系都用 表 来表示（学生是一张表、课程也是一张表，学生与课程的选课关系也是一张表） 2. 关系数据模型最大的缺点是利用 SQL 语句隐藏了数据存取的细节，所以查询效率需要优化，所以才会有 高效 SQL 这门学问 3. 在关系模型中，现实世界中的实体和实体之间的联系都可以用 关系 来描述 4. 关系实质上就是一张二维表，表的每行为一个元组，每列为一个属性。一个元组就是该关系所设计的属性集的笛卡尔积的一个元素。其实也就是学生表与课程表做笛卡尔积得到的一个子集，称为表。一张关系表就是两个实体的笛卡尔积的子集。</li>
<li>关系的三种类型 1. 基本表：数据库中实际存在的表 2. 查询表：SQL 查询结果 3. 视图表：由基本表或其他视图导出的表，是虚表</li>
<li>关系的完整性约束条件 1. 实体完整性（Entity Integrity）若某属性 A 是关系 R 的主属性，那么 A 非空。（主键 非空） 2. 参照完整性（Referential Integrity）某一张表中的某个属性的取值参考 另一张表中的主键 （表中的某一属性参照另一张表中的主键） 3. 用户定义完整性</li>
<li>关系运算 1. 选择：从关系 R （表）中选择满足给定条件的元组 2. 投影：选择若干属性列组成新的关系 3. 连接：对两张表进行笛卡尔积，选择满足条件的元组构成新表 4. 除：待学习</li>
<li>参照完整性规则 如果表 A 中的属性 S 是外键，参考了 表B 中的 S 属性，属性 S 的取值要么为空，要么来源应该来源于 表 B中的 S 属性的所有值。</li>
</ul>
<h2 id="mysql-配置文件"><a class="header" href="#mysql-配置文件">MySQL 配置文件</a></h2>
<p>通过 <code>apt-get install mysql-server</code> 命令安装的 MySQL，其配置文件默认为 <code>/etc/mysql/my.cnf</code>。</p>
<p><code>/etc/mysql/my.cnf</code> 是一个全局配置文件，如果我们想要面向不同的用户进行不同的配置，需要把全局配置文件拷贝到 <code>~/.my.cnf</code>并进行配置。</p>
<p>注意</p>
<ol>
<li>所有的配置文件，都需要以 <code>.cnf</code> 结尾</li>
<li>全局配置文件中，还包含了两个文件夹，在该两个文件夹内的所有 .cnf 文件都是配置文件，其中 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>中存储了大量的 MySQL 配置</li>
</ol>
<pre><code class="language-text">#
# The MySQL database server configuration file.
#
# You can copy this to one of:
# - &quot;/etc/mysql/my.cnf&quot; to set global options,
# - &quot;~/.my.cnf&quot; to set user-specific options.
# 
# One can use all long options that the program supports.
# Run program with --help to get a list of available options and with
# --print-defaults to see which it would actually understand and use.
#
# For explanations see
# http://dev.mysql.com/doc/mysql/en/server-system-variables.html

#
# * IMPORTANT: Additional settings that can override those from this file!
#   The files must end with '.cnf', otherwise they'll be ignored.
#
# 
!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/
</code></pre>
<h2 id="mysql-小知识"><a class="header" href="#mysql-小知识">MySQL 小知识</a></h2>
<ol>
<li>
<p>默认端口号：3306</p>
</li>
<li>
<p>SQL 语句最后要加 ;</p>
</li>
<li>
<p>注释：</p>
<p>单行注释：--</p>
<p>多行注释：/ __/</p>
</li>
</ol>
<h2 id="数据库增删改查"><a class="header" href="#数据库增删改查">数据库增删改查</a></h2>
<ul>
<li>创建数据库 create database senti_weibo DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</li>
<li>更改数据库字符集 ALTER DATABASE <code>senti_weibo</code> CHARACTER SET utf8 COLLATE utf8_general_ci;</li>
<li>查看所有数据库 show databases;</li>
<li>查看某个数据库建库语句 show create database db_name; 或者 <code>desc table</code></li>
<li>查看某张表的建表语句 show create table table_name;</li>
<li>删除数据库 drop database db_name;</li>
<li>进入某个数据库 use db_name;</li>
<li>查看某个数据库中的表的情况 select table_name from information_schema.tables where table_schema='csdb' and table_type='base table';</li>
<li>查看某个数据库的表的信息 show tables;</li>
</ul>
<h2 id="数据库表级别操作"><a class="header" href="#数据库表级别操作">数据库表级别操作</a></h2>
<h3 id="查看表"><a class="header" href="#查看表">查看表</a></h3>
<pre><code class="language-text">show tables;
</code></pre>
<h3 id="表重命名"><a class="header" href="#表重命名">表重命名</a></h3>
<pre><code class="language-text">RENAME TABLE old_table TO new_table;
</code></pre>
<h3 id="删除表"><a class="header" href="#删除表">删除表</a></h3>
<pre><code class="language-text">drop table table_name;
</code></pre>
<h3 id="复制表"><a class="header" href="#复制表">复制表</a></h3>
<p><strong>参考</strong></p>
<p><a href="https://www.cnblogs.com/zhangjpn/p/6231662.html">https://www.cnblogs.com/zhangjpn/p/6231662.html</a></p>
<p><a href="https://www.jb51.net/article/47562.htm">https://www.jb51.net/article/47562.htm</a></p>
<p><strong>Demo</strong></p>
<pre><code class="language-mysql"># 把旧表的所有数据复制到新表
insert into table1 select * from table2
# 复制旧表的部分数据到新表
insert into table1 select  *   from   table2 where ……

# 复制表结构到新表
CREATE TABLE 新表 LIKE 旧表 ;
# 复制表结构和所有数据到新表
CREATE TABLE 新表 SELECT * FROM 旧表
# 复制旧表的数据到新表(假设两个表结构不一样)
INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表
</code></pre>
<h3 id="导出-mysql-查询到的数据"><a class="header" href="#导出-mysql-查询到的数据">导出 MySQL 查询到的数据</a></h3>
<pre><code class="language-shell">mysql -uroot -pxxxxxx -e &quot;select weibo_content from spider_db.spider_realtime_weibo&quot; &gt; /home/admin/test/weibo_content.txt
</code></pre>
<h3 id="表添加删除修改字段"><a class="header" href="#表添加删除修改字段">表添加/删除/修改字段</a></h3>
<pre><code class="language-mysql">-- 增加字段
alter table senti_weibo_realtime_weibo add seged_words varchar(4096) COLLATE utf8mb4_unicode_ci DEFAULT &quot;&quot;;
alter table senti_weibo_keyword add sentiment varchar(32) DEFAULT &quot;&quot;;

-- 修改字段
alter table senti_weibo_realtime_weibo modify last_modify_time timestamp not null default current_timestamp on update current_timestamp;

-- 删除字段
ALTER TABLE mytable DROP 字段名;

-- 修改字段的编码和排序规则（配置字段内容大小写敏感） CHARSET is a synonym for CHARACTER SET，COLLATE 用来指定排序字符集
ALTER TABLE users modify name varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '用户登录名';
</code></pre>
<h3 id="修改表的编码"><a class="header" href="#修改表的编码">修改表的编码</a></h3>
<pre><code class="language-mysql">alter table spider_realtime_weibo character set utf8 COLLATE utf8_general_ci;
</code></pre>
<h2 id="数据库-表数据-增删改查"><a class="header" href="#数据库-表数据-增删改查">数据库-表数据-增删改查</a></h2>
<h3 id="查询数据"><a class="header" href="#查询数据">查询数据</a></h3>
<pre><code class="language-Mysql">* distinct
distinct 只能放在开头
通常的用法是 distinct(name)，加 括号
如果 distinct 没有加括号，则默认对（所有的字段放在一起）进行去重
sql = &quot;&quot;&quot;select distinct product_line, deploy_plat,
         source, module, 1 as callednum
         from %s
         where source != &quot;sample&quot;
         and idc != &quot;sample&quot;
         and idc != &quot;se-offline&quot;
         and idc != &quot;ipad_page&quot;
         and idc != &quot;debug&quot;
         and deploy_plat != &quot;dfp&quot;
         &quot;&quot;&quot; % (table)

* distinct，count 组合
select count(DISTINCT(username)) as count1 from managerConfig_online ; # count1 为 重新命名

* 模糊匹配
url like '%.baidu.com'
% 类似于 正则表达式中的 .*
Demo:
select problem_occur_time, problem_solve_time from feedbackorigindata where problem_occur_time &gt; problem_solve_time and problem_solve_time like &quot;%2018-%&quot;;

* or 关键字
select * from managerConfig where username = 'v_liulonggang' or username = 'v_zhangyafei';

* in 关键字
in 关键字可以替换 or 关键字的作用，而且更加简洁。
select 
 count(DISTINCT(module)) 
from 
 run_case_deploycoveragedetail 
where 
 is_coverage in (&quot;Y&quot;, &quot;N&quot;, &quot;W&quot;) and 
 query_start_time &gt;= &quot;2018-07-01 00:00:00&quot; and 
 query_end_time &lt;= &quot;2018-07-31 00:00:00&quot; and 
 deploy_plat = '863';

* select 子句 嵌套查询
select mailbox_id from co_user where mailbox_id not in (select mailbox_id from core_mailbox);

* 按字段进行排序
select icafe_id from feedbackorigindata where product_id = 1 and subproduct_id = 'all' and space = 'http://cp01-sys-rpm66.cp01.baidu.com:8235/getFeedback.php' order by icafe_id desc ;
默认 对 结果 升序排序，加了 **desc** 后，则改成降序排序。

* rand() 函数随机选择条数
需求：从数据库中读取 1000 条数据，要求这 1000 条数据是随机选择的，
SELECT * FROM tablename ORDER BY RAND() LIMIT num；

-- limit offset 关键字
-- Limit子句可以被用于强制 SELECT 语句返回指定的记录数。Limit接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。
-- 注意：
-- 1. limit 要在 offset 前面，如果颠倒了，会出现语法错误
-- 2. offset 不能单独使用，要配合 limit 一起使用，limit 可以单独使用 https://stackoverflow.com/questions/255517/mysql-offset-infinite-rows
SELECT * FROM table LIMIT 5; //检索前 5 个记录行
SELECT * FROM table LIMIT 5,10; //检索记录行6-15 从第六行开始检索
SELECT * FROM table LIMIT 10 offset 5; //检索记录行6-15 从第六行开始检索，跳过前5 行

* group by， having
group by 将结果按照指定的列进行分组，该属性列值相等的元组为一个组。通常会在每组中运行聚集函数进行计算。
group by 的 select 中字段的选择，应该选择 group by x1,x2,x3 中的 x1, x2, x3 中的子集。例如 group by product_line, deploy_plat, source, module ，那么 只能 select 其中的子集。
selet 后面还可以加入聚集函数，例如 count(*), min(*) 等。例如 select group by product_line, deploy_plat, source, module, count(*)。
having 是 group by 的子句，表示只有满足指定条件的组才予以输出
注意 groupby 并没有删除数据，只是将查询到的数据进行分组。

* 嵌套查询
将第一次查询的结果当作一张表进行二次查询。可多层嵌套。
select 
 run_id, module, source, idc, status, reason, times 
from 
 (
  select 
   *, count(DISTINCT run_id, task_type, task_id, execute_id)
  from 
   run_case_detail
  where 
   run_id &gt;= &quot;20180717000000000000&quot; and run_id &lt;= &quot;20180725000000000000&quot;
  group by 
   run_id, task_type, task_id, execute_id
 ) 
 as 
 distinct_data
where 
 product_line = &quot;search&quot; and 
 product_form = &quot;wise&quot; and 
 source != &quot;sample&quot; and 
 (idc != &quot;se-offline&quot; and idc != &quot;template&quot; and idc != &quot;ipad_page&quot;) and
  module != &quot;debug&quot;
;
</code></pre>
<h3 id="插入数据"><a class="header" href="#插入数据">插入数据</a></h3>
<pre><code class="language-Mysql">全插入
insert into userInfo values(1,'aaa','1212');
指定列插入（推荐这种方式）
insert into userInfo(name,password) values('ddf','8979');

* 自增长主键插入数据
当数据表中有自增长主键时，当用SQL插入语句中插入语句带有ID列值记录的时候，有两种做法：
1. 指定了该列的值，则新插入的值不能和已有的值重复，而且必须大于其中最大的一个值；
2. 不指定该列的值，只将其他列的值插入，让ID还是按照MySQL自增自己填，有两种做法：
    1. 把id的值设置为null或者0，这样子mysql都会自己做处理 
    2. 手动指定需要插入的列，不插入这一个字段的数据

手动制定需要插入的列，这种方式比较好，如果后来表发生了变化，这个 insert 语句还是可以用的！
insert into userInfo(name,password) values('wanshuo','8979');

# 不重复插入：主键存在则不插入
insert ignore into res_entity_item values(&quot;55&quot;, &quot;111&quot;, &quot;2021-01-01 00:00:00&quot;, &quot;desc&quot;, &quot;expression&quot;, &quot;8&quot;, &quot;2021-01-01 00:00:00&quot;, &quot;test_name&quot;);
</code></pre>
<h3 id="删除数据"><a class="header" href="#删除数据">删除数据</a></h3>
<pre><code class="language-sql">-- 标准代码
delete from run_case_deploycoveragedetail where query_start_time like '2018-07-15%';
</code></pre>
<h3 id="更新数据"><a class="header" href="#更新数据">更新数据</a></h3>
<pre><code class="language-sql">-- set 是一个固定的关键字
update run_case_statistics set cycle = 'month', module = 'module1' where id &gt;= 5927 and id &lt;= 6265;

-- 多表关联更新
update test1,test2 set test1.name=test2.name,test1.age=test2.age where test1.id=test2.id;

</code></pre>
<h3 id="建表"><a class="header" href="#建表">建表</a></h3>
<pre><code class="language-sql"># 测试代码
create table test_table(
    id int(11) primary key,
    name varchar(8) unique
);

* 重点    
if not exists
可以先判断表是否存在

varchar(n)
设置变长字符，最大长度为 n，有多长，就动态的占用多大的空间
n 在 MySQL 4.1 版本下，最长可以达到 255。
varchar 写越大越好，否则会报 Data truncated for column 'module_detail' at row 1 错，后期各种心累。

varchar 长度计算：https://www.cnblogs.com/jewave/p/6214540.html

KEY
Key是索引约束,主要是用来加快查询速度的

COMMENT
字段注释

AUTO_INCREMENT
只适用于 int 字段，MySQL 会自动生成

default
default 'wanshuo'
使用 DEFAULT 修饰符为字段设定一个默认值，如果没有设置default，那么 MySQL 会根据该字段是 NULL 还是 NOT NULL 自动设置默认值

* desc 命令
查看表中各个字段的描述
desc 表名
</code></pre>
<p>mysql 建表数据类型</p>
<p>包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION),还有枚举类型enum 和集合类型set 以及布尔值、<a href="https://www.yiibai.com/mysql/boolean.html">json</a></p>
<h4 id="数值数据"><a class="header" href="#数值数据">数值数据</a></h4>
<table><thead><tr><th style="text-align: left">型</th><th style="text-align: left">大小</th><th style="text-align: left">范围（有符号）</th><th style="text-align: left">范围（无符号）</th><th style="text-align: center">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">TINYINT</td><td style="text-align: left">1 byte</td><td style="text-align: left">(-128，127)</td><td style="text-align: left">(0，255)</td><td style="text-align: center">小整数值</td></tr>
<tr><td style="text-align: left">SMALLINT</td><td style="text-align: left">2 bytes</td><td style="text-align: left">(-32 768，32 767)</td><td style="text-align: left">(0，65 535)</td><td style="text-align: center">大整数值</td></tr>
<tr><td style="text-align: left">MEDIUMINT</td><td style="text-align: left">3 bytes</td><td style="text-align: left">(-8 388 608，8 388 607)</td><td style="text-align: left">(0，16 777 215)</td><td style="text-align: center">大整数值</td></tr>
<tr><td style="text-align: left">INT或INTEGER</td><td style="text-align: left">4 bytes</td><td style="text-align: left">(-2 147 483 648，2 147 483 647)</td><td style="text-align: left">(0，4 294 967 295)</td><td style="text-align: center">大整数值</td></tr>
<tr><td style="text-align: left">BIGINT</td><td style="text-align: left">8 bytes</td><td style="text-align: left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align: left">(0，18 446 744 073 709 551 615)</td><td style="text-align: center">极大整数值</td></tr>
<tr><td style="text-align: left">FLOAT</td><td style="text-align: left">4 bytes</td><td style="text-align: left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align: left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align: center">单精度 浮点数值</td></tr>
<tr><td style="text-align: left">DOUBLE</td><td style="text-align: left">8 bytes</td><td style="text-align: left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align: left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align: center">双精度 浮点数值</td></tr>
<tr><td style="text-align: left">DECIMAL</td><td style="text-align: left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align: left">依赖于M和D的值</td><td style="text-align: left">依赖于M和D的值</td><td style="text-align: center">小数值</td></tr>
</tbody></table>
<h4 id="时间和日期类型"><a class="header" href="#时间和日期类型">时间和日期类型</a></h4>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">大小 ( bytes)</th><th style="text-align: left">范围</th><th style="text-align: left">格式</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">DATE</td><td style="text-align: left">3</td><td style="text-align: left">1000-01-01/9999-12-31</td><td style="text-align: left">YYYY-MM-DD</td><td style="text-align: left">日期值</td></tr>
<tr><td style="text-align: left">TIME</td><td style="text-align: left">3</td><td style="text-align: left">'-838:59:59'/'838:59:59'</td><td style="text-align: left">HH:MM:SS</td><td style="text-align: left">时间值或持续时间</td></tr>
<tr><td style="text-align: left">YEAR</td><td style="text-align: left">1</td><td style="text-align: left">1901/2155</td><td style="text-align: left">YYYY</td><td style="text-align: left">年份值</td></tr>
<tr><td style="text-align: left"><strong>DATETIME</strong></td><td style="text-align: left">8</td><td style="text-align: left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align: left">YYYY-MM-DD HH:MM:SS</td><td style="text-align: left">混合日期和时间值</td></tr>
<tr><td style="text-align: left">TIMESTAMP</td><td style="text-align: left">4</td><td style="text-align: left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align: left">YYYYMMDD HHMMSS</td><td style="text-align: left">混合日期和时间值，时间戳</td></tr>
</tbody></table>
<h4 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h4>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">大小</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">CHAR</td><td style="text-align: left">0-255 bytes</td><td style="text-align: left">定长字符串</td></tr>
<tr><td style="text-align: left">VARCHAR</td><td style="text-align: left">0-65535 bytes</td><td style="text-align: left">变长字符串</td></tr>
<tr><td style="text-align: left">TINYBLOB</td><td style="text-align: left">0-255 bytes</td><td style="text-align: left">不超过 255 个字符的二进制字符串</td></tr>
<tr><td style="text-align: left">TINYTEXT</td><td style="text-align: left">0-255 bytes</td><td style="text-align: left">短文本字符串</td></tr>
<tr><td style="text-align: left">BLOB</td><td style="text-align: left">0-65 535 bytes</td><td style="text-align: left">二进制形式的长文本数据 binary large object</td></tr>
<tr><td style="text-align: left">TEXT</td><td style="text-align: left">0-65 535 bytes</td><td style="text-align: left">长文本数据</td></tr>
<tr><td style="text-align: left">MEDIUMBLOB</td><td style="text-align: left">0-16 777 215 bytes</td><td style="text-align: left">二进制形式的中等长度文本数据</td></tr>
<tr><td style="text-align: left">MEDIUMTEXT</td><td style="text-align: left">0-16 777 215 bytes</td><td style="text-align: left">中等长度文本数据</td></tr>
<tr><td style="text-align: left">LONGBLOB</td><td style="text-align: left">0-4 294 967 295 bytes</td><td style="text-align: left">二进制形式的极大文本数据</td></tr>
<tr><td style="text-align: left">LONGTEXT</td><td style="text-align: left">0-4 294 967 295 bytes</td><td style="text-align: left">极大文本数据</td></tr>
</tbody></table>
<h3 id="sql-查询-demos"><a class="header" href="#sql-查询-demos">SQL 查询 demos</a></h3>
<pre><code class="language-sql">-- 查询学生的姓名和出生年份
select name, 2018 - age from student_table;

-- 改变列名, 改为小写 lower()
select lower(name) studentname from student_table;

-- between and 
select name from student_table where age between 18 and 23;

-- 匹配任意 长度 字符 和 任意 单个 字符
select name from student_table where name like &quot;王%&quot;;
select name from student_table where name like &quot;万__&quot;； -- 查询三个字的万同学

-- 需要转义的字符
%, _
select name from student_table where name = &quot;王\_&quot;; -- 查是否有人叫 王_

-- is null
select name from student_table where grade is null;

-- 对查询结果两个字段进行排序，前者升序，后者降序
select * from student_table order by dept, age desc; -- 按系名升序，age 降序

-- 聚集函数
count 统计元组个数
sum(列名) 计算列值总和
avg(列名) 计算平均值
max/min(列名) 找到最值

-- 求各个课程号及对应的选课人数 group by
select Cno, count(Sno) from SC group by Cno;

-- group by having demo: 查询选修了三门以上课程的学生学号
select Sno from SC group by Sno having count(*) &gt; 3; -- having 仅作用于group by 生成的组

-- group by 查询举例
    select 
     product_line, 
     deploy_plat,
     source, 
     module, 
     count(*)
    from 
     run_case_deploy
    where 
     source != &quot;sample&quot;
     and idc != &quot;sample&quot;
     and idc != &quot;se-offline&quot;
     and idc != &quot;ipad_page&quot;
     and idc != &quot;debug&quot;
     and start_time &gt;= '2018-08-13 00:00:00'
     and end_time &lt;= '2018-08-14 00:00:00'
     and deploy_plat != &quot;dfp&quot;
    group BY
     product_line, 
     deploy_plat,
     source, 
     module
    ;

-- 自身连接查询
select first.Cno, second.Cpno from Course first, Course second where first.Cpno = second.Cno;

-- 左外连接
select student, sno, sname, sex from student_table left out join sc_table on (student_table.sno = sc_table.sno);

-- 不相关子查询（不相关嵌套查询）
查询与 万朔 同系的学生
select id from student_table where department in (select department from student_table where name ='万朔');

-- 相关嵌套查询
找出每个学生超过他选修课程平均成绩的课程号
select student_id, course_id from score_table table1 where grade &gt;= (select avg(grade) from score_table table2 where table1.student_id = table2.student_id);

-- any, all
查询其他系中，比计算机科学系所有学生年龄都小的学生姓名和年龄。
select name, age from student_table where age &lt; all (select age from student_table where department = 'cs') and department != 'cs';

-- exists 存在量词
查询所有选修了 1 号 课程的学生姓名。
select name from student_table where exists (select * from xuanxiu_table where name = student_table.name and xuanxiu_course = '1')
存在量词的嵌套查询中 一定是 select *，如果内层查询结果非空，那么外层的 where 子句返回真值。
exists 一定是相关子查询。

    select 
     DISTINCT deploy_plat, module 
    from 
     run_case_deploycoveragedetail detail_1 
    where 
     exists (
      select 
       * 
      from 
       run_case_deploycoveragedetail detail_2 
      where 
       detail_1.module = detail_2.module and 
       is_coverage = &quot;Y&quot; and
       idc = &quot;&quot;
     ) and 
     idc = &quot;fj&quot; and 
     is_coverage = &quot;N&quot;;

-- 多个查询结果的并集和差集 union， Intersect
select name from student_table where sex = '男' and age &gt; 18
union / intersect
select name from student_table where sex = '女' and age &gt; 18;
# 适用于将多表查询的结果整合
</code></pre>
<h2 id="show-命令"><a class="header" href="#show-命令">show 命令</a></h2>
<pre><code class="language-mysql">-- 显示 MySQL 的当前状态
show status;

-- 显示某张表的所有字段
show columns from table;

-- 显示授予某个用户的权限
show grants user_name;
show grants; -- 所有用户

-- 查看错误和警报
show errors;
show warnings;
</code></pre>
<h2 id="连接-join"><a class="header" href="#连接-join">连接 join</a></h2>
<p>连接 涉及到了 多表操作，也可以是 pandas 的多个 DataFrame 的操作。 连接 是从两个关系的 <strong>笛卡尔积</strong> 中选取 <strong>属性间满足一定条件</strong> 的元组。</p>
<p>其中 A 和 B 分别 为 R 和 S 上度数相等并且可比的属性组。连接运算从 R 和 S 的笛卡尔积中选择 R关系 在 A属性组 上的值 与 S关系 在 B属性组 上满足比较关系 theta 的元组。</p>
<ul>
<li>笛卡尔积</li>
<li>各种连接 等值连接 和 自然连接</li>
<li>外连接不同于等值连接，等值连接去除产生 NAN 的元组，外连接会保留</li>
<li>外连接一共有两种：
<ol>
<li>外连接</li>
<li>左右外连接</li>
</ol>
</li>
</ul>
<p>语法：</p>
<pre><code class="language-sql">where table_A left join table_B on table_A.column = table_B.column 
</code></pre>
<p><a href="https://dataschool.com/how-to-teach-people-sql/sql-join-types-explained-visually/">join 的图释</a></p>
<h3 id="内连接-inner-join"><a class="header" href="#内连接-inner-join">内连接 (inner join)</a></h3>
<p><strong>内连接就是求交集。</strong></p>
<p><img src="computer-science-notebook/database/assets%5C1567998218103.png" alt="内连接" /></p>
<h3 id="外连接-outer--left--right-join"><a class="header" href="#外连接-outer--left--right-join">外连接 outer / left / right join</a></h3>
<p>Outer join: <strong>外连接是求并集。</strong></p>
<img align="left " src="computer-science-notebook/database/assets/image-20210814095906436.png" alt="image-20210814095906436" style="zoom:80%;" />
<p>left / right join 通常会产生 NULL 值</p>
<p><img src="computer-science-notebook/database/assets%5C1567998297852.png" alt="左外链接" /></p>
<p><img src="computer-science-notebook/database/assets%5C1567998320178.png" alt="右外连接" /></p>
<pre><code class="language-sql">select 
    P.FirstName, P.LastName, A.City, A.State
from 
    Person as P left join 
    Address as A
on
    P.PersonID = A.PersonID
;
</code></pre>
<h3 id="外键"><a class="header" href="#外键">外键</a></h3>
<h4 id="定义"><a class="header" href="#定义">定义</a></h4>
<p>A foreign key relationship involves a parent table that holds the initial column values, and a child table with column values that reference the parent column values. A foreign key constraint is defined on the child table.</p>
<p>The essential syntax for a defining a foreign key constraint in a <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html"><code>CREATE TABLE</code></a> or <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html"><code>ALTER TABLE</code></a> statement includes the following:</p>
<pre><code class="language-sql">[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
</code></pre>
<p>Demo: </p>
<pre><code class="language-sql">create table test_table(
    id int(11) primary key,
    name varchar(8) unique,
    fid int(11),
    foreign key (fid) references test_table(id) on update cascade on delete restrict 
    -- 持有一个 fid 外键，该外键指向本表的 id，父更新后，能够级联更新子，但是不能删除父
);
</code></pre>
<h4 id="referential-actions"><a class="header" href="#referential-actions">Referential Actions</a></h4>
<p>When an <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html"><code>UPDATE</code></a> or <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html"><code>DELETE</code></a> operation affects a key value in the parent table that has matching rows in the child table, the result depends on the <em>referential action</em> specified by <code>ON UPDATE</code> and <code>ON DELETE</code> subclauses of the <code>FOREIGN KEY</code> clause. Referential actions include:</p>
<ul>
<li>
<p><code>CASCADE</code>: Delete or update the row from the parent table and automatically delete or update the matching rows in the child table. Both <code>ON DELETE CASCADE</code> and <code>ON UPDATE CASCADE</code> are supported. Between two tables, do not define several <code>ON UPDATE CASCADE</code> clauses that act on the same column in the parent table or in the child table.</p>
<p>Note：Cascaded foreign key actions do not activate triggers.</p>
</li>
<li>
<p><code>SET NULL</code>: Delete or update the row from the parent table and set the foreign key column or columns in the child table to <code>NULL</code>. Both <code>ON DELETE SET NULL</code> and <code>ON UPDATE SET NULL</code> clauses are supported.</p>
<p>If you specify a <code>SET NULL</code> action, <em>make sure that you have not declared the columns in the child table as <code>NOT NULL</code></em>.</p>
</li>
<li>
<p><code>RESTRICT</code>: Rejects the delete or update operation for the parent table. Specifying <code>RESTRICT</code> (or <code>NO ACTION</code>) is the same as omitting the <code>ON DELETE</code> or <code>ON UPDATE</code> clause.</p>
</li>
<li>
<p><code>NO ACTION</code>: A keyword from standard SQL. In MySQL, equivalent to <code>RESTRICT</code>. The MySQL Server rejects the delete or update operation for the parent table if there is a related foreign key value in the referenced table. Some database systems have deferred checks, and <code>NO ACTION</code> is a deferred check. In MySQL, foreign key constraints are checked immediately, so <code>NO ACTION</code> is the same as <code>RESTRICT</code>.</p>
</li>
<li>
<p><code>SET DEFAULT</code>: This action is recognized by the MySQL parser, but both <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html"><code>InnoDB</code></a> and <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html"><code>NDB</code></a> reject table definitions containing <code>ON DELETE SET DEFAULT</code> or <code>ON UPDATE SET DEFAULT</code> clauses.</p>
</li>
</ul>
<p>For storage engines that support foreign keys, MySQL rejects any <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html"><code>INSERT</code></a> or <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html"><code>UPDATE</code></a> operation that attempts to create a foreign key value in a child table if there is no matching candidate key value in the parent table.</p>
<p>For an <code>ON DELETE</code> or <code>ON UPDATE</code> that is not specified, the default action is always <code>RESTRICT</code>.</p>
<h2 id="视图-view"><a class="header" href="#视图-view">视图 View</a></h2>
<h3 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h3>
<p>视图 View 对于用户来说，<strong>和正常的表没有区别</strong>，视图的数据本质上是对数据库中表数据的 select。</p>
<p>新建一个视图，对于用户来说，其等价于新建了一张表，用户可以对这张表进行增删改查，其增删改查的操作最后都会映射到其关联的表中。这张视图表的生命周期和其他正常的表一样，即使重启数据库，视图仍然存在。</p>
<p>如果我们修改了某些表，那么依赖这些表的视图也会相应的进行更新。</p>
<p>视图由于依赖其他表，其性能上可能不如直接查询其他表速度来的快。</p>
<h3 id="视图的作用"><a class="header" href="#视图的作用">视图的作用</a></h3>
<ul>
<li>整合多表数据：对多个表的数据进行组合，新建成一张视图，方便进行二次查询</li>
<li>截取单表数据：只对某张表的某些字段进行操作</li>
<li>数据保护：可以针对想要公开的数据，生成一张视图，并提供给用户进行操作</li>
</ul>
<h3 id="视图增删改查"><a class="header" href="#视图增删改查">视图增删改查</a></h3>
<pre><code class="language-mysql">create view view_test as
select * from -- 标准的 sql 查询语言

show create view view_name; -- 查看建立视图的 命令

drop view view_name; -- 删除视图

-- 更新视图，先 drop，再 create
</code></pre>
<h2 id="报错"><a class="header" href="#报错">报错</a></h2>
<ul>
<li>
<p>Data truncated for column 'date' at row 1</p>
<p>有时候设置了 键 的约束，但是插入的数据越过了这个约束，就会报错，例如设置了 varchar(16)，但是插入的字符串长度为 20 ，那么就会报错。</p>
</li>
</ul>
<h2 id="数据库-sql-差异性"><a class="header" href="#数据库-sql-差异性">数据库 sql 差异性</a></h2>
<ul>
<li>
<p>Oracle sql 语句结尾不能加 <code>;</code></p>
</li>
<li>
<p>单引号和双引号的区别</p>
<p>在 sql 标准中，单引号表示字符串，双引号表示 identifiers，例如表名或者列名</p>
<pre><code class="language-sql">delete from 
  table_a 
where 
  id in (
    select 
      id 
    from 
      (select * from table_a) as table_a_copy 
      left join 
	  (select *, 'flag' as &quot;flag&quot; from table_b) as table_b_copy 
	  on 
	  table_a_copy.id = table_b_copy.cc 
    where 
      table_b_copy.flag is NULL
  );
</code></pre>
</li>
<li>
<p>Oracle 对 as 的兼容性不太好，不要用 as 了，as 类似于语法糖，不用也 ok 的</p>
<pre><code class="language-sql">select *, 'flag' flag from table_b
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-进阶"><a class="header" href="#mysql-进阶">MySQL 进阶</a></h1>
<p>[TOC]</p>
<h2 id="进阶-mysql-的目的"><a class="header" href="#进阶-mysql-的目的">进阶 MySQL 的目的</a></h2>
<ul>
<li>DBA</li>
<li>Mysql 的执行效率非常高，而且提供了非常多丰富的功能，例如各种字符串函数，触发器，字段的约束等功能。在实际应用中，我们可以将统一的计算迁移到 MySQL 上，这样就避免了在切换不同的框架时写重复的代码。这篇文章的思想 <a href="https://sivers.org/pg">Simplify: move code into database functions</a> 和我的思想不谋而合。这也是为什么要深入学习 Mysql 的一个原因。</li>
<li>个人能力的提升</li>
</ul>
<h2 id="fixed-problems"><a class="header" href="#fixed-problems">Fixed problems</a></h2>
<p><strong>root 用户无法远程访问</strong></p>
<p>根本原因在于，没有为 <code>&quot;root&quot;@&quot;%&quot; 配置密码</code></p>
<p>root 用户在 MySQL 的 user 表中，有多种，这是 mysql.user 表中的数据：</p>
<table><thead><tr><th>Host</th><th>User</th></tr></thead><tbody>
<tr><td>localhost</td><td>root</td></tr>
<tr><td>%</td><td>root</td></tr>
</tbody></table>
<p>如果我们想要使用 root 用户远程访问数据库，必须先去数据库里看看到底有几个 root 用户配置：</p>
<pre><code class="language-mysql">use mysql;
select * from user where user=&quot;root&quot;;
</code></pre>
<p><strong>Access denied for user 没有权限</strong></p>
<pre><code>mysqldump --databases checkRandomDiff dashboard dashboard_debug diff liuli12 rpmp &gt; dump.sql
# 在 dump 的时候提示 access denied for user
解决：为该命令指定用户
mysqldump -uroot -p123456  --databases checkRandomDiff dashboard dashboard_debug diff liuli12 rpmp &gt; dump.sql
</code></pre>
<h2 id="dba-相关"><a class="header" href="#dba-相关">DBA 相关</a></h2>
<h3 id="权限控制"><a class="header" href="#权限控制">权限控制</a></h3>
<p><strong>官方文档</strong></p>
<p>https://dev.mysql.com/doc/refman/5.7/en/grant.html</p>
<p><strong>权限相关查询</strong></p>
<pre><code class="language-mysql">-- 查询可以使用 root 用户访问数据库的 host
use mysql;
SELECT host FROM user WHERE user = 'root';
</code></pre>
<h4 id="grant-授权语法"><a class="header" href="#grant-授权语法">Grant 授权语法</a></h4>
<pre><code class="language-mysql">-- Demo
GRANT 
	SELECT -- 权限
ON 
	spider_db.* -- 数据库.表 这里表示数据库的所有表
TO 
	'wanshuo'@'%' -- '用户名'@'host', % 表示并没有指定任何 host，用户可以从任何 host 上访问
IDENTIFIED BY 
	&quot;xxxxxx&quot;; 
flush privileges;
/*
详解
1. 如果 'wanshuo'@'%' 这个用户配置在 mysql.user 中已经存在，那么 IDENTIFIED BY 就不需要加入，如果加入了，那么配置的密码就会覆盖原始的密码，grant 就是单纯的为 'wanshuo'@'%'赋予权限。
2. 如果 'wanshuo'@'%' 这个用户配置在 mysql.user 中不存在，那么 grant 的作用是创建用户，并赋予权限。IDENTIFIED BY 起到配置密码的作用

identified by 参考：https://stackoverflow.com/questions/31111847/identified-by-password-in-mysql
*/
</code></pre>
<h4 id="grant-demo"><a class="header" href="#grant-demo">Grant demo</a></h4>
<pre><code class="language-mysql">-- 把查询 student 表的权限授权给 u1
grant select on table student to u1; 

-- 把对 student 表和 course 表的所有权限赋给 u1,u2
grant all privileges on table student, course to u1, u2; 

-- 把对 student 表的查询权限赋给所有用户
grant select on table student to public; 

-- 把查询 student 表 和 修改学号的权限赋给 u1
grant select, update(sno) on student to u1;

-- 把对 student 表的插入权限赋给 u1，并允许 u1 再将此权限授予其他用户
grant insert on student to u1 with grant option;
</code></pre>
<h4 id="revoke-收回授权"><a class="header" href="#revoke-收回授权">Revoke 收回授权</a></h4>
<pre><code>revoke 
	insert 
on
	spider_db.*
from
	user;
</code></pre>
<h4 id="创建用户授予权限删除用户的-demo"><a class="header" href="#创建用户授予权限删除用户的-demo">创建用户，授予权限，删除用户的 Demo</a></h4>
<pre><code class="language-mysql">CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'password';
GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';
ALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;

DROP USER 'jeffrey'@'localhost';
</code></pre>
<h4 id="远程访问"><a class="header" href="#远程访问">远程访问</a></h4>
<pre><code class="language-mysql">grant all privileges on *.* to 'root'@'%' identified by '密码' with grant option;
flush privileges;  
</code></pre>
<h3 id="其他-1"><a class="header" href="#其他-1">其他</a></h3>
<h4 id="打开关闭重启-mysql查看运行状态"><a class="header" href="#打开关闭重启-mysql查看运行状态">打开/关闭/重启 Mysql，查看运行状态</a></h4>
<pre><code class="language-shell">sudo /etc/init.d/mysql start # open
sudo /etc/init.d/mysql stop
sudo /etc/init.d/mysql restart
sudo /etc/init.d/mysql status
</code></pre>
<pre><code class="language-shell"># windows 平台
net stop mysql
net start mysql
# 没有重启的命令
</code></pre>
<h4 id="mysqladmin-命令"><a class="header" href="#mysqladmin-命令">mysqladmin 命令</a></h4>
<pre><code class="language-mysql">-- 设置用户, mysqladmin
mysqladmin -u xxx password xxx
</code></pre>
<h4 id="重置密码"><a class="header" href="#重置密码">重置密码</a></h4>
<pre><code>1. 在配置文件中 [mysqld] 下添加 skip-grant-tables，保存退出
2. 重启 mysql，执行以下命令：
   mysql
   mysql &gt; use mysql;
   mysql &gt; update user set password=password('root') where user='root';   
   mysql &gt; flush privileges;
   mysql &gt; exit;
3. 停止 mysql 服务， 在配置文件中 [mysqld] 下删除 skip-grant-tables，保存退出
</code></pre>
<h4 id="时区"><a class="header" href="#时区">时区</a></h4>
<pre><code class="language-mysql">SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP);
-- 如果输出 08:00:00，则说明是中国时区
</code></pre>
<h4 id="engine"><a class="header" href="#engine">Engine</a></h4>
<p><strong>查看 mysql 支持的引擎</strong></p>
<pre><code class="language-mysql">show engines;
</code></pre>
<p><strong>概述</strong></p>
<p>MySQL 5.7 的存储引擎默认是 InnoDB，值得一提的是，mysql 支持内存数据库。</p>
<h4 id="查看-mysql-版本"><a class="header" href="#查看-mysql-版本">查看 MySQL 版本</a></h4>
<pre><code class="language-mysql">-- 在 bash 中
mysql --help | findstr Distrib
-- 在 MySQL 中
select version();
</code></pre>
<h2 id="数据库专有名词"><a class="header" href="#数据库专有名词">数据库专有名词</a></h2>
<h3 id="qps"><a class="header" href="#qps">qps</a></h3>
<p>query per second</p>
<p>是指一台服务器每秒能够接受的查询次数。</p>
<h3 id="只读实例与主备实例"><a class="header" href="#只读实例与主备实例">只读实例与主备实例</a></h3>
<p><strong>详细介绍</strong>：https://www.alibabacloud.com/help/zh/doc-detail/26136.htm</p>
<p><strong>应用场景</strong></p>
<p>在对数据库有少量写请求，但有大量读请求的应用场景下，单个实例可能无法承受读取压力，甚至对业务产生影响。为了实现读取能力的弹性扩展，分担数据库压力，您可以创建一个或多个只读实例，利用只读实例满足大量的数据库读取需求，增加应用的吞吐量。</p>
<p><strong>拓扑图</strong></p>
<p><img src="computer-science-notebook/database/assets/1566893242817.png" alt="只读实例与主备实例" /></p>
<h2 id="mysql-内置函数"><a class="header" href="#mysql-内置函数">Mysql 内置函数</a></h2>
<p>注意，所有的功能性的内置函数，都可以直接通过 select 进行调用。例如：</p>
<pre><code class="language-mysql">select CurDate();
select Upper(&quot;nihao&quot;);
</code></pre>
<h3 id="时间相关"><a class="header" href="#时间相关">时间相关</a></h3>
<p>Mysql 的日期格式，必须是 <code>2019-01-01</code></p>
<h4 id="time_to_sec-timediff"><a class="header" href="#time_to_sec-timediff">time_to_sec, timediff</a></h4>
<pre><code class="language-mysql">select 
	cid, (1-sum(TIME_TO_SEC(TIMEDIFF(meddle_end,meddle_start)))/2592000) as sec 
from 
	run_case_meddlecase
where 
	meddle_start &gt; &quot;2018-09-01&quot; and meddle_start &lt; &quot;2018-10-01&quot;
	and TIMEDIFF(meddle_end,meddle_start) &lt;= &quot;168:00:00&quot;
group by 
	cid
order by 
	sec
</code></pre>
<h4 id="date-time-year"><a class="header" href="#date-time-year">Date(), Time(), Year()</a></h4>
<p>如果只需要比较一部分日期，例如只针对日期/时间/年份/月份进行查询，则需要用到一些日期的处理函数</p>
<table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody>
<tr><td>Date()</td><td>返回一个日期的日期部分</td></tr>
<tr><td>Time()</td><td>返回一个日期的时间部分</td></tr>
<tr><td>Year()</td><td>返回一个日期的年份</td></tr>
<tr><td>Now()</td><td>返回当前日期和时间</td></tr>
<tr><td>CurDate()</td><td>返回当前日期</td></tr>
<tr><td>CurDate()</td><td>返回当前时间</td></tr>
</tbody></table>
<p><strong>Demos</strong></p>
<pre><code class="language-mysql">select weibo_content from senti_weibo_realtime_weibo where weibo_content like &quot;%[微笑]%&quot; and Date(post_time ) = &quot;2019-04-22&quot;;

select CurDate();
</code></pre>
<h3 id="concat-round"><a class="header" href="#concat-round">concat() ,round()</a></h3>
<p><strong>作用</strong></p>
<p>concat(str1, str2)连接字符串，其输入可以为 整型</p>
<p>round(num, 2) 对 num 四舍五入保留两位</p>
<p><strong>Demo</strong></p>
<pre><code>select table_name, concat(round((data_length + index_length)/1024/1024, 2), 'M') as size_M from information_schema.tables where table_schema = &quot;se_monitor&quot; and table_name = &quot;run_case_deploycoveragedetail&quot;; 
</code></pre>
<h3 id="to_days"><a class="header" href="#to_days">to_days()</a></h3>
<p>Given a date <em>date</em>, returns a day number (the number of days since year 0). 常用于对数据库表按照时间进行分区时的时间函数。</p>
<p><strong>Demo</strong></p>
<pre><code class="language-mysql"> SELECT TO_DAYS(&quot;2017-06-20 09:34:00&quot;);
</code></pre>
<h2 id="数据备份dump-与-load"><a class="header" href="#数据备份dump-与-load">数据备份：dump 与 load</a></h2>
<p>https://dev.mysql.com/doc/refman/5.7/en/mysqlpump.html</p>
<p><strong>数据库备份工具</strong></p>
<p>Navicat</p>
<h3 id="mysqldump"><a class="header" href="#mysqldump">mysqldump</a></h3>
<pre><code class="language-shell"># 将远程库 bq 中的 svmstate 表存储到 backup.sql
mysqldump -h 10.67.32.24 -uroot -pIQd7VOksI8KtHeZ8Hy0U -P 9306 bq svmstate &gt; backup.sql

# 备份多个数据库，注意，必须要加 --databases 参数，该参数可以指定命令行中所有的 name 都是数据库的名称，如果不加 --databases，则会默认 db1 为数据库的名称，db2，db3 为表名
mysqldump --databases db1 db2 db3 &gt; dump.sql

# 加 --databases 和 不加 --databases 的区别
##########################################
# Use of --databases with the mysqldump command line causes the dump file to include CREATE
# DATABASE and USE statements that create the database if it does exist and make it the    # default database for the reloaded data.
# Alternatively, you can omit --databases from the mysqldump command. Then you will need to # create the database on Server 2 (if necessary) and specify it as the default database    # when you reload the dump file.
##########################################

# mysqldump 会锁住表，加上  --single-transaction 参数可以在不加锁的情况下进行备份

# 常见的两种 备份 和 加载 方式
mysqldump --databases db1 &gt; dump.sql
mysql &lt; dump.sql

mysqldump db1 &gt; dump.sql
mysqladmin create db1

# dump 所有的数据库
mysqldump --all-databases &gt; dump.sql

# 备份指定的数据库，加入 --databases，就会备份备份建表语句
mysqldump --databases db1 db2 db3 &gt; dump.sql

# 备份数据库中除某些表之外的部分表
mysqldump -uroot -p123456 diff --ignore-table=diff.getdiffrate_difftraceinfo --ignore-table =diff.test &gt; /home/work/mysql_backup/dump.sql

# dump 表中的一部分数据，加入 where 条件
mysqldump -uroot -p123456 diff getdiffrate_difftraceinfo --where=&quot;id &gt; 1 ORDER BY ID DESC LIMIT 100&quot; &gt; /home/work/mysql_backup/getdiffrate_difftraceinfo_partial_data.sql
# 注意，where 字句中一定要加入一个条件，例如 id &gt; 1，否则不符合语法要求。

# 只 dump 表结构 -d 参数
mysqldump -d 数据库名 -uroot -p &gt; xxx.sql

mysql -h 106.54.116.243 -P 3306 -u root -pxxxxxx

# 只 dump 数据 -t 参数
mysqldump -h 10.91.162.162 -umonitor -pmonitor123 -P 3306 se_monitor run_case_detail_20180201 -t --single-transaction --where=&quot;id &gt; 1000 limit 10&quot;  &gt; /home/work/mysql_dump/sql/run_case_detail_20180201.sql
</code></pre>
<h3 id="load"><a class="header" href="#load">load</a></h3>
<pre><code class="language-shell"># 将本地的 sql 文件导入远程的数据库中，这里这是备份了数据库中的一张表，所以需要指定数据库
mysql -h 10.64.26.153 -P 8091 -u dasou_wangye --password=6fb943b0-d74d-4d26-8aa6-217848bd04ea se_monitor &lt; /home/work/mysql_dump/sql/run_case_20180801.sql

# 将本地的包含多个库的备份文件导入数据库中，不需要指定数据库
./mysql -h localhost -P 3306  -uroot -p123456 &lt; /home/work/mysql_backup/dump_except_diff.sql
</code></pre>
<p><strong>注意</strong></p>
<p>对于 id 自增的数据表，不管其增加新的数据，然后删除，还是删除旧的数据，然后更新，在使用 MySQL dump 命令的时候，都不会导致 id 中断。只要 dump 的 sql 文件中，没有冲突的 id，就能 load 成功。</p>
<h3 id="dumpsql-详解"><a class="header" href="#dumpsql-详解">dump.sql 详解</a></h3>
<p>dump.sql 文件其实是一个纯文本文件，其中包含了数据库表的创建信息，还有要插入的数据。</p>
<pre><code class="language-mysql">-- MySQL dump 10.13  Distrib 5.5.30, for Linux (x86_64)
--
-- Host: 10.67.32.24    Database: bq
-- ------------------------------------------------------
-- Server version	5.1.49-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `svmstate`
--

DROP TABLE IF EXISTS `svmstate`; # 会覆盖之前存储的同名的表
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `svmstate` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID标识',
  `module` varchar(255) NOT NULL COMMENT '类型',
  `flag` varchar(255) NOT NULL COMMENT '状态',
  `last_modify_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `svmstate`
--

LOCK TABLES `svmstate` WRITE; # 在写入的时候，会锁住 写入的数据表
/*!40000 ALTER TABLE `svmstate` DISABLE KEYS */;
INSERT INTO `svmstate` VALUES (1,'feedback','1','2018-02-02 05:32:59'),(3,'onlineproblem','1','2018-03-22 09:06:45'),(4,'bugs','1','2018-03-22 09:32:37');
/*!40000 ALTER TABLE `svmstate` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-10-15 20:29:56

</code></pre>
<h3 id="innodb_force_recovery-进入安全模式备份数据"><a class="header" href="#innodb_force_recovery-进入安全模式备份数据">innodb_force_recovery 进入安全模式备份数据</a></h3>
<p><strong>Forcing InnoDB Recovery 模式</strong></p>
<p>在 my.cnf 中加入  innodb_force_recovery = 1，进入强制恢复模式。</p>
<p>进行该操作只是权宜之计，用来启动 InnoDB 引擎并 dump 数据。</p>
<p>开启 Forcing Recovery 模式后，InnoDB 会禁止对数据库的 增删改 操作，当 innodb_force_recovery &gt; 3 后，数据库会进入只读模式，并且到了 4 就会有永久损坏数据的危险。</p>
<p>1 &lt;= innodb_force_recovery &lt;= 6，数字越高，风险越大。innodb_force_recovery  的默认值为 0。</p>
<p>已经实践确认，进入安全模式后，确实不能进行增删改操作，但是能在 innodb_force_recovery &lt;= 3 时进行新建表，和删除表的操作。如果进行 insert 操作，会报： ERROR 1030 (HY000): Got error -1 from storage engine 的错误。</p>
<h2 id="其他知识点"><a class="header" href="#其他知识点">其他知识点</a></h2>
<h3 id="mysql-自带的四个数据库"><a class="header" href="#mysql-自带的四个数据库">Mysql 自带的四个数据库</a></h3>
<h4 id="mysql-数据库"><a class="header" href="#mysql-数据库">mysql 数据库</a></h4>
<p>存储 mysql 的配置信息，例如 mysql 的用户，访问权限等。</p>
<h4 id="performance-schema-和-sys-数据库"><a class="header" href="#performance-schema-和-sys-数据库">performance schema 和 sys 数据库</a></h4>
<p>存储服务器性能参数，暂时不需要了解。</p>
<h4 id="information-schema-数据库"><a class="header" href="#information-schema-数据库">information schema 数据库</a></h4>
<p><strong>abstract</strong></p>
<p>information_schema 数据库中存储着 MySQL 下的所有数据库的配置信息。包括用户、权限、数据库大小等信息。</p>
<p>information_schema 数据库中每一张表，都存储着一种配置，下面对于常用到的表进行解释。</p>
<p>information schema 数据库中的表实际上都是只读视图。</p>
<p><strong>TABLES 表</strong></p>
<table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody>
<tr><td>TABLE_SCHEMA</td><td>database name</td></tr>
<tr><td>TABLE_NAME</td><td>table name</td></tr>
<tr><td>DATA_LENGTH</td><td>数据量大小，单位 byte</td></tr>
<tr><td>INDEX_LENGTH</td><td>索引大小，单位 byte</td></tr>
<tr><td>TABLE_ROWS</td><td>表的行数</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<p><strong>Demo</strong></p>
<pre><code class="language-mysql">* 查看各个库的大小
select table_schema, sum(data_length+index_length)/1024/1024 as total_mb, \
sum(data_length)/1024/1024 as data_mb, sum(index_length)/1024/1024 as index_mb, \
count(*) as tables, curdate() as today from information_schema.tables group by table_schema order by 2 desc;

* 查看某张表的大小
select table_name, (data_length + index_length)/1024/1024 as size_M from information_schema.tables where table_schema = &quot;se_monitor&quot; and table_name = &quot;run_case_deploycoveragedetail&quot;; 

# 查看某张表有多少行
select table_rows  from tables where table_schema = &quot;diff&quot; and table_name = &quot;getdiffrate_difftraceinfo&quot;;
</code></pre>
<h3 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h3>
<h3 id="primary-key--unique-key"><a class="header" href="#primary-key--unique-key">primary key / unique key</a></h3>
<p><strong>相同点</strong></p>
<ul>
<li>两者都用来标记一条独一无二的数据</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>primary key 是 not null, 而 <strong>unique key 可以是 null</strong></li>
<li>primary key 只能有一个，而 unique 可以定义多个</li>
</ul>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<p><a href="https://time.geekbang.org/column/article/105553#previewimg">深入浅出数据库索引</a></p>
<h3 id="为什么要建立索引"><a class="header" href="#为什么要建立索引">为什么要建立索引</a></h3>
<p>数据库为了提高查询效率，通常会为某些字段加入索引。当我们查询某个字段的时候，如果这个字段没有添加索引，那么查询速度就会非常慢，因为数据库要从第一行开始查找。</p>
<p>数据库会默认为 Primary Key 建立索引，但是这远远不够，如果我们对某张表的某个字段查询比较频繁，我们最好给这个字段加入索引，进而提高查询效率。</p>
<h3 id="索引的缺点"><a class="header" href="#索引的缺点">索引的缺点</a></h3>
<ul>
<li>索引的缺点，就是 B+ 树的缺点，索引方便了查询，但是不利于数据的增删改</li>
<li>简历索引和维护索引需要耗费很多计算资源和内存空间</li>
</ul>
<h3 id="索引的类型"><a class="header" href="#索引的类型">索引的类型</a></h3>
<table><thead><tr><th>索引名</th><th>作用</th></tr></thead><tbody>
<tr><td>index,  key</td><td>普通索引，加快查询速度( key 的功能多于 index，默认用key)</td></tr>
<tr><td>unique</td><td>唯一索引，该值在字段下唯一，可以为 null</td></tr>
<tr><td>primary key</td><td>主索引，主键</td></tr>
<tr><td>foreign key</td><td>外索引，外键</td></tr>
</tbody></table>
<p><strong>Demo</strong></p>
<pre><code class="language-mysql">create table test_table(
	id int(11) auto_increment,
	name varchar(8) not null,
	mother varchar(8) not null,
	primary key (id), -- 主键
	key mother (mother), -- 加索引
	foreign key (name) -- 加外键
)ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1; -- id 从 1 开始增长
</code></pre>
<h3 id="索引的实现"><a class="header" href="#索引的实现">索引的实现</a></h3>
<p>Mysql InnoDB 引擎采用 B+ 树（多叉平衡树）建立索引，所有数据存储到 B+ 树中。之所以采用 B+  树，首先如果采用传统的二叉查找树，那么很容易导致树的高度过高，一层就是一次查询，进而导致查询效率不高。那么为了优化二叉查找树，我们考虑采用 AVL(<strong>二叉平衡树</strong>) 才建立索引，但是问题在于，当数据量很大时，即使是平衡树，树也会达到很深的深度。所以我们采用 B+ 树，B+ 树既是平衡树，又因为一个节点存储多值，所以树的深度会变浅，从而查询次数比较少。</p>
<p><strong>优化的准则：降低查找树的深度，减少磁盘访问次数。</strong></p>
<p><strong>优化的过程</strong>：</p>
<pre><code>二叉排序树 ——&gt; AVL 树 ——&gt; B树 ——&gt; B+树
</code></pre>
<p>Demo:</p>
<pre><code class="language-mysql">create table T(
    id int primary key, -- 主键建立主索引
    k int not null, 
    name varchar(16),
	index (k) -- k 建立普通索引
)engine=InnoDB;
</code></pre>
<p>如果我们有五组数据要存储到表中：<code>（id, k), (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)</code> ，那么这两棵树存储结构为：	</p>
<p><img src="computer-science-notebook/database/assets/1566907351970.png" alt="主键索引与非主键索引" /></p>
<p>主键索引叶子节点存储的是整行的数据，而非主键索引叶子节点存储的是主键，所以如果我们想要查找主键，只需要搜索<strong>一次</strong> B+ 树，而如果我们想要对其他非主键索引的字段进行查找，则需要查找<strong>两次</strong> B+ 树，第一次是查找字段所在 B+ 树，找到主键ID，然后根据主键 ID 去主键索引树中查找。</p>
<p>由此我们也可以看到，普通索引的叶子节点，存储的是主键ID，那么主键的存储空间越小，那么普通索引的叶子节点就越小，普通索引占用的空间也越小。这就是为什么，大多数的数据库表，主键设置为主键自增长，而且用整型来存储，这样即方便比较，存储的体积也小。举个例子，如果我们设置了某一个字段为主键，例如身份证，那么其他非主键索引树的叶子节点，就存储的是身份证号，身份证号比起自增长 ID 来说，占用了更多的空间。而且每一个非主键索引树，都会附带上身份证号，导致索引树的体积变大。</p>
<h3 id="索引失效的情况"><a class="header" href="#索引失效的情况">索引失效的情况</a></h3>
<p>一个宗旨：对带所有的字段进行查找，尽量不要设计非索引字段的查找。</p>
<ul>
<li>where 子句
<ul>
<li>进行 null 值的判断: <code>is null</code></li>
<li><code>!= &lt; &gt;</code> 的使用</li>
<li><code>or</code> 如果包含了一个非索引的字段，则也会索引失效，进行全表扫描</li>
<li><code>in</code> 的使用</li>
<li>函数操作 <code>substring(name) = &quot;wansho&quot;</code></li>
<li><code>like</code> 模糊查询</li>
</ul>
</li>
</ul>
<h2 id="mysql-优化"><a class="header" href="#mysql-优化">Mysql 优化</a></h2>
<h3 id="查看-mysql-线程"><a class="header" href="#查看-mysql-线程">查看 Mysql 线程</a></h3>
<p>Mysql 是多用户多线程的，有时候一个线程任务速度慢，可能会拖慢所有任务。</p>
<p>查看当前线程的命令：</p>
<pre><code class="language-mysql">show processlist;
</code></pre>
<p>kill 某个线程的命令:</p>
<pre><code class="language-mysql">kill id;
</code></pre>
<h3 id="delayed-关键字-延迟执行"><a class="header" href="#delayed-关键字-延迟执行">delayed 关键字 延迟执行</a></h3>
<p>delayed 常用于延迟执行 insert。有时候 MySQL 事务繁忙，例如某张表正在被读任务占用，我们就可以延迟对这张表的写入。delayed insert 语句实际上进入了一个队列，当读操作结束的时候，delayed 队列中的 insert 语句才会执行。常用于缓解数据库的压力。</p>
<p>Demo:</p>
<pre><code class="language-mysql">insert delayed into senti_weibo_conf values(7, &quot;hehe&quot;, &quot;1&quot;, &quot;2019-09-09 00:00:00&quot;, &quot;s&quot;);
</code></pre>
<h3 id="其他优化技巧"><a class="header" href="#其他优化技巧">其他优化技巧</a></h3>
<ul>
<li>
<p>Mysql Script （存储过程）的执行速度，快于一条一条单独执行的速度。</p>
</li>
<li>
<p>不要用 select *，用到什么字段，select 什么字段</p>
</li>
<li>
<p>使用 delayed 关键字延迟命令的执行，防止数据库压力过大</p>
</li>
<li>
<p>用 union 替代 or</p>
</li>
<li>
<p>避免在线上环境使用 like</p>
</li>
</ul>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<h3 id="浮点型"><a class="header" href="#浮点型">浮点型</a></h3>
<p><code>alter table spider_realtime_weibo add sentiment_score float(5,2) ;</code></p>
<p>给spider_realtime_weibo 加入一个浮点型字段，其可以表示两位小数，包括小数点最长可达 5 位。</p>
<p>上述描述同样适用于 double 类型</p>
<p>注意：float 型必须指定小数点位数，否则存入数据库时还是整数</p>
<h3 id="对于-null-值的判断"><a class="header" href="#对于-null-值的判断">对于 NULL 值的判断</a></h3>
<pre><code class="language-mysql">is null
select crawl_time, sentiment_score  from spider_realtime_weibo where sentiment_score is null;
</code></pre>
<h3 id="datetime-与-timestamp"><a class="header" href="#datetime-与-timestamp">datetime 与 timestamp</a></h3>
<p><strong>timestamp</strong></p>
<p>timestamp 只占用 4 个字节，可以表示的时间范围有上限和下线，这是一个坑。</p>
<p>两个属性：</p>
<ol>
<li>CURRENT_TIMESTAMP  insert 时插入当前时间</li>
<li>ON UPDATE CURRENT_TIMESTAMP update 时更新为当前时间</li>
</ol>
<p>常用组合：</p>
<pre><code class="language-MySQL">last_modify_time timestamp not null default current_timestamp on update current_timestamp comment '最后更新时间'  -- 创建新记录和修改现有记录的时候都对这个数据列刷新
</code></pre>
<p><strong>datetime</strong></p>
<p>datetime 的时间没有上线限制，可以在 timestamp 失效时，替代 timestamp</p>
<p><strong>实际问题</strong></p>
<p>往数据库中插入时间 &gt;  '2038-01-19 3:14:7' 的时间时，会报错</p>
<pre><code class="language-mysql">INSERT INTO `run_case_deploycoveragedetail` VALUES ('3380211', 'search', '', 'dict', 'online', '', '', '', 'dictserver@misdata:CompactionKvDictZdictBuild@query_log_dict_31', 'misdata:CompactionKvDictZdictBuild@query_log_dict_31', 'beehive_jobplatform', '', '1', 'lichenggang,chaijunjun', '', '', 'http://10.46.63.64:8888/jobplatform/data?task_id=1539834449_1', 'CompactionKvDictZdictBuild', '1539834449_1', 'Y', 'day', '2018-10-18 11:47:29', '2038-01-19 3:14:8', '2018-10-18 00:00:00', '2018-10-19 00:00:00', '2018-10-19 08:01:35');
[Err] 1292 - invalid time format: '{2038 1 19 3 14 8 0}'
</code></pre>
<p><strong>原因</strong></p>
<p>mysql 的 timestamp 的时间范围为 1970-01-01 00:00:00 到 2038-01-19  3:14:07，timestamp 占 4 个字节。</p>
<p>具体解释：http://blog.itpub.net/7728585/viewspace-2077609/</p>
<h2 id="mysql-script-存储过程"><a class="header" href="#mysql-script-存储过程">Mysql Script 存储过程</a></h2>
<p>实现类似 Linux Script 的功能，包含了 if else while 变量等特性，入门参考 MySQL 必知必会。</p>
<h2 id="mysql-触发器"><a class="header" href="#mysql-触发器">Mysql 触发器</a></h2>
<p>触发器是应对 增删改 的操作触发执行的 mysql 语句或 MySQL script。 </p>
<h2 id="mysql-partition-拆表"><a class="header" href="#mysql-partition-拆表">Mysql Partition 拆表</a></h2>
<h3 id="partition-的目的"><a class="header" href="#partition-的目的">Partition 的目的</a></h3>
<p>将大表拆成小表，降低增删改查的成本。</p>
<h3 id="查看是否支持-partition"><a class="header" href="#查看是否支持-partition">查看是否支持 Partition</a></h3>
<pre><code class="language-mysql">-- 查看结果中是否有 Name 为 partition 的 plugin，并且其状态是否为 active，如果是 active，则支持 partition
SHOW PLUGINS;
</code></pre>
<h3 id="overview-of-partitioning-in-mysql"><a class="header" href="#overview-of-partitioning-in-mysql"><a href="https://dev.mysql.com/doc/refman/5.6/en/partitioning-overview.html">Overview of Partitioning in MySQL</a></a></h3>
<p>Partition 可以将我们的一张表切分成多块，分不到各个地方。事实上，被切分出来的不同的表块，是作为不同的表存储在其他位置。至于一条数据要被切分到哪一个小表，是根据 partition function 进行区分的。</p>
<p><strong>水平切分</strong></p>
<p>This is known as horizontal partitioning—that is, different rows of a table may be assigned to different physical partitions. <strong>MySQL 5.7</strong> does not support vertical partitioning, in which different columns of a table are assigned to different physical partitions. There are no plans at this time to introduce vertical partitioning into MySQL.</p>
<p>目前 Mysql5.7 只支持水平切分，水平切分的最小单位是 data-row。</p>
<p><strong>注意</strong></p>
<ul>
<li>切分出来的没一张表，其 database engine 都应该是一样的</li>
<li>partition 描述应该放到建表语句的最后</li>
<li>被切分的键，应该隶属于 primary key 或者 unique key，参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-partitioning-keys-unique-keys.html">Partitioning Keys, Primary Keys, and Unique Keys</a></li>
</ul>
<h3 id="partitioning-types-and-partition-management"><a class="header" href="#partitioning-types-and-partition-management"><a href="https://dev.mysql.com/doc/refman/5.6/en/partitioning-types.html">Partitioning Types</a> and <a href="https://dev.mysql.com/doc/refman/5.6/en/partitioning-management.html">Partition Management</a></a></h3>
<h4 id="range-partition"><a class="header" href="#range-partition">range partition</a></h4>
<pre><code class="language-mysql">-- 创建带有分区的表
CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE) PARTITION BY RANGE( YEAR(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005),
        PARTITION p4 VALUES LESS THAN (2010),
        PARTITION p5 VALUES LESS THAN (2015)
);

-- 正常插入数据
INSERT INTO tr VALUES
(1, 'desk organiser', '2003-10-15'),
(2, 'alarm clock', '1997-11-05'),
(3, 'chair', '2009-03-10'),
(4, 'bookcase', '1989-01-10'),
(5, 'exercise bike', '2014-05-09'),
(6, 'sofa', '1987-06-05'),
(7, 'espresso maker', '2011-11-22'),
(8, 'aquarium', '1992-08-04'),
(9, 'study desk', '2006-09-16'),
(10, 'lava lamp', '1998-12-25');

-- 从某个分区获取数据
SELECT * FROM tr PARTITION (p2);

-- 删除某个分区，注意：在删除某个分区后，该分区的数据也会对应的被删除
ALTER TABLE tr DROP PARTITION p2;

-- 对于在创建时，没有设置 partition 的 table，alter 初次设置其 partition 的命令
ALTER TABLE tr
    PARTITION BY HASH(id)
    PARTITIONS 8;
-- 同上
ALTER TABLE senti_weibo_realtime_weibo PARTITION BY RANGE( to_days(post_time) ) (

	PARTITION p0 VALUES LESS THAN (to_days(&quot;2016-01-01&quot;)),
	PARTITION p1 VALUES LESS THAN (to_days(&quot;2017-01-01&quot;)),
	PARTITION p2 VALUES LESS THAN (to_days(&quot;2018-01-01&quot;)),
	PARTITION p3 VALUES LESS THAN (to_days(&quot;2018-03-01&quot;)),
	PARTITION p4 VALUES LESS THAN (to_days(&quot;2018-06-01&quot;)),
	PARTITION p5 VALUES LESS THAN (to_days(&quot;2018-08-01&quot;)),
	PARTITION p6 VALUES LESS THAN (to_days(&quot;2018-10-01&quot;)),
	PARTITION p7 VALUES LESS THAN (to_days(&quot;2018-12-01&quot;)),
	PARTITION p8 VALUES LESS THAN (to_days(&quot;2019-01-01&quot;)),
	PARTITION p9 VALUES LESS THAN (to_days(&quot;2019-03-01&quot;)),
	PARTITION p10 VALUES LESS THAN (to_days(&quot;2019-05-01&quot;)),
	PARTITION p11 VALUES LESS THAN (to_days(&quot;2019-07-01&quot;)),
	PARTITION p12 VALUES LESS THAN (to_days(&quot;2019-09-01&quot;)),
	PARTITION p13 VALUES LESS THAN (to_days(&quot;2019-11-01&quot;)),
	PARTITION p14 VALUES LESS THAN (to_days(&quot;2020-01-01&quot;)),
	PARTITION p15 VALUES LESS THAN (to_days(&quot;2020-03-01&quot;)),
	PARTITION p16 VALUES LESS THAN (to_days(&quot;2020-05-01&quot;)),
	PARTITION p17 VALUES LESS THAN (to_days(&quot;2020-07-01&quot;)),
	PARTITION p18 VALUES LESS THAN (to_days(&quot;2020-09-01&quot;)),
	PARTITION p19 VALUES LESS THAN MAXVALUE
);
</code></pre>
<h3 id="partition-pruningselection"><a class="header" href="#partition-pruningselection">Partition Pruning/Selection</a></h3>
<h4 id="partition-pruning"><a class="header" href="#partition-pruning">Partition Pruning</a></h4>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-pruning.html">Partition Pruning</a> Mysql 语句修剪：对包含分区的表的 sql 查询语句进行修剪优化。Partition Pruning 是 Mysql 自带的一个 Optimizer，其可以对 partitioned table 进行 sql 语句的自动优化，提高 sql 效率</p>
<p>Mysql 中有一个 optimizer，可以对分区表的 sql 查询进行优化，其优化的 case 主要有两种：</p>
<ul>
<li><code>partition_column = constant</code></li>
<li><code>partition_column IN (constant1, constant2, ..., constantN)</code></li>
</ul>
<p>对于 case1, optimizer 会直接根据所给的值，判断该条数据在哪一个分区，然后只扫描这一个分区，除了 <code>=</code> 外，optimizer 还可以对  <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, and <code>&lt;&gt;</code> ，<code>between</code> 进行优化；</p>
<p>对于 case2, optimizer 会根据 list 中所给值匹配到一个 partition_list，然后扫描。</p>
<p>Partition Pruning 可以对 <code>select update delete</code> 进行优化，不能对 <code>insert</code> 进行优化。</p>
<p>Partition Pruning 还可以对在 partition table 时采用 <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_year"><code>YEAR()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_to-days"><code>TO_DAYS()</code></a> ，<a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_to-seconds"><code>TO_SECONDS()</code></a>作为划分函数的 table 进行优化</p>
<h4 id="partition-selection"><a class="header" href="#partition-selection">Partition Selection</a></h4>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-selection.html">Partition selection</a> 是明确指定分区的 select 语法，其作用类似于 Partition pruning，但区别在于其明确指定了从哪一个分区进行 select。</p>
<h2 id="mysql-执行计划-explain"><a class="header" href="#mysql-执行计划-explain">MySQL 执行计划 explain</a></h2>
<p>explain 命令用来剖析 sql 的执行。</p>
<pre><code class="language-sql">explain select * from users where name = &quot;wanshuo&quot;;
</code></pre>
<p><img src="computer-science-notebook/database/assets/image-20211124090417979.png" alt="image-20211124090417979" /></p>
<pre><code class="language-sql">explain select * from users where id = &quot;08e83a509fbe4c3e9010c7c5da984db0&quot;;
</code></pre>
<p><img src="computer-science-notebook/database/assets/image-20211124093408525.png" alt="image-20211124093408525" /></p>
<pre><code class="language-sql">explain select * from blog_browse_history where chapter_id &gt; 2700;
</code></pre>
<p><img src="computer-science-notebook/database/assets/image-20211124094340040.png" alt="image-20211124094340040" /></p>
<pre><code class="language-sql">explain select * from blog_browse_history where chapter_id &gt; 270;
-- 并没有走索引，查询优化器根据索引数据的分布情况，判断是走索引查询，还是全表扫描，这里是走全表扫描了，所以并不是配置了索引，就一定走索引
</code></pre>
<p><img src="computer-science-notebook/database/assets/image-20211124095113735.png" alt="image-20211124095113735" /></p>
<ul>
<li>id: 自增序号</li>
<li>select_type: 查询类型，simple 代表直接对表的简单查询</li>
<li>table: 查询哪张表</li>
<li>partitions: 坐落分区，数据分区存储的时候使用</li>
<li>type: 索引检索类型
<ul>
<li>const 表示针对主键或唯一索引的等值查询扫描，最多只返回一行数据</li>
<li>system 表示表中只有一条数据，这个类型是特殊的 const 类型</li>
<li>all 表示全表扫描，性能最差的查询，我们的查询不应该出现全表扫描</li>
<li>index 表示全索引扫描，和 all 类似，不过 all 是全表扫描，而 index 是扫描所有的索引，包括主键索引和普通索引。<code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时, Extra 字段 会显示 <code>Using index</code></li>
<li>range 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个</li>
<li>ref, eq_ref 通常表示多表 join 查询</li>
</ul>
</li>
<li>possible_keys: 与当前查询相关备选的索引，primary 代表主键</li>
<li>key: 代表当前实际使用的索引</li>
<li>key_len: 代表单个索引值的长度</li>
<li>ref: 显示使用哪个列或者常数与 key 一起从表中选择行</li>
<li>rows: 本次查询扫描的行数，注意，这个值可能与最终结果不一致，扫描行数越少越好</li>
<li>filter: 过滤器</li>
<li>extra: 扩展条件的详细信息。
<ul>
<li>using index condition 表示通过索引筛选满足的 chapter_id</li>
<li>using MRR 表示默认是按照主键索引升序排序</li>
<li>using where 表示直接扫描数据行进行筛选</li>
<li>using filesort 表示使用文件排序，非常低效</li>
</ul>
</li>
</ul>
<h2 id="mysql-执行计划-explain-多表"><a class="header" href="#mysql-执行计划-explain-多表">MySQL 执行计划 explain 多表</a></h2>
<p>多表查询类似于嵌套 for 循环，最外层的 for 循环尤为关键，最外层的 for 循环表也被叫做驱动表。</p>
<p>驱动表选哪一个，是MySQL 根据查询优化器自己选择的。</p>
<h2 id="mysql-保留字"><a class="header" href="#mysql-保留字">MySQL 保留字</a></h2>
<p>mysql 使用反引号来括住表名和字段名，以区分保留字和普通字符。注意，只有 MySQL 才有反引号这个怪东西。</p>
<pre><code class="language-mysql">CREATE TABLE `students` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `nickname` varchar(20) DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `in_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8
</code></pre>
<p>不能将字段名命名为如下列举的名字：</p>
<ul>
<li>order </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库理论"><a class="header" href="#数据库理论">数据库理论</a></h1>
<p>[TOC]</p>
<h2 id="祖师爷"><a class="header" href="#祖师爷">祖师爷</a></h2>
<p>埃德加·弗兰克·科德（Edgar Frank Codd E.F Codd， 1923年8月23日－2003年4月18日）</p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>范式的作用：解决如何建表，建几张表的问题。</p>
<p>一个好的设计模式，应该不会发生插入异常/删除异常/更新异常，数据冗余也应该尽可能的少。</p>
<p>关系模式三元组：$R&lt;U, F&gt;$ U: 属性组，属性集合，F: U 上的函数依赖</p>
<h3 id="函数依赖"><a class="header" href="#函数依赖">函数依赖</a></h3>
<ul>
<li>学号 —&gt; 姓名，姓名依赖于学号，姓名也完全取决于学号，所以姓名<strong>完全函数依赖</strong>于学号。姓名 = f(学号)</li>
<li>(学号，性别) —&gt; 姓名，姓名依赖于(学号，性别) ，但是姓名并不是完全依赖于学号与性别，姓名只是对学号和性别<strong>部分函数依赖</strong></li>
<li>X —&gt; Y Y —&gt; Z : X —&gt; Z，Z 对 X 传递函数依赖</li>
</ul>
<h3 id="候选码--主码--主属性--外码"><a class="header" href="#候选码--主码--主属性--外码">候选码 / 主码 / 主属性 / 外码</a></h3>
<p>一组能唯一确定一条元组的属性集合。如果候选码不止一个，那么则选定其中的一个为<strong>主码</strong>（<strong>Primary Key</strong>）。</p>
<p>主码中的属性称为<strong>主属性</strong>。</p>
<p>如果一个属性或者属性组 X 并非 关系模式R 的码，但 X 是另一个<strong>关系模式</strong>（一张表就是一个关系模式）的码，那么则称 X 是 R 的<strong>外码</strong>（外键）。</p>
<h3 id="关系模式经常存在的问题"><a class="header" href="#关系模式经常存在的问题">关系模式经常存在的问题</a></h3>
<p><img src="computer-science-notebook/database/assets/1568597648520.png" alt="一张错误的关系模式" /></p>
<ul>
<li>数据冗余（系主任存储冗余）</li>
<li>更新异常（数据冗余导致更新表的时候带来债务，例如更换系主任时，必须修改每一条学生数据）</li>
<li>插入异常（如果一个系刚成立，没有学生，就无法将该系及其系主任的信息存入数据库）</li>
<li>删除异常（删除学生的时候，会把系和系主任也删除了）</li>
</ul>
<h2 id="范式"><a class="header" href="#范式">范式</a></h2>
<p>范式就是关系型数据库的规范化。</p>
<p>范式：符合某一种级别的关系模式的集合。</p>
<p><img src="computer-science-notebook/database/assets/1568597919605.png" alt="范式" /></p>
<p><strong>第一范式</strong>：每一个属性都是不可分的数据项。</p>
<p><strong>第二范式</strong>：若 R 属于 1NF，且每一个非主属性<strong>完全函数依赖</strong>于码，则 R 属于 2NF。一个关系模式（表）不属于 2NF，会产生 插入异常，修改异常，删除异常等问题。</p>
<p><img src="computer-science-notebook/database/assets/1568599080206.png" alt="满足第二范式的关系模式" /></p>
<p><strong>第三范式</strong>：每一个非主属性，既不部分依赖于码，也不传递依赖于码。图6.5的关系模式，由于存在传递函数依赖，所以需要将其拆开。</p>
<p>注意：并不是规范化程度越高，关系就越优，当查询设计到多表查询时，连接运算会导致查询效率降低。有时候，第二范式，甚至第一范式，是比较折中的选择</p>
<h2 id="数据库恢复技术--transaction"><a class="header" href="#数据库恢复技术--transaction">数据库恢复技术 / Transaction</a></h2>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>Transaction：用户定义的一个数据库操作脚本，这些操作要么全做要么全不做，是一个原子操作。在关系型数据库中，一个事务可以是一条 SQL语句或一个存储过程。</p>
<p>Transaction 举例：从账户 A 中取出一万元，存入账户 B。需要定义一个 transaction，包含两个操作，从 A 中减去一万元，然后想 B 中加入一万元。</p>
<p><strong>Transaction 的三个命令</strong></p>
<ul>
<li>begin transaction</li>
<li>commit：提交事务的所有操作，将事务中所有对数据库的更新写入磁盘，事务正常结束</li>
<li>rollback：撤销事务的执行，回滚到初始状态</li>
</ul>
<p><strong>Transaction 的四大特性：ACID</strong></p>
<ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li>
<li>隔离性（Isolation）：一个事务的隔离并不会被其他事务干扰</li>
<li>持续性（Durability）：transaction 一旦提交，其改变就应该是持久性的</li>
</ul>
<p>多个事务交叉运行，需要数据库管理系统拥有<strong>并发控制机制</strong>，一个事务被迫中断，则需要 DBMS 拥有<strong>中断恢复机制</strong>。</p>
<h3 id="恢复技术"><a class="header" href="#恢复技术">恢复技术</a></h3>
<p>事务意外中断在所难免，那么如何进行现场的恢复？</p>
<p>恢复的原理：冗余。（数据备份和日志）</p>
<h2 id="规范化和去规范化"><a class="header" href="#规范化和去规范化">规范化和去规范化</a></h2>
<p><a href="https://www.infoq.cn/article/1afyz3b6hnhprrg12833">MySQL 数据实时同步到 Elasticsearch 的技术方案选型和思考（外键）</a> </p>
<p>规范化：关系型数据库中通过一系列数据库范式来减少数据冗余、增强数据一致性的策略。</p>
<p>规范化的特征：符合第二或第三范式，窄表，关系表</p>
<p>规范化的问题：涉及多表的复杂查询，要么多次查询数据库，要么连接查询</p>
<p>去规范化的措施：宽表，视图(其实也是宽表)，数据迁移(宽表)</p>
<h2 id="oltp-olap-htap-mpp"><a class="header" href="#oltp-olap-htap-mpp">OLTP OLAP HTAP MPP</a></h2>
<p>数据库操作分为两种：</p>
<ul>
<li>
<p>OLTP online transaction processing</p>
<p>线上请求。</p>
<p>OLTP 是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。传统的INSERT、Update、DELETE等都属于OLTP，主要是涉及事务处理。</p>
</li>
<li>
<p>OLAP online analytical processing</p>
<p>后台分析。</p>
<p>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。SELECT中的count(*)、MAX()、MIN()、Group By、Order By等函数都属于OLAP的范畴。</p>
</li>
<li>
<p>Hybrid Transactional/Analytical Processing</p>
<p>OLTP + OLAP</p>
</li>
</ul>
<p>MPP：massive parallel processing 大规模并行计算</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elastic-search"><a class="header" href="#elastic-search">elastic-search</a></h1>
<p>[TOC]</p>
<h2 id="技术栈"><a class="header" href="#技术栈">技术栈</a></h2>
<p>MySQL 有的功能，elastic search 一般都有。(elastic search 没有 acid 特性)</p>
<ul>
<li>
<p>增量数据迁移 mysql =&gt; es: alibaba canal</p>
<p>canal 有服务端(slaver管道)、adapter(消费者) 和 admin 三个主要程序</p>
<p>配置特别麻烦，不适合多现场部署，版本兼容性也不咋地，太重了</p>
</li>
<li>
<p>全量数据迁移：logstash</p>
</li>
</ul>
<h2 id="视频教程"><a class="header" href="#视频教程">视频教程</a></h2>
<p><a href="https://www.bilibili.com/video/BV1854y1E78p">ElasticSearch入门到精通2021最新教程</a> 讲师-吴磊</p>
<p>elasticsearch笔记链接：https://pan.baidu.com/s/1dvrgjdiwf09cOhBiL7ezWQ 
提取码：8888 
Elasticsearch大数据搜索引擎链接：https://pan.baidu.com/s/14Tc8c6ZXZLZ61i-rKLXxGQ 
提取码：8888 
第二版：Elasticsearch 24 道链接：https://pan.baidu.com/s/15DadWyGblRA1Tenn7JthEg 
提取码：8888</p>
<h2 id="数据高可用"><a class="header" href="#数据高可用">数据高可用</a></h2>
<p><img src="computer-science-notebook/database/assets/image-20210801094139464.png" alt="image-20210801094139464" /></p>
<p>高可用，就是数据冗余，elastic search 会进行数据冗余，副本分片是只读的，主要用来做搜索。</p>
<p><strong>集群健康值</strong></p>
<p>green-yellow-red</p>
<p>查看当前集群不健康的原因：<code>get _cluster/allocation/explain</code></p>
<p>灰色的分片，是因为我们只有一个节点，数据是不可能有副本的，这违背了高可用原则。</p>
<p>怎么把黄色告警删除？把这个索引的副本分片设置为 0:</p>
<pre><code class="language-json">put index_name/_settings
{
    &quot;number_of_replicas&quot;: 1
}
</code></pre>
<p><img src="computer-science-notebook/database/assets/image-20210801095253754.png" alt="image-20210801095253754" /></p>
<h2 id="index-shards-replicas"><a class="header" href="#index-shards-replicas">index, shards, replicas</a></h2>
<img src="computer-science-notebook/database/assets/image-20210801150652716.png" alt="image-20210801150652716" style="zoom:80%;" />
<p>elastic search 不能以 root 用户启动。</p>
<h2 id="基于canal的mysqles数据同步方案"><a class="header" href="#基于canal的mysqles数据同步方案">基于canal的MySQL=&gt;ES数据同步方案</a></h2>
<ol>
<li>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p><strong>canal [kə'næl]</strong>，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费</p>
<p>早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p>
</li>
<li>
<h3 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h3>
<p><code>Elasticsearch</code> 不支持<code>事务</code>。 ES通常在分布式系统架构中承担“搜索引擎”的角色，一般来说解决词类问题，可以把ES和支持ACID特性的关系型数据库结合起来使用。首先把对数据的更（增删改）操作在RDB中执行，然后把这些动作同步到<code>Elasticsearch</code>。 通过这种方式，你将受益于数据库 ACID 事务支持，并且在 Elasticsearch 中以正确的顺序产生变更。 并发在关系数据库中得到了处理。</p>
<p><strong>以<code>MySQL</code>为例，如果要把数据从同步至ES，<code>canal + binary log</code>就是常用的一种增量解决方案。</strong></p>
</li>
<li>
<h3 id="原理"><a class="header" href="#原理">原理</a></h3>
<p><img src="https://camo.githubusercontent.com/c26e367a6ffcce8ae6ecb39476a01bef14af6572124a6df050c4dc0c7f1074f3/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333038362f34363863316131342d653761642d333239302d396433642d3434616335303161373232372e6a7067" alt="img" /></p>
<h4 id="mysql主备复制原理"><a class="header" href="#mysql主备复制原理">MySQL主备复制原理</a></h4>
<ul>
<li>MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)</li>
<li>MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)</li>
<li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<h4 id="canal-工作原理"><a class="header" href="#canal-工作原理">canal 工作原理</a></h4>
<ul>
<li>
<p>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</p>
</li>
<li>
<p>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</p>
</li>
<li>
<p>canal 解析 binary log 对象(原始为 byte 流)</p>
<img src="https://img-blog.csdnimg.cn/img_convert/7138b15848a0e26bd84862cc01d0b03c.png" alt="image.png" style="zoom: 67%;" />
</li>
</ul>
</li>
<li>
<h3 id="优势"><a class="header" href="#优势">优势</a></h3>
<ul>
<li>准实时性</li>
<li>性能好</li>
<li>一劳永逸</li>
</ul>
</li>
<li>
<h3 id="玩法"><a class="header" href="#玩法">玩法</a></h3>
<ol>
<li>
<p><strong>环境</strong>：</p>
<p>​	<strong>Java和ES兼容性：https://www.elastic.co/cn/support/matrix#matrix_jvm</strong></p>
<ul>
<li>JDK：1.8</li>
<li>Elasticsearch：7.x</li>
<li>MySQL： 5.7</li>
<li>Canal： 1.1.4</li>
</ul>
</li>
<li>
<p><strong>下载：</strong></p>
<p>Github：				https://github.com/alibaba/canal/</p>
<p>Github 咻咻咻：	https://github.com/fhefh2015/Fast-GitHub</p>
</li>
<li>
<p><strong>步骤：</strong></p>
<ol>
<li>
<p>保证<code>Elasticsearch</code>服务可用</p>
</li>
<li>
<p>保证<code>MySQL</code>服务可用</p>
</li>
<li>
<p>开启MySQL的binary log（主备模式）</p>
<ul>
<li><strong>配置：</strong></li>
</ul>
<pre><code class="language-yaml">server_id = 1 #开启主从模式后每个MySQL节点的id
log-bin = mysql-bin #bin-log的存储位置
binlog-format = ROW #选择存储binlog日志方式为ROW模式
</code></pre>
<ul>
<li>
<p><strong>重启MySQL服务</strong></p>
</li>
<li>
<p><strong>验证是否开启成功</strong></p>
<pre><code class="language-mysql">SHOW VARIABLES LIKE 'log_bin';
log_bin	ON #开启
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>canal-deployer</code></p>
<ul>
<li>
<p>配置<code>conf/example/instance.properties</code></p>
<pre><code class="language-yaml">#canal示例的slaveId
canal.instance.mysql.slaveId=1234
#mysql地址
canal.instance.master.address= 127.0.0.1:3306
#用户名
canal.instance.dbUsername = root
#密码
canal.instance.dbPassword = 123456
#指定需要同步的数据库
canal.instance.defaultDatabaseName = msb_order
#指定编码方式
canal.instance.connectionCharset = UTF-8
#监控的是所有数据库，所有的表改动都会监控到，这样可能会浪费不少性能，可能我只想监控的是某一个数据库下的表。
#  .*\\..*表示监控所有数据库，canal\\..*表示监控canal数据库
canal.instance.filter.regex = .\*\\\\..\*
</code></pre>
</li>
<li>
<p>启动： ./startup.sh（Linux）</p>
</li>
<li>
<p>验证：demo</p>
</li>
</ul>
</li>
<li>
<p><code>canal-admin</code></p>
<ul>
<li>
<p>配置<code>conf/application.yml</code></p>
<pre><code class="language-yaml">server:
  port: 8089
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

spring.datasource:
  address: 127.0.0.1:3306
  database: canal_manager
  username: root
  password: 123456
  driver-class-name: com.mysql.jdbc.Driver
  url: jdbc:mysql://${spring.datasource.address}/${spring.datasource.database}?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false
  hikari:
    maximum-pool-size: 30
    minimum-idle: 1
canal:
  adminUser: admin
  adminPasswd: admin
</code></pre>
</li>
<li>
<p>启动管理服务</p>
</li>
<li>
<p>访问服务：<code>server_ip:8089</code></p>
</li>
</ul>
</li>
<li>
<p><code>canal-adapter</code></p>
<ul>
<li>配置<code>conf/application.yml</code></li>
</ul>
<pre><code class="language-yaml">server:
  port: 8081
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
    default-property-inclusion: non_null

canal.conf:
  mode: tcp #tcp kafka rocketMQ rabbitMQ
  flatMessage: true
  zookeeperHosts:
  syncBatchSize: 1000
  retries: 0
  timeout:
  accessKey:
  secretKey:
  consumerProperties:
    # canal tcp consumer
    canal.tcp.server.host: 127.0.0.1:11111
    canal.tcp.zookeeper.hosts:
    canal.tcp.batch.size: 500
    canal.tcp.username:
    canal.tcp.password:
    # kafka consumer
    kafka.bootstrap.servers: 127.0.0.1:9092
    kafka.enable.auto.commit: false
    kafka.auto.commit.interval.ms: 1000
    kafka.auto.offset.reset: latest
    kafka.request.timeout.ms: 40000
    kafka.session.timeout.ms: 30000
    kafka.isolation.level: read_committed
    kafka.max.poll.records: 1000
    # rocketMQ consumer
    rocketmq.namespace:
    rocketmq.namesrv.addr: 127.0.0.1:9876
    rocketmq.batch.size: 1000
    rocketmq.enable.message.trace: false
    rocketmq.customized.trace.topic:
    rocketmq.access.channel:
    rocketmq.subscribe.filter:
    # rabbitMQ consumer
    rabbitmq.host:
    rabbitmq.virtual.host:
    rabbitmq.username:
    rabbitmq.password:
    rabbitmq.resource.ownerId:

  srcDataSources:
    defaultDS:
      url: jdbc:mysql://127.0.0.1:3306/msb_order?useUnicode=true
      username: root
      password: 123456
  canalAdapters:
  - instance: example # canal instance Name or mq topic name
    groups:
    - groupId: g1
      outerAdapters:
      - name: logger
      - name: es7
        hosts: 127.0.0.1:9200 # 127.0.0.1:9200 for rest mode
        key: exampleKey
        properties:
          mode: rest # transport or rest
          # security.auth: test:123456 #  only used for rest mode
          cluster.name: elasticsearch
</code></pre>
<ul>
<li>配置<code>conf/es7/my_order.yml</code></li>
</ul>
<pre><code class="language-yaml">dataSourceKey: defaultDS        # 源数据源的key, 对应上面配置的srcDataSources中的值
outerAdapterKey: exampleKey     # 对应application.yml中es配置的key 
destination: example            # cannal的instance或者MQ的topic
groupId: g1                     # 对应MQ模式下的groupId, 只会同步对应groupId的数据_search
esMapping:
  _index: msb_order             # es 的索引名称
  _type: _doc					# es7 固定'_doc'，es8删除
  _id: _id                      # es 的_id, 如果不配置该项必须配置下面的pk项_id则会由es自动分配
  upsert: true
  sql: &quot;SELECT a.id as _id,	a.customer_phone, a.customer_name, a.customer_region, a.customer_city, a.customer_district, a.customer_addr, a.failure_phenomenon, a.failure_phenomenon_text, a.book_date, a.service_required, a.buyshop_detail, a.buy_shop, a.buy_way, a.product_type, a.model_no, a.process_type, a.ex_order_no, a.customer_country, a.source, a.matnr, a.buyDate, a.serviceReq, a.create_time, a.result, a.rvstatus, a.ip_address FROM msb_order_1 a&quot;
  commitBatch: 3000  
</code></pre>
<ul>
<li>服务启动</li>
<li>注意：
<ul>
<li>索引<code>msb_order</code>的mapping必须提前创建好</li>
<li>索引中的<code>id</code>字段是<code>_id</code>，因此需要查询的时候需要<code>id as _id</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>按时</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="搜索推荐词"><a class="header" href="#搜索推荐词">搜索推荐词</a></h2>
<p>Query Suggestion</p>
<img src="computer-science-notebook/database/assets/image-20210801160029394.png" alt="image-20210801160029394" style="zoom:80%;" />
<h2 id="过滤"><a class="header" href="#过滤">过滤</a></h2>
<p>filter 对结果进行过滤。filter 不会贡献相关性得分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logstash"><a class="header" href="#logstash">Logstash</a></h1>
<p>[TOC]</p>
<p>logstash 是一个管道！可以类比成 Linux 中的管道 <code>|</code>。</p>
<h2 id="logstash-introduction"><a class="header" href="#logstash-introduction">Logstash Introduction</a></h2>
<p>Logstash is an open source data collection engine with real-time pipelining capabilities. Logstash can dynamically unify data from disparate sources and normalize the data into destinations of your choice. Cleanse and democratize all your data for diverse advanced downstream analytics and visualization use cases.</p>
<p>While Logstash originally drove innovation in log collection, its capabilities extend well beyond that use case. Any type of event can be enriched and transformed with a broad array of input, filter, and output plugins, with many native codecs further simplifying the ingestion process. Logstash accelerates your insights by harnessing a greater volume and variety of data.</p>
<img align="left" src="computer-science-notebook/database/assets/image-20210812191337704.png" alt="image-20210812191337704" style="zoom:50%;" />
<h2 id="logstash-日志采集方案"><a class="header" href="#logstash-日志采集方案">Logstash 日志采集方案</a></h2>
<p>程序中集成 Logback 插件 LogstashTcpSocketAppender，将日志通过 tcp socket 推送给 Logstash。</p>
<p>缺点：侵入式，与代码耦合在一块了。不合适！</p>
<img align="left" src="computer-science-notebook/database/assets/image-20211106221133108.png" alt="image-20211106221133108" style="zoom: 67%;" />
<h2 id="filebeat"><a class="header" href="#filebeat">FileBeat</a></h2>
<p>elastic 开发的轻量级日志采集，非侵入式，可以直接配置对日志文件进行监听，不需要改源码，不和源码耦合。</p>
<p>FileBeat 顾名思义，文件的心跳，就是对文件进行监听！</p>
<p>FileBeat 的短板：只能有一个输出。</p>
<img align="left" src="computer-science-notebook/database/assets/image-20211106221756199.png" alt="image-20211106221756199" style="zoom: 80%;" />
<p>解决 FileBeat 只能有一个输出的短板：FileBeat 把消息送给 Kafka，其他应用再订阅 Kafka</p>
<img align="left" src="computer-science-notebook/database/assets/image-20211106222101175.png" alt="image-20211106222101175" style="zoom:80%;" />
<h2 id="服务器监控的三种数据"><a class="header" href="#服务器监控的三种数据">服务器监控的三种数据</a></h2>
<ul>
<li>
<p>指标监控 Monitor</p>
<p>CPU，内存，进程监控</p>
</li>
<li>
<p>链路监控 Tracing</p>
<p>业务相关的监控，常用于分布式系统的监控</p>
</li>
<li>
<p>日志采集 Logging</p>
</li>
</ul>
<h2 id="logstash-vs-prometheus"><a class="header" href="#logstash-vs-prometheus">Logstash vs Prometheus</a></h2>
<p>Logstash 更倾向于日志采集，Prometheus 更倾向于指标监控。</p>
<p>Kibana 和 Grafana 也是如此，Kibana 倾向于日志采集和分析，Grafana 倾向于监控。</p>
<h2 id="prometheus--grafana"><a class="header" href="#prometheus--grafana">Prometheus + Grafana</a></h2>
<p>支持多种 exporter 采集指标数据，支持 PushGateway 进行数据上报，Prometheus 性能足够支撑上万台规模的集群。</p>
<p>Prometheus 用于指标采集，Grafana 用于可视化。</p>
<img align="left" src="computer-science-notebook/database/assets/image-20211206140944696.png" alt="image-20211206140944696" style="zoom:80%;" />
<p>node-exporter 和 jmx-exporter 是额外安装到节点上的，用来进行监控。Prometheus 支持自定义 exporter。</p>
<p>TSDB（Time Series Database） 是时序数据库。</p>
<p>Prometheus 自带的常用的 exporter：</p>
<pre><code>node_exporter： Linux 类操作系统相关数据的采集程序
jmx_exporter: Java 进程指标采集程序
mysqld_exporter: MySQL server 数据采集程序
redis_exporter: Redis 数据采集程序
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle"><a class="header" href="#oracle">Oracle</a></h1>
<p>[TOC]</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="oracle-数据库远程登录"><a class="header" href="#oracle-数据库远程登录">Oracle 数据库远程登录</a></h3>
<pre><code>ip:
port:
服务名：
username:
passwd:
</code></pre>
<p>其中服务名就是数据库名。</p>
<h2 id="数据库配置"><a class="header" href="#数据库配置">数据库配置</a></h2>
<h3 id="查看数据库版本"><a class="header" href="#查看数据库版本">查看数据库版本</a></h3>
<pre><code class="language-sql">select * from v$version;

-- Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production
</code></pre>
<h2 id="建表语句"><a class="header" href="#建表语句">建表语句</a></h2>
<p>Oracle 不支持 id 自增的配置：auto_increment</p>
<p>也不支持 comment</p>
<p>以后写 SQL，尽量写兼容 Oracle 和 MySQL 的 SQL。</p>
<h2 id="数据库-sql-差异性-1"><a class="header" href="#数据库-sql-差异性-1">数据库 sql 差异性</a></h2>
<ul>
<li>
<p>Oracle sql 语句结尾不能加 <code>;</code></p>
</li>
<li>
<p>单引号和双引号的区别</p>
<p>在 sql 标准中，单引号表示字符串，双引号表示 identifiers，例如表名或者列名</p>
<pre><code class="language-sql">delete from 
  table_a 
where 
  id in (
    select 
      id 
    from 
      (select * from table_a) as table_a_copy 
      left join 
	  (select *, 'flag' as &quot;flag&quot; from table_b) as table_b_copy 
	  on 
	  table_a_copy.id = table_b_copy.cc 
    where 
      table_b_copy.flag is NULL
  );
</code></pre>
</li>
<li>
<p>Oracle 对 as 的兼容性不太好，不要用 as 了，as 类似于语法糖，不用也 ok 的</p>
<pre><code class="language-sql">select *, 'flag' flag from table_b
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-leetcode"><a class="header" href="#mysql-leetcode">MySQL-Leetcode</a></h1>
<p>MySQL-Demos</p>
<h2 id="second-highest-salary"><a class="header" href="#second-highest-salary">second-highest-salary</a></h2>
<p>难点：</p>
<ul>
<li>第二高薪水 (distinct + limit + offset)</li>
<li>如果没有则返回 NULL (outer select)</li>
</ul>
<pre><code class="language-sql">select 
    (
    select 
        distinct Salary 
    from 
        Employee
    order by
        Salary desc limit 1 offset 1
    ) 
as SecondHighestSalary;

-- or
SELECT max(Salary)
FROM Employee
WHERE Salary &lt; (SELECT max(Salary) FROM Employee)

-- bad answer
select 
    Salary as SecondHighestSalary
from 
    Employee
order by
    Salary desc limit 1 offset 1;
-- 如果没有第二高的薪水，则返回空 &quot;&quot;，使用 max 函数可以返回 NULL，outer select 在查询不到的时候也会返回空。如果第二高的薪水一定存在，则用 limit 最好
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他数据库产品"><a class="header" href="#其他数据库产品">其他数据库产品</a></h1>
<p>[TOC]</p>
<h2 id="国产数据库"><a class="header" href="#国产数据库">国产数据库</a></h2>
<h3 id="高斯"><a class="header" href="#高斯">高斯</a></h3>
<p>高斯数据库，基于 <em>PostgreSQL</em> 开发</p>
<h3 id="达梦"><a class="header" href="#达梦">达梦</a></h3>
<p>达梦数据库类似 Oracle</p>
<p>达梦数据库低版本不支持 Java 的 LocalDateTime </p>
<h3 id="金仓"><a class="header" href="#金仓">金仓</a></h3>
<p>类似 PostgreSQL</p>
<h2 id="开源数据库"><a class="header" href="#开源数据库">开源数据库</a></h2>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<p><em>PostgreSQL</em> 是应用最广泛的开源数据库</p>
<p>PostgreSQL 不允许创建名为 user 的表，user 在 PostgreSQL 中是一个保留字……</p>
<p>尽量不要将 column 重命名为 name，可以加 as</p>
<pre><code class="language-sql">❎ select a.name name from people a;
✔️ select a.name as name from people a;
</code></pre>
<p>postgresql 保留字段：user, status</p>
<h2 id="内存数据库"><a class="header" href="#内存数据库">内存数据库</a></h2>
<h3 id="redis"><a class="header" href="#redis">redis</a></h3>
<h3 id="h2"><a class="header" href="#h2">h2</a></h3>
<p>h2 的访问路径：http://localhost:8080/h2-console/login.do</p>
<h2 id="数据库比较"><a class="header" href="#数据库比较">数据库比较</a></h2>
<h3 id="mysql-独有的特性"><a class="header" href="#mysql-独有的特性">MySQL 独有的特性</a></h3>
<p>insert ignore: 主键重复则不插入</p>
<p>反引号：用来区分保留字</p>
<h3 id="mysql-vs-postgresql"><a class="header" href="#mysql-vs-postgresql">MySQL vs PostgreSQL</a></h3>
<p>MySQL</p>
<ul>
<li>数据库 varchar 能够接 Integer 类型</li>
<li>数据库 int 能够接 String 类型，传 3，3.1415926 都能自动接住，但是只能接住数字</li>
<li>Boolean 类型可以和 0，1 进行比较，可以存储 0 1</li>
</ul>
<p>PostgreSQL / 高斯数据库</p>
<ul>
<li>
<p>数据库 varchar 能够接住 Integer 类型，会自动做 cast</p>
</li>
<li>
<p>Boolean 类型不能和 0，1 进行比较</p>
</li>
<li>
<p>数据库 int 不能接 String 类型</p>
<p><img src="computer-science-notebook/database/assets/image-20211213080752162.png" alt="image-20211213080752162" /></p>
</li>
</ul>
<h3 id="字符字段大小写敏感"><a class="header" href="#字符字段大小写敏感">字符字段大小写敏感</a></h3>
<p>用 mysql 碰到这个问题，大小写不敏感。</p>
<img align="left" src="computer-science-notebook/database/assets/image-20220425162817212.png" alt="image-20220425162817212" style="zoom: 33%;" />
<p>查阅文档后 https://dev.mysql.com/doc/refman/8.0/en/case-sensitivity.html，发现 mysql 字符内容默认就是大小写不敏感，除非手动配置：</p>
<pre><code class="language-sql">ALTER TABLE nrcloud.users modify name varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '用户登录名';
</code></pre>
<p>For nonbinary strings (<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>TEXT</code></a>), string searches use the collation of the comparison operands. For binary strings (<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>BINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>BLOB</code></a>), comparisons use the numeric values of the bytes in the operands; this means that for alphabetic characters, comparisons are case-sensitive.</p>
<p>经测试，Oracle 和 Postgre 都是默认大小写敏感的，这好像是 mysql 独有的问题……</p>
<p>参考文献：</p>
<ul>
<li>https://dev.mysql.com/doc/refman/8.0/en/case-sensitivity.html</li>
<li>https://dev.mysql.com/doc/refman/8.0/en/create-table.html</li>
</ul>
<h3 id="postgresql-无法插入空字符串"><a class="header" href="#postgresql-无法插入空字符串">postgresql 无法插入空字符串</a></h3>
<p>如果插入空字符串，会被转成 null</p>
<h2 id="olap-数据库"><a class="header" href="#olap-数据库">OLAP 数据库</a></h2>
<h3 id="databend"><a class="header" href="#databend">Databend</a></h3>
<p>rust 开发的数据仓库，兼容 MySQL，国产</p>
<h2 id="数据同步"><a class="header" href="#数据同步">数据同步</a></h2>
<h3 id="datax"><a class="header" href="#datax">dataX</a></h3>
<p>不支持分布式</p>
<h3 id="seatunnel"><a class="header" href="#seatunnel">SeaTunnel</a></h3>
<p>海量数据的管道</p>
<p>和 logstash 类似，通过配置的方式（低代码），实现海量数据的同步。分布式特性。</p>
<p>SeaTunnel 对 Spark 和 Flink 做了一层包装。SeaTunnel 的日常使用，就是编辑配置文件，然后配置文件被 SeaTunnel 转换成具体的 Spark 或 Flink 任务。</p>
<p><img src="computer-science-notebook/database/assets/image-20220421191506205.png" alt="image-20220421191506205" /></p>
<h2 id="htap-数据库"><a class="header" href="#htap-数据库">HTAP 数据库</a></h2>
<p><em>HTAP</em>（Hybrid Transaction Analytical Processing）</p>
<p><em>HTAP</em>= OLTP +OLAP</p>
<p>HTAP 数据库代表：TiDB 全能数据库</p>
<p><a href="https://ossinsight.io/blog/why-we-choose-tidb-to-support-ossinsight/">why-we-choose-tidb-to-support-ossinsight</a></p>
<p><img src="computer-science-notebook/database/assets/how-different-db-handle-github-data-097746b55085a93fa36a6bfb7af4cb0b.png" alt="Simplified architecture after we use TiDB" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-data-intensive-app"><a class="header" href="#design-data-intensive-app">Design Data Intensive App</a></h1>
<p><a href="http://shop.oreilly.com/product/0636920032175.do">《Designing Data-Intensive Applications》</a>读书笔记，摘抄总结对我来说是盲点的知识。</p>
<p>[TOC]</p>
<h2 id="学习目的和总结"><a class="header" href="#学习目的和总结">学习目的和总结</a></h2>
<ul>
<li>了解主流数据库</li>
<li>结合业务场景进行技术选型</li>
<li>设计科学使用的 schema</li>
<li>掌握数据库出问题时候的科学解决思路</li>
</ul>
<p><strong>数据库选型</strong></p>
<table><thead><tr><th>需求</th><th>选型</th><th>备注</th></tr></thead><tbody>
<tr><td>schema 不确定，由外部系统决定；<br />存在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的；<br />应用程序经常需要访问整个文档（例如，将其渲染至网页）;</td><td>mongodb</td><td>例如医疗大数据中的处方，就适合用 mongodb 存储；mongodb 的单个是连续存储在磁盘上的，适合海量数据处理，OLAP。</td></tr>
<tr><td>一对一关系，一对多关系和少见的多对多关系</td><td>关系型数据库</td><td>mysql 是预先定义好 schema，一张表的数据可能存储在磁盘的不同位置，适合 online transaction processing（OLTP ）</td></tr>
<tr><td>多对多关系很常见</td><td>图数据模型</td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p><strong>数据库分类</strong></p>
<table><thead><tr><th>数据库类型</th><th>数据库产品</th><th>查询语言</th><th>应用场景</th></tr></thead><tbody>
<tr><td>关系型数据库</td><td>mysql</td><td>SQL</td><td></td></tr>
<tr><td>文档数据库</td><td>mongodb</td><td></td><td>数据通常是自我包含的，而且文档之间的关系非常稀少。</td></tr>
<tr><td>图形数据库</td><td>neo4j</td><td>Cypher</td><td>任意事物都可能与任何事物相关联。</td></tr>
<tr><td>搜索数据库</td><td>ES，Solr</td><td></td><td></td></tr>
</tbody></table>
<h2 id="知识点"><a class="header" href="#知识点">知识点</a></h2>
<ul>
<li>NoSQL：not only sql</li>
<li>MongoDB：被设计主要用来存储 json</li>
<li>SQL 是一种声明式查询语言，和注解、函数式编程一样都是声明式的</li>
<li>消息队列其实是一种代理，消息代理 Message Broker</li>
</ul>
<h2 id="第一章可靠性可伸缩性可维护性"><a class="header" href="#第一章可靠性可伸缩性可维护性">第一章：可靠性，可伸缩性，可维护性</a></h2>
<h3 id="关于数据系统的思考"><a class="header" href="#关于数据系统的思考">关于数据系统的思考</a></h3>
<p>数据系统可以分为以下几种：</p>
<ul>
<li>存储数据，以便自己或其他应用程序之后能再次找到 （<em><strong>数据库（database）</strong></em>）</li>
<li>记住开销昂贵操作的结果，加快读取速度（<em><strong>缓存（cache）</strong></em>）</li>
<li>允许用户按关键字搜索数据，或以各种方式对数据进行过滤（<em><strong>搜索索引（search indexes）</strong></em>）</li>
<li>向其他进程发送消息，进行异步处理（<em><strong>流处理（stream processing）</strong></em>）</li>
<li>定期处理累积的大批量数据（<em><strong>批处理（batch processing）</strong></em>）</li>
</ul>
<p><strong>数据库产品越来越全能了</strong>，不同数据库产品之间的界限越来越模糊，例如：<strong>数据存储可以被当成消息队列用（Redis）</strong>，<strong>消息队列则带有类似数据库的持久保证（Apache Kafka）</strong>。Elastic Search 既能做搜索，也能做存储。</p>
<p>其次，越来越多的应用程序有着各种严格而广泛的要求，单个工具不足以满足所有的数据处理和存储需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并通过应用代码将它们缝合起来。</p>
<p><img src="computer-science-notebook/database/assets/image-20210904111000407.png" alt="image-20210904111000407" /></p>
<p>本书着重讨论三个在大多数软件系统中都很重要的问题：</p>
<p><em><strong>可靠性（Reliability）</strong></em></p>
<p>​	系统在<strong>困境（adversity）</strong>（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。请参阅“<a href="computer-science-notebook/database/design-data-intensive-app.html#%E5%8F%AF%E9%9D%A0%E6%80%A7">可靠性</a>”。</p>
<p><em><strong>可伸缩性（Scalability）</strong></em></p>
<p>​	有合理的办法应对系统的增长（数据量、流量、复杂性）。请参阅“<a href="computer-science-notebook/database/design-data-intensive-app.html#%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7">可伸缩性</a>”。</p>
<p><em><strong>可维护性（Maintainability）</strong></em></p>
<p>​	许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。请参阅“<a href="computer-science-notebook/database/design-data-intensive-app.html#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7">可维护性</a>”。</p>
<p>​	人们经常追求这些词汇，却没有清楚理解它们到底意味着什么。为了工程的严谨性，本章的剩余部分将探讨可靠性、可伸缩性、可维护性的含义。为实现这些目标而使用的各种技术，架构和算法将在后续的章节中研究。</p>
<h3 id="可靠性"><a class="header" href="#可靠性">可靠性</a></h3>
<p>提高软件可靠性的措施</p>
<ul>
<li>将人们最容易犯错的地方与可能导致失效的地方<strong>解耦（decouple）</strong>。特别是提供一个功能齐全的非生产环境<strong>沙箱（sandbox）</strong>，使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。</li>
<li>快速迭代，敏捷开发，分批次发布新代码，以便任何意外错误只影响一小部分用户</li>
</ul>
<h2 id="第二章数据模型与查询语言"><a class="header" href="#第二章数据模型与查询语言">第二章：数据模型与查询语言</a></h2>
<h3 id="对象关系不匹配"><a class="header" href="#对象关系不匹配">对象关系不匹配</a></h3>
<p>目前大多数应用程序开发都使用面向对象的编程语言来开发，这导致了对SQL数据模型的普遍批评：如果数据存储在关系表中，那么需要一个<strong>笨拙的转换层</strong>，处于应用程序代码中的对象和表，行，列的数据库模型之间。模型之间的不连贯有时被称为<strong>阻抗不匹配（impedance mismatch）</strong><sup class="footnote-reference"><a href="#i">1</a></sup>。</p>
<div class="footnote-definition" id="i"><sup class="footnote-definition-label">1</sup>
<p>一个从电子学借用的术语。每个电路的输入和输出都有一定的阻抗（交流电阻）。当你将一个电路的输出连接到另一个电路的输入时，如果两个电路的输出和输入阻抗匹配，则连接上的功率传输将被最大化。阻抗不匹配会导致信号反射及其他问题。</p>
</div>
<p>像ActiveRecord和Hibernate这样的 <strong>对象关系映射（ORM object-relational mapping）</strong> 框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异。</p>
<h3 id="一对多多对多问题"><a class="header" href="#一对多多对多问题">一对多，多对多问题</a></h3>
<p>如果数据库本身不支持连接，则必须在应用程序代码中通过对数据库进行多个查询来模拟连接。（在这种情况中，地区和行业的列表可能很小，改动很少，应用程序可以简单地将其保存在内存中。不过，执行连接的工作从数据库被转移到应用程序代码上。</p>
<h3 id="静态-动态-schema"><a class="header" href="#静态-动态-schema">静态/ 动态 schema</a></h3>
<p>不同的数据库有不同的建 schema 的方式，主要可以分为两种：</p>
<ul>
<li>
<p><strong>读时模式（schema-on-read）</strong></p>
<p>schema 并不是预先定义的，数据的结构是隐含的，只有在数据被读取时才被解释，例如 mongodb。</p>
<p>类似于编程语言中的动态类型检查。</p>
</li>
<li>
<p><strong>写时模式（schema-on-write）</strong></p>
<p>schema 是预先定义好的。传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式。</p>
<p>类似于编程语言中的静态（编译时）类型检查。</p>
</li>
</ul>
<p>在应用程序想要改变其数据格式的情况下，这些方法之间的区别尤其明显。例如，假设你把每个用户的全名存储在一个字段中，而现在想分别存储名字和姓氏【23】。在文档数据库中，只需开始写入具有新字段的新文档，并在应用程序中使用代码来处理读取旧文档的情况。例如：</p>
<pre><code class="language-go">if (user &amp;&amp; user.name &amp;&amp; !user.first_name) {
	// Documents written before Dec 8, 2013 don't have first_name
	user.first_name = user.name.split(&quot; &quot;)[0];
}
</code></pre>
<p>另一方面，在“静态类型”数据库模式中，通常会执行以下 <strong>迁移（migration）</strong> 操作：</p>
<pre><code class="language-sql">ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1); 		-- PostgreSQL
UPDATE users SET first_name = substring_index(name, ' ', 1); 	-- MySQL
</code></pre>
<p>模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行<code>ALTER TABLE</code>语句。MySQL是一个值得注意的例外，它执行<code>ALTER TABLE</code>时会复制整个表，这可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机时间，尽管存在各种工具来解决这个限制【24,25,26】。</p>
<p>大型表上运行<code>UPDATE</code>语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将<code>first_name</code>设置为默认值<code>NULL</code>，并在读取时再填充，就像使用文档数据库一样。</p>
<p>当由于某种原因（例如，数据是异构的）集合中的项目并不都具有相同的结构时,读时模式更具优势。例如，如果：</p>
<ul>
<li>存在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的。</li>
<li>数据的结构由外部系统决定。你无法控制外部系统且它随时可能变化。</li>
</ul>
<p>在上述情况下，模式的坏处远大于它的帮助，无模式文档可能是一个更加自然的数据模型。但是，要是所有记录都具有相同的结构，那么模式是记录并强制这种结构的有效机制。第四章将更详细地讨论模式和模式演化。</p>
<h3 id="声明式查询语言-sql"><a class="header" href="#声明式查询语言-sql">声明式查询语言 SQL</a></h3>
<p>当引入关系模型时，关系模型包含了一种查询数据的新方法：SQL是一种 <strong>声明式</strong> 查询语言，而IMS和CODASYL使用 <strong>命令式</strong> 代码来查询数据库。那是什么意思？</p>
<p>许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，返回列表中的鲨鱼可以这样写：</p>
<pre><code class="language-js">function getSharks() {
    var sharks = [];
    for (var i = 0; i &lt; animals.length; i++) {
        if (animals[i].family === &quot;Sharks&quot;) {
            sharks.push(animals[i]);
        }
    }
    return sharks;
}
</code></pre>
<p>在关系代数中：
$$
sharks = σ_{family = &quot;sharks&quot;}(animals)
$$
σ（希腊字母西格玛）是选择操作符，只返回符合条件的动物，<code>family=&quot;shark&quot;</code>。</p>
<p>定义SQL时，它紧密地遵循关系代数的结构：</p>
<pre><code class="language-sql">SELECT * FROM animals WHERE family ='Sharks';
</code></pre>
<p>命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条件，更新变量，并决定是否再循环一遍。</p>
<p>在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合） - 但不是如何实现这一目标。数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。</p>
<p>声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行性能提升。</p>
<p>例如，在本节开头所示的命令代码中，动物列表以特定顺序出现。如果数据库想要在后台回收未使用的磁盘空间，则可能需要移动记录，这会改变动物出现的顺序。数据库能否安全地执行，而不会中断查询？</p>
<p>SQL示例不确保任何特定的顺序，因此不在意顺序是否改变。但是如果查询用命令式的代码来写的话，那么数据库就永远不可能确定代码是否依赖于排序。SQL相当有限的功能性为数据库提供了更多自动优化的空间。</p>
<p>最后，声明式语言往往适合并行执行。现在，CPU的速度通过核心(core)的增加变得更快，而不是以比以前更高的时钟速度运行【31】。命令代码很难在多个核心和多个机器之间并行化，因为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言的并行实现【32】。</p>
<h3 id="图数据模型"><a class="header" href="#图数据模型">图数据模型</a></h3>
<p>多对多关系是不同数据模型之间具有区别性的重要特征。如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。</p>
<p>但是，要是多对多关系在你的数据中很常见呢？关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。</p>
<p>一个图由两种对象组成：<strong>顶点（vertices）</strong>（也称为<strong>节点（nodes）</strong> 或<strong>实体（entities）</strong>），和<strong>边（edges）</strong>（ 也称为<strong>关系（relationships）<strong>或</strong>弧 （arcs）</strong> ）。多种数据可以被建模为一个图形。典型的例子包括：社交图谱，网络图谱，公路或铁路网络。</p>
<p>Cypher是属性图的声明式查询语言，为Neo4j图形数据库而发明【37】。</p>
<h3 id="sparql查询语言"><a class="header" href="#sparql查询语言">SPARQL查询语言</a></h3>
<p><strong>SPARQL</strong>是一种用于三元组存储的面向RDF数据模型的查询语言，【43】。（它是SPARQL协议和RDF查询语言的缩写，发音为“sparkle”。）SPARQL早于Cypher，并且由于Cypher的模式匹配借鉴于SPARQL，这使得它们看起来非常相似【37】。</p>
<p>与之前相同的查询 - 查找从美国转移到欧洲的人 - 使用SPARQL比使用Cypher甚至更为简洁（请参阅<a href="computer-science-notebook/database/">例2-9</a>）。</p>
<p><strong>例2-9 与示例2-4相同的查询，用SPARQL表示</strong></p>
<pre><code class="language-sparql">PREFIX : &lt;urn:example:&gt;
SELECT ?personName WHERE {
  ?person :name ?personName.
  ?person :bornIn  / :within* / :name &quot;United States&quot;.
  ?person :livesIn / :within* / :name &quot;Europe&quot;.
}
</code></pre>
<p>结构非常相似。以下两个表达式是等价的（SPARQL中的变量以问号开头）：</p>
<pre><code>(person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (location)   # Cypher
?person :bornIn / :within* ?location.                   # SPARQL
</code></pre>
<p>因为RDF不区分属性和边，而只是将它们作为谓语，所以可以使用相同的语法来匹配属性。在下面的表达式中，变量<code>usa</code>被绑定到任意具有值为字符串<code>&quot;United States&quot;</code>的<code>name</code>属性的顶点：</p>
<pre><code>(usa {name:'United States'})   # Cypher
?usa :name &quot;United States&quot;.    # SPARQL
</code></pre>
<p>SPARQL是一种很好的查询语言——哪怕语义网从未实现，它仍然可以成为一种应用程序内部使用的强大工具。</p>
<h2 id="第三章存储与检索"><a class="header" href="#第三章存储与检索">第三章：存储与检索</a></h2>
<p>存储引擎分为两大类：</p>
<ul>
<li>
<p><strong>日志结构（log-structured）</strong> 的存储引擎</p>
<p>只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个类别。</p>
</li>
<li>
<p><strong>面向页面（page-oriented）</strong> 的存储引擎</p>
<p>将磁盘视为一组可以覆写的固定大小的页面。 B树是这种哲学的典范，用在所有主要的关系数据库中和许多非关系型数据库。</p>
</li>
</ul>
<h3 id="最简单的数据库"><a class="header" href="#最简单的数据库">最简单的数据库</a></h3>
<p>世界上最简单的数据库可以用两个Bash函数实现：</p>
<pre><code class="language-bash">#!/bin/bash
db_set () {
	echo &quot;$1,$2&quot; &gt;&gt; database
}

db_get () {
	grep &quot;^$1,&quot; database | sed -e &quot;s/^$1,//&quot; | tail -n 1
}
</code></pre>
<p>这两个函数实现了键值存储的功能。执行 <code>db_set key value</code> ，会将 <strong>键（key）<strong>和</strong>值（value）</strong> 存储在数据库中。键和值（几乎）可以是你喜欢的任何东西，例如，值可以是JSON文档。然后调用 <code>db_get key</code> ，查找与该键关联的最新值并将其返回。</p>
<p>麻雀虽小，五脏俱全：</p>
<pre><code class="language-bash">$ db_set 123456 '{&quot;name&quot;:&quot;London&quot;,&quot;attractions&quot;:[&quot;Big Ben&quot;,&quot;London Eye&quot;]}' $ 

$ db_set 42 '{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Golden Gate Bridge&quot;]}'

$ db_get 42
{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Golden Gate Bridge&quot;]}
</code></pre>
<p>底层的存储格式非常简单：一个文本文件，每行包含一条逗号分隔的键值对（忽略转义问题的话，大致与CSV文件类似）。每次对 <code>db_set</code> 的调用都会向文件末尾追加记录，所以更新键的时候旧版本的值不会被覆盖 —— 因而查找最新值的时候，需要找到文件中键最后一次出现的位置（因此 <code>db_get</code> 中使用了 <code>tail -n 1 </code> 。)</p>
<pre><code class="language-bash">$ db_set 42 '{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Exploratorium&quot;]}' 

$ db_get 42
{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Exploratorium&quot;]}

$ cat database
123456,{&quot;name&quot;:&quot;London&quot;,&quot;attractions&quot;:[&quot;Big Ben&quot;,&quot;London Eye&quot;]}
42,{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Golden Gate Bridge&quot;]}
42,{&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Exploratorium&quot;]}
</code></pre>
<p><code>db_set</code> 函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与<code>db_set</code>做的事情类似，许多数据库在内部使用了<strong>日志（log）</strong>，也就是一个 <strong>仅追加（append-only）</strong> 的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志极其有用，我们还将在本书的其它部分重复见到它好几次。</p>
<blockquote>
<p><strong>日志（log）</strong> 这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更普遍的意义下使用<strong>日志</strong>这一词：一个仅追加的记录序列。它可能压根就不是给人类看的，使用二进制格式，并仅能由其他程序读取。</p>
</blockquote>
<p>另一方面，如果这个数据库中有着大量记录，则这个<code>db_get</code> 函数的性能会非常糟糕。每次你想查找一个键时，<code>db_get</code> 必须从头到尾扫描整个数据库文件来查找键的出现。用算法的语言来说，查找的开销是 <code>O(n)</code> ：如果数据库记录数量 n 翻了一倍，查找时间也要翻一倍。这就不好了。</p>
<p>为了高效查找数据库中特定键的值，我们需要一个数据结构：<strong>索引（index）</strong>。本章将介绍一系列的索引结构，并它们进行对比。索引背后的大致思想是，保存一些额外的元数据作为路标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你也许需要不同的索引，建在数据的不同部分上。</p>
<p>索引是从主数据衍生的<strong>附加（additional）</strong> 结构。许多数据库允许添加与删除索引，这不会影响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通常都会减慢写入速度，因为每次写入数据时都需要更新索引。</p>
<p>这是存储系统中一个重要的权衡：**精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。**因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同时又不会引入超出必要开销的索引。</p>
<h3 id="数据仓库"><a class="header" href="#数据仓库">数据仓库</a></h3>
<p>OLTP系统往往对业务运作至关重要，因而通常会要求 <strong>高可用</strong> 与 <strong>低延迟</strong>。所以DBA会密切关注他们的OLTP数据库，他们通常不愿意让业务分析人员在OLTP数据库上运行临时分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时执行的事务的性能。</p>
<p>相比之下，数据仓库是一个独立的数据库，分析人员可以查询他们想要的内容而不影响OLTP操作【48】。数据仓库包含公司各种OLTP系统中所有的只读数据副本。从OLTP数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。将数据存入仓库的过程称为“<strong>抽取-转换-加载（ETL）</strong>”，如<a href="computer-science-notebook/database/img/fig3-8.png">图3-8</a>所示。</p>
<p><img src="computer-science-notebook/database/assets/image-20210905101115880.png" alt="image-20210905101115880" /></p>
<h2 id="第四章编码与演化"><a class="header" href="#第四章编码与演化">第四章：编码与演化</a></h2>
<h3 id="面临的问题"><a class="header" href="#面临的问题">面临的问题</a></h3>
<p>应用程序不可避免地随时间而变化。新产品的推出，对需求的深入理解，或者商业环境的变化，总会伴随着<strong>功能（feature）</strong> 的增增改改。<a href="computer-science-notebook/database/ch1.html">第一章</a>介绍了**可演化性(evolvability)**的概念：应该尽力构建能灵活适应变化的系统（请参阅“<a href="computer-science-notebook/database/ch1.html#%E5%8F%AF%E6%BC%94%E5%8C%96%E6%80%A7%EF%BC%9A%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96">可演化性：拥抱变化</a>”）。</p>
<p>在大多数情况下，修改应用程序的功能也意味着需要更改其存储的数据：可能需要使用新的字段或记录类型，或者以新方式展示现有数据。</p>
<p>我们在<a href="computer-science-notebook/database/ch2.html">第二章</a>讨论的数据模型有不同的方法来应对这种变化。关系数据库通常假定数据库中的所有数据都遵循一个模式：尽管可以更改该模式（通过模式迁移，即<code>ALTER</code>语句），但是在任何时间点都有且仅有一个正确的模式。相比之下，<strong>读时模式（schema-on-read）</strong>（或 <strong>无模式（schemaless）</strong>）数据库不会强制一个模式，因此数据库可以包含在不同时间写入的新老数据格式的混合（请参阅 “<a href="computer-science-notebook/database/ch2.html#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E7%81%B5%E6%B4%BB%E6%80%A7">文档模型中的模式灵活性</a>” ）。</p>
<p>当数据<strong>格式（format）</strong> 或<strong>模式（schema）</strong> 发生变化时，通常需要对应用程序代码进行相应的更改（例如，为记录添加新字段，然后修改程序开始读写该字段）。但在大型应用程序中，代码变更通常不会立即完成：</p>
<ul>
<li>对于 <strong>服务端（server-side）</strong> 应用程序，可能需要执行 <strong>滚动升级 （rolling upgrade）</strong> （也称为 <strong>阶段发布（staged rollout）</strong> ），一次将新版本部署到少数几个节点，检查新版本是否运行正常，然后逐渐部完所有的节点。这样无需中断服务即可部署新版本，为频繁发布提供了可行性，从而带来更好的可演化性。</li>
<li>对于 <strong>客户端（client-side）</strong> 应用程序，升不升级就要看用户的心情了。用户可能相当长一段时间里都不会去升级软件。</li>
</ul>
<p>这意味着，新旧版本的代码，以及新旧数据格式可能会在系统中同时共处。系统想要继续顺利运行，就需要保持<strong>双向兼容性</strong>：</p>
<p><em><strong>向后兼容 (backward compatibility)</strong></em></p>
<p>​	新代码可以读旧数据。</p>
<p><em><strong>向前兼容 (forward compatibility)</strong></em></p>
<p>​	旧代码可以读新数据。</p>
<p>向后兼容性通常并不难实现：新代码的作者当然知道由旧代码使用的数据格式，因此可以显示地处理它（最简单的办法是，保留旧代码即可读取旧数据）。</p>
<p>向前兼容性可能会更棘手，因为旧版的程序需要忽略新版数据格式中新增的部分。</p>
<p>本章中将介绍几种编码数据的格式，包括 JSON，XML，Protocol Buffers，Thrift和Avro。尤其将关注这些格式如何应对模式变化，以及它们如何对新旧代码数据需要共存的系统提供支持。然后将讨论如何使用这些格式进行数据存储和通信：在Web服务中，<strong>表述性状态传递（REST）<strong>和</strong>远程过程调用（RPC）</strong>，以及<strong>消息传递系统</strong>（如Actor和消息队列）。</p>
<h3 id="序列化和反序列化"><a class="header" href="#序列化和反序列化">序列化和反序列化</a></h3>
<p>程序通常（至少）使用两种形式的数据：</p>
<ol>
<li>在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）。</li>
<li>如果要将数据写入文件，或通过网络发送，则必须将其 <strong>编码（encode）</strong> 为某种自包含的字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数据结构完全不同。</li>
</ol>
<p>所以，需要在两种表示之间进行某种类型的翻译。 从内存中表示到字节序列的转换称为 <strong>编码（Encoding）</strong> （也称为<strong>序列化（serialization）<strong>或</strong>编组（marshalling）</strong>），反过来称为<strong>解码（Decoding）</strong>（<strong>解析（Parsing）</strong>，<strong>反序列化（deserialization）</strong>，<strong>反编组( unmarshalling）</strong>）。</p>
<hr />
<p>许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java有<code>java.io.Serializable</code> 【1】，Ruby有<code>Marshal</code>【2】，Python有<code>pickle</code>【3】等等。许多第三方库也存在，例如<code>Kryo for Java</code> 【4】。</p>
<p>这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：</p>
<ul>
<li>这类编码通常与特定的编程语言深度绑定，其他语言很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。</li>
<li>为了恢复相同对象类型的数据，解码过程需要<strong>实例化任意类</strong>的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程序解码任意的字节序列，他们就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码【6,7】。</li>
<li>在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。</li>
<li>效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。 例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】。</li>
</ul>
<p>因此，除非临时使用，采用语言内置编码通常是一个坏主意。</p>
<h3 id="通用编码json-xml-base64"><a class="header" href="#通用编码json-xml-base64">通用编码：json, xml, base64</a></h3>
<p>当我们谈到可以被多种编程语言读写的标准编码时，JSON和XML是最显眼的角逐者。它们广为人知，广受支持，也“广受憎恶”。 XML经常收到批评：过于冗长与且过份复杂【9】。 JSON的流行则主要源于（通过成为JavaScript的一个子集）Web浏览器的内置支持，以及相对于XML的简单性。 CSV是另一种流行的与语言无关的格式，尽管其功能相对较弱。</p>
<p>JSON，XML和CSV属于文本格式，因此具有人类可读性（尽管它们的语法是一个热门争议话题）。除了表面的语法问题之外，它们也存在一些微妙的问题：</p>
<ul>
<li><strong>数值（numbers）</strong> 的编码多有歧义之处。XML和CSV不能区分数字和字符串（除非引用一个外部模式）。 JSON虽然区分字符串与数值，但不区分整数和浮点数，而且不能指定精度。</li>
<li>当处理更大的数值时，这个问题显得尤为严重。例如大于$2^{53}$的整数无法使用IEEE 754双精度浮点数精确表示，因此在使用浮点数（例如JavaScript）的语言进行分析时，这些数字会变得不准确。 Twitter有一个关于大于$2^{53}$的数字的例子，它使用64位整数来标识每条推文。 Twitter API返回的JSON包含了两种推特ID，一种是JSON数值，另一种是十进制字符串，以避免JavaScript程序无法正确解析数字的问题【10】。</li>
<li>JSON和XML对Unicode字符串（即人类可读的文本）有很好的支持，但是它们不支持二进制数据（即不带 <strong>字符编码(character encoding)</strong> 的字节序列）。二进制串是很有用的功能，人们通过使用Base64将二进制数据编码为文本来绕过此限制。其特有的模式标识着这个值应当被解释为Base64编码的二进制数据。这种方案虽然管用，但比较Hacky，并且会增加三分之一的数据大小。</li>
<li>XML 【11】和 JSON 【12】都有可选的模式支持。这些模式语言相当强大，所以学习和实现起来都相当复杂。 XML模式的使用相当普遍，但许多基于JSON的工具才不会去折腾模式。对数据的正确解读（例如区分数值与二进制串）取决于模式中的信息，因此不使用XML/JSON模式的应用程序可能需要对相应的编码/解码逻辑进行硬编码。</li>
<li>CSV没有任何模式，因此每行和每列的含义完全由应用程序自行定义。如果应用程序变更添加了新的行或列，那么这种变更必须通过手工处理。 CSV也是一个相当模糊的格式（如果一个值包含逗号或换行符，会发生什么？）。尽管其转义规则已经被正式指定【13】，但并不是所有的解析器都正确的实现了标准。</li>
</ul>
<p>尽管存在这些缺陷，但JSON，XML和CSV对很多需求来说已经足够好了。它们很可能会继续流行下去，特别是作为数据交换格式来说（即将数据从一个组织发送到另一个组织）。在这种情况下，只要人们对格式是什么意见一致，格式有多美观或者效率有多高效就无所谓了。让不同的组织就这些东西达成一致的难度超过了绝大多数问题。</p>
<h3 id="消息代理"><a class="header" href="#消息代理">消息代理</a></h3>
<p>过去，**消息代理（Message Broker）**主要是TIBCO，IBM WebSphere和webMethods等公司的商业软件的秀场。最近像RabbitMQ，ActiveMQ，HornetQ，NATS和Apache Kafka这样的开源实现已经流行起来。我们将在<a href="computer-science-notebook/database/ch11.html">第十一章</a>中对它们进行更详细的比较。</p>
<p>详细的交付语义因实现和配置而异，但通常情况下，消息代理的使用方式如下：一个进程将消息发送到指定的队列或主题，代理确保将消息传递给那个队列或主题的一个或多个消费者或订阅者。在同一主题上可以有许多生产者和许多消费者。</p>
<p>一个主题只提供单向数据流。但是，消费者本身可能会将消息发布到另一个主题上（因此，可以将它们链接在一起，就像我们将在<a href="computer-science-notebook/database/ch11.html">第十一章</a>中看到的那样），或者发送给原始消息的发送者使用的回复队列（允许请求/响应数据流，类似于RPC）。</p>
<p>消息代理通常不会执行任何特定的数据模型 - 消息只是包含一些元数据的字节序列，因此您可以使用任何编码格式。如果编码是向后和向前兼容的，您可以灵活地对发布者和消费者的编码进行独立的修改，并以任意顺序进行部署。</p>
<p>如果消费者重新发布消息到另一个主题，则可能需要小心保留未知字段，以防止前面在数据库环境中描述的问题（<a href="computer-science-notebook/database/img/fig4-7.png">图4-7</a>）。</p>
<h2 id="第七章事务"><a class="header" href="#第七章事务">第七章：事务</a></h2>
<h3 id="是什么"><a class="header" href="#是什么">是什么</a></h3>
<p>事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。从概念上讲，事务中的所有读写操作被视作单个操作来执行：整个事务要么成功（<strong>提交（commit）</strong>）要么失败（<strong>中止（abort）</strong>，<strong>回滚（rollback）</strong>）。如果失败，应用程序可以安全地重试。对于事务来说，应用程序的错误处理变得简单多了，因为它不用再担心部分失败的情况了，即某些操作成功，某些失败（无论出于何种原因）。</p>
<p>2000 年以后，非关系（NoSQL）数据库开始普及。它们的目标是在关系数据库的现状基础上，通过提供新的数据模型选择（请参阅<a href="computer-science-notebook/database/ch2.html">第二章</a>）并默认包含复制（第五章）和分区（第六章）来进一步提升。事务是这次运动的主要牺牲品：这些新一代数据库中的许多数据库完全放弃了事务，或者重新定义了这个词，描述比以前所理解的更弱得多的一套保证【4】。</p>
<p>随着这种新型分布式数据库的炒作，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务以保持良好的性能和高可用性【5,6】。另一方面，数据库厂商有时将事务保证作为“重要应用”和“有价值数据”的基本要求。这两种观点都是<strong>纯粹的夸张</strong>。</p>
<h3 id="acid"><a class="header" href="#acid">ACID</a></h3>
<h4 id="原子性atomicity"><a class="header" href="#原子性atomicity">原子性（Atomicity）</a></h4>
<p><strong>all-or-nothing</strong></p>
<p>一般来说，原子是指不能分解成小部分的东西。这个词在计算机的不同领域中意味着相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。系统只能处于操作之前或操作之后的状态，而不是介于两者之间的状态。</p>
<p>相比之下，ACID的原子性并<strong>不</strong>是关于 <strong>并发（concurrent）</strong> 的。它并不是在描述如果几个进程试图同时访问相同的数据会发生什么情况，这种情况包含在缩写 <em><strong>I</strong></em> 中，即<a href="computer-science-notebook/database/design-data-intensive-app.html#%E9%9A%94%E7%A6%BB%E6%80%A7"><strong>隔离性</strong></a>。</p>
<p>ACID的原子性描述了当客户想进行多次写入，但在一些写操作处理完之后出现故障的情况。例如进程崩溃，网络连接中断，磁盘变满或者某种完整性约束被违反。如果这些写操作被分组到一个原子事务中，并且该事务由于错误而不能完成（提交），则该事务将被中止，并且数据库必须丢弃或撤消该事务中迄今为止所做的任何写入。</p>
<p>如果没有原子性，在多处更改进行到一半时发生错误，很难知道哪些更改已经生效，哪些没有生效。该应用程序可以再试一次，但冒着进行两次相同变更的风险，可能会导致数据重复或错误的数据。原子性简化了这个问题：如果事务被<strong>中止（abort）</strong>，应用程序可以确定它没有改变任何东西，所以可以安全地重试。</p>
<p>ACID原子性的定义特征是：<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。</strong> 或许 <strong>可中止性（abortability）</strong> 是更好的术语，但本书将继续使用原子性，因为这是惯用词。</p>
<h4 id="隔离性isolation"><a class="header" href="#隔离性isolation">隔离性（Isolation）</a></h4>
<p>大多数数据库都会同时被多个客户端访问。如果它们各自读写数据库的不同部分，这是没有问题的，但是如果它们访问相同的数据库记录，则可能会遇到<strong>并发</strong>问题（<strong>竞争条件（race conditions）</strong>）。</p>
<p><a href="computer-science-notebook/database/img/fig7-1.png">图7-1</a>是这类问题的一个简单例子。假设你有两个客户端同时在数据库中增长一个计数器。（假设数据库没有内建的自增操作）每个客户端需要读取计数器的当前值，加 1 ，再回写新值。<a href="computer-science-notebook/database/img/fig7-1.png">图7-1</a> 中，因为发生了两次增长，计数器应该从42增至44；但由于竞态条件，实际上只增至 43 。</p>
<p>ACID意义上的隔离性意味着，<strong>同时执行的事务是相互隔离的</strong>：它们不能相互冒犯。传统的数据库教科书将隔离性形式化为<strong>可串行化（Serializability）</strong>，这意味着每个事务可以假装它是唯一在整个数据库上运行的事务。数据库确保当多个事务被提交时，结果与它们串行运行（一个接一个）是一样的，尽管实际上它们可能是并发运行的【10】。</p>
<p><img src="computer-science-notebook/database/assets/image-20210905160525545.png" alt="image-20210905160525545" /></p>
<h4 id="持久性durability"><a class="header" href="#持久性durability">持久性（Durability）</a></h4>
<p>数据库系统的目的是，提供一个安全的地方存储数据，而不用担心丢失。<strong>持久性</strong> 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<h3 id="脏读写"><a class="header" href="#脏读写">脏读/写</a></h3>
<p>回顾一下，在ACID中，原子性和隔离性描述了客户端在同一事务中执行多次写入时，数据库应该做的事情：</p>
<p><em><strong>原子性</strong></em></p>
<p>如果在一系列写操作的中途发生错误，则应中止事务处理，并丢弃当前事务的所有写入。换句话说，数据库免去了用户对部分失败的担忧——通过提供“<strong>宁为玉碎，不为瓦全（all-or-nothing）</strong>”的保证。</p>
<p><em><strong>隔离性</strong></em></p>
<p>同时运行的事务不应该互相干扰。例如，如果一个事务进行多次写入，则另一个事务要么看到全部写入结果，要么什么都看不到，但不应该是一些子集。</p>
<p>这些定义假设你想同时修改多个对象（行，文档，记录）。通常需要<strong>多对象事务（multi-object transaction）</strong> 来保持多块数据同步。<a href="computer-science-notebook/database/img/fig7-2.png">图7-2</a>展示了一个来自电邮应用的例子。执行以下查询来显示用户未读邮件数量：</p>
<pre><code class="language-sql">SELECT COUNT（*）FROM emails WHERE recipient_id = 2 AND unread_flag = true
</code></pre>
<p>但如果邮件太多，你可能会觉得这个查询太慢，并决定用单独的字段存储未读邮件的数量（一种反规范化）。现在每当一个新消息写入时，必须也增长未读计数器，每当一个消息被标记为已读时，也必须减少未读计数器。</p>
<p>在<a href="computer-science-notebook/database/img/fig7-2.png">图7-2</a>中，用户2 遇到异常情况：邮件列表里显示有未读消息，但计数器显示为零未读消息，因为计数器增长还没有发生<sup class="footnote-reference"><a href="#ii">2</a></sup>。隔离性可以避免这个问题：通过确保用户2 要么同时看到新邮件和增长后的计数器，要么都看不到。反正不会看到执行到一半的中间结果。</p>
<div class="footnote-definition" id="ii"><sup class="footnote-definition-label">2</sup>
<p>可以说邮件应用中的错误计数器并不是什么特别重要的问题。但换种方式来看，你可以把未读计数器换成客户账户余额，把邮件收发看成支付交易。</p>
</div>
<p><img src="computer-science-notebook/database/assets/fig7-2.png" alt="脏读" /></p>
<p>脏读我的理解：批处理处理了一半，程序出异常了，数据库中存在了很多脏数据，如果读取了这些脏数据，则为脏读。如何解决脏读的问题：重要的业务采用事务进行处理。</p>
<p><strong>图7-2 违反隔离性：一个事务读取另一个事务的未被执行的写入（“脏读”）。</strong></p>
<p><a href="computer-science-notebook/database/img/fig7-3.png">图7-3</a>说明了对原子性的需求：如果在事务过程中发生错误，邮箱和未读计数器的内容可能会失去同步。在原子事务中，如果对计数器的更新失败，事务将被中止，并且插入的电子邮件将被回滚。</p>
<p><img src="computer-science-notebook/database/assets/fig7-3.png" alt="" /></p>
<p><strong>图7-3 原子性确保发生错误时，事务先前的任何写入都会被撤消，以避免状态不一致</strong></p>
<p>多对象事务需要某种方式来确定哪些读写操作属于同一个事务。在关系型数据库中，通常基于客户端与数据库服务器的TCP连接：在任何特定连接上，<code>BEGIN TRANSACTION</code> 和 <code>COMMIT</code> 语句之间的所有内容，被认为是同一事务的一部分.<sup class="footnote-reference"><a href="#iii">3</a></sup></p>
<p><em><strong>脏写</strong></em></p>
<p>​	一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-3"><a class="header" href="#questions-3">Questions</a></h1>
<ul>
<li>Innodb 引擎建立索引的方法是什么，其优化的目标是什么</li>
<li>为什么大多数表都将主键设置为自增长的 Integer 类型</li>
<li>MySQL 索引分哪两大类，具体有哪几小类</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="密码学"><a class="header" href="#密码学">密码学</a></h1>
<p>Cryptography </p>
<p>[TOC]</p>
<h2 id="reference"><a class="header" href="#reference">reference</a></h2>
<p><a href="https://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰-密码学笔记</a></p>
<h2 id="加密-demo"><a class="header" href="#加密-demo">加密 demo</a></h2>
<h3 id="demo1"><a class="header" href="#demo1">demo1</a></h3>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211205205142481.png" alt="image-20211205205142481" style="zoom:67%;" />
<p>对称加密，密钥只能由加密方和解密方持有，不能公开。身份证就是密钥。</p>
<h3 id="资料加密-demo"><a class="header" href="#资料加密-demo">资料加密 demo</a></h3>
<pre><code>解压缩密码为 4 个字符，为了防止答案泄露，辛苦大家把手头的资料作为字典，查找一下这几个字符：

****

第一个字符：第一本资料，最后一页的那个题目题号的第一个数字
第二个字符：第一本资料，页码第 1 页的第一个字母的小写
第三个字符：第二本资料，页码第 156 页，我提到的第一款电脑游戏的第二个字母，小写
第四个字符：南航计算机考8?9，填写中间的那个数字
</code></pre>
<h2 id="对称加密--单钥加密"><a class="header" href="#对称加密--单钥加密">对称加密 / 单钥加密</a></h2>
<p>对称密钥，采用单钥加密，加密和解密都用一个密钥。</p>
<p>常见的单钥加密算法：</p>
<ul>
<li>DES（Data Encryption Standard）</li>
<li>AES</li>
<li>SM4 商密</li>
</ul>
<h2 id="非对称加密--双钥加密"><a class="header" href="#非对称加密--双钥加密">非对称加密 / 双钥加密</a></h2>
<p>双钥加密，加密和解密的密钥不同。</p>
<p>常见的双钥加密算法：</p>
<ul>
<li>RSA（ Rivest-Shamir-Adleman）</li>
<li>DSA（Digital Signature Algorithm）</li>
<li>SM2 商密2</li>
</ul>
<p>公钥可以解密私钥加密的数据，私钥也可以解密公钥加密的数据。私钥加密也叫做签名，私钥只有本人拥有，具有唯一性（注意摘要和签名是两回事）。</p>
<p>公钥用来做加密信息，私钥用来做数字签名。通常用 hash 函数生成摘要，然后再用私钥对摘要进行数字签名。</p>
<p>因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的<a href="https://www.verisign.com/">Verisign</a>公司，它的主要业务就是分发RSA数字证书。</p>
<h3 id="生成公钥私钥"><a class="header" href="#生成公钥私钥">生成公钥私钥</a></h3>
<p>生成属于自己的公钥和私钥</p>
<pre><code class="language-shell">ssh-keygen

# 指定密钥的加密算法，通常会选择 dsa 或 rsa 算法
ssh-keygen -t dsa

# -t 选择加密算法
# -b 设置密钥长度
# -C 设置密钥文件的注释
ssh-keygen -t rsa -b 4096 -C &quot;your_email@domain.com&quot;

# -f 指定生成的文件名，生成 mykey 和 mykey.pub
ssh-keygen -t dsa -f mykey
c
# 检查某个主机名是否在 known_hosts 中
ssh-keygen -F example.com

# 将服务器的公钥指纹移出 known_hosts
ssh-keygen -R example.com
</code></pre>
<h3 id="用公钥加密文件"><a class="header" href="#用公钥加密文件">用公钥加密文件</a></h3>
<p>convert your ssh public key to PEM format. 将公钥转换 pem 格式。</p>
<pre><code class="language-shell">ssh-keygen -f ~/.ssh/id_rsa.pub -e -m PKCS8 &gt; id_rsa.pem.pub

# -f filename: Specifies the filename of the key file.

# -e export: This option will read a private or public OpenSSH key file and print to stdout a public key in one of the formats specified by the -m option.  The default export format is “RFC4716”.  This option allows exporting OpenSSH keys for use by other programs, including several commercial SSH implementations.

# -m key_format: Specify a key format for key generation, the -i (import), -e (export) conversion options, and the -p change passphrase operation.  The latter may be used to convert between OpenSSH private key and PEM private key formats. The supported key formats are: “RFC4716” (RFC 4716/SSH2public or private key), “PKCS8” (PKCS8 public or private key) or “PEM” (PEM public key).  By default OpenSSH will write newly-generated private keys in its own format, but when converting public keys for export the default format is “RFC4716”.  Setting a format of “PEM” when generating or updating a supported private key type will cause the key to be stored in the legacy PEM private key format.

# PEM: Privacy Enhanced Mail 的缩写，一种非常常见的数字证书和密钥的容器格式。PEM格式的私钥将具有扩展名 .key 和页眉和页脚：
# -----BEGIN RSA PRIVATE KEY----- 以及 -----END RSA PRIVATE KEY-----

</code></pre>
<p>ssh-keygen 只能用来生成密钥，想要加密的话，需要用 openssl，里面封装了很多密码学的工具。</p>
<pre><code class="language-shell">openssl rsautl -encrypt -pubin -inkey id_rsa.pem.pub -ssl -in myMessage.txt -out myEncryptedMessage.txt

# The rsautl command can be used to sign, verify, encrypt and decrypt data using the RSA algorithm.

# -pubin: The input file is an RSA public key.

# -inkey file: The input key file; by default an RSA private key.

# -in file: The input file to read from, or standard input if not specified.

# -out file: The output file to write to, or standard output if not specified.

# -ssl: use SSL v2 padding

</code></pre>
<p>对加密后的文本，用私钥解密</p>
<pre><code class="language-shell">openssl rsautl -decrypt -inkey ~/.ssh/id_rsa -in myEncryptedMessage.txt -out myDecryptedMessage.txt
</code></pre>
<h2 id="message-digest"><a class="header" href="#message-digest">Message Digest</a></h2>
<p>hash 算法通常用于生成消息的<strong>摘要</strong>，这个摘要能代表这个消息，是独一无二的。hash 函数是不可逆的。</p>
<p>摘要类似于一个人的身份证号，给一个人进行 hash，生成一个独一无二的身份证号。</p>
<p>作用：</p>
<ul>
<li>用于表示这条消息没有被修改过</li>
<li>单向加密，例如用户密码存储</li>
</ul>
<p>常见的 hash 函数：</p>
<ul>
<li>MD5（Message Digest）</li>
<li>SM3 商密</li>
<li>SHA 家族（Secure Hash Algorithm）</li>
</ul>
<h2 id="openssl"><a class="header" href="#openssl">OpenSSL</a></h2>
<p><a href="https://www.openssl.net.cn/">OpenSSL 中文手册</a></p>
<p>Secure Sockets Layer. OpenSSL 是一个安全工具箱。</p>
<p>The OpenSSL Project develops and maintains the OpenSSL software - a robust, commercial-grade, full-featured toolkit for general-purpose cryptography and secure communication. </p>
<p>openssl 包含的工具：</p>
<pre><code>标准命令
Standard commands
asn1parse         ca                ciphers           cms
crl               crl2pkcs7         dgst              dh
dhparam           dsa               dsaparam          ec
ecparam           enc               engine            errstr
gendh             gendsa            genpkey           genrsa
nseq              ocsp              passwd            pkcs12
pkcs7             pkcs8             pkey              pkeyparam
pkeyutl           prime             rand              req
rsa               rsautl            s_client          s_server
s_time            sess_id           smime             speed
spkac             ts                verify            version
x509

签名命令
Message Digest commands (see the `dgst' command for more details)
md2               md4               md5               rmd160
sha               sha1

加密命令
Cipher commands (see the `enc' command for more details) 
aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb
aes-256-cbc       aes-256-ecb       base64            bf
bf-cbc            bf-cfb            bf-ecb            bf-ofb
camellia-128-cbc  camellia-128-ecb  camellia-192-cbc  camellia-192-ecb
camellia-256-cbc  camellia-256-ecb  cast              cast-cbc
cast5-cbc         cast5-cfb         cast5-ecb         cast5-ofb
des               des-cbc           des-cfb           des-ecb
des-ede           des-ede-cbc       des-ede-cfb       des-ede-ofb
des-ede3          des-ede3-cbc      des-ede3-cfb      des-ede3-ofb
des-ofb           des3              desx              idea
idea-cbc          idea-cfb          idea-ecb          idea-ofb
rc2               rc2-40-cbc        rc2-64-cbc        rc2-cbc
rc2-cfb           rc2-ecb           rc2-ofb           rc4
rc4-40            rc5               rc5-cbc           rc5-cfb
rc5-ecb           rc5-ofb           seed              seed-cbc
seed-cfb          seed-ecb          seed-ofb          zlib
</code></pre>
<p>查看每个命令具体怎么使用：</p>
<pre><code class="language-shell">openssl rasutil --help
</code></pre>
<h3 id="standard-commands"><a class="header" href="#standard-commands">standard commands</a></h3>
<p>标准命令</p>
<h3 id="message-digest-commands"><a class="header" href="#message-digest-commands">message digest commands</a></h3>
<h3 id="cipher-commands"><a class="header" href="#cipher-commands">cipher commands</a></h3>
<p>加密命令</p>
<p>base64 加密</p>
<pre><code class="language-shell">openssl base64 -in crypt-test.txt -out test.txt
</code></pre>
<h2 id="数字签名与数字证书"><a class="header" href="#数字签名与数字证书">数字签名与数字证书</a></h2>
<p>数字签名，重点在于签名二字，不在数字。签名，顾名思义，就是证明这份文件是我的。</p>
<p>那么数字签名，是怎么证明，这个文件是我的呢，不是被人掉包过的，或者改动过的呢？</p>
<p>甲写了一个文档，用 md5 生成摘要，md5 只能保证文档没有被修改过，如果只把文档和摘要发送给乙的话，不能证明这个文档没有被掉包。</p>
<p>那么怎么证明文档没有被掉包呢，证明文件是甲的呢，这就需要对文件进行签名了，生活中我们用笔给文件进行签名，在虚拟世界，我们用私钥给文件进行签名，因为 md5 摘要可以完全代表这个文档，我们只需要用私钥对 md5 摘要进行加密签名就可以了，然后把这个签名和文档一起发给乙。</p>
<p>乙收到文档和签名后，用甲给的公钥解密签名，得到 md5 摘要，然后再用 md5 算法计算文档摘要，如果两个摘要一样，说明这个文档确实是甲发的，而且内容没有被改过。</p>
<p>但是数字签名还是有漏洞的，乙全程持有的都是甲的公钥，如果这个公钥被偷换成了丙的公钥，那么丙就可以冒充甲。</p>
<p>那么怎么证明乙持有的公钥就是甲的公钥呢？这就需要一个公正处（certificate authority，简称CA）来公证了，每次都从公证处获取甲的公钥，然后再解密。这样乙就不要总是持有甲的公钥了。</p>
<p>证书中心用自己的私钥，对甲的公钥和甲的相关信息进行签名，生成甲的数字证书。然后把文档 + 数字签名 + 数字证书一起发给乙。乙收到后，用证书中心的公钥，对数字证书进行解密，获取里面包含的甲的公钥，就能保证公钥的安全了。</p>
<p><img src="computer-science-notebook/cryptography-web-security/assets/image-20211115084236450.png" alt="image-20211115084236450" /></p>
<h2 id="查表备忘"><a class="header" href="#查表备忘">查表备忘</a></h2>
<h3 id="pkcs"><a class="header" href="#pkcs">PKCS</a></h3>
<p>The Public-Key Cryptography Standards (PKCS) 公钥密码学标准</p>
<table><thead><tr><th>PKCS</th><th>版本</th><th>介绍</th><th>详解</th></tr></thead><tbody>
<tr><td><a href="https://zh.wikipedia.org/w/index.php?title=PKCS_1&amp;action=edit&amp;redlink=1">PKCS #1</a></td><td>2.1</td><td>RSA密码编译标准（RSA Cryptography Standard）</td><td>定义了RSA的数理基础、公/私钥格式，以及加/解密、签/验章的流程。1.5版本曾经遭到攻击[<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A0%87%E5%87%86#cite_note-1">1]</a>。</td></tr>
<tr><td>PKCS #2</td><td>-</td><td><em>弃用</em></td><td>原本是用以规范RSA加密摘要的转换方式，现已被纳入PKCS#1之中。</td></tr>
<tr><td>PKCS #3</td><td>1.4</td><td><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">DH密钥协议</a>标准（Diffie-Hellman key agreement Standard）</td><td>规范以DH密钥协议为基础的密钥协议标准。其功能，可以让两方透过金议协议，拟定一把会议密钥(Session key)。</td></tr>
<tr><td>PKCS #4</td><td>-</td><td><em>弃用</em></td><td>原本用以规范转换RSA密钥的流程。已被纳入PKCS#1之中。</td></tr>
<tr><td>PKCS #5</td><td>2.0</td><td>密码基植加密标准（Password-based Encryption Standard）</td><td>参见RFC 2898与<a href="https://zh.wikipedia.org/w/index.php?title=PBKDF2&amp;action=edit&amp;redlink=1">PBKDF2</a>。</td></tr>
<tr><td>PKCS #6</td><td>1.5</td><td>证书扩展语法标准（Extended-Certificate Syntax Standard）</td><td>将原本X.509的证书格式标准加以扩展。</td></tr>
<tr><td>PKCS #7</td><td>1.5</td><td>密码消息语法标准（Cryptographic Message Syntax Standard）</td><td>参见RFC 2315。规范了以<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E8%A8%AD%E6%96%BD&amp;action=edit&amp;redlink=1">公开密钥基础设施</a>（PKI）所产生之签名/密文之格式。其目的一样是为了拓展数字证书的应用。其中，包含了<a href="https://zh.wikipedia.org/wiki/S/MIME">S/MIME</a>与<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%86%E7%A2%BC%E8%A8%8A%E6%81%AF%E8%AA%9E%E6%B3%95&amp;action=edit&amp;redlink=1">CMS</a>。</td></tr>
<tr><td><a href="https://zh.wikipedia.org/w/index.php?title=PKCS_8&amp;action=edit&amp;redlink=1">PKCS #8</a></td><td>1.2</td><td>私钥消息表示标准（Private-Key Information Syntax Standard）.</td><td>Apache读取证书私钥的标准。</td></tr>
<tr><td>PKCS #9</td><td>2.0</td><td>选择属性格式（Selected Attribute Types）</td><td>定义PKCS#6、7、8、10的选择属性格式。</td></tr>
<tr><td><a href="https://zh.wikipedia.org/w/index.php?title=PKCS_10&amp;action=edit&amp;redlink=1">PKCS #10</a></td><td>1.7</td><td>证书申请标准（Certification Request Standard）</td><td>参见RFC 2986。规范了向证书中心申请证书之CSR（certificate signing request）的格式。</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/PKCS11">PKCS #11</a></td><td>2.20</td><td>密码设备标准接口（Cryptographic Token Interface (Cryptoki)）</td><td>定义了密码设备的应用程序接口（API）之规格。</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/PKCS_12">PKCS #12</a></td><td>1.0</td><td>个人消息交换标准（Personal Information Exchange Syntax Standard）</td><td>定义了包含私钥与<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89">公钥证书</a>（public key certificate）的文件格式。私钥采密码(password)保护。常见的PFX就履行了PKCS#12。</td></tr>
<tr><td>PKCS #13</td><td>–</td><td><a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6">椭圆曲线密码学</a>标准（Elliptic curve cryptography Standard）</td><td>制定中。规范以椭圆曲线密码学为基础所发展之密码技术应用。椭圆曲线密码学是新的密码学技术，其强度与效率皆比现行以指数运算为基础之密码学算法来的优秀。然而，该算法的应用尚不普及。</td></tr>
<tr><td>PKCS #14</td><td>–</td><td><a href="https://zh.wikipedia.org/w/index.php?title=%E6%93%AC%E4%BA%82%E6%95%B8%E7%94%A2%E7%94%9F%E5%99%A8&amp;action=edit&amp;redlink=1">拟随机数产生器</a>标准（Pseudo-random Number Generation）</td><td>制定中。规范拟随机数产生器的使用与设计。</td></tr>
<tr><td>PKCS #15</td><td>1.1</td><td>密码设备消息格式标准（Cryptographic Token Information Format Standard）</td><td>定义了密码设备内部数据的组织结构。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssh"><a class="header" href="#ssh">SSH</a></h1>
<p>[TOC]</p>
<p><a href="https://wangdoc.com/ssh/">阮一峰 SSH 教程</a></p>
<h2 id="我的理解"><a class="header" href="#我的理解">我的理解</a></h2>
<ul>
<li>
<p>公钥用来加密，账户密码登录 server 就是用的 server 的公钥</p>
</li>
<li>
<p>私钥用来签名，免密登录 server 就是用的 client 的私钥</p>
</li>
<li>
<p><code>.ssh/</code> 下的所有文件释义</p>
<pre><code>* id_rsa 用 rsa 算法生成的私钥
* id_rsa.pub 用 rsa 算法生成的公钥
* know_hosts client 所有，保存登录 server 时，存储的 server 的公钥
* authorized_keys server 所有，保存免密登录时，上传到 server 的公钥
</code></pre>
</li>
</ul>
<h2 id="基本知识"><a class="header" href="#基本知识">基本知识</a></h2>
<p>SSH 主要用于<strong>远程登录</strong>。由于采用 SSH 进行通信的客户端和服务端，使用了非对称加密加密了通话内容，所以 SSH 是 Secured 的</p>
<p>SSH（<strong>Secure</strong> Shell 的缩写）是一种网络协议，用于<strong>加密</strong>两台计算机之间的<strong>通信</strong>，并且支持各种<strong>身份验证</strong>机制。SSH 是协议，ssh 是基于 SSH 实现的软件。</p>
<p><strong>SSH 协议的开源实现</strong>：<strong>OpenSSH</strong></p>
<p><strong>SSH 架构</strong>：CS 架构</p>
<p><strong>OpenSSH</strong>：client-ssh，server-sshd，辅助工具：ssh-keygen, ssh-agent，客户端工具：scp，sftp</p>
<h2 id="ssh-客户端"><a class="header" href="#ssh-客户端">ssh 客户端</a></h2>
<pre><code class="language-shell">usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]
           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]
           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]
           [-i identity_file] [-J [user@]host[:port]] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] destination [command]
</code></pre>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<pre><code class="language-shell"># ubuntu, debian
sudo apt install openssh-client

# centos, fedora
sudo dnf install openssh-clients
</code></pre>
<p>二进制程序所在位置：<code>/usr/local/bin/ssh</code>，<code>\Program Files\OpenSSH\bin\ssh.exe</code></p>
<h3 id="登录服务器"><a class="header" href="#登录服务器">登录服务器</a></h3>
<p><img src="computer-science-notebook/cryptography-web-security/assets/image-20211112170131199.png" alt="image-20211112170131199" /></p>
<p>密码登录用服务端的公钥加密；免密登录用客户端端的私钥加密。</p>
<p>实现 ssh 免密登录的时候，第一次登录是要输入服务器的账户密码的，也就是相当于第一次登录的时候，用服务器的账户密码换一个 token。</p>
<pre><code class="language-shell"># 免密登录
ssh-copy-id -i id_rsa user@host

# 登录远程主机，默认使用当前的用户进行远程登录
ssh hostname/ip/ 

# 指定登录哪一个用户
ssh user@hostname
ssh -l username host

# 如果本地用户名与远程用户名一致，登录时可以省略用户名。
ssh host

# 指定端口，默认 22 端口
ssh -p 8821 foo.com

# Enables X11 forwarding 加 X 参数可以打开图形界面
ssh -X ...

# 在登录完服务器后，直接执行命令
ssh foo@server.example.com cat /etc/hosts
</code></pre>
<h3 id="中间人攻击"><a class="header" href="#中间人攻击">中间人攻击</a></h3>
<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<p>整个过程是这样的：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ol>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">&quot;中间人攻击&quot;</a>（Man-in-the-middle attack）。</p>
<h3 id="连接流程"><a class="header" href="#连接流程">连接流程</a></h3>
<p>第一次连接服务器的时候，服务器会返回一个指纹</p>
<pre><code>The authenticity of host 'foo.com (192.168.121.111)' can't be established.
ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>这个指纹，实际上是服务器公钥的签名，主要是因为服务器公钥太长，所以使用 md5 hash 算法对其进行一次 hash，获取一个摘要。</p>
<p>查看服务器公钥指纹的命令：</p>
<pre><code class="language-shell">ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub

# -f filename
# -l Show fingerprint of specified public key file. Private RSA1 keys are also supported. For RSA and DSA keys ssh-keygen tries to find the matching public key file and prints its fingerprint. If combined with -v, an ASCII art representation of the key is supplied with the fingerprint.
</code></pre>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<blockquote>
<p>Are you sure you want to continue connecting (yes/no)? yes</p>
</blockquote>
<p>系统会出现一句提示，表示 host 主机已经得到认可。</p>
<blockquote>
<p>Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.</p>
</blockquote>
<p>然后，会要求输入密码。</p>
<blockquote>
<p>Password: (enter password)</p>
</blockquote>
<p>如果密码正确，就可以登录了。ssh 密码登录过程是这样的：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ol>
<p>当远程主机的公钥被接受以后，它就会被保存在文件 <code>$HOME/.ssh/known_hosts</code> 之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>每个SSH用户都有自己的 <code>known_hosts</code> 文件，此外系统也有一个这样的文件，通常是 <code>/etc/ssh/ssh_known_hosts</code>，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<p>如果服务器指纹变了，也就是重新生成了密钥（例如重装系统），那么再次 ssh 连接服务器的时候，会报错：</p>
<pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Please contact your system administrator.
Add correct host key in /home/me/.ssh/known_hosts to get rid of this message.
Offending key in /home/me/.ssh/known_hosts:36
</code></pre>
<p>意思是检测到的指纹，和本地 <code>~/.ssh/known_hosts</code> 存储的指纹不一样</p>
<p>那么就需要将该服务器的指纹从本地文件中删除(其中 hostname 就是服务器的 hostname)：</p>
<pre><code>ssh-keygen -R hostname
</code></pre>
<p>也可以直接清空 <code>~/.ssh/known_hosts</code> 文件，重新缓存服务器的指纹。</p>
<h2 id="ssh-密钥登录"><a class="header" href="#ssh-密钥登录">SSH 密钥登录</a></h2>
<p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是更好的解决方案。</p>
<h3 id="什么是密钥"><a class="header" href="#什么是密钥">什么是密钥</a></h3>
<p>SSH 密钥登录采用的是非对称加密，每个用户通过自己的密钥登录。其中，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。它们的关系是，公钥和私钥是一一对应的，每一个私钥都有且仅有一个对应的公钥，反之亦然。</p>
<p>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行；反过来，如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。</p>
<h3 id="ssh-密钥登录过程"><a class="header" href="#ssh-密钥登录过程">SSH 密钥登录过程</a></h3>
<p>预备步骤，客户端通过<code>ssh-keygen</code>生成自己的公钥和私钥。</p>
<p>第一步，手动将客户端的公钥放入远程服务器的指定位置。</p>
<p>第二步，客户端向服务器发起 SSH 登录的请求。</p>
<p>第三步，服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</p>
<p>第四步，客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</p>
<p>第五步，服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</p>
<h3 id="ssh-keygen-密钥生成"><a class="header" href="#ssh-keygen-密钥生成">ssh-keygen 密钥生成</a></h3>
<p>生成公钥和私钥</p>
<pre><code class="language-shell">ssh-keygen

# 指定密钥的加密算法，通常会选择 dsa 或 rsa 算法
ssh-keygen -t dsa
</code></pre>
<p>生成的公钥和私钥文件：公钥 <code>~/.ssh/id_dsa.pub</code>，私钥 <code>~/.ssh/id_dsa</code>，如果选择 rsa 算法，那么生成的密钥文件就是：<code>~/.ssh/id_rsa.pub</code></p>
<p>查看所有的公钥：<code>$ ls -l ~/.ssh/id_*.pub</code></p>
<pre><code class="language-shell"># -t 选择加密算法
# -b 设置密钥长度
# -C 设置密钥文件的注释
ssh-keygen -t rsa -b 4096 -C &quot;your_email@domain.com&quot;

# -f 指定生成的文件名，生成 mykey 和 mykey.pub
ssh-keygen -t dsa -f mykey

# 检查某个主机名是否在 known_hosts 中
ssh-keygen -F example.com

# 将服务器的公钥指纹移出 known_hosts
ssh-keygen -R example.com
</code></pre>
<h3 id="ssh-keygen-上传公钥免密登录"><a class="header" href="#ssh-keygen-上传公钥免密登录">ssh-keygen 上传公钥，免密登录</a></h3>
<p>OpenSSH 规定，将客户机的公钥上传到服务机的对应用户的 <code>.ssh/authorized_keys</code> 文件中，就可以实现免密登录。</p>
<p>注意</p>
<ol>
<li>如果我们想要免密登录服务器的 root 用户，那么就需要将客户机的公钥上传到服务器的 <code>/root/.ssh/authorized_keys</code> 文件中，如果是想免密登录非 root 用户，例如 work 用户，则需要将公钥上传到 <code>/home/work/.ssh/authorized_keys</code> 中</li>
<li>authorized_keys 的权限要改成 644</li>
<li><code>.ssh</code> 的权限要改成 700</li>
<li><code>/home/work</code> 目录 必须是 755权限</li>
<li>重启 <code>systemctl restart sshd</code></li>
<li>如果不能实现免密登录，去看一下 <code>tail -f /var/log/secure</code> 日志</li>
</ol>
<p>不能免密登录的终极解决方案：</p>
<p>修改 sshd 的配置文件 <code>/etc/ssh/sshd_config</code>，更改 <code>LogLevel</code> 为 <code>DEBUG</code> 模式，然后重启 sshd <code>systemctl restart sshd</code>，再登录查看 sshd 的运行日志 <code>tail -f /var/log/secure</code>，就可以看到更详细的 debug 信息</p>
<p>如果他妈的还是不行的话，就更改安全环境：<code>chcon -Rv -t ssh_home_t ~/.ssh</code> <code>restorecon -FRvv ~/.ssh</code> <a href="https://stackoverflow.com/questions/20688844/sshd-gives-error-could-not-open-authorized-keys-although-permissions-seem-corre">教程</a></p>
<h3 id="ssh-copy-id-命令自动上传公钥"><a class="header" href="#ssh-copy-id-命令自动上传公钥">ssh-copy-id 命令：自动上传公钥</a></h3>
<p>OpenSSH 自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p>
<p>用户在本地计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。</p>
<pre><code>$ ssh-copy-id -i key_file user@host
</code></pre>
<p>上面命令中，<code>-i</code>参数用来指定公钥文件，<code>user</code>是所要登录的账户名，<code>host</code>是服务器地址。如果省略用户名，默认为当前的本机用户名。执行完该命令，公钥就会拷贝到服务器。</p>
<pre><code>$ ssh-copy-id -i id_rsa user@host
</code></pre>
<p>上面命令中，公钥文件会自动匹配到<code>~/.ssh/id_rsa.pub</code>。</p>
<p><code>ssh-copy-id</code>会采用密码登录，系统会提示输入远程服务器的密码。</p>
<p>注意，<code>ssh-copy-id</code>是直接将公钥添加到<code>authorized_keys</code>文件的末尾。如果<code>authorized_keys</code>文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果<code>authorized_keys</code>文件已经存在，使用<code>ssh-copy-id</code>命令之前，务必保证<code>authorized_keys</code>文件的末尾是换行符（假设该文件已经存在）。</p>
<p>关闭密码登录：</p>
<p>为了安全性，启用密钥登录之后，最好关闭服务器的密码登录。对于 OpenSSH，具体方法就是打开服务器 sshd 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>这一项设为<code>no</code>。</p>
<h2 id="ssh-服务器"><a class="header" href="#ssh-服务器">SSH 服务器</a></h2>
<h3 id="安装启动"><a class="header" href="#安装启动">安装，启动</a></h3>
<pre><code class="language-shell"># install
# Debian
$ sudo aptitude install openssh-server
# Red Hat
$ sudo yum install openssh-server

# start
$ sshd # 或者 /usr/sbin/sshd 自动进入后台，命令后面不需要加 &amp;

# 启动
$ sudo systemctl start sshd.service
# 停止
$ sudo systemctl stop sshd.service
# 重启
$ sudo systemctl restart sshd.service
</code></pre>
<h2 id="ssh-端口转发"><a class="header" href="#ssh-端口转发">SSH 端口转发</a></h2>
<h3 id="是什么-1"><a class="header" href="#是什么-1">是什么</a></h3>
<p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。</p>
<h3 id="动态转发"><a class="header" href="#动态转发">动态转发</a></h3>
<p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p>
<p>动态转发需要把本地端口绑定到 SSH 服务器。至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发。</p>
<pre><code>$ ssh -D local-port tunnel-host -N
</code></pre>
<p>上面命令中，<code>-D</code>表示动态转发，<code>local-port</code>是本地端口，<code>tunnel-host</code>是 SSH 服务器，<code>-N</code>表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。</p>
<p>举例来说，如果本地端口是<code>2121</code>，那么动态转发的命令就是下面这样。</p>
<pre><code>$ ssh -D 2121 tunnel-host -N
</code></pre>
<p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。</p>
<p>下面是 SSH 隧道建立后的一个使用实例。</p>
<pre><code>$ curl -x socks5://localhost:2121 http://www.example.com
</code></pre>
<p>上面命令中，curl 的<code>-x</code>参数指定代理服务器，即通过 SOCKS5 协议的本地<code>2121</code>端口，访问<code>http://www.example.com</code>。</p>
<p>如果经常使用动态转发，可以将设置写入 SSH 客户端的用户个人配置文件（<code>~/.ssh/config</code>）。</p>
<pre><code>DynamicForward tunnel-host:local-port
</code></pre>
<h3 id="本地转发"><a class="header" href="#本地转发">本地转发</a></h3>
<p>本地转发（local forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p>
<p>它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p>
<pre><code>$ ssh -L local-port:target-host:target-port tunnel-host
</code></pre>
<p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>tunnel-host</code>是 SSH 跳板机。</p>
<p>举例来说，现在有一台 SSH 跳板机<code>tunnel-host</code>，我们想要通过这台机器，在本地<code>2121</code>端口与目标网站<code>www.example.com</code>的80端口之间建立 SSH 隧道，就可以写成下面这样。</p>
<pre><code>$ ssh -L 2121:www.example.com:80 tunnel-host -N
</code></pre>
<p>然后，访问本机的<code>2121</code>端口，就是访问<code>www.example.com</code>的80端口。</p>
<pre><code>$ curl http://localhost:2121
</code></pre>
<p>注意，本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议。</p>
<p>另一个例子是加密访问邮件获取协议 POP3。</p>
<pre><code>$ ssh -L 1100:mail.example.com:110 mail.example.com
</code></pre>
<p>上面命令将本机的1100端口，绑定邮件服务器<code>mail.example.com</code>的110端口（POP3 协议的默认端口）。端口转发建立以后，POP3 邮件客户端只需要访问本机的1100端口，请求就会通过 SSH 跳板机（这里是<code>mail.example.com</code>），自动转发到<code>mail.example.com</code>的110端口。</p>
<p>上面这种情况有一个前提条件，就是<code>mail.example.com</code>必须运行 SSH 服务器。否则，就必须通过另一台 SSH 服务器中介，执行的命令要改成下面这样。</p>
<pre><code>$ ssh -L 1100:mail.example.com:110 other.example.com
</code></pre>
<p>上面命令中，本机的1100端口还是绑定<code>mail.example.com</code>的110端口，但是由于<code>mail.example.com</code>没有运行 SSH 服务器，所以必须通过<code>other.example.com</code>中介。本机的 POP3 请求通过1100端口，先发给<code>other.example.com</code>的22端口（sshd 默认端口），再由后者转给<code>mail.example.com</code>，得到数据以后再原路返回。</p>
<p>注意，采用上面的中介方式，只有本机到<code>other.example.com</code>的这一段是加密的，<code>other.example.com</code>到<code>mail.example.com</code>的这一段并不加密。</p>
<p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p>
<p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件（<code>~/.ssh/config</code>）。</p>
<pre><code>Host test.example.com
LocalForward client-IP:client-port server-IP:server-port
</code></pre>
<h3 id="简易-vpn"><a class="header" href="#简易-vpn">简易 VPN</a></h3>
<p>VPN 用来在外网与内网之间建立一条加密通道。内网的服务器不能从外网直接访问，必须通过一个跳板机，如果本机可以访问跳板机，就可以使用 SSH 本地转发，简单实现一个 VPN。</p>
<pre><code>$ ssh -L 2080:corp-server:80 -L 2443:corp-server:443 tunnel-host -N
</code></pre>
<p>上面命令通过 SSH 跳板机，将本机的<code>2080</code>端口绑定内网服务器的<code>80</code>端口，本机的<code>2443</code>端口绑定内网服务器的<code>443</code>端口。</p>
<h3 id="动态转发和本地转发的区别"><a class="header" href="#动态转发和本地转发的区别">动态转发和本地转发的区别</a></h3>
<p><img src="computer-science-notebook/cryptography-web-security/assets/image-20210105093123839.png" alt="image-20210105093123839" /></p>
<h2 id="scp-命令"><a class="header" href="#scp-命令">scp 命令</a></h2>
<h3 id="是什么-2"><a class="header" href="#是什么-2">是什么</a></h3>
<p>scp: secure copy, 用于在两台主机之间加密传送文件。</p>
<h3 id="demo"><a class="header" href="#demo">Demo</a></h3>
<pre><code class="language-shell"># 将远程主机（user@host）用户主目录下的foo.txt，复制为本机当前目录的bar.txt。可以看到，主机与文件之间要使用冒号（:）分隔
$ scp source destination
$ scp user@host:foo.txt bar.txt

# 支持一次复制多个文件
$ scp source1 source2 destination

# 本地文件复制到远程服务器
$ scp SourceFile user@host:directory
$ scp file.txt remote_username@10.10.0.2:/remote/directory

# 拷贝目录
# 将本机整个目录拷贝到远程目录下，可以同时拷贝多个文件夹
$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/
# 将本机目录下的所有内容拷贝到远程目录下
$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/

# 两个远程系统之间的复制
# 语法
$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile
# 示例
$ scp user1@host1.com:/files/file.txt user2@host2.com:/files
</code></pre>
<h3 id="配置项"><a class="header" href="#配置项">配置项</a></h3>
<pre><code class="language-shell"># -q 参数用来关闭显示拷贝的进度条。
$ scp -q Label.pdf mrarianto@202.x.x.x:.

# -r 参数表示是否以递归方式复制目录。

# -v 参数用来显示详细的输出。
$ scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt
</code></pre>
<h2 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h2>
<h3 id="rsync"><a class="header" href="#rsync">rsync</a></h3>
<p>远程同步命令</p>
<p>rsync 是一个常用的 Linux 应用程序，用于文件同步。</p>
<h3 id="sftp"><a class="header" href="#sftp">sftp</a></h3>
<p>secure ftp</p>
<p><code>sftp</code>是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p>
<p>下面的命令连接 FTP 主机。</p>
<pre><code>$ sftp username@hostname
</code></pre>
<p>执行上面的命令，会要求输入 FTP 的密码。密码验证成功以后，就会出现 FTP 的提示符<code>sftp&gt;</code>，下面是一个例子。</p>
<pre><code>$ sftp USER@penguin.example.com
USER@penguin.example.com's password:
Connected to penguin.example.com.
sftp&gt;
</code></pre>
<p>FTP 的提示符下面，就可以输入各种 FTP 命令了，这部分完全跟传统的 FTP 用法完全一样。</p>
<ul>
<li><code>ls [directory]</code>：列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</li>
<li><code>cd directory</code>：从当前目录改到指定目录。</li>
<li><code>mkdir directory</code>：创建一个远程目录。</li>
<li><code>rmdir path</code>：删除一个远程目录。</li>
<li><code>put localfile [remotefile]</code>：本地文件传输到远程主机。</li>
<li><code>get remotefile [localfile]</code>：远程文件传输到本地。</li>
<li><code>help</code>：显示帮助信息。</li>
<li><code>bye</code>：退出 sftp。</li>
<li><code>quit</code>：退出 sftp。</li>
<li><code>exit</code>：退出 sftp。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-and-authorization"><a class="header" href="#authentication-and-authorization">Authentication and Authorization</a></h1>
<p>认证和授权。</p>
<p>[TOC]</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>https://zhuanlan.zhihu.com/p/342744060</p>
<p>jwt: json web token </p>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>授权</p>
<p>https://zhuanlan.zhihu.com/p/342746910</p>
<h2 id="spring-security"><a class="header" href="#spring-security">spring security</a></h2>
<img src="computer-science-notebook/cryptography-web-security/assets/image-20210822092249260.png" alt="image-20210822092249260" style="zoom:80%;" />
<p>微服务认证授权过程：</p>
<img src="computer-science-notebook/cryptography-web-security/assets/image-20210822212423380.png" alt="image-20210822212423380" style="zoom:80%;" />
<h2 id="单点登录"><a class="header" href="#单点登录">单点登录</a></h2>
<p>https://blog.csdn.net/xiaoguan_liu/article/details/91492110</p>
<p>单点登录，类似于小区门卫，在门卫处登记后，给一个授权的牌子。</p>
<p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p>
<p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明。</p>
<h2 id="跨域"><a class="header" href="#跨域">跨域</a></h2>
<h3 id="跨域-1"><a class="header" href="#跨域-1">跨域</a></h3>
<p>跨域是浏览器端的限制！</p>
<p>跨域是浏览器的一个特性，就是浏览器从一个 “域” 向另一个 “域” 的服务器发出请求，来访问另一个“域”上的资源。但是，由于请求的文件可能会存在恶意攻击，浏览器并不允许直接访问另一个“域”上的资源，只能访问同一个“域”上的资源(sentiweibo 的前端，Ajax 请求只能访问 sentiweibo 的后端)，这个就是“同源策略”。而所谓的“同源”，指的是“协议、域名、端口号”一致。</p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20210822184626515.png" alt="image-20210822184626515" style="zoom:80%;" />
<p><strong>同源请求总是被允许的，跨源请求则取决于服务端。</strong></p>
<h3 id="csrf"><a class="header" href="#csrf">csrf</a></h3>
<p>Cross site request forgery 跨网站请求伪造</p>
<p>简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">Cookie 的 SameSite 属性</a></p>
<h3 id="cors"><a class="header" href="#cors">cors</a></h3>
<p>Cross-Origin Resource Sharing 跨域资源共享</p>
<p><strong>浏览器存在跨域的限制，CORS 的出现，是用于实现跨域访问！</strong></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></p>
<p>CORS 用于实现跨域的资源请求。CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。</p>
<p>跨域条件：需要浏览器和服务器同时支持。目前所有浏览器都支持 cors。对于服务端，以 springboot 举例，需要在接口上开启跨域访问 <code>@CrossOrigin</code></p>
<p>通过 <code>href</code> <code>src</code> 请求得到的资源，是不存在跨域问题的，只有 ajax 请求会存在跨域问题。 </p>
<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源 AJAX 请求的根本解决方法。它允许浏览器向跨源服务器，发出XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制。（Ajax 请求一定会受到跨域限制的，但是XMLHttpRequest 可以发起跨域请求）</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，<strong>实现CORS通信的关键是服务器</strong>。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h3 id="浏览器同源政策"><a class="header" href="#浏览器同源政策">浏览器同源政策</a></h3>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></p>
<p>A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;:</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<p>随着互联网的发展，&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p>
<p>（2） DOM 无法获得。</p>
<p>（3） AJAX 请求不能发送。</p>
<p>同源政策规定，AJAX请求只能发给同源的网址（也就是说 ajax 只能访问本地的服务端），否则就报错。</p>
<p>除了架设服务器代理（<strong>浏览器请求同源服务器，再由后者请求外部服务</strong>），有三种方法规避这个限制。</p>
<ul>
<li>JSONP </li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h2 id="jwt"><a class="header" href="#jwt">jwt</a></h2>
<p>JSON Web Token</p>
<h3 id="教程"><a class="header" href="#教程">教程</a></h3>
<p><a href="https://www.bilibili.com/video/BV1C44y1k7VC">前后端分离架构下 jwt 认证该怎么设计</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单点登录-1"><a class="header" href="#单点登录-1">单点登录</a></h1>
<p>单点登录，single-sign-on SSO</p>
<p>[TOC]</p>
<p>https://blog.csdn.net/xiaoguan_liu/article/details/91492110</p>
<h2 id="我的理解-1"><a class="header" href="#我的理解-1">我的理解</a></h2>
<p>单点登录，类似于去迪士尼乐园游玩。我们到入口卖票处 (SSO) 购得一张票（令牌），然后各个项目都可以玩，在玩之前，要校验一下票。如果在玩一个项目的时候没有买票，则会通知到 SSO 那里购票。</p>
<p>也类似于小区给快递小哥发的一个磁卡通行证。</p>
<h2 id="单系统登录机制"><a class="header" href="#单系统登录机制">单系统登录机制</a></h2>
<h3 id="1http无状态协议"><a class="header" href="#1http无状态协议">1、http无状态协议</a></h3>
<p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155231224-831614516.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155231912-1627010726.png" alt="3c91a3bf-25d8-4b1f-8e4a-68535c51aaa8" /></a></p>
<p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制</p>
<h3 id="2会话机制"><a class="header" href="#2会话机制">2、会话机制</a></h3>
<p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155232537-1894700627.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155233115-1744636093.png" alt="8a9fb230-d506-4b19-b821-4001c68c4588" /></a></p>
<p>　　服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式</p>
<ol>
<li>请求参数</li>
<li>cookie</li>
</ol>
<p>　　将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息</p>
<p>　　tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155233724-190446648.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155234443-99011212.png" alt="518293d9-64b2-459c-9d45-9f353c757d1f" /></a></p>
<h3 id="3登录状态"><a class="header" href="#3登录状态">3、登录状态</a></h3>
<p>　　有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下
用户再次访问时，tomcat在会话对象中查看登录状态</p>
<pre><code class="language-vbscript">HttpSession session = request.getSession();



session.setAttribute(&quot;isLogin&quot;, true);
HttpSession session = request.getSession();



session.getAttribute(&quot;isLogin&quot;);
</code></pre>
<p>　　实现了登录状态的浏览器请求服务器模型如下图描述</p>
<p>　　每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p>
<h2 id="多系统的复杂性"><a class="header" href="#多系统的复杂性">多系统的复杂性</a></h2>
<p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155236162-1706551789.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155236615-855014039.png" alt="6dfbb0b1-46c0-4945-a3bf-5f060fa80710" /></a></p>
<p>　　web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155237240-1462133891.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155237802-1969340065.png" alt="9fe14ab3-4254-447b-b850-0436e628c254" /></a></p>
<p>　　虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p>
<p>　　单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155238365-788619473.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155238881-1171826792.png" alt="4d58ccfa-0114-486d-bec2-c28f2f9eb513" /></a></p>
<p>　　既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p>
<p>　　然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p>
<p>　　因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</p>
<h2 id="单点登录-2"><a class="header" href="#单点登录-2">单点登录</a></h2>
<p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p>
<h3 id="1登录"><a class="header" href="#1登录">1、登录</a></h3>
<p>　　相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明</p>
<p><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161203152650974-276822362.png" alt="img" /></p>
<p>　　下面对上图简要描述</p>
<ol>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li>
<li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统1</li>
<li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统2的受保护资源</li>
<li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li>
<li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统2</li>
<li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
<p>　　用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p>
<ol>
<li>局部会话存在，全局会话一定存在</li>
<li>全局会话存在，局部会话不一定存在</li>
<li>全局会话销毁，局部会话必须销毁</li>
</ol>
<p>　　你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数</p>
<h3 id="2注销"><a class="header" href="#2注销">2、注销</a></h3>
<p>　　单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155242271-222889796.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155243068-1378377736.png" alt="3b139d2e-0b83-4a69-b4f2-316adb8997ce" /></a></p>
<p>　　sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p>
<p>　　下面对上图简要说明</p>
<ol>
<li>用户向系统1发起注销请求</li>
<li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li>
<li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li>
<li>sso认证中心引导用户至登录页面</li>
</ol>
<h2 id="部署图"><a class="header" href="#部署图">部署图</a></h2>
<p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述</p>
<p><a href="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155243834-48122435.png"><img src="computer-science-notebook/cryptography-web-security/assets/797930-20161129155244646-2067469767.png" alt="fb29685c-487c-42b9-9ceb-6c7ee29e98c9" /></a></p>
<p>　　sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p>
<p>　　sso-client</p>
<ol>
<li>拦截子系统未登录用户请求，跳转至sso认证中心</li>
<li>接收并存储sso认证中心发送的令牌</li>
<li>与sso-server通信，校验令牌的有效性</li>
<li>建立局部会话</li>
<li>拦截用户注销请求，向sso认证中心发送注销请求</li>
<li>接收sso认证中心发出的注销请求，销毁局部会话</li>
</ol>
<p>　　sso-server</p>
<ol>
<li>验证用户的登录信息</li>
<li>创建全局会话</li>
<li>创建授权令牌</li>
<li>与sso-client通信发送令牌</li>
<li>校验sso-client令牌有效性</li>
<li>系统注册</li>
<li>接收sso-client注销请求，注销所有会话</li>
</ol>
<p>　　接下来，我们按照原理来一步步实现sso吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth"><a class="header" href="#oauth">OAuth</a></h1>
<p>[TOC]</p>
<h2 id="学习资料-1"><a class="header" href="#学习资料-1">学习资料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/OAuth">[Wiki-OAuth]</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">[阮一峰 - OAuth 2.0 的一个简单解释]</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">[阮一峰 - OAuth 2.0 的四种方式]</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">阮一峰 - 理解OAuth 2.0</a></li>
</ul>
<h2 id="学习笔记"><a class="header" href="#学习笔记">学习笔记</a></h2>
<p>OAuth 不能解决所有的验证问题，只能解决第三方客户端获取用户信息的问题。</p>
<p>现实中遇到 OAuth 问题，只需要代入几种角色，对号入座，问题即可迎刃而解。</p>
<h3 id="oauth-中的几个概念"><a class="header" href="#oauth-中的几个概念">OAuth 中的几个概念</a></h3>
<ol>
<li>
<p><strong>Third-party application</strong>：第三方应用程序，本文中又称&quot;客户端&quot;（client），即上一节例子中的&quot;云冲印&quot;。</p>
</li>
<li>
<p><strong>HTTP service</strong>：HTTP服务提供商，本文中简称&quot;服务提供商&quot;，即上一节例子中的Google。</p>
</li>
<li>
<p><strong>Resource Owner</strong>：资源所有者，本文中又称&quot;用户&quot;（user）。</p>
</li>
<li>
<p><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
</li>
<li>
<p><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
</li>
<li>
<p><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</li>
</ol>
<h3 id="oauth-实例"><a class="header" href="#oauth-实例">OAuth 实例</a></h3>
<ul>
<li>第三方应用导向 GitHub，微信，QQ 进行认证，实际上就是为了获取授权码</li>
<li>Strava 案例分析</li>
<li>对于常见的 web 系统来说，web 前端和 app 客户端，相对于后端服务来说，都是第三方客户端</li>
</ul>
<h3 id="wiki"><a class="header" href="#wiki">wiki</a></h3>
<p><strong>OAuth</strong> is an <a href="https://en.wikipedia.org/wiki/Open_standard">open standard</a> for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords.</p>
<p>OAuth essentially allows <a href="https://en.wikipedia.org/wiki/Access_token">access tokens</a> to be issued to third-party clients by an authorization server, with the approval of the resource owner. The third party then uses the access token to access the protected resources hosted by the resource server.</p>
<p>OAuth 有 1.0 和 2.0，2.0 不兼容 1.0</p>
<h3 id="阮一峰---什么是-oauth2"><a class="header" href="#阮一峰---什么是-oauth2">阮一峰 - 什么是 OAuth2</a></h3>
<p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p>
<p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>
<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>
<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>
<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>
<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p>
<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p>
<h3 id="阮一峰---oauth-20-的四种方式"><a class="header" href="#阮一峰---oauth-20-的四种方式">阮一峰 - OAuth 2.0 的四种方式</a></h3>
<p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p>
<blockquote>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。......资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
</blockquote>
<p>这段话的意思就是，**OAuth 的核心就是向第三方应用颁发令牌。**然后，RFC 6749 接着写道：</p>
<blockquote>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
</blockquote>
<p>也就是说，**OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。**下面就是这四种授权方式。</p>
<blockquote>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
</blockquote>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h4 id="授权码"><a class="header" href="#授权码">授权码</a></h4>
<p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>注意：A 网站是我们的网站！我们在 B 网站（例如微信！）上已经注册了一个用户，我们不想再在其他网站上注册新用户，想直接用 B 网站的用户！</p>
<p>第一步，A 网站（我们自己的网站，想用微信的用户登录）提供一个链接，用户点击后就会跳转到 B 网站（微信），授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<blockquote>
<pre><code class="language-javascript">https://b.com/oauth/authorize?
  response_type=code&amp;
  client_id=CLIENT_ID&amp;
  redirect_uri=CALLBACK_URL&amp;
  scope=read
</code></pre>
</blockquote>
<p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img" /></p>
<p>第二步，用户跳转后，B 网站会要求用户登录（我们也是 B 网站的用户！），然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址（这个网址 A 网站后端的端点！）。跳转时，会传回一个授权码，就像下面这样。</p>
<blockquote>
<pre><code class="language-javascript">https://a.com/callback?code=AUTHORIZATION_CODE
</code></pre>
</blockquote>
<p>上面 URL 中，<code>code</code>参数就是授权码。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img" /></p>
<p>第三步，A 网站拿到授权码以后，就可以在后端（注意，这里 A 向 B 请求令牌，是在后端发生的！），向 B 网站请求令牌。</p>
<blockquote>
<pre><code class="language-javascript">https://b.com/oauth/token?
 client_id=CLIENT_ID&amp;
 client_secret=CLIENT_SECRET&amp;
 grant_type=authorization_code&amp;
 code=AUTHORIZATION_CODE&amp;
 redirect_uri=CALLBACK_URL
</code></pre>
</blockquote>
<p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img" /></p>
<p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p>
<blockquote>
<pre><code class="language-javascript">{    
  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,
  &quot;token_type&quot;:&quot;bearer&quot;,
  &quot;expires_in&quot;:2592000,
  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,
  &quot;scope&quot;:&quot;read&quot;,
  &quot;uid&quot;:100101,
  &quot;info&quot;:{...}
}
</code></pre>
</blockquote>
<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040905.jpg" alt="img" /></p>
<h4 id="简化模式"><a class="header" href="#简化模式">简化模式</a></h4>
<h4 id="密码模式"><a class="header" href="#密码模式">密码模式</a></h4>
<p>resource owner password credentials</p>
<h4 id="客户端模式"><a class="header" href="#客户端模式">客户端模式</a></h4>
<p>client credentials</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-web-token"><a class="header" href="#json-web-token">JSON Web Token</a></h1>
<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案</p>
<p>[TOC]</p>
<h2 id="阮一峰-jwt-的前世今生"><a class="header" href="#阮一峰-jwt-的前世今生">阮一峰 jwt 的前世今生</a></h2>
<h3 id="跨域认证的问题"><a class="header" href="#跨域认证的问题">跨域认证的问题</a></h3>
<p>由于 http 是无状态的，所以常用的认证流程通常是这样的：</p>
<pre><code>1、用户向服务器发送用户名和密码。

2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。

3、服务器向用户返回一个 session_id，写入用户的 Cookie。

4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。

5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。
</code></pre>
<p>单个服务，用 session 来存储登录状态没问题，但是如果有多个系统，需要跨域共用 session 的话，就不行了，因为 cookie 不能跨域。举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>怎么把用户信息传给另一个网站呢？用户信息可以存储到 localStorage 中，要跨域的时候，从 localStorage 中取出来，通过 post 请求发送给其他网站。</p>
<h3 id="jwt-的原理"><a class="header" href="#jwt-的原理">jwt 的原理</a></h3>
<p>session 用户登录信息，是存储在服务端的，但是这需要服务端去维护 session，很麻烦。jwt 实现了服务端的无状态，不需要再保存 session，将登录状态的维护，交给了浏览器客户端。</p>
<p>jwt 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样：</p>
<pre><code class="language-json">{
  &quot;姓名&quot;: &quot;张三&quot;,
  &quot;角色&quot;: &quot;管理员&quot;,
  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;
}
</code></pre>
<p>用户与服务端通信的时候，都要发回这个 JSON 对象。<strong>服务器完全只靠这个对象认定用户身份</strong>。</p>
<p><strong>那么用户如果篡改到期时间怎么办？这个好办？服务器给这个 json 签名就好了。</strong></p>
<h3 id="jwt-数据结构"><a class="header" href="#jwt-数据结构">jwt 数据结构</a></h3>
<p>一个典型的 jwt：</p>
<pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIwOGU4M2E1MDlmYmU0YzNlOTAxMGM3YzVkYTk4NGRiMCIsInZlciI6IkRCMS4wIiwidXNlcl9uYW1lIjoid2Fuc2h1byIsInByaSI6WyJBRE1JTiJdLCJsYXN0X2xvZ2luIjoxNjM3NjUxODY2MDAwLCJzY29wZSI6WyJhbGwiXSwiaXNzIjoibnJlYyIsImV4cCI6MTYzNzczODI2NiwianRpIjoiNTEzZjk0MjctODFiMS00YzA5LThhMGYtMzYzZDAzMDUwMDU0IiwiY2xpZW50X2lkIjoiZnJvbnRlbmQifQ.gQv28a-m20LQBBx1U7yx_9qzoAGuP0ZqK9syop3wHqLFG_fUkWP2KD5AjaohSZ-x3ugiruGvDSrpa65PJvEeM3E1lVGSQHzFMMj_bv29saxqSIQotz4l808l_cgiVzCw57RftwisW4pMuGpRuhWXPwbAJOvLQ9EE58JKS7c6tXU
</code></pre>
<p>jwt 分为三段：</p>
<ul>
<li>
<p><strong>Header</strong>（头部）：是一个 json 对象的 base64url 转码，json 对象存储了 jwt 元数据</p>
<p><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</code> 解码后的数据</p>
<pre><code class="language-json">{&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}
</code></pre>
<p><code>alg</code> 表示签名的算法，<code>typ</code> 表示令牌类型，统一为 jwt</p>
</li>
<li>
<p><strong>Payload</strong>（负载）</p>
<p><code>eyJzdWIiOiIwOGU4M2E1MDlmYmU0YzNlOTAxMGM3YzVkYTk4NGRiMCIsInZlciI6IkRCMS4wIiwidXNlcl9uYW1lIjoid2Fuc2h1byIsInByaSI6WyJBRE1JTiJdLCJsYXN0X2xvZ2luIjoxNjM3NjUxODY2MDAwLCJzY29wZSI6WyJhbGwiXSwiaXNzIjoibnJlYyIsImV4cCI6MTYzNzczODI2NiwianRpIjoiNTEzZjk0MjctODFiMS00YzA5LThhMGYtMzYzZDAzMDUwMDU0IiwiY2xpZW50X2lkIjoiZnJvbnRlbmQifQ</code> 经过 base64url 解码后得到：</p>
<pre><code class="language-json">{
	&quot;sub&quot;: &quot;08e83a509fbe4c3e9010c7c5da984db0&quot;,
	&quot;ver&quot;: &quot;DB1.0&quot;,
	&quot;user_name&quot;: &quot;wanshuo&quot;,
	&quot;pri&quot;: [&quot;xxx&quot;],
	&quot;last_login&quot;: 1637651866000,
	&quot;iss&quot;: &quot;nrec&quot;,
	&quot;exp&quot;: 1637738266,
	&quot;jti&quot;: &quot;513f9427-81b1-4c09-8a0f-xxx&quot;,
	&quot;client_id&quot;: &quot;xxx&quot;
}
</code></pre>
<p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<pre><code>iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
</li>
<li>
<p><strong>Signature</strong>（签名）</p>
<p>用服务端私钥对 header 和 payload 进行签名</p>
<pre><code class="language-java">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), 私钥)
</code></pre>
</li>
</ul>
<p>最后把三个部分用 <code>.</code> 号拼接起来，就形成了 jwt。</p>
<h3 id="jwt-的不可篡改性"><a class="header" href="#jwt-的不可篡改性">jwt 的不可篡改性</a></h3>
<ol>
<li>服务端生成 jwt 时，用私钥对 header 和 payload 进行签名</li>
<li>用户与服务端交互时，带上 jwt，服务端对 header 和 payload 进行 base64url 解码，然后再用私钥生成对应的签名，如果两个签名没有匹配上，则说明 jwt 被篡改</li>
</ol>
<h3 id="jwt-如何使用"><a class="header" href="#jwt-如何使用">jwt 如何使用</a></h3>
<ol>
<li>客户端收到 jwt 时，通常存入 localstorage</li>
<li>客户端在向服务端发起请求时，通常把 jwt 放入 http 请求头的 Authorization 中</li>
<li>客户端在向另一个网站发起跨域请求时，通常把 jwt 放入 POST 请求参数中</li>
</ol>
<h3 id="注意"><a class="header" href="#注意">注意</a></h3>
<ul>
<li>jwt 虽然不可篡改，但是并非是加密的，所以 payload 中不要放敏感信息</li>
<li>jwt 一经生成，无法销毁，所以不建议填写很长的有效期</li>
<li>JWT 设计最大的亮点是 理论上 JWT 是无状态自包含的，也就是 JWT 里面可以带有大量标明用户身份的元数据，但是问题是：
<ul>
<li>如果要吊销或者续签就必然是有状态的，否则分发出去的 token 不到自身过期可能一直有效，存在安全问题，过期时间过短又有需要不断更换 token 的操作</li>
<li>即使 token 校验本身通过，也只是完成 Authentication 阶段，对于 authorization 阶段仍然需要到后端数据库去查询用户允许做什么，不允许做什么，用 Stack Overflow 那个老哥的原话是： You are going to hit the database anyway.</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="it-老齐-jwt-实战应用"><a class="header" href="#it-老齐-jwt-实战应用">IT 老齐 jwt 实战应用</a></h2>
<h3 id="前后端分离的-jwt-认证"><a class="header" href="#前后端分离的-jwt-认证">前后端分离的 jwt 认证</a></h3>
<p>方案一：网关统一校验</p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123161342490.png" alt="image-20211123161342490" style="zoom:80%;" />
<p>方案二：应用认证方案</p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123161648504.png" alt="image-20211123161648504" style="zoom:80%;" />
<p>可以通过自定义注解，利用 AOP 做验签。</p>
<pre><code class="language-java">@GetMapping(&quot;/xxx&quot;)
@CheckJwt
public void xxx(){
    // controller 代码
}
</code></pre>
<p>两种方案比较：</p>
<ul>
<li>方案一：jwt 校验无感知，验签过程无侵入，执行效率低（并不是所有的请求，都有权限控制，有的请求不需要验签），适用于低并发企业级应用</li>
<li>方案二：控制更加灵活，有一定代码入侵，代码可以灵活控制，适合追求性能的互联网应用</li>
</ul>
<h3 id="jwt-续签"><a class="header" href="#jwt-续签">jwt 续签</a></h3>
<p><strong>为什么要续签</strong></p>
<p>jwt 因为有 expire 超时时间，所以必然会失效：</p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123162826008.png" alt="image-20211123162826008" style="zoom:80%;" />
<p>如果到期的时候，用户正在进行转账，怎么办？用户体验太差了！</p>
<p>那么 jwt 不设置超时时间行不行？不可以，会留下“太空垃圾”，后患无穷。例如 jwt 被泄露后，其他人就可以使用 jwt 来假冒我们的身份进行登录，转走我们的 money。</p>
<p>而且必须要有续签功能，延长 jwt 的使用时间。同时 jwt 也要有退出机制，不能有无限续签。</p>
<p><strong>续签方式：不改变 token 令牌实现续签</strong></p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123164458187.png" alt="image-20211123164458187" style="zoom: 67%;" />
<p>加入 Redis 后，jwt 中的过期时间就不需要校验了，转而校验 redis 中的过期时间。过期时间被放在 Redis 中，可以灵活控制。</p>
<p>在生成 md5 签名时加入环境特征，尽量避免了认为盗取。</p>
<p>这个方案意味着 jwt 在服务端是有状态的，但是这样保证了不改变 jwt 令牌。</p>
<p><strong>续签方式：允许改变 Token 令牌实现续签</strong></p>
<p>认证中心返回两个 token，一个 access_token，一个 refresh_token，refresh_token 决定了是否续签，是一个刷新的标识。</p>
<p>access_token 用于业务系统交互，是最核心的数据；refresh_token 只用于向认证中心获取新的 access_token 和 refresh_token。</p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123165307202.png" alt="image-20211123165307202" style="zoom:67%;" />
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123165334932.png" alt="image-20211123165334932" style="zoom:67%;" />
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211123165705986.png" alt="image-20211123165705986" style="zoom:67%;" />
<p>两个 jwt 导致客户端变复杂了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全漏洞"><a class="header" href="#安全漏洞">安全漏洞</a></h1>
<p>[TOC]</p>
<h2 id="xss"><a class="header" href="#xss">XSS</a></h2>
<p>Cross-site scripting</p>
<p><a href="https://www.bilibili.com/video/BV1fP4y1572A">IT老齐 XSS 介绍</a></p>
<img align="left" src="computer-science-notebook/cryptography-web-security/assets/image-20211122083927141.png" alt="image-20211122083927141" style="zoom:67%;" />
<p>XSS 攻击：利用网页开发时留下的漏洞，通过巧妙地方式，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</p>
<p>解决方法：不要在前端对输入内容进行转义（表单欺诈），要在服务端做转义符转换（对 &lt;&gt; 进行转义）和有效性校验。</p>
<pre><code class="language-java">// org.springframework.web.util.HtmlUitls

String escapedHtml = HtmlUtils.htmlEscape(&quot;&lt;div&gt;hello world&lt;/div&gt;&quot;);
String source = HtmlUtils.htmlUnescape(escapedHtml);
</code></pre>
<h2 id="密码泄露查询"><a class="header" href="#密码泄露查询">密码泄露查询</a></h2>
<p>https://monitor.firefox.com/</p>
<h2 id="安全知识记录"><a class="header" href="#安全知识记录">安全知识记录</a></h2>
<p>目前最安全的认证方法应该是密码 + 物理密钥（U盾）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network--web"><a class="header" href="#network--web">Network &amp; Web</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机网络"><a class="header" href="#计算机网络">计算机网络</a></h1>
<p>[TOC]</p>
<h2 id="路由"><a class="header" href="#路由">路由</a></h2>
<p>路由就是实现一个网段到另一个网段之间的通信，路由分为静态路由、动态路由。</p>
<img align="left" src="computer-science-notebook/network-web/assets/image-20201014091518075.png" alt="image-20201014091518075" style="zoom:67%;" />
<p><a href="https://www.cnblogs.com/ssgeek/p/9220690.html">[举例讲解]</a></p>
<p><img src="computer-science-notebook/network-web/assets/image-20201014100215674.png" alt="image-20201014100215674" /></p>
<pre><code>有四台机器，按照顺序 1，2，3，4 连在一起

Linux1:
	10.0.0.128
	
Linux2:
	10.0.0.129
	192.168.1.129
	
Linux3:
	192.168.1.130
	192.168.2.130

Linux4:
	192.168.2.131

其中 Linux2,3 作为路由器

添加静态路由常用参数：

add 增加路由

del 删除路由

-net 设置到某个网段的路由

-host 设置到某台主机的路由

gw     出口网关 IP地址

dev 出口网关 物理设备名


设置到某个网段的路由:
	route add -net 目标网段 gw 网关(路由器)
	例如：
	从 1 到 3，经过路由 2：route add –net 192.168.1.0/24 gw 10.0.0.129
	从 3 到 1，经过路由 2：route add -net 10.0.0.0/24 gw 10.0.0.129
</code></pre>
<h2 id="正向代理和反向代理"><a class="header" href="#正向代理和反向代理">正向代理和反向代理</a></h2>
<p>正向代理隐藏真实客户端 VPN，反向代理隐藏真实服务端 Nginx。</p>
<h2 id="分层传输"><a class="header" href="#分层传输">分层传输</a></h2>
<p>计算机网络的分层协议，可以形象的转换成快递不断封装的一个过程。</p>
<ol>
<li><strong>分批次</strong></li>
<li><strong>套上第一个信封</strong>，写上寄件单位的部门（源<strong>端口号</strong>），收件单位的部门（目标端口号），批次编号。<strong>传输层</strong>负责该任务，有两个协议：TCP/UDP，UDP 并不能保证对方一定能收到，信封上没写批次编号。有了端口号，就能保证信封到达后，能发送到指定的部门，端口号保证了属于<strong>局域网</strong>内的传输。</li>
<li><strong>套上第二个信封</strong>，写上寄件单位地址（源IP），收件单位地址（目标IP），有了 IP 地址，就能保证快递在广域网上进行流通（由多段快递公司负责传输）。<strong>网络层</strong>负责该任务，该层最重要的协议是 IP 协议。</li>
<li><strong>套上第三个信封</strong>，信封上写的内容，由负责该段运输的快递公司决定，当快递从一个快递公司交接到另一个公司时，拆掉信封，重新换上新的信封。</li>
</ol>
<h2 id="各层协议"><a class="header" href="#各层协议">各层协议</a></h2>
<p><img src="computer-science-notebook/network-web/assets/1568689924043.png" alt="各层协议" /></p>
<p>DNS()：域名解析协议</p>
<p>DHCP(Dynamic Host Configuration Protocol)：计算机接入网络时的初始化，分配 IP 地址并配置网关</p>
<p>ARP(Address Resolution Protocol)：局域网中的协议，解析目的地的主机 IP 地址得到 MAC 地址</p>
<p>RARP(Reverse Address Resolution Protocol)：MAC 地址解析成 IP 地址，很少用到</p>
<p>ICMP(Internet Control Message Protocol)：检测网络连接状态，ping, traceroute</p>
<p><img src="computer-science-notebook/network-web/assets/image-20210716085709776.png" alt="image-20210716085709776" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webservice-详解"><a class="header" href="#webservice-详解">WebService 详解</a></h1>
<p>[TOC]</p>
<h2 id="questions-4"><a class="header" href="#questions-4">Questions</a></h2>
<ul>
<li>Web Service 是什么</li>
<li>XML 与 HTML 的两个最大的不同点</li>
<li>Restful 位于 Webservice 的哪一层</li>
</ul>
<h2 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h2>
<p>Web 服务是什么？Web 服务就是在计算机和计算机之间交换数据。</p>
<p>WebService = HTTP 协议(传输协议) + 数据（JSON / XML）</p>
<p>传统的 Web Service 定义：</p>
<p><img src="computer-science-notebook/network-web/assets/1566654030697.png" alt="WebService" /></p>
<h2 id="xml"><a class="header" href="#xml">XML</a></h2>
<p><strong>XML 与 HTML 的区别</strong></p>
<ul>
<li>HTML 的标签集合优先，XML 可以自己定义标签</li>
<li>HTML 是面向用户的，而 XML 面向的是计算机，是为了计算机能够读懂数据</li>
</ul>
<pre><code class="language-HTML">&lt;HTML&gt;
    &lt;BODY&gt;
        &lt;H1&gt;XML in a Nutshell&lt;/H1&gt;
        &lt;H2&gt;Elliot Harold Rusty&lt;/H2&gt;
        &lt;I&gt;O’Reilly &amp; Associates,&lt;/I&gt;
        &lt;B&gt;2002&lt;/B&gt;
    &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>HTML 本质上是一种格式化标签语言，将一串 HTML 扔给计算机，计算机并不能理解 HTML 标签包裹的数据，其只能对数据进行格式化。</p>
<pre><code class="language-xml">&lt;BOOK&gt;
    &lt;TITLE&gt; XML in a Nutshell&lt;/TITLE&gt;
    &lt;AUTHOR&gt; Elliot Harold Rusty &lt;/AUTHOR&gt;
    &lt;DATE&gt;2002&lt;/DATE&gt;
    &lt;PUBLISHER&gt;O’Reilly &amp; Associates&lt;/PUBLISHER&gt;
&lt;/BOOK&gt;
</code></pre>
<p>而 XML 是面向计算机的语言，对于每一条数据，其都有对应的解释，其是 key: value 型的数据结构。之所以用 xml 来进行数据的传递，是因为 xml 语言对计算机的可解释性，其独立于任何计算机系统/软件/语言的，换句话说，只要是 key-value 型的数据，都可以当作信息传递的载体。</p>
<h2 id="soap"><a class="header" href="#soap">SOAP</a></h2>
<p><strong>Simple Object Access Protocol</strong>, SOAP 是基于 XML 的通信方式，其 request 和 reponse 都是 XML 格式的请求。Here is a sample SOAP request to a weather service：</p>
<pre><code class="language-xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;SOAP-ENV:Envelope
    xmlns:SOAP-ENV=&quot;http://www.w3.org/2001/09/soap-envelope/&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
    &lt;SOAP-ENV:Body&gt;
        &lt;ns1:getWeather
            xmlns:ns1=&quot;urn:examples:weatherservice&quot;
            SOAP-ENV:encodingStyle=&quot;http://www.w3.org/2001/09/soap-encoding/&quot;&gt;
            &lt;zipcode xsi:type=&quot;xsd:string&quot;&gt;10016&lt;/zipcode&gt;
        &lt;/ns1:getWeather&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>
<h2 id="soap-vs-rest"><a class="header" href="#soap-vs-rest">SOAP vs Rest</a></h2>
<p>SOAP 是一项协议，而 Rest 是一种标准。SOAP 的客户端和服务端是紧密耦合在一起的，而 Rest 的客户端和服务端是解耦合的。</p>
<p>SOAP 是 HTTP + XML</p>
<p>Rest 是 HTTP + json</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-协议"><a class="header" href="#http-协议">HTTP 协议</a></h1>
<p>[TOC]</p>
<p><a href="https://www.bilibili.com/video/av28681865?from=search&amp;seid=10684427334026635806">燕十八 HTTP 教程</a></p>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<ul>
<li>
<p>WebService == HTTP 协议（负责传输数据） + XML （数据）</p>
<p>Rest == HTTP 协议 + json（使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。）</p>
<p>各种 API，也一般是用 HTTP + XML/Json 来实现的</p>
</li>
<li>
<p>什么是协议</p>
<p>计算机中的协议和生活中的 <strong>合同</strong>  是一样的，一式双份/多份，多方都遵从共同的规范，这个规范就可以称为协议。</p>
<p>协议就是按照规矩说话：</p>
<p>你来问，我来答；</p>
<p>你怎么问，我怎么答。</p>
<p>至于 HTTP 协议，就是客户端如何问，服务端如何答。</p>
</li>
<li>
<p>计算机网络中的各种协议</p>
<p>HTTP，ftp，stmp，pop，tcp/ip，udp</p>
</li>
<li>
<p>HTTP 只是一种协议，并不需要浏览器去发送，只要满足了这种协议，那么任何工具都可以发送 HTTP 协议 </p>
</li>
</ul>
<p><img src="http://assets.processon.com/chart_image/5c93aeade4b0f88919b7a567.png" alt="HTTP学习" /></p>
<h2 id="http-request"><a class="header" href="#http-request">HTTP Request</a></h2>
<h3 id="请求的信息"><a class="header" href="#请求的信息">请求的信息</a></h3>
<ul>
<li><strong>请求行</strong>
<ul>
<li>请求方法(区分大小写)
<ul>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>TRACE</li>
<li>OPTIONS</li>
</ul>
</li>
<li>请求路径 (所请求的资源)</li>
<li>请求协议 (HTTP/1.1)</li>
</ul>
</li>
<li><strong>请求头信息</strong> (header key: value，内容最丰富)</li>
<li><strong>请求主体信息</strong> （非必须）</li>
</ul>
<p>注意，头信息后有一个空行，用来与主体信息做区分，即使没有主体信息，也需要此空行</p>
<h3 id="get-请求-telnet-demo"><a class="header" href="#get-请求-telnet-demo">get 请求 telnet-Demo</a></h3>
<pre><code class="language-shell">GET / HTTP/1.1
Host: localhost
csrftoken: Zr6Sy6DpRMjMYjDGjHavuS9lwc5JLCt2MxMiogaNhd7pueKHwR4tbOcvJa5smoaz


</code></pre>
<p>其中第一行分别是 请求方式/ 请求路径/ 请求所用协议</p>
<p>第二行和第三行都是请求头信息（注意，如果头信息中有多对 key value，那么一对 key value 放入作为一行）</p>
<p>第三方是一个空行，用来表示头信息已经输入完毕</p>
<h3 id="post-请求-telnet-demo"><a class="header" href="#post-请求-telnet-demo">post 请求 telnet-Demo</a></h3>
<pre><code class="language-shell">POST / HTTP/1.1
Host: localhost
csrftoken: Zr6Sy6DpRMjMYjDGjHavuS9lwc5JLCt2MxMiogaNhd7pueKHwR4tbOcvJa5smoaz
Content-Length: 20 
Content-Type: application/x-www-form-urlencoded

oid=46810686&amp;type=1
</code></pre>
<h3 id="get-和-post-区别"><a class="header" href="#get-和-post-区别">get 和 post 区别</a></h3>
<p>post 比 get 的 header 信息中，多了</p>
<ul>
<li>Content-Length，也就是主体内容长度的配置 ( POST 必须要加入的内容)</li>
<li>Content-Type  ( POST 必须要加入的内容)</li>
<li>主体信息，也就是提交的内容</li>
</ul>
<h3 id="query-params--body-params"><a class="header" href="#query-params--body-params">query params / body params</a></h3>
<p>query params: 查询参数</p>
<p>body params: 请求体（只有 post 才有！）</p>
<table><thead><tr><th></th><th>get</th><th>post</th></tr></thead><tbody>
<tr><td>query params</td><td>√</td><td>√</td></tr>
<tr><td>body params</td><td>×</td><td>√</td></tr>
</tbody></table>
<p>query params demo: <code>http://198.87.103.240:38080/app/mock/21/organization/v1/user/delete?id=1</code></p>
<p>body params 通常是 json 格式的数据</p>
<h3 id="请求方法详解"><a class="header" href="#请求方法详解">请求方法详解</a></h3>
<p>GET / POST / HEAD / PUT / TRACE / DELETE / OPTIONS</p>
<p>注意，这些方法，虽然 HTTP 协议里面规定了，但是并不是所有的 WebServer 都支持，例如 Django 的默认 runserver 就不支持 TRACE 方法。</p>
<h4 id="head-方法"><a class="header" href="#head-方法">HEAD 方法</a></h4>
<p>HEAD 与 GET 基本一致，只是不返回内容. 使用情境 Demo:</p>
<p>比如我们只确认一个图片是否存在于服务器上，或者服务器是否正常，那么只需要服务器发给我状态码就够了，不需要服务器返回图片。</p>
<pre><code>HEAD / HTTP/1.1
Host: localhost
csrftoken: Zr6Sy6DpRMjMYjDGjHavuS9lwc5JLCt2MxMiogaNhd7pueKHwR4tbOcvJa5smoaz

</code></pre>
<h4 id="put-方法"><a class="header" href="#put-方法">PUT 方法</a></h4>
<p>往服务器写入内容。通常服务器不支持该方法</p>
<h4 id="trace-方法"><a class="header" href="#trace-方法">TRACE 方法</a></h4>
<p>当我们用了代理进行上网的是否，如果我们想要看看代理有没有篡改我们发出的 HTTP 请求，就可以用 TRACE 来测试。通常服务器不支持该方法</p>
<pre><code>TRACE / HTTP/1.1
Host: baidu.com

</code></pre>
<h4 id="options"><a class="header" href="#options">OPTIONS</a></h4>
<p>测试服务器都支持哪些 HTTP 方法</p>
<pre><code>OPTIONS / HTTP/1.1
Host: baidu.com

</code></pre>
<p>返回支持四个方法：</p>
<pre><code>HTTP/1.1 200 OK
Date: Sun, 24 Mar 2019 09:21:56 GMT
Server: WSGIServer/0.2 CPython/3.7.0
Content-Type: text/html; charset=utf-8
Allow: GET, POST, HEAD, OPTIONS
Content-Length: 0
X-Frame-Options: SAMEORIGIN
</code></pre>
<h3 id="常见-headers"><a class="header" href="#常见-headers">常见 Headers</a></h3>
<table><thead><tr><th>key: value</th><th>含义</th></tr></thead><tbody>
<tr><td><code>if-modified-since: Wed, 21 Jan 2004 19:51:30 GMT</code></td><td>判断文件在服务器端是否有变化</td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="http-reponse"><a class="header" href="#http-reponse">HTTP Reponse</a></h2>
<ul>
<li>响应行
<ul>
<li>协议版本</li>
<li>状态码</li>
<li>状态文字</li>
</ul>
</li>
<li>响应头信息</li>
<li>响应主体信息（即返回的内容）</li>
</ul>
<p>注意：响应行中的状态码，和响应体中的 code，是两个不同的 code，</p>
<ul>
<li>
<p>http 的状态码，描述的是 http 的响应状态</p>
</li>
<li>
<p>响应行中的状态码是固定格式的，但是响应体中的状态码，是服务端自定义的</p>
</li>
</ul>
<h3 id="http-reponse-demo"><a class="header" href="#http-reponse-demo">Http Reponse Demo</a></h3>
<pre><code>HTTP/1.1 200 OK
Date: Sun, 24 Mar 2019 08:56:37 GMT
Server: WSGIServer/0.2 CPython/3.7.0
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Vary: Cookie
Content-Length: 1570
Set-Cookie:  csrftoken=9G06qAdcE6H25HLTS7KpJJvQCTHjHsVZMk8KK7WZ118LhOeYWGVL31qotAVxSmRs; expires=Sun, 22 Mar 2020 08:56:37 GMT; Max-Age=31449600; Path=/; SameSite=Lax

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
……  
</code></pre>
<h3 id="状态码"><a class="header" href="#状态码">状态码</a></h3>
<p>反映服务器的响应结果，状态文字用来描述状态码。</p>
<table><thead><tr><th>状态码</th><th>定义</th><th>说明</th></tr></thead><tbody>
<tr><td>1XX</td><td>信息</td><td>接受到请求，继续处理</td></tr>
<tr><td><strong>2XX</strong></td><td>成功</td><td>操作成功收到，理解为接受</td></tr>
<tr><td><strong>3XX</strong></td><td>重定向</td><td>为了完成请求，必须采取进一步的措施</td></tr>
<tr><td><strong>4XX</strong></td><td>客户端错误</td><td>请求的语法有错误，或不能完全被满足</td></tr>
<tr><td><strong>5XX</strong></td><td>服务端错误</td><td>服务器无法完成明显有效的请求</td></tr>
</tbody></table>
<p>常见状态码</p>
<table><thead><tr><th>状态码</th><th>状态文字</th><th>解释</th></tr></thead><tbody>
<tr><td>200</td><td>OK</td><td>成功</td></tr>
<tr><td>301/302</td><td></td><td>永久/临时 重定向</td></tr>
<tr><td>304</td><td>Not Modified</td><td>指的是请求的内容在服务器中未修改，可以直接从浏览器的缓存中取缓存的内容。对于一张图片，服务器在返回图片资源的是否，会在 Response Header 中加入一个 标记 <code>last-modified: Wed, 21 Jan 2004 19:51:30 GMT</code>，当客户端进行下次请求时，其 request Header 会带上 <code>if-modified-since: Wed, 21 Jan 2004 19:51:30 GMT</code>，如果服务器返回 304，那么客户端就会默认从缓存中取出图片</td></tr>
<tr><td>302</td><td>Found</td><td>将请求重定向到另一个地址，经常用于 SEO</td></tr>
<tr><td>307</td><td></td><td>重定向中保持原有的 post 数据，例如通过 form 提交一组数据，如果提交处理的服务器将此请求进行了重定向，那么必须指定 307 来进行 post 数据的保持，否则重定后，post 请求会变成 get 请求，导致 form 数据丢失</td></tr>
<tr><td>404</td><td>Not Found</td><td>没有找到该请求文件</td></tr>
</tbody></table>
<h2 id="cookie---实现模拟登陆灌水"><a class="header" href="#cookie---实现模拟登陆灌水">Cookie - 实现模拟登陆，灌水</a></h2>
<h3 id="cookie-的由来"><a class="header" href="#cookie-的由来">Cookie 的由来</a></h3>
<p>HTTP 客户端每一次和 服务器进行连接，都是无状态连接，其连接结束后，服务器就不记得客户端了，为了让服务器能记住 HTTP 客户端，所以引入 Cookie。(相当于存储用户的上下文)</p>
<h3 id="cookie-的原理"><a class="header" href="#cookie-的原理">Cookie 的原理</a></h3>
<p>第一次请求服务器的时候，服务器发给客户端一个标记（cookie），用来标记这个客户，等到客户端下次访问服务端的时候，就会带上这个 cookie，用来表示客户端的身份。</p>
<p>Cookie 内的 key: value，往往和我们的头信息的内容有关，还有一些时间戳信息，用来防止 Cookie 被滥用。</p>
<h2 id="headers-详解"><a class="header" href="#headers-详解">Headers 详解</a></h2>
<table><thead><tr><th>Key: Value</th><th>解释</th></tr></thead><tbody>
<tr><td>Referer</td><td>代表网页的来源和上一页的地址</td></tr>
<tr><td>Accept-Encoding</td><td>支持的压缩协议，例如 gzip，deflate，compress，</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="referer-头与防盗链"><a class="header" href="#referer-头与防盗链">Referer 头与防盗链</a></h2>
<h3 id="几个问题"><a class="header" href="#几个问题">几个问题</a></h3>
<ul>
<li>当我们在站内引用站外的图片时，经常出现不能引用的情况，例如引用百度或QQ空间的图片。那么服务器怎么知道这个请求是站外发送的请求呢？</li>
<li>百度统计，Google 统计，是如何知道其用户是从何而来的呢</li>
</ul>
<h3 id="referer"><a class="header" href="#referer">Referer</a></h3>
<p>在 HTTP 协议的头信息里面，有一个重要的 Referer 选项，代表网页的来源。如果是直接在浏览器中敲入地址，则没有 Referer 选项，如果是从站外的网站来请求 QQ空间 站内的图片，那么由于 Referer 不是站内的地址，则不能实现引用，这就是 QQ空间 的 <strong>防盗链</strong>。所以不能拿 QQ空间，百度图片，百度贴吧 作为<strong>图床</strong>，不稳定。</p>
<h3 id="配置-apache-图片防盗链"><a class="header" href="#配置-apache-图片防盗链">配置 Apache 图片防盗链</a></h3>
<p>作用：防止我们站内的图片被别人盗用。</p>
<p>原理：对 Referer 进行分析，如果不是来自本站，则拒绝服务。</p>
<h2 id="http-内容压缩"><a class="header" href="#http-内容压缩">HTTP 内容压缩</a></h2>
<p><strong>引出问题</strong>：有时候我们发现 content-length 的值与响应主体的长度不一致</p>
<p><strong>原因</strong>：我们请求的头信息中，往往有 <code>Accept-Encoding: gzip</code> 这个属性，用来表示客户端可以允许的压缩协议，服务器可以通过这些协议将 Reponse 的主体信息压缩，然后返回给客户端，content-length 是压缩后的长度。</p>
<p><strong>实战中需要注意的地方</strong>：对于常见的爬虫程序，我们在构造 Headers 时，不要加入支持的压缩协议这个键值，否则返回的数据，可能是压缩的数据，还需要进行解压。</p>
<h2 id="http-持久连接分块传输-和-应用"><a class="header" href="#http-持久连接分块传输-和-应用">HTTP 持久连接，分块传输 和 应用</a></h2>
<p>客户端与服务器通过 HTTP协议通信，客户端在收到 Content-Length 长度的内容后，就会自动断开连接。</p>
<p>那么，我们如何实现持久的连接，从而减少资源的消耗，实现 在线聊天 的应用呢？</p>
<p>在 HTTP/1.1 中，允许我们不指定 Content-Length，比如我们不知道要发送的内容长度，这时候我们就需要一个特殊的 <code>Content-Type: chunked</code></p>
<p>分块传输的原理：</p>
<pre><code>123H \r\n
123H长度的内容传输给客户端 \r\n
……
41H \r\n
客户端继续接受 41H 长度的内容 \r\n
……
0\r\n (服务器说内容发完了)
</code></pre>
<p>Python urllib 连接池应该就是基于分块传输的原理。 </p>
<h2 id="实战--用-http-post-请求实现自动化注册"><a class="header" href="#实战--用-http-post-请求实现自动化注册">实战 — 用 HTTP Post 请求实现自动化注册</a></h2>
<p>步骤1. 抓包分析</p>
<pre><code>请求行：
    请求方法：POST
    请求地址：/
    请求协议：HTTP/1.1
请求Header：
	Host: 127.0.0.1:8000
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 200
	Cookie: csrftoken=Ogosp1RUaFAUlorzmd58H2WwJ8KvFXDJy3ybWWmRd7YJBuAwryXBDGeLQld7nKk8; sessionid=hcws2297v37svsk0oliqvqd10vnrc054
	
请求（提交）主体：
	csrfmiddlewaretoken=4CcHhpsA0WQ0XhBd0wyHXQp1QFt14W5KOpmqOkXx3oePdnKa5RqaTuHgXSWDMJM9&amp;name=%E4%B8%9C%E9%91%AB&amp;sex=1&amp;profession=%E5%AD%A6%E7%94%9F&amp;email=949178872%40qq.com&amp;qq=949178872&amp;phone=18851876323 
</code></pre>
<p>步骤2. 在 telnet（xshell 上有 telnet 的实现） 上对协议进行测试：</p>
<pre><code>POST / HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 200
Cookie: xxxxxxx

csrfmiddlewaretoken=4CcHhpsA0WQ0XhBd0wyHXQp1QFt14W5KOpmqOkXx3oePdnKa5RqaTuHgXSWDMJM9&amp;name=%E4%B8%9C%E9%91%AB&amp;sex=1&amp;profession=%E5%AD%A6%E7%94%9F&amp;email=949178872%40qq.com&amp;qq=949178872&amp;phone=18851876323

</code></pre>
<p>测试成功后，就可以在脚本中模拟 POST 请求</p>
<p>步骤三：用一门语言，将上面的协议实现。</p>
<h2 id="我的理解-2"><a class="header" href="#我的理解-2">我的理解</a></h2>
<ul>
<li>
<p>微博爬虫之所以被监测到，是因为我们没有按照微博网站说定的协议来访问他们，也就是协议没有达成。</p>
</li>
<li>
<p>我们编程的是否也应该按照请求行，请求头信息，请求主体信息三要素来进行编程</p>
</li>
<li>
<p>网络上对于网站的请求，大多数都是 get/post 请求，如果我们掌握了这些 get/post 请求，就可以自己写脚本发起 HTTP 请求，然后实现一些自动化的操作，例如</p>
<ul>
<li>Get 请求
<ul>
<li>爬虫</li>
<li>网站内容监控</li>
</ul>
</li>
<li>Post 请求
<ul>
<li>批量账号注册</li>
<li>批量发帖</li>
<li>批量发微博</li>
<li>自动化删帖</li>
</ul>
</li>
</ul>
<p>等自动化操作。</p>
<p>其实这也涉及到网络安全的问题，别人利用 HTTP 请求，很容易就可以往数据库里写入大量的信息，发起大量的请求。</p>
</li>
<li>
<p>理论上讲，所有的网页操作，都可以用 HTTP 协议进行模拟，进而实现自动化。浏览器作为 HTTP 客户端，进行 HTTP 请求的发送，和自己写的 HTTP 客户端，进行 HTTP 发送，本质上是没有区别的，只要两者发送的 HTTP 消息一致，那么服务器就无法进行拦截。</p>
</li>
<li>
<p>如果想要实现缓存/压缩等服务，需要在 Web 服务器上进行配置</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-5"><a class="header" href="#questions-5">Questions</a></h1>
<p>[TOC]</p>
<h2 id="http-协议-1"><a class="header" href="#http-协议-1">HTTP 协议</a></h2>
<ul>
<li>解释 HTTP 协议</li>
<li>HTTP 协议的 Get 方法和 Post 方法的区别</li>
<li>Restful API 是什么</li>
<li>常见的有哪两类服务器状态码</li>
<li>Cookie 的由来和实现原理</li>
<li>解释 Referer 和 防盗链 的作用原理</li>
<li>HTTP 如何实现持久传输</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="golang"><a class="header" href="#golang">Golang</a></h1>
<h2 id="golang-的-pypi--npm--maven"><a class="header" href="#golang-的-pypi--npm--maven">golang 的 pypi / npm / maven</a></h2>
<p>pkg.go.dev</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<p>Kotlin 是一门编程语言，由 Jetbrain 开发。其可以被编译成 Java 字节码，放入 Java 虚拟机中运行，也可以被编译成 JavaScript。</p>
<p>Kotlin 可以开发 Android。</p>
<p>kotlin 能否看成是 Java 的语法糖？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p><a href="https://www.zdnet.com/article/rust-takes-a-major-step-forward-as-linuxs-second-official-language/">《Rust 正在变成 Linux 的第二官方语言》</a></p>
<p>Rust 是内存安全的。</p>
<h2 id="学习生态"><a class="header" href="#学习生态">学习生态</a></h2>
<ul>
<li><a href="https://github.com/sunface/rust-course">Rust 语言圣经 (The course)</a></li>
<li><a href="https://github.com/Keats/tera">tera</a> A template engine for Rust based on Jinja2/Django</li>
<li><a href="https://github.com/tauri-apps/tauri">tauri</a> Build smaller, faster, and more secure desktop applications with a web frontend.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svg"><a class="header" href="#svg">SVG</a></h1>
<p>[TOC]</p>
<h2 id="我的思考"><a class="header" href="#我的思考">我的思考</a></h2>
<p>SVG 最本质的突破，是用纯文本来描述图像。</p>
<p>纯文本可以写论文：Latex</p>
<p>纯文本可以写 ppt：Marpit</p>
<p>纯文本可以画图：SVG</p>
<p>纯文本可以记笔记：Markdown</p>
<p>下一步：纯文本可以做视频？（其实已经实现了，机器学习用文本生成视频，只是没有形成一个通用的协议）</p>
<p>纯文本可以干这么多事情，本质上是制定了各种协议，然后由协议来实现的。</p>
<h2 id="wiki-1"><a class="header" href="#wiki-1">Wiki</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a></p>
<p><strong>Scalable Vector Graphics</strong> (<strong>SVG</strong> 可缩放矢量图) is an <a href="https://en.wikipedia.org/wiki/Extensible_Markup_Language">Extensible Markup Language</a> (XML)-based <a href="https://en.wikipedia.org/wiki/Vector_image_format">vector image format</a> for <a href="https://en.wikipedia.org/wiki/Two-dimensional">two-dimensional</a> graphics with support for interactivity and animation. The SVG specification is an <a href="https://en.wikipedia.org/wiki/Open_standard">open standard</a> developed by the <a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium</a> (W3C) since 1999.</p>
<p>SVG images and their behaviors are defined in XML text files. This means that they can be <a href="https://en.wikipedia.org/wiki/Search_algorithm">searched</a>, <a href="https://en.wikipedia.org/wiki/Subject_indexing">indexed</a>, <a href="https://en.wikipedia.org/wiki/Scripting_language">scripted</a>, and <a href="https://en.wikipedia.org/wiki/Data_compression">compressed</a>. As XML files, SVG images can be created and edited with any <a href="https://en.wikipedia.org/wiki/Text_editor">text editor</a>, as well as with <a href="https://en.wikipedia.org/wiki/Drawing_software">drawing software</a>.</p>
<p>All major modern <a href="https://en.wikipedia.org/wiki/Web_browser">web browsers</a>—including <a href="https://en.wikipedia.org/wiki/Mozilla_Firefox">Mozilla Firefox</a>, <a href="https://en.wikipedia.org/wiki/Internet_Explorer">Internet Explorer</a>, <a href="https://en.wikipedia.org/wiki/Google_Chrome">Google Chrome</a>, <a href="https://en.wikipedia.org/wiki/Opera_(web_browser)">Opera</a>, <a href="https://en.wikipedia.org/wiki/Safari_(web_browser)">Safari</a>, and <a href="https://en.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a>—have <a href="https://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Scalable_Vector_Graphics)">SVG rendering support</a>.</p>
<p>SVG 图片的特点：</p>
<ul>
<li>矢量图，放大不失真</li>
<li>可交互，支持动画</li>
<li>文本文件，采用 xml 语言定义，主流浏览器可渲染</li>
</ul>
<h2 id="阮一峰-svg-入门教程"><a class="header" href="#阮一峰-svg-入门教程">阮一峰 SVG 入门教程</a></h2>
<p><a href="http://www.ruanyifeng.com/blog/2018/08/svg.html">link</a></p>
<p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p>
<p>SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;svg
             id=&quot;mysvg&quot;
             xmlns=&quot;http://www.w3.org/2000/svg&quot;
             viewBox=&quot;0 0 800 600&quot;
             preserveAspectRatio=&quot;xMidYMid meet&quot;
             &gt;
            &lt;circle id=&quot;mycircle&quot; cx=&quot;400&quot; cy=&quot;300&quot; r=&quot;50&quot; /&gt;
        &lt;svg&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上面是 SVG 代码直接插入网页的例子。</p>
<p>SVG 代码也可以写在一个独立文件中，然后用</p>
<pre><code class="language-html">&lt;iframe&gt; &lt;embed&gt; &lt;object&gt; &lt;img&gt;
</code></pre>
<p>等标签插入网页。</p>
<pre><code class="language-html">&lt;img src=&quot;circle.svg&quot;&gt;
&lt;object id=&quot;object&quot; data=&quot;circle.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;
&lt;embed id=&quot;embed&quot; src=&quot;icon.svg&quot; type=&quot;image/svg+xml&quot;&gt;
&lt;iframe id=&quot;iframe&quot; src=&quot;icon.svg&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>CSS 也可以使用 SVG 文件。</p>
<pre><code class="language-css">.logo {
background: url(icon.svg);
}
</code></pre>
<p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p>
<pre><code class="language-html">&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt;
</code></pre>
<h2 id="用-javascript-生成-svg-标签"><a class="header" href="#用-javascript-生成-svg-标签">用 JavaScript 生成 SVG 标签</a></h2>
<p>实际应用中，我们不可能手写 SVG，可以由 JavaScript 生成的。</p>
<h2 id="给-svg-标签添加事件"><a class="header" href="#给-svg-标签添加事件">给 SVG 标签添加事件</a></h2>
<p>给标签加标识，然后对标识添加事件。本质上是对 svg 标签添加点击事件。</p>
<pre><code class="language-javascript">// 给所有的线和圆添加鼠标移到上面的事件
var lines = document.getElementsByClassName('lineStyle');
var circles = document.getElementsByClassName('circleStyle');
for(var i=0; i&lt;circles.length; i++){
  // onmouseover 事件发生在鼠标指针移动到元素或它的子元素上时。
  circle[i].onmouseover = function(){
  
  }
  circle[i].onmouseleave = function(){
  
  }
}
for(var i=0; i&lt;lines.length; i++){
  // onmouseover 事件发生在鼠标指针移动到元素或它的子元素上时。
  lines[i].onmouseover = function(){
  
  }
  lines[i].onmouseleave = function(){
  
  }
}
</code></pre>
<h2 id="运动动画"><a class="header" href="#运动动画">运动动画</a></h2>
<ul>
<li>原生 JS 操作 JQuery 的 animate
<ul>
<li>duration</li>
<li>easing</li>
<li>step</li>
</ul>
</li>
<li>svg 运动标签 animate
<ul>
<li>attributeName</li>
<li>dur</li>
<li>from</li>
<li>to</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正则表达式-1"><a class="header" href="#正则表达式-1">正则表达式</a></h1>
<p>[TOC]</p>
<h2 id="正则表达式替换"><a class="header" href="#正则表达式替换">正则表达式替换</a></h2>
<pre><code>'(measure_site)\.(.*?views.*?)(\..*)'
(\1)_(\2)(\3)

用于将 'measure_site.views_showx.config_tasklist_groupby_source' 替换成 measure_site_views_showx.config_tasklist_groupby_source

p
</code></pre>
<h2 id="正则表达式符号的优先级"><a class="header" href="#正则表达式符号的优先级">正则表达式符号的优先级</a></h2>
<p>| &lt;  the ^ $ &lt; * + ? {}  &lt; ()</p>
<h2 id="正则表达式工具"><a class="header" href="#正则表达式工具">正则表达式工具</a></h2>
<p>http://tool.oschina.net/regex/#</p>
<p><strong>可以用Notepad++的正则表达式功能去测试</strong></p>
<p>经过测试，这个在线工具和python的正则表达式是没有冲突的，完美匹配</p>
<p>提供了很多正则表达式的模板</p>
<h2 id="重点"><a class="header" href="#重点">重点</a></h2>
<ol>
<li>转义字符为 <code>\</code>, <code> \</code> 在正则表达式中也是特殊字符,需要转义才能用,也就是说,在匹配的时候,要用两个 \ 来匹配 </li>
<li>findall中千万不要加() ，真的很烦，操，就算加了（），那么写完的正则表达式，也不要再findall中测试，不知道返回的什么玩意。如果findall的pattern中存在捕获组，也就是括号，那么整个表达式匹配的文本不会包含在返回的文本中，而是返回每一个括号匹配文本构成的tuple
例如<code>re.findall(r'(\d{4})-(\d{2})-(\d{2})'), '2018-02-10 2018-12-30'</code> 返回的结果为<code> [('2018','2','10'),('2018','12','30')]</code></li>
<li>正则表达式有可能把字符串末的换行符替换掉，那么字符串就不能换行了！！(regex)代表一个分组，假设我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个()所指代的内容，item[1]就代表第二个()所指代的内容，以此类推。</li>
<li>正则表达式前面要加** r** ，这样就避免了字符的转义，r 为原生字符</li>
<li><strong><code>.</code>号不能匹配换行符 \n，可以匹配空格</strong></li>
<li><code>\s</code> 能够匹配换行符，而不是只匹配空格，所以如果想匹配空格，最保险的方法是直接输入一个空格 </li>
<li>正则表达式只能匹配一行的内容，如果需要跨行匹配，则需要把文本的所有行拼在一起，也就是把换行符都删掉 <code>str.replace(&quot;\n&quot;, &quot; &quot;)</code></li>
<li><code>\d</code> 只能匹配 0-9，不能匹配负数！！！</li>
<li>匹配 0 个或 1 个：<code>?</code></li>
</ol>
<h2 id="常见的正则表达式"><a class="header" href="#常见的正则表达式">常见的正则表达式</a></h2>
<pre><code>匹配url
re_url = '(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]'

匹配汉字
re_chinese = '[\u4e00-\u9fa5]'
</code></pre>
<h2 id="正则表达式的规则"><a class="header" href="#正则表达式的规则">正则表达式的规则</a></h2>
<h3 id="枚举"><a class="header" href="#枚举">枚举</a></h3>
<pre><code>枚举
[aA]  [万玩晚] [a-z] [A-Z] [0-9] [abcd]

范围表示法的本质：根据字符对应的ASCII码顺序，可以是 [0-3], 但是不可以逆序:[3-0]
</code></pre>
<h3 id="-的用法"><a class="header" href="#-的用法">^ 的用法</a></h3>
<pre><code>^ 的两种用法
1. 非  ^
[^A-Z] 开头不是大写字母
[^Ss] 开头不是字母 s
[^\.] 开头不是 .
注意，如果开头是取非符号的话，那么 [] 所有枚举的都不匹配

2. 表示以什么为开头
http://www.baidu.com
^http 能匹配到 http
^ttp   不能匹配到 ttp，因为找不到以 t 开头的字符串

注意 ^ 只有在开头才起作用，而且只能用在 [ ]中
[a^b] 只能匹配 a，^ 或者 b
a^b 只能匹配 a^b
</code></pre>
<hr />
<pre><code>可选可不选 ?

原则：就近原则

colou?r 可以匹配 color 或者 colour

</code></pre>
<hr />
<pre><code>0 个或 任意多个  *

wansho* 可以匹配 wansho,wanshoo,wanshooo,wanshoooo
[ab]*可以匹配 aaabbabaabb,aaab,aaa,bbb,ababab

</code></pre>
<hr />
<pre><code>1个或任意多个  +

和上面类似
</code></pre>
<hr />
<pre><code>匹配任意字符

你好.*请问.* 　可以匹配　你好，我是，请问。。。 注意不能匹配换行
</code></pre>
<hr />
<pre><code>匹配词的边界 
\b     boundary
例如 \bthe\b 匹配 the 而不是匹配 other
</code></pre>
<hr />
<pre><code>或者  |

| 的优先级最低，可以用来括住两个正则表达式

dog|cat 能匹配dog,cat
.*请问.*|.*吗.*|.*是不是.*|.*问题.*|.*咋.*|.*什么.*|.*有没有.*  可以匹配一些提问

</code></pre>
<hr />
<pre><code>括号 ()

可以括住任何东西，经常和 | 合作

举例：
NLPLove Deep Learning
re : (NLP)|(\bDeep\b)
result : NLP Deep
</code></pre>
<hr />
<pre><code>正则的贪心性

举例:
[a-z]*  会匹配最长能匹配到的字符串

默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。例如?

</code></pre>
<h3 id="保留字符-转义"><a class="header" href="#保留字符-转义">保留字符 (转义)</a></h3>
<pre><code>转义字符

对于正则表达式中的一些符号，如果想用作字符的话，需要进行转义
例如 匹配 ？  ： \?

所有的元字符 ：
. ^ $ * + ? { } [ ] \ | ( )
在使用时都需要转义

</code></pre>
<hr />
<pre><code>特殊字符


\t 匹配一个tab
\n 匹配一个换行
\* 匹配一个 * 号
\w 匹配 [a-z0-9A-Z] 还有下划线
\W 匹配 ^\w
\s 匹配 空格
\d 匹配数字
\D 匹配非数字

</code></pre>
<hr />
<pre><code>出现次数

{n} 出现了n次
{n,m} 出现 n 到 m 次
{n,} 不少于 n 次
</code></pre>
<hr />
<pre><code>替换

举例：
the (.*)er they are, the \1er they will be 

the \1 will be replaced by whatever string matched the first item in parenteses().

the (.*)er they (.*), the \1er we \2

给每个单词加引号

notepad++ 匹配目标： (.+)
替换为： &quot;\1&quot;
 
</code></pre>
<hr />
<pre><code>特殊符号：
^ 定位到字符串的起始位置，也就是从字符串开头进行匹配
$ 定位到字符串末尾
如果一个正则表达式是： ^123$ ,那么该字符串就是匹配整个字符串都是123的字符
</code></pre>
<h2 id="ant-模式匹配"><a class="header" href="#ant-模式匹配">Ant 模式匹配</a></h2>
<p><code>*</code> ：匹配 0 个或多个字符（不包含<a href="https://so.csdn.net/so/search?q=%E5%88%86%E9%9A%94%E7%AC%A6&amp;spm=1001.2101.3001.7020">分隔符</a> <code>/</code>）
<code>?</code> ：匹配一个字符
<code>**</code> ：匹配 0 个或多个目录（如果模式以 <code>/</code> 或 <code>\</code> 结尾，则会自动补上 **）</p>
<p><img src="computer-science-notebook/programming-language/assets/image-20220927103246593.png" alt="image-20220927103246593" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-批处理命令"><a class="header" href="#windows-批处理命令">Windows 批处理命令</a></h1>
<p>[TOC]</p>
<h2 id="批处理命令的作用"><a class="header" href="#批处理命令的作用">批处理命令的作用</a></h2>
<p>将重复的事情自动化批处理，常用于开机时的一些系统配置。</p>
<h2 id="windows-开启自启设置"><a class="header" href="#windows-开启自启设置">Windows 开启自启设置</a></h2>
<p>将写好的 bat 脚本扔到 Windows 开启自启文件夹中，Win10 的地址为： <code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code> 中即可。</p>
<h2 id="fixed-problems-1"><a class="header" href="#fixed-problems-1">Fixed Problems</a></h2>
<ol>
<li>
<p>您需要管理员权限才能移动到此文件夹</p>
<p>把杀毒软件关掉，包括火绒</p>
</li>
</ol>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<h3 id="echo"><a class="header" href="#echo">echo</a></h3>
<p>如果在批处理文件第一行加上echo off 命令，那么批处理文件中的cmd就不会出现在命令行窗口中，只会显示结果。</p>
<p>注意：</p>
<ol>
<li>echo 不能叠加在一行中，否则把echo也打印出来</li>
<li>echo off 如果想有效果，必须放在第一行！其有效范围是该命令之后的命令</li>
</ol>
<p>使用场景：</p>
<p>如果该批处理文件是提供给别人用的，而且你不像使用者知道你用了什么命令，例如病毒，那么就可以使用echo off 来屏蔽这些命令的显示，只显示结果。</p>
<h3 id=""><a class="header" href="#">@</a></h3>
<p>@作用和echo类似，同样用于屏蔽命令，不同的是，该命令只能一行一行的屏蔽。但是其能屏蔽echo off 命令！</p>
<pre><code class="language-powershell">@echo off
</code></pre>
<h3 id="pause"><a class="header" href="#pause">pause</a></h3>
<p>该命令起到暂停执行的作用，可以使DOS窗口暂停关闭</p>
<p>pause在敲回车后，程序继续执行</p>
<h3 id="goto"><a class="header" href="#goto">goto</a></h3>
<p>跳转执行命令，跳转的位置必须有一个标识符。例如下面的命令中，1 就是一个标志，以: 开头。</p>
<p>使用场景：往往配合if 语句使用，或者用goto实现循环效果</p>
<pre><code class="language-powershell">echo off
: 1
echo 万东鑫
goto 1
</code></pre>
<h3 id="call"><a class="header" href="#call">call</a></h3>
<ol>
<li>调用另外一个bat文件</li>
<li>调用指定标记后面的所有命令</li>
</ol>
<p>使用场景：打开另一个bat文件，或者调用其他的命令</p>
<h3 id="start"><a class="header" href="#start">start</a></h3>
<p>该命令是异步执行的。</p>
<pre><code class="language-powershell">rem 新开一个窗口，然后执行 cmd
start &quot;窗口名&quot; cmd 
</code></pre>
<h3 id="rem"><a class="header" href="#rem">rem</a></h3>
<p>注释。注意：要在脚本开头加上 <code>echo off</code> 否则注释会出现在命令行中</p>
<h2 id="demos"><a class="header" href="#demos">Demos</a></h2>
<h3 id="启动某些软件"><a class="header" href="#启动某些软件">启动某些软件</a></h3>
<pre><code class="language-powershell">rem 酷Q
start &quot;&quot; &quot;E:\酷Q Air\CQA.exe&quot;  
rem &quot;&quot; 是新打开的cmd的窗口名
rem Chrome
start &quot;&quot; &quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chrome.exe&quot;
rem 百度云
start &quot;&quot; &quot;E:\百度云管家\BaiduNetdisk\BaiduNetdisk.exe&quot;
rem 搜索
start &quot;&quot; &quot;C:\Program Files\Everything\Everything.exe&quot;
rem 文件管理器
start explorer
rem 打开OneNote
start &quot;&quot; &quot;C:\Program Files (x86)\Microsoft Office\root\Office16\ONENOTE.exe&quot;
</code></pre>
<h3 id="循环删除某个文件夹"><a class="header" href="#循环删除某个文件夹">循环删除某个文件夹</a></h3>
<pre><code class="language-powershell">@echo off
rem 不断的检测，循环删除一个文件
: 1
if exist &quot;H:\代码\批处理文件\你好&quot; (
rd /s /q &quot;H:\代码\批处理文件\你好&quot; 
goto 1 )  else (
echo 没有发现该文件
goto 1
)
</code></pre>
<h3 id="拨号上网"><a class="header" href="#拨号上网">拨号上网</a></h3>
<pre><code class="language-powershell">rem 注意拨号上网的名称要用 ASCII 字符
rasdial name SZ1716029 300059 
</code></pre>
<h3 id="按照端口号查杀进程"><a class="header" href="#按照端口号查杀进程">按照端口号查杀进程</a></h3>
<pre><code class="language-powershell">netstat -ano | findstr 8007 # 8007 端口号
tasklist | findstr 20992 # 20992 进程号
taskkill /f /pid 20992
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qt"><a class="header" href="#qt">QT</a></h1>
<p>[TOC]</p>
<h2 id="安装和环境配置"><a class="header" href="#安装和环境配置">安装和环境配置</a></h2>
<p><a href="http://download.qt.io/archive/qt/">[Download]</a> 版本 5.9.4 <a href="https://blog.csdn.net/qq_23473839/article/details/80523318">[安装教程]</a></p>
<p>选择安装的组件：</p>
<ul>
<li>MinGW (使用 MinGW 编译)</li>
<li>所有以 QT 开头的组件</li>
<li>Tools 下的 Qt Creater 和 MinGW</li>
</ul>
<p>注意：QT 也支持 <strong>Python</strong> 作为开发语言，<strong>PyQt</strong></p>
<h2 id="入门资源"><a class="header" href="#入门资源">入门资源</a></h2>
<p><a href="https://www.qt.io/developers">[Qt Developer]</a></p>
<ul>
<li><a href="https://doc.qt.io/qt-5/qtwidgets-tutorials-notepad-example.html">Getting Started Programming with Qt Widgets</a></li>
<li><a href="https://doc.qt.io/qt-5/qtdoc-tutorials-alarms-example.html">Getting Started Programming with Qt Quick</a></li>
</ul>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p><a href="https://doc.qt.io/qt-5/qtwidgets-tutorials-notepad-example.html">[Tutorial]</a> <a href="https://doc.qt.io/qt-5/qtdesigner-manual.html">[Qt Designer Manual]</a> <a href="https://doc.qt.io/qt-5.9/index.html">[Qt Documentation]</a></p>
<h3 id="工程文件"><a class="header" href="#工程文件">工程文件</a></h3>
<p>The <strong>Qt Widgets Application</strong> wizard creates a project that contains a main source file and a set of files that specify a user interface (Notepad widget):</p>
<ul>
<li>notepad.pro - the project file.</li>
<li>main.cpp - the main source file for the application.</li>
<li>notepad.cpp - the source file of the notepad class of the Notepad widget.</li>
<li>notepad.h - the header file of the notepad class for the Notepad widget.</li>
<li>notepad.ui - the UI form for the Notepad widget.</li>
</ul>
<h3 id="ui-qt-designer"><a class="header" href="#ui-qt-designer">UI Qt Designer</a></h3>
<p>UI 文件实际上是一个 xml 文件。</p>
<p>When you build the application, Qt Creator launches the Qt <a href="https://doc.qt.io/qt-5/uic.html">User Interface Compiler (uic)</a> that reads the .ui file and creates a corresponding C++ header file, ui_notepad.h.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="note-for-c"><a class="header" href="#note-for-c">Note-for-C</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-learn-c"><a class="header" href="#how-to-learn-c">How to Learn C</a></h1>
<h2 id="入门"><a class="header" href="#入门">入门</a></h2>
<ul>
<li>How to Think Like a Computer Scientist  C Version</li>
</ul>
<h2 id="深入"><a class="header" href="#深入">深入</a></h2>
<ul>
<li>Modern-C</li>
<li><a href="https://www.bilibili.com/video/BV1o741177Gv">【C语言】深入剖析班（国嵌主讲）（直戳C语言的本质）</a></li>
<li>C 语言深度剖析 链接：https://pan.baidu.com/s/1Ri87HP0PtudmgNWgdJwVZQ 提取码：xan1 </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-think-like-a-computer-scientist--c-version"><a class="header" href="#how-to-think-like-a-computer-scientist--c-version">How to Think Like a Computer Scientist  C Version</a></h1>
<p>[TOC]</p>
<h2 id="c-语言起源和什么是编程"><a class="header" href="#c-语言起源和什么是编程">C 语言起源和什么是编程</a></h2>
<p>程序员最重要的能力：解决问题的能力。（对问题进行计算机的抽象，并解决问题）</p>
<p>编程：programming is the process of breaking a large, complex task up into smaller and smaller subtasks until eventually the subtasks are simple enough to be performed with one of these basic operations.</p>
<p>C 语言在 1970 年代由 Dennis M. Ritchie  在贝尔实验室创造。</p>
<h2 id="什么是程序"><a class="header" href="#什么是程序">什么是程序</a></h2>
<p><strong>任何程序都是由 输入，输出，条件语句，循环语句，数学运算符/操作符 所构成</strong></p>
<h2 id="什么是-debug"><a class="header" href="#什么是-debug">什么是 Debug</a></h2>
<ul>
<li>Compile-time errors  编译时问题</li>
<li>Run-time errors  运行时问题</li>
<li>Logic errors and semantics  逻辑问题</li>
</ul>
<h2 id="翻译高级语言的方式"><a class="header" href="#翻译高级语言的方式">翻译高级语言的方式</a></h2>
<ul>
<li>
<p>Interpreting</p>
<p>translates the program line-by-line  边解释边执行</p>
</li>
<li>
<p>Compiling</p>
<p>translates it all at once and generate a executable object 一次编译，多次执行</p>
</li>
</ul>
<p>注意，一种语言不能被简单地归类为编译型语言或者解释型语言：</p>
<p>C 语言在很多人的印象中是编译型语言，但是 TCC 却可以解释执行 C；</p>
<p>Java 是先将源码编译成字节码，然后由虚拟机逐条解释执行；</p>
<p>CPython 是将 Python 源码编译成字节码，有可能存到 .pyc 的字节码文件中，然后由解释器解释执行；</p>
<h2 id="编程语言的分类"><a class="header" href="#编程语言的分类">编程语言的分类</a></h2>
<p><img src="computer-science-notebook/note-for-c/assets/image-20200523112503095.png" alt="编程语言分类" /></p>
<h3 id="high-level-vs-low-level"><a class="header" href="#high-level-vs-low-level">High Level vs Low Level</a></h3>
<ul>
<li>high level (高级语言)
<ul>
<li>C，Java，Python，C++</li>
</ul>
</li>
<li>low level (低级语言)
<ul>
<li>汇编语言</li>
</ul>
</li>
</ul>
<p>计算机只能运行低级语言，所有以高级语言编写的程序，都要被<strong>翻译</strong>成低级语言，然后再运行。翻译的过程需要耗费一定的时间，这也是高级语言的一个缺点。</p>
<h3 id="强类型-vs-弱类型"><a class="header" href="#强类型-vs-弱类型">强类型 vs 弱类型</a></h3>
<p>强弱和内存有关。</p>
<ul>
<li>
<p>强类型</p>
<p>一个变量在定义的时候，就已经确定好了这个变量的类型，后面不能再改变。没有强制类型转换之前，不允许两个类型不能的变量进行相互操作；<strong>一块内存只能看作一种类型</strong>；</p>
<p>error cases:</p>
<pre><code class="language-java">int a = 1.1; // java
</code></pre>
<pre><code class="language-python">a = 1
a = a + '1' # python
</code></pre>
</li>
<li>
<p>弱类型</p>
<p>数据类型可以被忽略。一个变量可以被赋予不同类型的值；<strong>允许将一块内存看作多种类型</strong>，例如 C 语言可以将整型变量和字符型变量相加。C 语言中的类型实际上就是一块内存的别称。</p>
<p>right cases:</p>
<pre><code class="language-c">int a = 1;
printf(&quot;%d \n&quot;, a + '1'); % 50
</code></pre>
</li>
</ul>
<h3 id="动态类型-vs-静态类型"><a class="header" href="#动态类型-vs-静态类型">动态类型 vs 静态类型</a></h3>
<p>动态 or 静态和编译运行有关</p>
<ul>
<li>
<p>动态类型</p>
<p>在<strong>程序运行时</strong>检查数据类型，python 就是动态类型</p>
<p>example:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 1
&gt;&gt;&gt; type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = &quot;s&quot;
&gt;&gt;&gt; type(a)
&lt;type 'str'&gt;
</code></pre>
</li>
<li>
<p>静态类型</p>
<p>在<strong>编译阶段</strong>检查数据类型</p>
<p>error cases:</p>
<pre><code class="language-java">int a = 1.1; // java，在编译成字节码 class 文件时就会报错
</code></pre>
</li>
</ul>
<h2 id="代码风格"><a class="header" href="#代码风格">代码风格</a></h2>
<ul>
<li>
<p><strong>variableNames</strong>: 首字母小写，驼峰风格</p>
</li>
<li>
<p><strong>FunctionNames</strong>: 首字母大写，驼峰风格；最好包含一个可以描述该函数的动词；返回布尔值的函数以 'Is Are' 开始</p>
</li>
<li>
<p><strong>UserDefinedTypes_t</strong>: always end in ’_t’. Type names names must be capitalised in order to avoid conflict with POSIX names.</p>
</li>
<li>
<p><strong>pointerNames_p</strong>: in order to visually separate pointer variables from ordinary variables you should consider ending pointers with ’_p’.</p>
</li>
</ul>
<pre><code class="language-c">if (condition) {
    statement1;
    statement2;
}

/*
* File: test.c
* Author: Peter Programmer
* Date: May, 29th, 2009
*
* Purpose: to demonstrate good programming
* practise
* /

#include &lt;stdlib.h&gt;

/*
* main function, does not use arguments
*/
int main (void){
	return EXIT_SUCCESS;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-语言深度剖析"><a class="header" href="#c-语言深度剖析">C 语言深度剖析</a></h1>
<ul>
<li><a href="https://www.bilibili.com/video/BV1o741177Gv">【C语言】深入剖析班（国嵌主讲）（直戳C语言的本质）</a>
<ul>
<li>书籍：C 语言深度剖析 链接：https://pan.baidu.com/s/1Ri87HP0PtudmgNWgdJwVZQ 提取码：xan1 </li>
</ul>
</li>
</ul>
<p>C 语言是一门静态的弱类型语言。</p>
<p>作者：陈正冲 毕业于长春光学精密机械学院（长春理工大学）数学系</p>
<h2 id="数据类型的本质"><a class="header" href="#数据类型的本质">数据类型的本质</a></h2>
<p>C 语言中的数据类型可以理解为<strong>固定内存大小的别名</strong>，是<strong>创建变量的模子</strong>。</p>
<p>C 语言是一种<strong>弱类型语言</strong>，其<strong>一块内存可以叫做不同的类型</strong>。<strong>汇编时代</strong>，程序员都是直接从内存中申请 1 个字节，两个字节，4 个字节的空间，后来为了方便使用，所以对固定大小的内存空间进行命名。</p>
<p>内存空间按照大小可以命名为：</p>
<table><thead><tr><th>字节数</th><th>命名</th></tr></thead><tbody>
<tr><td>1</td><td>char</td></tr>
<tr><td>2</td><td>short</td></tr>
<tr><td>4</td><td>int</td></tr>
</tbody></table>
<pre><code class="language-c">int i; // 告诉编译器，申请一个 4 个字节大小的空间，将其叫做 i

sizeof(short); // 查找一下 short 是什么的别名，原来是两个字节的别名
</code></pre>
<pre><code class="language-c">#include&lt;stdio.h&gt;

/*
1. typedef 顾名思义，类型定义，给数据类型起别名；
2. typedef 是一条语句，需要加 ;
3. typedef 自定义的类型，要全部大写；
4. 结构体就是一个类型，用 typedef 对结构体进行重命名
*/
typedef int INT32; 
typedef unsigned char BYTE; 
typedef struct _demo { // 8 个字节
	short s;
	BYTE b1;
	BYTE b2;
	INT32 i;
} DEMO;

int main() {
	// 创建变量后，并不一定要初始化
	INT32 i32;
	BYTE byte;
	DEMO d;

	printf(&quot;%d, %d \n&quot;, sizeof(INT32), sizeof(i32));
	printf(&quot;%d, %d \n&quot;, sizeof(BYTE), sizeof(byte));
	printf(&quot;%d, %d \n&quot;, sizeof(DEMO), sizeof(d));
	/*
	4, 4
	1, 1
	8, 8 
	从此处可以看出，结构体 struct 本身并不占用多余的空间，结构体只是多种数据类型组合而成的新的数据结构
	*/

	return 0;
}

</code></pre>
<h2 id="变量名的本质"><a class="header" href="#变量名的本质">变量名的本质</a></h2>
<p>变量是一段实际连续存储空间的别名；程序中通过变量来申请并命名存储空间；通过变量的名字可以使用存储空间。</p>
<p>指针，指针也是变量。</p>
<h2 id="变量的属性--属性关键字"><a class="header" href="#变量的属性--属性关键字">变量的属性 / 属性关键字</a></h2>
<p><strong>变量可以拥有自己的属性</strong>：auto, register, static。在定义变量的时候，可以加上属性关键字，属性关键字表明了变量的特殊意义。</p>
<table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody>
<tr><td>auto</td><td>1. C 语言中<strong>局部变量</strong>的默认属性</td></tr>
<tr><td></td><td>2. 指明在程序的<strong>栈</strong>上分配空间（也就是说，局部变量都是在栈上分配的空间）</td></tr>
<tr><td>static</td><td>1. static 修饰的<strong>局部变量</strong>存储在<strong>程序静态区</strong></td></tr>
<tr><td></td><td>2.1. static 修饰的<strong>全局变量</strong>，其作用域只限于该文件（<strong>声明作用域</strong>）</td></tr>
<tr><td></td><td>2.2. static 修饰的<strong>函数</strong>，其作用域只限于该文件</td></tr>
<tr><td>register</td><td>1. 声明变量存储在<strong>寄存器</strong>中（访问速度比内存更快）</td></tr>
<tr><td></td><td>1.1 register 修饰的变量，必须是 CPU 可以接受的类型，其长度应该 &lt;= 整型</td></tr>
<tr><td></td><td>1.2 register 修饰的变量，不能对其用取址运算符 <code>&amp;</code>，因为<strong>取址运算符是用来去内存寻址的</strong>，而 register 不是内存</td></tr>
<tr><td></td><td>1.3 register 只是<strong>请求</strong>将变量放在寄存器中，实际上<strong>可能申请不到</strong></td></tr>
<tr><td></td><td>2. 寄存器变量用在<strong>讲究性能的实时系统</strong>中</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C++</a></h1>
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<p>以后排查问题的时候 可以用这种办法直接在某个语句调用之前在日志里面输出调用的堆栈。</p>
<p>http://www.gnu.org/software/libc/manual/html_node/Backtraces.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="note-for-python"><a class="header" href="#note-for-python">Note-for-Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandas"><a class="header" href="#pandas">Pandas</a></h1>
<p>[TOC]</p>
<h2 id="learning-pandas"><a class="header" href="#learning-pandas">Learning Pandas</a></h2>
<ol>
<li>官方文档1：http://pandas.pydata.org/pandas-docs/stable/</li>
<li>官网文档2：https://pandas.pydata.org/pandas-docs/stable/user_guide/index.html</li>
<li><a href="https://book.douban.com/subject/25779298/">《利用 Python 进行数据分析》</a></li>
</ol>
<h2 id="pandas-introduction"><a class="header" href="#pandas-introduction">Pandas Introduction</a></h2>
<p>Pandas 是 Excel 和 SQL 的结合体。Excel 和 SQL 中实现的数据处理功能，Pandas 基本上都能实现。</p>
<h2 id="pandas-特征"><a class="header" href="#pandas-特征">Pandas 特征</a></h2>
<ul>
<li>pandas 能够替换一些非常复杂的嵌套 for 循环，或者 if 的嵌套，能用 pandas 简化，就尽量用 pandas 简化，包括将 pandas 的所有值转换成一个 字典 list</li>
<li>pandas 能够简化大多数的数据处理，能用 pandas，就尽量不要用其他逻辑</li>
<li>很多时候，是需要什么功能，去找 pandas 的功能，而不是学会了再去用，这种思想要转变过来</li>
<li>学习 pandas 一定要有开放的心态，我们不可能把所有的方法都记住的，我们需要具备的能力，是能敏锐的观察到 pandas 会提供一种解决这个问题的方法，然后我们再去快速的找出来；其实学习其他技术也是如此。</li>
<li>Pandas 几乎所有的方法，都是级联的，cascade，在方法处理完后，都会返回一个 pandas 对象</li>
</ul>
<h2 id="pandas-series"><a class="header" href="#pandas-series">Pandas Series</a></h2>
<p>Series 是一个类数组的数据结构，同时带有标签（lable）或者说索引（index）。</p>
<h3 id="init-a-pandas-series"><a class="header" href="#init-a-pandas-series">Init a Pandas Series</a></h3>
<p>新建 Series 对象，有三种常见方法</p>
<pre><code class="language-python">from pandas import Series
ser1 = Series([1,2,3,4]) # 直接用 list 生成，index 默认从 0 开始

ser1 = Series([1,2,3,4], index=[0,1,2,3]) # 指定 index，values 值不支持 关键字参数

sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000} # 用字典生成，key 作为 index，value 作为 value，采用此种生成方式，比较耗费内存
ser3 = Series(sdata)
</code></pre>
<h3 id="series-查找赋值"><a class="header" href="#series-查找赋值">Series 查找/赋值</a></h3>
<p>Series 查找的时间复杂度为 O(1)，可以按照元素在 series 中的位置进行查找，也可以按照标签进行查找</p>
<pre><code class="language-Python">series_demo[0]
series[&quot;name&quot;]

# DataFrame Demo
for index, row in pd_data.iterrows():
    print row[0] # 按照位置查找
    print row[&quot;name&quot;] # 按照标签查找
    
# 对 Series 的 index 重新赋值
pd_series.index = [&quot;1&quot;,&quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
</code></pre>
<h3 id="series-特有的方法"><a class="header" href="#series-特有的方法">Series 特有的方法</a></h3>
<h4 id="value_counts"><a class="header" href="#value_counts">value_counts()</a></h4>
<p>统计每个 value 出现的次数</p>
<pre><code class="language-Python">pd_demo = pd.Series([1,2,3,4,5,5,2,3])
pd_demo.value_counts() # 返回一个 pandas.Series 对象，index为value 集合，value 为每一个index的频数，按照降序排列
</code></pre>
<h4 id="计算分位数--获取中位数"><a class="header" href="#计算分位数--获取中位数">计算分位数 / 获取中位数</a></h4>
<pre><code class="language-Python"># 计算分位数
pd_series.quantile(0.5) # 将 pd_series 中的数先排序，然后获取 0.9 分位的数
</code></pre>
<h4 id="series-去重"><a class="header" href="#series-去重">Series 去重</a></h4>
<pre><code class="language-Python"># unique 方法，获取去重后的值，其功能等价于 set()
pd_series = pd_series.unique()
</code></pre>
<h2 id="pandas-dataframe"><a class="header" href="#pandas-dataframe">Pandas DataFrame</a></h2>
<h3 id="dataframe-attention-"><a class="header" href="#dataframe-attention-">DataFrame Attention !!!</a></h3>
<ul>
<li>DataFrame 的算数运算/函数运算等各种运算，其都是按照 index 进行匹配，我们在计算的时候，不能忽略 index 这个潜藏的因素</li>
</ul>
<h3 id="dataframe-构造"><a class="header" href="#dataframe-构造">DataFrame 构造</a></h3>
<p>一个 DataFrame 对象就是一张数据库中的表。</p>
<p>DataFrame 构造方式：</p>
<ul>
<li>第一种：传入一个 元素为 dict 的 sequence</li>
<li>第二种：传入一个元素为 tuple 的 sequence，并指定 column</li>
<li>第三种：传入一个 dict</li>
<li>第四种：传入一个 DataFrame (浅拷贝)</li>
<li>指定 index，column，构建一个空的 DataFrame</li>
</ul>
<p><strong>注意，对于没有指定 index 的 DataFrame，其 Index 为 [0, 1, 2, 3, ……]</strong></p>
<pre><code class="language-python">import pandas as pd

# 第一种：dict in list
my_list = [{&quot;name1&quot;:&quot;wanshuo&quot;,&quot;age&quot;:&quot;11&quot;}, {&quot;name1&quot;:&quot;wangyanan&quot;,&quot;age&quot;:&quot;13&quot;}]
pd_data = pd.DataFrame(my_list) # 传入一个 list 

# 第二种：tuple in list + column
my_list = [(&quot;wansho&quot;, 11), (&quot;wandongxin&quot;, 12)]
pd_data = pd.DataFrame(my_list, columns=[&quot;name&quot;, &quot;age&quot;])

# 第三种：dict
data = {'name' : ['万朔', '王雅楠'], 'age' : [12,13]}
pd_data = pd.DataFrame(data)

# 第四种：传入一个 DataFrame
pd.DataFrame(dataframe)

# 构建空的 DataFrame，但是有 columns，有 index
pd_result = pd.DataFrame(index=[&quot;index1&quot;, &quot;index2&quot;], columns=[&quot;timelist&quot;, &quot;type&quot;, &quot;name&quot;, &quot;refer&quot;]) # pd_result 仍然是空的 pd_result.empty
</code></pre>
<h3 id="empty-判空"><a class="header" href="#empty-判空">empty 判空</a></h3>
<p>empty 适用于 Pandas 中的任何对象，包括 DataFrame， Series</p>
<pre><code class="language-Python"># empty 判空
pandas_data = pd.DataFrame()
if pandas_data.empty:
    continue
</code></pre>
<h3 id="dataframe-元素查找与替换"><a class="header" href="#dataframe-元素查找与替换">DataFrame 元素查找与替换</a></h3>
<h4 id="replace-元素替换"><a class="header" href="#replace-元素替换">replace() 元素替换</a></h4>
<pre><code class="language-python"># replace 替换方法
pd_data.replace([100, 101], 1) # 把所有的 100 和 101 替换成 1
pd_data.replace([100, 101], [1, 2]) # 把 100 替换成 1，101 替换成 2
</code></pre>
<h4 id="loc-元素查找"><a class="header" href="#loc-元素查找">loc() 元素查找</a></h4>
<pre><code class="language-Python">pd_hour_statistics.loc[run_id_period, cid] += 1 # loc 的第一个值为 index，第二个值就是 column 的名字
</code></pre>
<h3 id="iterrows-遍历每行"><a class="header" href="#iterrows-遍历每行">iterrows() 遍历每行</a></h3>
<pre><code class="language-python"># 遍历 DataFrame 每行
for index, row in pandas_data_deployed.iterrows():
    deploy_plat = row['deploy_plat'] # 直接传入
    source = row['source']
    module = row['module']
    
# 上面的代码可以用这个代替
data['rows'] = pandas_data.T.to_dict().values()
</code></pre>
<h3 id="concat-数据连接"><a class="header" href="#concat-数据连接">concat() 数据连接</a></h3>
<p>cancat 分为横向连接，纵向连接</p>
<pre><code class="language-Python"># 纵向的连接，相当于给表中加入更多的元组
pd_deployed = [pd_863, pd_noah, pd_beehive, pd_dfp]
pd_deployed = pd.concat(pd_deployed).fillna(&quot;&quot;) # 连接并且填充空值为 &quot;&quot;

# 横线连接
pd.concat([pd1, pd2], axis=1)
</code></pre>
<h3 id="drop_duplicates-去重"><a class="header" href="#drop_duplicates-去重">drop_duplicates() 去重</a></h3>
<p><strong>参数</strong></p>
<pre><code>subset: 
	column label or sequence of labels, optional 
	用来指定特定的列，默认所有列
keep: 
	{‘first’, ‘last’, False}, default ‘first’ 
	删除重复项并保留第一次出现的项
inplace: 
	boolean, default False 
	是直接在原来数据上修改还是保留一个副本
</code></pre>
<p><strong>Demo</strong></p>
<pre><code class="language-Python">DataFrame.drop_duplicates([&quot;&quot;, &quot;&quot;, &quot;&quot;], keep='first', inplace=True) # 对 DataFrame 格式的数据，去除特定列的重复行，重复数据保留第一次出现的数据，就地去重

import pandas as pd
data = pd.DataFrame({'A' : [1,2,3,4], 'B' : ['a', 'b', 'a', 'b']}) 
data.drop_duplicates('B',  keep='first', inplace = True)
&quot;&quot;&quot;
print data
结果
 A B
 0 1 a
 1 2 b
&quot;&quot;&quot;
</code></pre>
<h3 id="index-column-设置"><a class="header" href="#index-column-设置">index, column 设置</a></h3>
<h4 id="设置-column-和-index-的-name"><a class="header" href="#设置-column-和-index-的-name">设置 column 和 index 的 name</a></h4>
<pre><code class="language-Python"># 设置 index 或 columns 的 name
frame.index.name = xxx # 可以在 reset_index 的时候用到，给 index 起一个名字，然后就可以把 index 变成一个 column
frame.columns.name = yyy
</code></pre>
<h4 id="reindex"><a class="header" href="#reindex">reindex()</a></h4>
<p>注意：reindex 只是改变 pandas 数据按照 index 的排列顺序，并不是更改 index</p>
<pre><code class="language-Python">frame.reindex(columns = [...], index=[...])
# 如果没有指定 index 和 column，那么默认修改 index
frame.reindex(['a', 'b', 'c'], fill_value=0) # 如果 'c' 无对应的值，则为 Nan
</code></pre>
<h4 id="导出-index-和-column"><a class="header" href="#导出-index-和-column">导出 index 和 column</a></h4>
<p>注意，pd_data.index 和 pd_data.column 返回的都是一个 Iterable 对象，这样可以在适当的情况下节省内存</p>
<pre><code class="language-Python">index_list = pd_data.index.tolist()
column_list = pd_data.column.tolist()
</code></pre>
<h4 id="重命名-rename"><a class="header" href="#重命名-rename">重命名 rename()</a></h4>
<p>可以通过 rename 重命名 column 和 index，需要注意的是，rename 默认并不是一个 inplace 函数，其仍然符合 cascade 法则，会开辟一块新的内存，最好加上 <code>inplace=True</code> 的参数。</p>
<pre><code class="language-Python"># 修改 column
pd_whitelist = pd_whitelist.rename(columns = {&quot;deploy_module&quot;: &quot;module&quot;, &quot;monitor_whitelist&quot;: &quot;idc&quot; }, inplace=True)
</code></pre>
<h4 id="重置-index--index-对齐"><a class="header" href="#重置-index--index-对齐">重置 index / index 对齐</a></h4>
<p>当我们对多个 DataFrame 进行计算时，往往需要两个 DataFrame 进行 Index 对齐，目前我发现的最简单的方法是：</p>
<pre><code class="language-Python">pd_data = pd_data.reset_index().drop(&quot;index&quot;, axis=1) # index 为 index name

# reset_index() 用于将 index 转成 column，然后 index 重新设置为 0,1,2,3
</code></pre>
<h4 id="column-转-index-set_index"><a class="header" href="#column-转-index-set_index">column 转 index: set_index</a></h4>
<pre><code class="language-Python"># 将某几列转成行索引
pd_frame = pd_frame.set_index([&quot;column1&quot;, &quot;column2&quot;])
</code></pre>
<h3 id="导出某列的值"><a class="header" href="#导出某列的值">导出某列的值</a></h3>
<pre><code class="language-Python"># 获取字段对应的列的所有值，转成 list
name = pd_data['姓名'] # 这里返回了 姓名 的Series
name = pd_data.姓名.tolist()
name_list = pd_data['姓名'].tolist()
</code></pre>
<h3 id="获取元组个数"><a class="header" href="#获取元组个数">获取元组个数</a></h3>
<pre><code class="language-Python">pd_size = len(pd_data)
</code></pre>
<h3 id="sort_values-排序"><a class="header" href="#sort_values-排序">sort_values 排序</a></h3>
<p>sort_values 已经替换了 sort_index 的功能，其可以对 index 和 column 进行排序。默认情况下，该方法对 index 进行排序，但是该方法已经可以根据 <code>by</code> 自动识别 index 和 column，我们不需要显式的指定 index 还是 value，但是为了严谨一点，我们还是加入 axis = 1，表示是对 column 进行排序</p>
<pre><code class="language-Python">pandas_data = pandas_data.sort_values(by = [&quot;created_time&quot;, &quot;age&quot;], ascending = [False,True], axis=1) 	
</code></pre>
<h3 id="append--concat-添加行列"><a class="header" href="#append--concat-添加行列">append / concat 添加行列</a></h3>
<p>axis = 1: 添加列; axis = 0: 添加行</p>
<p>注意，如果我们合并的行列与 index 无关的话，那么最好加上 <code>ignore_index</code> ，否则 index 在合并的时候，可能会带来问题。</p>
<pre><code class="language-Python"># 添加 行，
pd_result = pd.concat([pd_result, pd_new_data], ignore_index=True, axis=1)

# 添加列
pd_result = pd.concat([pd_result, pd_new_data], ignore_index=True, axis=1)
</code></pre>
<pre><code class="language-Python"># append 只能用来添加元组，并返回一个新的对象
pd_vote_tor_train.append(pd_vote_for_test, ignore_index=True)
</code></pre>
<h3 id="drop-删除数据"><a class="header" href="#drop-删除数据">drop 删除数据</a></h3>
<p>Drop specified labels from rows or columns. 返回 drop 之后的 pandas</p>
<pre><code class="language-Python"># 删除两列
pd_data = pd_data.drop([&quot;vote_result&quot;, &quot;score&quot;], axis=1)

# 删除行数据，
frame.drop([index1, index2]) # 默认 drop 删除行数据 axis = 0 就是行
</code></pre>
<h3 id="矩阵转置"><a class="header" href="#矩阵转置">矩阵转置</a></h3>
<pre><code class="language-Python"># 矩阵和图标的转置
pd_demo = pd_demo.T
</code></pre>
<h2 id="空值--missing-value处理"><a class="header" href="#空值--missing-value处理">空值 / missing value处理</a></h2>
<h3 id="判断空值-isnull-notnull"><a class="header" href="#判断空值-isnull-notnull">判断空值, isnull(), notnull()</a></h3>
<pre><code class="language-python"># isnull, notnull 检测缺失值
pd.isnull(obj)
pd.notnull(obj)
</code></pre>
<h2 id="pandas-科学计算--函数--映射"><a class="header" href="#pandas-科学计算--函数--映射">Pandas 科学计算 / 函数 / 映射</a></h2>
<h3 id="科学计算"><a class="header" href="#科学计算">科学计算</a></h3>
<pre><code class="language-python"># 引入 numpy 的科学计算函数
import numpy as np
np.log2(pd_data)
np.log10(pd_data)
np.exp(pd_data)

# 求最大值最小值
pd_demo.max()
# 如果 pd_demo 是 DataFrame，则默认对列进行操作，获取每列的最大值，形成一个 series
# 如果 pd_demo 是 Series，则返回最大值

# Series 可以直接进行算术运算
(pd_statistics_daycount * pd_sum_statistics).sort_values(ascending=False)
# Series 在进行算术运算时可以自动对齐不同索引的数据，而笛卡尔积式的索引

# apply
pd_data[&quot;meddle_time&quot;] = (pd_data[&quot;meddle_end&quot;].apply(
            lambda x: datetime.datetime.strptime(str(x), &quot;%Y-%m-%d %H:%M:%S&quot;)) - \
                            pd_data[&quot;meddle_start&quot;].apply(
            lambda x: datetime.datetime.strptime(str(x), &quot;%Y-%m-%d %H:%M:%S&quot;)))


</code></pre>
<h3 id="map-方法实现映射"><a class="header" href="#map-方法实现映射">map 方法实现映射</a></h3>
<p>map 方法需要传入一个 func，该 func 可以是 built-in function ，也可以是 lambda expression</p>
<pre><code class="language-Python">pd_frame[&quot;animal&quot;] = data[&quot;food&quot;].map(str.lower).map(food_to_animal_dict)
</code></pre>
<h3 id="排序"><a class="header" href="#排序">排序</a></h3>
<pre><code class="language-Python"># 对 Series 进行排序
pd_statistics_daycount = pd.Series(statistics_daycount_dict).sort_values(ascending=False) # 按值进行排序
pd_statistics_daycount = pd.Series(statistics_daycount_dict).sort_index(ascending=False) # 按索引进行排序
</code></pre>
<h3 id="集合运算"><a class="header" href="#集合运算">集合运算</a></h3>
<h4 id="index-扩展差集交集并集"><a class="header" href="#index-扩展差集交集并集">index 扩展/差集/交集/并集</a></h4>
<pre><code>append 连接另一个index对象，返回一个新的index

diff 计算差集
intersection 计算交集
union 计算并集
</code></pre>
<h2 id="pandas-内存优化"><a class="header" href="#pandas-内存优化">Pandas 内存优化</a></h2>
<h3 id="深拷贝与浅拷贝"><a class="header" href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></h3>
<pre><code class="language-python">pd_demo_copy= pd.DataFrame(pd_demo) # pd_demo_copy 其实是 pd_demo 的一个浅拷贝，对 pd_demo_copy 的任何操作，当相当于直接对 pd_demo_copy 进行操作
pd_demo_copy = pd_demo.copy(deep=True) # 这才是深拷贝
</code></pre>
<h3 id="iterable-objects"><a class="header" href="#iterable-objects">Iterable objects</a></h3>
<p>如果我们想要对 iterable objects 进行变换，那么就不需要将其先转成 list <code>to_list()</code> 再变换</p>
<pre><code class="language-Python">obj.index # 返回 RangeIndex类型的可迭代的对象
obj.values # 返回 numpy.ndarray 类型的可迭代的对象
</code></pre>
<h3 id="inplace-选项"><a class="header" href="#inplace-选项">inplace 选项</a></h3>
<p>大多数方法都有 inplace 选项，如果 inplace = True，就不会开辟额外的内存。例如 drop_duplicates 方法，就有 inplace 选项，下面列举一下带有 inplace 选项的方法：</p>
<pre><code>rename
drop_duplicates
</code></pre>
<p>注意：inplace = True 后，返回的 pandas 就是 None，代码就应该改成：</p>
<pre><code class="language-python">df_one_column = df_one_column.drop_duplicates(&quot;weibo&quot;)
# 改成
df_one_column.drop_duplicates(&quot;weibo&quot;, inplace=True) # 返回 None
</code></pre>
<h2 id="pandas-index-and-select"><a class="header" href="#pandas-index-and-select">Pandas Index and Select</a></h2>
<p>pandas 数据筛选，其功能等价于 sql 语句的 where 条件筛选。</p>
<p>官网文档：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html</a></p>
<h3 id="tips-1"><a class="header" href="#tips-1">Tips</a></h3>
<ul>
<li>
<p>Python 的 index operator <code>[]</code> 和 attribute operator <code>.</code>在 pandas 中同样通用。但是在不知道传入数据的数据类型的情况下，使用 index/attribute 操作符往往会出现一些意想不到的问题，例如<code>chained assignment</code>。所以我们要尽量用 Pandas 提供的 API 写 Pandasic 的代码，而不是 Pythonic。</p>
<p>总的来说，在系统报 <code>SettingWithCopy</code> 的错误时，我们应该将 chained assignment 改成 loc 的模式。 </p>
<table><thead><tr><th>Object Type</th><th>Selection(Chained assignment)</th><th>Return Value Type</th></tr></thead><tbody>
<tr><td>Series</td><td><code>series[label]</code></td><td>scalar value</td></tr>
<tr><td>DataFrame</td><td><code>frame[colname]</code></td><td><code>Series</code> corresponding to colname</td></tr>
</tbody></table>
</li>
<li>
<p>Pandas 的数据筛选的大部分 API，都是 Series/DataFrame 通用的，所以同样一个 API，以下的示例通常有两个Demo</p>
</li>
<li>
<p>Pandas 中的 label-based slice 是包含尾部元素的</p>
</li>
<li>
<p>ix 已经被 iloc 和 loc 替换</p>
</li>
</ul>
<h3 id="-operator-synx"><a class="header" href="#-operator-synx"><code>[].</code> Operator Synx</a></h3>
<h4 id="添加新列"><a class="header" href="#添加新列">添加新列</a></h4>
<p>注意，不能使用 attribute 的方式创建新列</p>
<pre><code class="language-Python"># 添加新列
pd_data[&quot;flag&quot;] = &quot;defaut_value&quot;
df.two = [4, 5, 6] # 会报 UserWarning

</code></pre>
<h4 id="select"><a class="header" href="#select">select</a></h4>
<pre><code class="language-Python">df1[lambda df: df.columns[0]] # 选取第一列
</code></pre>
<h3 id="-operator-和-loc-的优缺点分析"><a class="header" href="#-operator-和-loc-的优缺点分析"><code>[].</code> Operator 和 loc 的优缺点分析</a></h3>
<table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody>
<tr><td><code>[] .</code></td><td>简洁明了</td><td>1. 不能 slice 2. 会导致很多奇怪的问题</td></tr>
<tr><td><code>loc(),iloc()</code></td><td>准确规范</td><td>不够简洁</td></tr>
</tbody></table>
<h3 id="slice-for-dataframe"><a class="header" href="#slice-for-dataframe">Slice for DataFrame</a></h3>
<p>DataFrame 的 slice 是对行进行 slice。</p>
<pre><code class="language-Python">df[:3] # 对前三行进行 slice
df[::-1] # 按行逆置
</code></pre>
<h3 id="loc-label-based-index"><a class="header" href="#loc-label-based-index">loc (label-based index)</a></h3>
<p>loc 是根据 label 进行查找，label 包括 index 和 column。</p>
<table><thead><tr><th>Object Type</th><th>Indexers</th></tr></thead><tbody>
<tr><td>Series</td><td><code>s.loc[indexer]</code></td></tr>
<tr><td>DataFrame</td><td><code>df.loc[row_indexer,column_indexer]</code></td></tr>
</tbody></table>
<p><strong>Series</strong></p>
<pre><code class="language-Python"># 对 Series 进行切片
s1 = pd.Series(np.random.randn(6), index=list('abcdef'))
&quot;&quot;&quot;
a    1.431256
b    1.340309
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
dtype: float64
&quot;&quot;&quot;
s1.loc['c':] # 从 c slice 到最后
s1.loc['b'] # 获取 index 为 b 对应的值
s1.loc['c':] = 0 # slice 后统一赋值

# slice slice 是对 3 到 5 之间的元素进行 slice，并不是 对 3，4，5进行 slice，slice 是按照 index 顺序的
s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])
s.loc[3:5] # 3,2,5
s.sort_index() # 对数据按照 index 进行排序
</code></pre>
<p><strong>DataFrame</strong></p>
<pre><code class="language-Python">df1 = pd.DataFrame(np.random.randn(6, 4),
                     index=list('abcdef'),
                     columns=list('ABCD'))
df1.loc[['a', 'b', 'd'], :] # sample index 为 a,b,d 的 dataframe
df1.loc['d':, 'A':'C'] # sample index 为 d, column 为 ABC 的 dataframe
df1.loc['a'] # sample index 为 a 的 series
df1.loc['a', 'A'] # get a value in df1[&quot;a&quot;][&quot;A&quot;]

dfi.loc[:, 'C'] = dfi.loc[:, 'A'] # 新建 C 列，并将 A 列的数据赋值给 C 列
</code></pre>
<h3 id="iloc-postion-based-index"><a class="header" href="#iloc-postion-based-index">iloc (postion-based index)</a></h3>
<p>loc 是根据 position 进行 index 的。</p>
<p><strong>Series</strong></p>
<pre><code class="language-Python">s1 = pd.Series(np.random.randn(5), index=list(range(0, 10, 2)))
s1.iloc[:3] # 获取前三个数据
s1.iloc[3] # 获取第四个数据
s1.iloc[:3] = 0 # 对前三个数据进行赋值

</code></pre>
<p><strong>DataFrame</strong></p>
<pre><code class="language-Python">df1 = pd.DataFrame(np.random.randn(6, 4),
                       index=list(range(0, 12, 2)),
                       columns=list(range(0, 8, 2)))
df1.iloc[:3] # 获取前三行的 df
df1.iloc[1:5, 2:4] # 获取第二行到第五行，第三列到第四列的 df
df1.iloc[[1, 3, 5], [1, 3]] # 获取第 2，4，6 行，第2，4列的 df
df1.iloc[1:3, :]
df1.iloc[1] # 获取第二行的 series

# assign a dict to a row of a DataFrame
x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})
x.iloc[1] = {'x': 9, 'y': 99}
</code></pre>
<p>注意，当 slice 的界限超出了 pandas 的界限时，pandas 的处理方式 和 Python 的处理方式一样，都返回空，但是对于指定的 index，如果超出了界限，就会报 <code>IndexError</code></p>
<h3 id="selection-by-callable"><a class="header" href="#selection-by-callable">Selection By Callable</a></h3>
<p>在 select 的时候加入函数，实现更复杂的 select</p>
<pre><code class="language-Python">df1 = pd.DataFrame(np.random.randn(6, 4),
                       index=list('abcdef'),
                       columns=list('ABCD'))
&quot;&quot;&quot;
 	A         B         C         D
a -0.023688  2.410179  1.450520  0.206053
b -0.251905 -2.213588  1.063327  1.266143
c  0.299368 -0.863838  0.408204 -1.048089
d -0.025747 -0.988387  0.094055  1.262731
e  1.289997  0.082423 -0.055758  0.536580
f -0.489682  0.369374 -0.034571 -2.484478
&quot;&quot;&quot;
df1.loc[lambda df: df.A &gt; 0, :] # 对 row 进行 select，条件为 列 A 的值 &gt; 0
&quot;&quot;&quot;
 	A         B         C         D
c  0.299368 -0.863838  0.408204 -1.048089
e  1.289997  0.082423 -0.055758  0.536580
&quot;&quot;&quot;
df1.loc[:, lambda df: ['A', 'B']] # 选取 A，B 列
df1.iloc[:, lambda df: [0, 1]] # 选取第一列和第二列
df1[lambda df: df.columns[0]] # 选取第一列
df1.A.loc[lambda s: s &gt; 0] # 选取第一列中大于0的元素

# 两列进行比较
pd_candidate[pd_candidate.label != pd_candidate.predicted_label]
</code></pre>
<h3 id="sample--head"><a class="header" href="#sample--head">sample() / head()</a></h3>
<pre><code class="language-Python">df_sample = df1.sample(n=5) # 随机采样 5 个元素
df.head(n=10) # 选取头几个元素
</code></pre>
<h3 id="at--iat-快速-index"><a class="header" href="#at--iat-快速-index">at / iat 快速 index</a></h3>
<p><code>[] .</code> ，和 <code>loc,iloc</code> 都是先进行查找，再进行列查找，查找效率很低。如果想要快速定位到某一个位置的值，可以使用 <code>at/iat</code></p>
<pre><code class="language-Python">df1 = pd.DataFrame({'A':list(&quot;avb&quot;)})
df1.iat[0,0] # 返回 a
df1.iat[0,0] = &quot;s&quot; # 赋值
</code></pre>
<h3 id="boolean-selecting"><a class="header" href="#boolean-selecting">Boolean Selecting</a></h3>
<p>Operators: |<code>for </code>or<code>, </code>&amp;<code>for</code>and<code>, and </code>~<code>for</code>not`</p>
<p>注意，这些操作符必须被 <code>()</code> 圈起来。</p>
<pre><code class="language-Python"># series
s = pd.Series(range(-3, 4))
s[s &gt; 0] # 返回大于 0 的 series
s[(s &lt; -1) | (s &gt; 0.5)] # 返回一定范围的 series

# dataframe
df[df['A'] &gt; 0] 
df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
                       'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
                       'c': np.random.randn(7)})
criterion = df2['a'].map(lambda x: x.startswith('t'))
df2[criterion]
&quot;&quot;&quot;
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075
&quot;&quot;&quot;
df2[criterion &amp; (df2['b'] == 'x')] # 多个条件
&quot;&quot;&quot;
 	a  	  b       c
3  three  x  0.361719
&quot;&quot;&quot;
df2.loc[criterion &amp; (df2['b'] == 'x'), 'b':'c'] # 多多个条件
&quot;&quot;&quot;
 	b         c
3  x  0.361719
&quot;&quot;&quot;

pandas_selected = pandas_data[(pandas_data.status == 'fail') \
                            &amp; ((pandas_data.reason == 'online') \
                               | (pandas_data.reason == 'known_online') \
                               | (pandas_data.reason == 'deploy')
                              )]

# 否定的使用
pandas_selected = pandas_data[~(pandas_data.status == 'fail')]
</code></pre>
<h3 id="select-with-isin"><a class="header" href="#select-with-isin">select with isin()</a></h3>
<pre><code class="language-Python">s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')
s.isin([2, 4, 6])
&quot;&quot;&quot;
4    False
3    False
2     True
1    False
0     True
dtype: bool
&quot;&quot;&quot;
s[s.isin([2, 4, 6])]
&quot;&quot;&quot;
2    2
0    4
dtype: int64
&quot;&quot;&quot;
s[s.index.isin([2, 4, 6])] # 判断 index isin

# df
pd_vote_for_test = pd_training_data[pd_training_data.hash_id.isin(test_hash_id)]

# not in 
pd_vote_for_test = pd_training_data[~(pd_training_data.hash_id.isin(test_hash_id))]
</code></pre>
<h3 id="where-method-for-select"><a class="header" href="#where-method-for-select"><code>where()</code> method for select</a></h3>
<p>where 和 boolen select 的区别：</p>
<p>Boolean select 出来的数据，通常是原 pandas 的子集，而 where 可以保留原 pandas 的结构。</p>
<pre><code class="language-Python">s.where(s &gt; 0)
&quot;&quot;&quot;
4    NaN
3    1.0
2    2.0
1    3.0
0    4.0
dtype: float64
&quot;&quot;&quot;
</code></pre>
<h3 id="query-method-for-select"><a class="header" href="#query-method-for-select"><code>query()</code> method for select</a></h3>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> objects have a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query"><code>query()</code></a> method that allows selection using an expression.</p>
<p>query() 的优点：</p>
<ul>
<li>兼容 Python 的语法，更接近自然语言表达，例如其兼容 and/or/in/not in</li>
<li><code>DataFrame.query()</code> using <code>numexpr</code> is slightly faster than Python for large frames.</li>
</ul>
<pre><code class="language-Python">df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)] # 等价于
df.query('(a &lt; b) &amp; (b &lt; c)') # 等价于
df.query('a &lt; b &amp; b &lt; c') # 等价于
df.query('a &lt; b and b &lt; c')

df.query('a in b') # 等价于
df[df.a.isin(df.b)]

df.query('a not in b') # 等价于
df[~df.a.isin(df.b)] 

df.query('a in b and c &lt; d')

df.query('b == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]') # simlilar to in ，等价于
df[df.b.isin([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])]

df.query('[1, 2] in c')
df.query('[1, 2] not in c')
</code></pre>
<h3 id="returning-a-view-versus-a-copy"><a class="header" href="#returning-a-view-versus-a-copy">Returning a view versus a copy</a></h3>
<p><code>SettingWithCopy</code> warning !!! 的原因：</p>
<pre><code class="language-Python">dfmi = pd.DataFrame([list('abcd'),
                      list('efgh'),
                      list('ijkl'),
                      list('mnop')],
                      columns=pd.MultiIndex.from_product([['one', 'two'],
                                                        ['first', 'second']]))
&quot;&quot;&quot;
    one          two       
  first second first second
0     a      b     c      d
1     e      f     g      h
2     i      j     k      l
3     m      n     o      p
&quot;&quot;&quot;

dfmi.loc[:, ('one', 'second')] = value 
# 等价于
dfmi.loc.__setitem__((slice(None), ('one', 'second')), value) # 一步到位

dfmi['one']['second'] = value 
# 等价于
dfmi.__getitem__('one').__setitem__('second', value) # 由于不确定 getitem 返回的对象是原对象还是新 copy 的对象，所以才会抛出 SettingWithCopy 的警告
</code></pre>
<h2 id="pandas-数据重塑和透视表"><a class="header" href="#pandas-数据重塑和透视表">Pandas 数据重塑和透视表</a></h2>
<p><strong>stack， unstack</strong></p>
<p><strong>stack</strong>: 将 dataframe 转成 多重索引的 series</p>
<p><strong>unstack</strong>: 将 多重索引的 series 转成 dataframe</p>
<pre><code class="language-python">pd_series.unstack(&quot;index1&quot;) # 将 index1 转成以 index1 为 column 的 dataframe
</code></pre>
<p><strong>pivot</strong></p>
<pre><code class="language-python"># pivot 用于将 信息量很大的长表（例如从数据库中读取的一张表），透视成一张宽表
pd_frame.pivot(&quot;index_column&quot;, &quot;column_column&quot;, &quot;value&quot;)
# 参数一：Column to use to make new frame’s index. If None, uses existing index.
# 参数二：Column to use to make new frame’s columns.
# 参数三：Column(s) to use for populating new frame’s values. If not specified, all remaining columns will be used and the result will have hierarchically indexed columns.
# raise: When there are any index, columns combinations with multiple values. DataFrame.pivot_table when you need to aggregate.
</code></pre>
<p><strong>pivot_table</strong></p>
<p>用于将长表变短表</p>
<p>http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html#pandas.DataFrame.pivot_table</p>
<pre><code class="language-python">df = pd.DataFrame({&quot;A&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;,
                          &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;],
                   &quot;B&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;,
                         &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;],
                   &quot;C&quot;: [&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;,
                         &quot;small&quot;, &quot;large&quot;, &quot;small&quot;, &quot;small&quot;,
                         &quot;large&quot;],
                   &quot;D&quot;: [1, 2, 2, 3, 3, 4, 5, 6, 7]})
'''         
df
     A    B      C  D
0  foo  one  small  1
1  foo  one  large  2
2  foo  one  large  2
3  foo  two  small  3
4  foo  two  small  3
5  bar  one  large  4
6  bar  one  small  5
7  bar  two  small  6
8  bar  two  large  7
'''    

table = pivot_table(df, values='D', index=['A', 'B'],
                     columns=['C'], aggfunc=np.sum)
''' 
table
C        large  small
A   B
bar one    4.0    5.0
    two    7.0    6.0
foo one    4.0    1.0
    two    NaN    6.0
'''    

table = pivot_table(df, values=['D', 'E'], index=['A', 'C'],
                   aggfunc={'D': np.mean, 'E': [min, max, np.mean]})
'''
table
                  D   E
               mean max median min
A   C
bar large  5.500000  16   14.5  13
    small  5.500000  15   14.5  14
foo large  2.000000  10    9.5   9
    small  2.333333  12   11.0   8
'''
</code></pre>
<h2 id="pandas-字符串处理函数"><a class="header" href="#pandas-字符串处理函数">pandas 字符串处理函数</a></h2>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html#indexing-with-str">Index with Str</a></p>
<pre><code class="language-python"># 过滤出 name 列包含有 pandas 的数据
pd_frame = pd_frame[pd_frame.name.str.contains(&quot;pandas&quot;)] # 类似的进行判断的字符串方法还有 endswith, startswith

# 对 name 列进行正则表达式的匹配，返回的是匹配到的 series
pd_series = pd_frame.name.str.match(pattern)
&quot;&quot;&quot;
index0 [&quot;wansho&quot;, &quot;wangkai&quot;]
index2 [&quot;libohan&quot;, &quot;guandonghai&quot;]
&quot;&quot;&quot;
# 获取元素的第 几个 字符
pd_series = pd_series.str.get(0)
# join 元素列表 
pd_series = pd_series.str.join(&quot;-&quot;)

# 判断 name 列的所有名字，某个字符串的出现次数
pd_series = pd_frame.name.str.count(&quot;love&quot;)

# 对某列的长度进行筛选
df = df[df.A.str.len() &gt; 2]

# 其他函数
lower(), upper()
center() # 在字符串左右两边添加空白符
repeat(3) # 字符串重复 3 次
replace(pattern, str, regex=True) # 用 str 替换 pattern 匹配的模式
split() # 根据分隔符或正则表达式对字符串进行拆分
strip(), lstrip(), rstrip()
len() 

</code></pre>
<h2 id="pandas-mergeconcat-详解"><a class="header" href="#pandas-mergeconcat-详解">pandas merge/concat 详解</a></h2>
<pre><code class="language-python">* merge 等价于数据库上的外连接，merge 是横向的连接
* 等值连接的时候，如果按照左边为主，就是左外连接，如果按照右边为主，就是右外连接
* 没有内连接
* 自然连接 没有 how 属性
* 外连接一共有三种：（都是等值连接）
    1. 外连接 how = 'out'
    2. 左外连接 how = 'left'
    3. 右外连接 how = 'right'
* 参数 on 就是设置按照哪一列进行等值连接

参考：
https://blog.csdn.net/zhouwenyuan1015/article/details/77334889
https://blog.csdn.net/starter_____/article/details/79198137

Code Demo1：
loss_data = pd.merge(pandas_data_deployed, pandas_data_called, how = 'left', on = columnsOfCoverageMerge)
pandas_data_deployed_columns_len = len(pandas_data_deployed.columns) # 获取字段数 22 个
col_y = loss_data.columns[pandas_data_deployed_columns_len] # 获取某个字段

loss_data = loss_data[loss_data[col_y].isnull()] # 如果该字段为空（NaN），那么选取该组数据，该方法经常用来获取两张表关于 某一 字段 的差集
如果是左连接，那么 isnull() 得到的就是关于某一字段的 A - B 的差集  
如果是右连接，那么 isnull() 得到的就是关于某一字段的 B - A 的差集  
注意如果是左连接，那么字段判空选择的字段 X 肯定是右边的那个表的非等值连接的某个字段，也就是可能会产生 空值 的字段。

loss_data = loss_data[columnsOfCoverageMerge]

Code Demo2：
data1 = {
        'A': ['a1', 'a1', 'a2', 'a2'],
        'B': ['b1', 'b2', 'b3', 'b4'],
        'C': [5, 6, 8, 12]
        }
data2 = {
        'B': ['b1', 'b2', 'b3', 'b3', 'b5'],
        'E': [3, 7, 10, 2, 2]
        }

pandas_data1 = pd.DataFrame(data1)
pandas_data2 = pd.DataFrame(data2)

merge_data1 = pd.merge(pandas_data1, pandas_data2, 
                 how = 'left', on = ['B'])
merge_data2 = pd.merge(pandas_data1, pandas_data2, how = 'outer', 
                 on = ['B']).fillna(0)
print merge_data1[merge_data1['A'].isnull()]
print merge_data1
print merge_data2

# left_on, right_on
pd.merge(pd_left, pd_right, left_on=[&quot;name&quot;], right_on=[&quot;姓名&quot;])

# suffixes 对于重复的字段，添加后缀
pd.merge(pd_left, pd_right, on=[], how=&quot;left&quot;, suffixes=[&quot;_left&quot;, &quot;_right&quot;])

# left_index, right_index, 将索引作为连接的键，类似于 left_on, right_on, 这四个参数可以混用
pd.merge(pd_left, pd_right, left_on=&quot;key1&quot;, right_index=True)

# how 参数的默认值为 inner，即内连接，其 merge 后的字段为两个 dataframe 的交集，left, right, outer 的字段为两个 dataframe 字段的并集

# 多个 pandas 横向纵向连接
pd.concat([pd1, pd2, pd3], axis=1, keys=[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], ignore_index=True， names=[&quot;upper&quot;, &quot;lower&quot;])
axis： 1 为横向连接，0 为纵向连接，默认纵向连接
keys： 连接后，新加的二层索引
ignore_index：是否不加入 index
names: 给多层索引从上到下起名称
pd.concat({&quot;level1&quot;: pd1, &quot;level2&quot;: pd2}) # 加入第二层索引的另一种方式
</code></pre>
<h2 id="groupby-详解"><a class="header" href="#groupby-详解">groupby 详解</a></h2>
<p>groupby 分两个步骤</p>
<ol>
<li>分组</li>
<li>计算</li>
</ol>
<pre><code class="language-python">################################### step1: 分组 #####################################
* groupby 通过 某几列 进行分组
pg_data = pandas_data.groupby([&quot;status&quot;, &quot;reason&quot;], as_index=False) # 返回一个 DataFrameGroupBy 对象, 如果 as_index 为 False，则不会将 staus 和 reason 变成 index
groupby 不会删除数据，只是对数据按照 N = |status| * |reason| 分成 N 组。分组后的数据条数不会变化。
demo:
pd_times_statistics = pandas_data_deployed[[&quot;deploy_plat&quot;, &quot;module&quot;, &quot;deploy_times&quot;]].groupby([&quot;deploy_plat&quot;, &quot;module&quot;]).count() # 生成一个 frame
# 解析 pd_times_statistics 获取 key:deploy_plat + module, value: times 的字典
module2times_dict = {','.join(index): row[&quot;deploy_times&quot;] for index, row in pd_times_statistics.iterrows()}

# 通过 字典 进行分组
mapping = {&quot;图搜&quot;: &quot;大搜&quot;, &quot;分级&quot;: &quot;大搜&quot;, &quot;人脸识别&quot;: &quot;AI&quot;}
pd_data = pd_data.group(mapping).count()
pd_data = pd_data.group(mapping, axis=1).count()

# 通过多级索引的索引级别进行分组 level
import pandas as pd
import numpy as np
columns = pd.MultiIndex.from_arrays([[&quot;US&quot;, &quot;US&quot;, &quot;US&quot;, &quot;JP&quot;, &quot;JP&quot;], [1,2,3,4,5]], names=[&quot;country&quot;, &quot;number&quot;])
pd_data = pd.DataFrame(np.random.randn(4, 5), columns=columns)
print(pd_data)
pd_data = pd_data.groupby(level=&quot;country&quot;, axis=1).sum()
print(pd_data)
'''
country        US                            JP          
number          1         2         3         4         5
0        0.014945  0.498798  0.939967  1.053238  2.689140
1       -0.092643  0.671471  0.255130 -0.035580 -1.422467
2       -1.594973  0.753659 -0.983928  0.341066  0.999692
3       -0.590248 -0.339360 -0.706315  0.277258 -1.921277

country        JP        US
0        3.742378  1.453709
1       -1.458048  0.833959
2        1.340759 -1.825242
3       -1.644020 -1.635923
'''

################################### step2: 计算 #####################################

# groupby 后的方法
count()
sum()
mean()
medain()
std() # 标准差
var() # 方差
min() 
max()
first(), last()
quantile(num) # 获取分位数 0 &lt;= num &lt;= 1

# groupby 自定义计算方法
def peak_2_peak(series):
    return series.max() - series.min()
grouped.agg(peak_2_peak)

# groupby 后进行多函数计算
grouped.agg([&quot;mean&quot;, &quot;count&quot;, &quot;std&quot;])
# groupby 后对不同的列进行不同的计算方法
grouped.agg({&quot;age&quot;: &quot;mean&quot;, &quot;sex&quot;: [&quot;sum&quot;, &quot;count&quot;]})

# groupby 遍历
for module, idc_group in dfp_pandas_data_called.groupby([&quot;module&quot;]): # module 是单个值或元组，idc_group 是 pandas dataframe 格式
    idcs = list(set(idc_group[&quot;idc&quot;].tolist()))
    dfp_module2idcs_dict[module] = idcs 
group 后的group 其实是一个 pandas dataframe 对象，其中存放了除 module属性 外的所有属于 module 组的属性，如果只选取一部分属性，可以直接 
idc_group[[&quot;A&quot;, &quot;B&quot;]]  # 这是 pandas 的一个语法糖

# 注意
groupby 后，groupby 的对象是唯一的，可以当 key 使用

# Demo
import pandas as pd
data1 = {
        'A': ['a1', 'a1', 'a2', 'a2', 'a3'],
        'B': ['b1', 'b1', 'b2', 'b2', 'b3'],
        'C': [5, 6, 8, 12, 1]
        }
pd_frame = pd.DataFrame(data1)
pd_statistics = pd_frame.groupby(['A','B']).count() # 注意结果是一个 DataFrame，有两个 index：A 和 B。C 变成了 count 字段。
结果：
      C
 A B    
a1 b1 2
a2 b2 2
a3 b3 1
上述结果得到的是一个 DataFrame，但是其得到的是一个有两个 index 的dataframe，实际上，按照那几个参数进行了groupby，那么index就有几个，如果想要将 index 转换成列信息，那么可以用：
pd_statistics.reset_index() # 将 两级 index 转成 列数据
那么结果就变成了：
     A B C
 0 a1 b1 2
 1 a2 b2 2
 2 a3 b3 1
 其中，index 变成了 数字
</code></pre>
<h2 id="pandas-io"><a class="header" href="#pandas-io">pandas IO</a></h2>
<h3 id="pandas-读写-mysql"><a class="header" href="#pandas-读写-mysql">pandas 读写 MySQL</a></h3>
<p><strong>官方文档</strong></p>
<p>http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html?highlight=to_sql#pandas.DataFrame.to_sql</p>
<p><strong>环境依赖</strong></p>
<pre><code class="language-shell">pip install sqlalchemy
pip install pymysql
</code></pre>
<p><strong>写数据库Demo</strong></p>
<pre><code class="language-python"># 写入 MySQL
from sqlalchemy import create_engine
# test 是 dbname ，localhost 指的是 IP
engine = create_engine('mysql+pymysql://user1:123456@localhost:3306/test')
# index 参数用于判断是否将 index 写入数据库
pd_conf.to_sql(table_name, con=engine, if_exists=&quot;append&quot;, index=False)
</code></pre>
<p><strong>注意</strong></p>
<ol>
<li>pandas 写入数据库时，如果数据表不存在，则会建立数据库，但是不会指定数据表的主键</li>
</ol>
<p><strong>读数据库Demo</strong></p>
<p>http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql.html#pandas.read_sql</p>
<p>http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_table.html?highlight=read_sql#pandas.read_sql_table</p>
<p>http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html?highlight=read_sql#pandas.read_sql_query</p>
<p>read_sql 是 对 read_sql_table 和 read_sql_query 的封装。</p>
<h3 id="pandas-读写-excel"><a class="header" href="#pandas-读写-excel">pandas 读写 excel</a></h3>
<p>对于非文本的文件的读取，excel 中存储的是什么格式，pandas 就读取的什么格式，如果一串数字以字符串的形式存储，其读到pandas中就是一个字符串，如果一列单元格存储的是时间，那么 pandas 读取后就是 datetime。</p>
<pre><code class="language-python">from openpyxl import load_workbook
def init_excel(self):
    &quot;&quot;&quot;创建一个空的 Excel 文件&quot;&quot;&quot;
    pd_empty = pd.DataFrame()
    try:
        pd_empty.to_excel(self.excel_path)
    except Exception as e:
        logging.error(&quot;init excel failed, because {e}&quot;.format(e=e))
    logging.info(&quot;init excel success&quot;)

def to_excel(self, pd_data, sheet_name):
    &quot;&quot;&quot;将 pandas 写入 Excel 的指定的 sheet 中&quot;&quot;&quot;
    excel_writer = pd.ExcelWriter(self.excel_path, engine='openpyxl')
    # 写入 Excel
    try:
        book = load_workbook(excel_writer.path)
        excel_writer.book = book
        pd_data.to_excel(excel_writer=excel_writer, sheet_name=sheet_name, index=False)
        excel_writer.close()
    except Exception as e:
        logging.error(&quot;pandas into excel failed, because {e}&quot;.format(e=e))
    logging.info(&quot;pandas into excel success&quot;)
    
# 读取 excel
pd_demo = pd.read_excel(path)
</code></pre>
<h3 id="pandas-读写-csv-文件"><a class="header" href="#pandas-读写-csv-文件">pandas 读写 csv 文件</a></h3>
<p>pandas 读取文本文件时，对于所有的数字内容，读取后都会转成数字，不管其读取之前是否为字符串</p>
<pre><code class="language-python"># 读取 csv 文件
pd.read_csv(path, header=None, index_col=[&quot;col1&quot;, &quot;col2&quot;]) # 不读取列名，并选择两列作为索引
pd.read_csv(path, error_bad_lines=False) # 跳过错误行
# 注意 如果文件中有数字类型的数据，那么统一转成 long 类型，即使存储前是 str 类型，那么读取出来也是 数字类型

# to_csv()
# 将 DataFrame 表存储成 csv 格式
deploy_cfg.to_csv(&quot;file.csv&quot;, encoding = 'utf_8_sig') # 注意文件名不要写中文
pd_data.to_csv(&quot;test.csv&quot;, mode=&quot;a&quot;, header=&quot;False&quot;) # 增量模式，不加 header
</code></pre>
<h2 id="pandas-时间序列"><a class="header" href="#pandas-时间序列">pandas 时间序列</a></h2>
<h3 id="时间戳作为-index"><a class="header" href="#时间戳作为-index">时间戳作为 index</a></h3>
<p><strong>TimeSeries初始化</strong></p>
<pre><code class="language-python">import pandas as pd
import numpy as np
from datetime import datetime
# TimeSeries 初始化，传入的 index 必须是 datetime 类型的 list
index = [datetime(2019, 1, 1), datetime(2019, 2, 2), datetime(2019, 3, 3), datetime(2021, 1, 3)] # DatetimeIndex 类型
pd_time = pd.Series(range(len(index)), index=index)
pd_time.index
</code></pre>
<pre><code>DatetimeIndex(['2019-01-01', '2019-02-02', '2019-03-03', '2021-01-03'], dtype='datetime64[ns]', freq=None)
</code></pre>
<p><strong>TimeSeries切片、选取、索引</strong></p>
<pre><code class="language-python"># 模糊选取
pd_time[&quot;2019&quot;]
</code></pre>
<pre><code>2019-01-01    0
2019-02-02    1
2019-03-03    2
dtype: int64
</code></pre>
<pre><code class="language-python"># 精确获取某个 index 对应的值
pd_time[datetime(2019,1,1)]
</code></pre>
<pre><code>0
</code></pre>
<pre><code class="language-python"># 按照给定时间范围切片
pd_time[&quot;2019-01-01&quot;: &quot;2019-03-01&quot;] 
</code></pre>
<pre><code>2019-01-01    0
2019-02-02    1
dtype: int64
</code></pre>
<p><strong>生成指定长度的 DatetimeIndex: date_range</strong></p>
<pre><code class="language-python">pd.date_range(&quot;2019-01&quot;, &quot;2020-01&quot;) # 默认的时间间隔是 天，注意：date_range 生成的是时间戳，而不是时间段
</code></pre>
<pre><code>DatetimeIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
               '2019-01-05', '2019-01-06', '2019-01-07', '2019-01-08',
               '2019-01-09', '2019-01-10',
               ...
               '2019-12-23', '2019-12-24', '2019-12-25', '2019-12-26',
               '2019-12-27', '2019-12-28', '2019-12-29', '2019-12-30',
               '2019-12-31', '2020-01-01'],
              dtype='datetime64[ns]', length=366, freq='D')
</code></pre>
<pre><code class="language-python"># 生成由每月最后一个工作日组成的日期索引
pd.date_range(start=&quot;2019-01&quot;, end=&quot;2019-12&quot;, freq=&quot;BM&quot;)
</code></pre>
<pre><code>DatetimeIndex(['2019-01-31', '2019-02-28', '2019-03-29', '2019-04-30',
               '2019-05-31', '2019-06-28', '2019-07-31', '2019-08-30',
               '2019-09-30', '2019-10-31', '2019-11-29'],
              dtype='datetime64[ns]', freq='BM')
</code></pre>
<pre><code class="language-python"># 由开始时间和持续时间生成的 index
pd.date_range(start=&quot;2019-01&quot;, periods=10) # period 指定了按照默认的 freq天级生成 10 组数据
</code></pre>
<pre><code>DatetimeIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
               '2019-01-05', '2019-01-06', '2019-01-07', '2019-01-08',
               '2019-01-09', '2019-01-10'],
              dtype='datetime64[ns]', freq='D')
</code></pre>
<pre><code class="language-python"># 频率和日期偏移量
# 按照 6hmin 的间隔生成 10 组时间戳, 注意： freq 可以写成任意时间间隔，P314  
pd.date_range(start=&quot;2019-01&quot;, periods=10, freq=&quot;6h20min&quot;) 
</code></pre>
<pre><code>DatetimeIndex(['2019-01-01 00:00:00', '2019-01-01 06:20:00',
               '2019-01-01 12:40:00', '2019-01-01 19:00:00',
               '2019-01-02 01:20:00', '2019-01-02 07:40:00',
               '2019-01-02 14:00:00', '2019-01-02 20:20:00',
               '2019-01-03 02:40:00', '2019-01-03 09:00:00'],
              dtype='datetime64[ns]', freq='380T')
</code></pre>
<h3 id="时间段作为-index"><a class="header" href="#时间段作为-index">时间段作为 index</a></h3>
<p><strong>period_range</strong></p>
<pre><code class="language-python"># PeriodIndex 类型
index_period = pd.period_range(&quot;2019-01-01&quot;, &quot;2019-01-12&quot;, freq=&quot;D&quot;)
pd.period_range(&quot;2019-01-01&quot;, &quot;2019-01-12&quot;, freq=&quot;D&quot;)
</code></pre>
<pre><code>PeriodIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
             '2019-01-05', '2019-01-06', '2019-01-07', '2019-01-08',
             '2019-01-09', '2019-01-10', '2019-01-11', '2019-01-12'],
            dtype='period[D]', freq='D')
</code></pre>
<pre><code class="language-python"># index 为 period 的 timeseries 的构造
pd_period = pd.Series(range(len(index_period)), index=index_period)
pd.Series(range(len(index_period)), index=index_period)
</code></pre>
<pre><code>2019-01-01     0
2019-01-02     1
2019-01-03     2
2019-01-04     3
2019-01-05     4
2019-01-06     5
2019-01-07     6
2019-01-08     7
2019-01-09     8
2019-01-10     9
2019-01-11    10
2019-01-12    11
Freq: D, dtype: int64
</code></pre>
<pre><code class="language-python"># 一时间段内的任意时间都可以作为 时间戳，化为 index
pd_period[&quot;2019-01-01 19:23:00&quot;] = 100
pd_period
</code></pre>
<pre><code>2019-01-01    100
2019-01-02      1
2019-01-03      2
2019-01-04      3
2019-01-05      4
2019-01-06      5
2019-01-07      6
2019-01-08      7
2019-01-09      8
2019-01-10      9
2019-01-11     10
2019-01-12     11
Freq: D, dtype: int64
</code></pre>
<h3 id="重采样-resample"><a class="header" href="#重采样-resample">重采样 resample</a></h3>
<p><strong>时间戳重采样</strong></p>
<pre><code class="language-python">pd_time.resample(&quot;Y&quot;).sum()
</code></pre>
<pre><code>2019-12-31    3
2020-12-31    3
Freq: A-DEC, dtype: int64
</code></pre>
<pre><code class="language-python"># 时间戳重采样
index_timestamp = pd.date_range(&quot;2019-01-01&quot;, periods=12, freq=&quot;T&quot;)
pd_time = pd.Series(range(len(index_timestamp)), index=index_timestamp) # 时间戳最细粒度的数据
pd_time.resample(&quot;5min&quot;).sum().index
</code></pre>
<pre><code>DatetimeIndex(['2019-01-01 00:00:00', '2019-01-01 00:05:00',
               '2019-01-01 00:10:00'],
              dtype='datetime64[ns]', freq='5T')
</code></pre>
<pre><code class="language-python"># 通过 groupby 和 lambda 函数进行重采样
index_range = pd.date_range(&quot;2019-01-01&quot;, periods=100, freq=&quot;D&quot;) 
pd_time = pd.Series(range(len(index_range)), index=index_range)
pd_time.groupby(lambda x: x.month).sum()
</code></pre>
<pre><code>1     465
2    1246
3    2294
4     945
dtype: int64
</code></pre>
<p><strong>时间段重采样</strong></p>
<pre><code class="language-python">pd_frame = pd.DataFrame(np.random.randn(12, 4),
                        index=pd.period_range(&quot;2010-01&quot;, &quot;2011-12&quot;, freq=&quot;2M&quot;), 
                        columns=[&quot;Colorado&quot;, &quot;Texas&quot;, &quot;New York&quot;, &quot;Ohio&quot;])
pd_frame.resample(&quot;D&quot;).mean().index # 升采样
</code></pre>
<pre><code>PeriodIndex(['2010-01-01', '2010-01-02', '2010-01-03', '2010-01-04',
             '2010-01-05', '2010-01-06', '2010-01-07', '2010-01-08',
             '2010-01-09', '2010-01-10',
             ...
             '2011-12-22', '2011-12-23', '2011-12-24', '2011-12-25',
             '2011-12-26', '2011-12-27', '2011-12-28', '2011-12-29',
             '2011-12-30', '2011-12-31'],
            dtype='period[D]', length=730, freq='D')
</code></pre>
<p><strong>重采样参数</strong></p>
<pre><code class="language-python">A year
M month
W week
D day
H hour
T minute
S second

Demo:
resample_time = &quot;5min&quot; # 5 分钟采样一次
resample_time = &quot;1H&quot; # 1 hour 采样一次
resample_time = &quot;1D&quot; # 1 天采样一次
pd_result = pd_result.resample(resample_time, how=&quot;sum&quot;)
</code></pre>
<h2 id="pandas-error"><a class="header" href="#pandas-error">Pandas Error</a></h2>
<h3 id="only-integers-accepted-as-n-values"><a class="header" href="#only-integers-accepted-as-n-values">Only integers accepted as n values</a></h3>
<pre><code class="language-Python">pd_data.sample(n) # n 一定要是非负整数，否则会报该错误
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调研-django-14-版本升级"><a class="header" href="#调研-django-14-版本升级">调研 Django 1.4 版本升级</a></h1>
<p>[TOC]</p>
<p><strong>主要参考文献</strong></p>
<p>Django 版本升级 API 调整记录：</p>
<p>https://docs.djangoproject.com/en/1.11/internals/deprecation/</p>
<p><strong>升级目的</strong></p>
<p>新版本的 Django ，稳定性和效率都有一定的增强，高版本的Django应该对 Models 数据库的增删改查进行一定的优化，从而减小数据库的压力。</p>
<p><strong>Django 版本升级调研</strong></p>
<p>当前版本： 1.4</p>
<p>打算升级到的版本：2.0</p>
<p><strong>版本问题</strong></p>
<p>Django 从 2.0 版本后不再支持 python 2.7，所以改用支持 python2.7 的最新 Django 版本：1.11</p>
<p><strong>最终方案</strong></p>
<p>1.4 ——&gt; 1.11</p>
<p><strong>升级测试</strong></p>
<pre><code># 测试环境搭建
pip install virtualenv # 安装该包
cd dir # cd 到一个空目录，创建虚拟环境
virtualenv --no-site-packages venv  # 创建一个虚拟的 python 开发环境，名字为 venv，其中默认不包含任何原环境的包，只有几个必要的包
source venv/bin/activate # 进入该虚拟环境
deactivate # 退出该虚拟环境
</code></pre>
<p><strong>升级遇到的问题</strong></p>
<ol>
<li>
<p>错误一：</p>
<pre><code class="language-shell">django.core.exceptions.ImproperlyConfigured:
The TEMPLATE_DIRS setting must be a tuple. Please fix your settings.
</code></pre>
<p>解决：</p>
<pre><code class="language-python"># settings.py 
PROJECT_PATH = os.path.dirname(os.path.realpath(__file__))
TEMPLATE_DIRS = (os.path.join(PROJECT_PATH, 'templates'),)
# https://stackoverflow.com/questions/25909833/django-core-exceptions-improperly-configured
</code></pre>
<p>实际上导致这个异常的原因是，直接使用了字符串绝对路径，而测试环境是在另一个文件夹下的，所以此处是一个bug，后期如果文件夹对不上的话，会有问题，统一改用程序获得绝对路径。</p>
</li>
<li>
<p>错误二：</p>
<pre><code>raise IOError(&quot;No translation files found for default language %s.&quot; % settings.LANGUAGE_CODE)；
IOError: No translation files found for default language zh-cn.
</code></pre>
<p>解决：</p>
<p>Django 升级后中文包升级成了 zh-Hans，在 settings.py 中将 LANGUAGE_CODE = 'zh-cn' 改为 LANGUAGE_CODE = 'zh-Hans' 即可</p>
</li>
<li>
<p>错误三：</p>
<pre><code>File &quot;/home/work/test/django_update_test/se_monitor/seMonitorAPI/urls.py&quot;, line 1, in &lt;module&gt;
from django.conf.urls import patterns, include, url
ImportError: cannot import name patterns
</code></pre>
<p>解决：</p>
<p>https://stackoverflow.com/questions/38786036/importerror-cannot-import-name-patterns</p>
<p>在Django1.10版本中，patterns方法已经被移除了，换成url即可。在 urls.py 中删除 patterns</p>
<pre><code class="language-python">from django.conf.urls import include, url

urlpatterns=[
    url(r'^admin/', include(admin.site.urls)),
    url(........),
]
</code></pre>
</li>
<li>
<p>错误四：</p>
<pre><code>File &quot;/home/work/test/django_update_test/venv/lib/python2.7/site-packages/django/conf/urls/__init__.py&quot;, line 85, in url
    raise TypeError('view must be a callable or a list/tuple in the case of include().')
TypeError: view must be a callable or a list/tuple in the case of include().
</code></pre>
<p>解决：</p>
<p>https://stackoverflow.com/questions/38744285/django-urls-typeerror-view-must-be-a-callable-or-a-list-tuple-in-the-case-of-in</p>
<p>Django 1.10 版本后，url(r'^accounts/login/$', 'django_cas.views.login'), 后的重定向 views 不需要加引号了，改为 引入 views.py 。例如：</p>
<pre><code>from django.conf.urls import include, url

from django.contrib.auth import views as auth_views
from myapp import views as myapp_views # 引入 views

urlpatterns = [ # 注意删除之前的 ''
    url(r'^$', myapp_views.home),
    url(r'^contact/$', myapp_views.contact),
    url(r'^login/$', auth_views.login),
]
</code></pre>
</li>
<li>
<p>错误五</p>
<pre><code>File &quot;/home/work/test/django_update_test/se_monitor/django_cas/views.py&quot;, line 6, in &lt;module&gt;
    from django.http import get_host, HttpResponseRedirect, HttpResponseForbidden
ImportError: cannot import name get_host
</code></pre>
<p>解决：</p>
<p>https://stackoverflow.com/questions/15664951/improperlyconfigured-error-importing-middleware-app-middleware-cannot-import</p>
<p>将 django_cas/views.py 中所有的 from django.http import get_host 改为 from django.http import HttpRequest 然后在程序中 HttpRequest.get_host()</p>
</li>
<li>
<p>错误六</p>
<pre><code>File &quot;/home/work/test/django_update_test/se_monitor/seMonitorAPI/run_case/management/commands/get_result.py&quot;, line 37, in Command
    option_list = BaseCommand.option_list + (
AttributeError: type object 'BaseCommand' has no attribute 'option_list'
</code></pre>
<p>解决：</p>
<p>https://docs.djangoproject.com/en/1.11/releases/1.8/#custom-test-management-command-arguments-through-test-runner</p>
<p>https://docs.djangoproject.com/en/1.11/howto/custom-management-commands/#accepting-optional-arguments</p>
<p>option_list 是 Command 的参数，从 Django1.8 开始被弃用，</p>
</li>
<li>
<p>错误七</p>
<pre><code>File &quot;/home/work/test/django_update_test/se_monitor/seMonitorAPI/urls.py&quot;, line 26, in &lt;module&gt;
    url(r'^run-case/', seMonitorAPI_views.run_case),
AttributeError: 'module' object has no attribute 'run_case'
</code></pre>
<p>解决：urls.py 中有部分旧的API已经弃用，包括 views_zqc.py 和 views_sample.py 的所有API，还有部分 views.py 中的部分API</p>
</li>
<li>
<p>错误八（存疑）</p>
<pre><code>Invalid HTTP_HOST header: '10.99.117.55:8999'. You may need to add u'10.99.117.55' to ALLOWED_HOSTS.
</code></pre>
<p>解决：</p>
<p>https://docs.djangoproject.com/en/1.11/ref/settings/#allowed-hosts</p>
<pre><code># settings.py 中加入以下规则，其中 10.99.117.55 为代码部署机器的 IP
ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '10.99.117.55']
</code></pre>
<p>存疑：</p>
<p>ALLOWED_HOSTS 字面意义上是允许访问的机器，为什么要把本机的 host 加入其中呢？</p>
</li>
<li>
<p>错误九（到此 运行 python manage.py 0:8999 已可以正常运行，但是并不能保证所有 views.py 中的所有 API 都能正常运行，因为还没有调用）</p>
<pre><code>File &quot;/home/work/test/django_update_test/se_monitor/seMonitorAPI/views.py&quot;, line 110, in get_result
    if &quot;job_id&quot; not in request.REQUEST:
AttributeError: 'WSGIRequest' object has no attribute 'REQUEST'
</code></pre>
<p>解决：</p>
<p>https://docs.djangoproject.com/en/1.11/ref/request-response/#django.http.HttpRequest.POST</p>
<p>从 Django 1.11 开始已经开始弃用 request.REQUEST， REQUEST 对 GET 和 POST 进行了封装，从 1.11 开始，GET 和 POST 开始区分开。</p>
<p>把 views.py 中的 request.REQUEST 统一改为 request.GET</p>
</li>
<li>
<p>错误十（measure_site 独有，多数据库配置问题）</p>
<pre><code>TypeError: allow_migrate() got an unexpected keyword argument 'model_name'
</code></pre>
<p>解决：</p>
<p>https://stackoverflow.com/questions/39282860/django-typeerror-allow-migrate-got-an-unexpected-keyword-argument-model-name</p>
<p>measure_site 中配置了两个数据库，default 和 bugzilla</p>
</li>
</ol>
<p><strong>API Test</strong></p>
<p>从 Nginx 的 log 中挑访问最频繁的 接口进行测试</p>
<p><strong>Command Test</strong></p>
<table><thead><tr><th>Command</th><th>Result</th><th>Project</th></tr></thead><tbody>
<tr><td>self_check</td><td>pass</td><td>seMonitor</td></tr>
<tr><td>trigger</td><td>pass</td><td>seMonitor</td></tr>
<tr><td>get_result</td><td>pass</td><td>seMonitor</td></tr>
<tr><td>sync_monster_cases</td><td>pass</td><td>seMonitor</td></tr>
<tr><td>deploy_coverage_detail</td><td>pass</td><td>measure_site</td></tr>
<tr><td>statistics_to_db</td><td>pass</td><td>measure_site</td></tr>
<tr><td>fenji_emulation_diff</td><td>pass</td><td>measure_site</td></tr>
<tr><td>get_fail_reason</td><td>pass</td><td>measure_site</td></tr>
<tr><td>backuptaskconf</td><td>pass</td><td>measure_site</td></tr>
<tr><td>fenji_completeness</td><td>pass</td><td>measure_site</td></tr>
<tr><td>get_noah_taskinfo</td><td>pass(一直在运行)</td><td>measure_site</td></tr>
<tr><td>icafe_untreated</td><td>pass</td><td>measure_site</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p><strong>包含 command option 的 Command</strong></p>
<table><thead><tr><th>Command</th><th>Project</th></tr></thead><tbody>
<tr><td>python manage.py sync_monster_cases day</td><td>seMonitor</td></tr>
<tr><td>python manage.py sync_monster_cases realtime</td><td>seMonitor</td></tr>
<tr><td>python manage.py statistics_to_db all day</td><td>measure_site</td></tr>
</tbody></table>
<p><strong>线上和测试环境测试切换步骤</strong></p>
<pre><code>大部分的 command 和 接口都测了，我准备开始切了，按照你的思路，先在 21 机器上的 measure_site 进行测试，步骤如下：
1. 把测试有效的代码提交到一个新的分支
2. 在 21 机器上，搭一个 test 环境，把测试代码拉过去
3. 把 21 机器上的 measure_site 停掉，Nginx 流量打到 test 环境上
4. 线上环境升级 Django，拉取测试分支，对测试的代码进行部署
5. 线上环境部署完后，再把 Nginx 流量切到线上环境
6. 验证没问题后，把测试分支合到 master 分支，再切到 master 分支
</code></pre>
<p><strong>切流量后暴露的问题</strong></p>
<ol>
<li>
<p>问题一：</p>
<p>对于 views.py 中提供的接口，</p>
<p>measure_site 大部分接口返回的 json 串，是包含有 转义字符的 json 串。</p>
<p>而 seMonitor 返回的 json 串，是正常的</p>
<p>解决：</p>
<p>比较 measure_site 的 sendHigroup（返回正常json alarm_notice_HiGroup） 和 result_debug_mod_info（异常json），发现 最后return 没有按照 Django 的 HttpResponse(json.dumps(return_list)) 正确规范。</p>
<p>问题还是在于 REQUEST 没有清理替换干净。</p>
</li>
<li>
<p>问题二：</p>
<p>se_monitor 的 run_case/list/ 和 api-useinfo/ 不进行 template 的渲染，整个 template 失效。</p>
</li>
<li>
<p>问题三：</p>
<p>measure_site 中的 views_showx.py 中，有个别接口有异常：config_tasklist_groupby_module， case_compare</p>
<pre><code>File &quot;/home/work/test/django_update_test/measure_site/measure_site/tools/tools.py&quot;, line 59, in decorator
    objects = func(request, *args, **kwargs)
  File &quot;/home/work/test/django_update_test/measure_site/measure_site/views_showx.py&quot;, line 4130, in config_tasklist_groupby_module
    product_line = cond[&quot;product_info&quot;].split(',')[0]
KeyError: 'product_info'
[]
{}

</code></pre>
<pre><code>File &quot;/home/work/test/django_update_test/measure_site/measure_site/tools/tools.py&quot;, line 59, in decorator
    objects = func(request, *args, **kwargs)
  File &quot;/home/work/test/django_update_test/measure_site/measure_site/views_showx.py&quot;, line 3832, in case_compare
    product_line = cond[&quot;product_info&quot;].split(',')[0]
KeyError: 'product_info'
</code></pre>
<p>解决：</p>
<p>已和 check，是 showx 端的机制问题，不会影响数据的获取</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-hacker"><a class="header" href="#python-hacker">Python Hacker</a></h1>
<p>[TOC]</p>
<h2 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h2>
<p>300 页的手册，两三天就可以啃完。</p>
<p>一本关于实战的📕。</p>
<p>Julien Danjou, 作者参与了 OpenStack 的开发，进而有丰富的 Python 开发经历。</p>
<h2 id="starting-your-project"><a class="header" href="#starting-your-project">Starting your project</a></h2>
<h3 id="project-layout"><a class="header" href="#project-layout">project layout</a></h3>
<img align='left' src="computer-science-notebook/note-for-python/assets/image-20201011111336046.png" alt="image-20201011111336046" style="zoom:90%;" />
<p>Docs 中的文档可以由 Sphinx 生成。</p>
<p>其他可能包含的文件：</p>
<pre><code>etc: sample configuration files
tools: shell scripts or related tools
bin: binary scripts you’ve written that will be installed by setup.py
</code></pre>
<p>Don’t create a directory and just an <code>__init__.py</code> file in it.</p>
<h3 id="pep8-coding-style"><a class="header" href="#pep8-coding-style">PEP8 Coding style</a></h3>
<p><a href="https://www.python.org/dev/peps/pep-0008">[PEP8]</a></p>
<p><strong>PEP8 标准已经被封装成一个工具</strong></p>
<pre><code class="language-shell">pip install pep8
</code></pre>
<pre><code class="language-shell">pep8 hello.py
</code></pre>
<pre><code>pycodestyle ...

  warnings.warn(
method.py:8:1: E302 expected 2 blank lines, found 1
method.py:11:5: E301 expected 1 blank line, found 0
</code></pre>
<p>其他 Python 静态代码检测工具：pyflakes, pylint</p>
<p><strong>代码长度</strong></p>
<p>一行代码长度：79 chars</p>
<p><strong>操作符</strong></p>
<pre><code class="language-python"># Wrong:
# operators sit far away from their operands
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)

# Correct:
# easy to match operators with operands
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</code></pre>
<p><strong>import</strong></p>
<p>Imports should be grouped in the following order:</p>
<ol>
<li>Standard library imports.</li>
<li>Related third party imports.</li>
<li>Local application/library specific imports.</li>
</ol>
<p>You should put a blank line between each group of imports.</p>
<p><strong>模块级 dunder names</strong></p>
<p>Module level &quot;dunders&quot; (i.e. names with two leading and two trailing underscores) such as <code>__all__</code>, <code>__author__</code>, <code>__version__</code>, etc. should be placed after the module docstring but before any import statements <em>except</em> <code>from __future__</code> imports. Python mandates that future-imports must appear in the module before any other code except docstrings:</p>
<pre><code class="language-python">&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
</code></pre>
<p><strong>whitespace 的使用惯例</strong></p>
<pre><code class="language-python"># Correct:
foo = (0,)

# Wrong:
bar = (0, )
</code></pre>
<pre><code class="language-python"># Correct:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

# Wrong:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
</code></pre>
<pre><code class="language-python"># Correct:
def complex(real, imag=0.0):
    return magic(r=real, i=imag)

# Wrong:
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)
</code></pre>
<p><strong>逗号的使用</strong></p>
<pre><code class="language-python"># Correct:
FILES = [
    'setup.cfg',
    'tox.ini', # 可能在后期进行扩展
    ]
initialize(FILES,
           error=True,
           )
# Wrong:
FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)
</code></pre>
<h2 id="modules-and-libraries"><a class="header" href="#modules-and-libraries">Modules and libraries</a></h2>
<h3 id="import-system"><a class="header" href="#import-system">import system</a></h3>
<p><strong><code>import this</code></strong></p>
<pre><code class="language-python">import this

&quot;&quot;&quot;
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
&quot;&quot;&quot;
</code></pre>
<p><strong>sys</strong></p>
<p>The sys module contains a lot of information about Python’s import system.</p>
<p><code>sys.modules</code> 变量(dict)中存储了当前已导入的 modules：</p>
<pre><code class="language-python">sys.modules['os'] # 键是 module 的名字，值是 module 对象
&quot;&quot;&quot; &lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt; &quot;&quot;&quot;
</code></pre>
<p>Python 导入 module 依赖很多路径，<code>sys.path</code> 变量（sequence）中存储了这些路径，<code>sys.path</code> 类似于系统中的环境变量，Python 在导包的时候，会去这些路径下找这些包。手动增加路径：</p>
<pre><code class="language-python">import sys
sys.path.append('/foo/bar')
</code></pre>
<h3 id="standard-libraries"><a class="header" href="#standard-libraries">Standard libraries</a></h3>
<p>Python <strong>自带电池，开箱即用</strong>。</p>
<p>需要了解的 Python 内置标准库(我还不熟悉的)</p>
<table><thead><tr><th>标准库</th><th>Desc</th></tr></thead><tbody>
<tr><td>atexit</td><td>allows ⁴ou to register functions to call when ⁴our program exits</td></tr>
<tr><td>argparse</td><td>provides functions for parsing command line arguments</td></tr>
<tr><td>bisect</td><td>provides bisection algorithms for sorting lists</td></tr>
<tr><td>calendar</td><td>provides a number of date-related functions</td></tr>
<tr><td>codecs</td><td>provides functions for encoding and decoding data</td></tr>
<tr><td>collections</td><td>provides a variet⁴ of useful data structures</td></tr>
<tr><td>copy</td><td>provides functions for cop⁴ing data</td></tr>
<tr><td>fnmatch</td><td>provides functions for matching Unix-st⁴le filename patterns</td></tr>
<tr><td>glob</td><td>provides functions for matching Unix-st⁴le path patterns</td></tr>
<tr><td>io</td><td>provides functions for handling I/O streams</td></tr>
<tr><td>multiprocessing</td><td>allows ⁴ou to run multiple subprocesses from ⁴our application,<br/>while providing an API that makes them look like threads.</td></tr>
<tr><td>operator</td><td>provides functions implementing the basic P⁴thon operators which ⁴ou<br/>can use instead of having to write ⁴our own lambda expressions</td></tr>
<tr><td>os</td><td>provides access to basic OS functions</td></tr>
<tr><td>select</td><td>provides access to the select() and poll() functions for creating event loops</td></tr>
<tr><td>shutil</td><td>provides access to high-level file functions</td></tr>
<tr><td>signal</td><td>provides functions for handling POSIX signals</td></tr>
<tr><td>tempfile</td><td>provides functions for creating temporar⁴ files and directories</td></tr>
<tr><td>threading</td><td>provides access to high-level threading functionalit⁴</td></tr>
<tr><td>uuid</td><td>allows ⁴ou to generate UUIDs (Universall⁴ Unique Identifiers)</td></tr>
</tbody></table>
<p><strong>我惊呆了，我竟然有这么多模块还不熟悉！这些标准库都是用 Python 实现的！有问题的时候学会看源码！</strong></p>
<p>The entire standard library is written in Python, so there’s nothing stopping you from looking at the source code of its modules and functions. When in doubt, crack open the code and see what it does for yourself. Even if the documentation has everything you need to know, there’s always a chance you could learn something useful.</p>
<p><strong>谨慎使用第三方库</strong></p>
<p>sqlalchemy-migrate  就是一个活生生的例子。OpenStack 使用了 sqlalchemy-migrate，database schema 会不断更新的，这就要求 sqlalchemy-migrate  不断更新。如果 sqlalchemy-migrate  断更，那么依赖于 sqlalchemy-migrate  的项目和数据库交互就会产生 bug.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="sphinx"><a class="header" href="#sphinx">Sphinx</a></h3>
<p>sphinx 是一个 Python 包：<code>pip install -U sphinx </code></p>
<p>Sphinx is the most commonly used tool for working with this format: it can read reST-formatted content and output documentation in a variety of other formats.</p>
<p>用到了再学，先知道有这回事。</p>
<h3 id="doc-includes"><a class="header" href="#doc-includes">Doc includes?</a></h3>
<p>Your project documentation should include:
• The problem your project is intended to solve, in one or two sentences.
• The license your project is distributed under. If your sotware is open source, you should also include this information in a header in each code file: just because you’ve uploaded your code to the Internet doesn’t mean that people will know what they’re allowed to do with it.
• A small example of how it works.
• Installation instructions.
• Links to community support, mailing list, IRC, forums, etc.
• A link to your bug tracker system.
• A link to your source code so that developers can download and start delving into it right away.</p>
<h3 id="tools-to-make-doc"><a class="header" href="#tools-to-make-doc">Tools to make Doc</a></h3>
<ul>
<li>
<p><a href="https://readthedocs.org/">[Read the Docs]</a></p>
<p>免费提供 Doc 部署的平台。</p>
<p>Read the Docs simplifies software documentation by automating building, versioning, and hosting of your docs for you.</p>
<ul>
<li>Free docs hosting</li>
<li>Webhooks</li>
<li>Multiple formats</li>
<li>Multiple versions</li>
</ul>
</li>
</ul>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h2>
<p>Writing code that is not tested is essentially useless, as there’s no way to conclusively prove that it works. </p>
<h3 id="how-to"><a class="header" href="#how-to">How to</a></h3>
<ul>
<li>
<p>创建 tests  module，也就是创建 tests 文件夹(文件夹中有 <code>__init__.py</code>)</p>
</li>
<li>
<p>如何我们想测试 <code>mylib/foobar.py</code>，那么就创建测试脚本：<code>mylib/tests/test_foobar.py</code>。测试脚本，其命名都以 <code>test_</code> 开头</p>
</li>
<li>
<p>自动化测试工具：<strong>nose</strong> ，可以帮我们进行自动化测试：<code>pip install nose</code> </p>
</li>
<li>
<p>编写单元测试的方式：<code>unittest</code>，已经集成到了 Python 的标准库中</p>
</li>
</ul>
<h3 id="demo-with-assert"><a class="header" href="#demo-with-assert">Demo with assert</a></h3>
<p>It’s usually simpler to use a hierarchy in your test tree that mimics the hierarchy you have in your module tree. This means that the tests covering the code of <code>mylib/foobar.py</code> should be inside <code>mylib/tests/test_foobar.py</code>; this makes things simpler
when looking for the tests relating to a particular file.
A really simple test in <code>test_true.py</code>: </p>
<pre><code class="language-python">def test_true():
	assert True
</code></pre>
<p>This is the most simple unit test that can be written. To run it, you simply need to load the test_true.py file and run the test_true function defined within.
Obviously, following these steps for all of your test files and functions would be a pain. This is where the nose package comes to the rescue – once installed, it providesthe nosetests command, which loads every filewhose name startswith <code>test_</code> and then executes all functions within that start with <code>test_</code>.
Therefore, withthe test_true.py file in our sourcetree, running nosetests will give us the following output:</p>
<pre><code class="language-shell">$ nosetests -v
test_true.test_true ... ok
---------------------------------------------------------
Ran 1 test in 0.003s
OK
</code></pre>
<p>一个测试出错的Demo：</p>
<pre><code class="language-python">def test_key():
    a = ['a', 'b']
    b = ['b']
    assert a == b
</code></pre>
<pre><code class="language-shell">$ nosetests -v
test_complicated.test_key ... FAIL
==========================================================
FAIL: test_complicated.test_key
Traceback (most recent call last):
File &quot;/usr/lib/python2.7/dist-packages/nose/case.py&quot;, line 197, in ←֓
	runTest
	self.test(*self.arg)
File &quot;/home/jd/test_complicated.py&quot;, line 4, in test_key
	assert a == b
AssertionError
---------------------------------------------------------
Ran 1 test in 0.001s
FAILED (failures=1)
</code></pre>
<p>测试结果并没有告诉我们哪里出错了</p>
<h3 id="demo-with-unittest"><a class="header" href="#demo-with-unittest">Demo with unittest</a></h3>
<p>Python 内置的用于单元测试的标准库，可以给出出错的详细信息，还提供了很多高级测试功能，例如：</p>
<p>skipping tests or executing actions before or ater running every test.</p>
<p>If we rewrite the previous example using unittest, this is what it will look like:</p>
<pre><code class="language-python">import unittest

class TestKey(unittest.TestCase):
    def test_key(self):
        a = ['a', 'b']
        b = ['b']
        self.assertEqual(a, b)
</code></pre>
<p>As you can see, the implementation isn’t much more complicated. All you have to do is create a class that inherits from unittest. TestCase, and write a method that runs a test. Instead of using assert, we rely on a method provided by unittest. TestCase that provides an equality tester. When run, it outputs the following:</p>
<pre><code class="language-shell">$ nosetests -v
test_key (test_complicated.TestKey) ... FAIL

=========================================================
FAIL: test_key (test_complicated.TestKey)
Traceback (most recent call last):

File &quot;/home/jd/Source/python-book/test_complicated.py&quot;, line 7, in ←֓
	test_key
	self.assertEqual(a, b)
AssertionError: Lists differ: ['a', 'b'] != ['b']

First differing element 0:
a 
b

First list contains 1 additional elements.
First extra element 1:
b

- ['a', 'b']
+ ['b']

---------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</code></pre>
<p>永远不要用 assert</p>
<p><strong>others demos with unittest</strong></p>
<pre><code class="language-python">class TestSkipped(unittest.TestCase):
    @unittest.skip(&quot;Do not run this&quot;)
    def test_fail(self):
    	self.fail(&quot;This should not be run&quot;)
    
    @unittest.skipIf(mylib is None, &quot;mylib is not available&quot;)
    def test_mylib(self):
    	self.assertEqual(mylib.foobar(), 42)
    
    def test_skip_at_runtime(self):
        if True:
        	self.skipTest(&quot;Finally I don't want to run it&quot;)
</code></pre>
<pre><code class="language-shell">$ python -m unittest -v test_skip
test_fail (test_skip.TestSkipped) ... skipped 'Do not run this'
test_mylib (test_skip.TestSkipped) ... skipped 'mylib is not available'
test_skip_at_runtime (test_skip.TestSkipped) ... skipped &quot;Finally I don't ←֓
want to run it&quot;
---------------------------------------------------------
Ran 3 tests in 0.000s
OK (skipped=3)
</code></pre>
<pre><code class="language-python">import unittest
class TestMe(unittest.TestCase):
    def setUp(self):
    	self.list = [1, 2, 3]
    
    def test_length(self):
    	self.list.append(4)
    	self.assertEqual(len(self.list), 4)
    
    def test_has_one(self):
        self.assertEqual(len(self.list), 3)
        self.assertIn(1, self.list)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-工匠"><a class="header" href="#python-工匠">Python 工匠</a></h1>
<p>[TOC]</p>
<p>ref: <a href="https://github.com/piglei/one-python-craftsman">[one-python-craftsman]</a></p>
<h2 id="mythink"><a class="header" href="#mythink">myThink</a></h2>
<ul>
<li>这份小册子，传达的很多小技巧和思想，不仅仅适用于 Python</li>
</ul>
<h2 id="1-使用好变量"><a class="header" href="#1-使用好变量">1. 使用好变量</a></h2>
<h3 id="用-dict-传参的缺点"><a class="header" href="#用-dict-传参的缺点">用 dict 传参的缺点</a></h3>
<ul>
<li>无法用 <code>x, *y = foo()</code> 的方式来一次解包多个变量</li>
<li>dict 老生常谈的问题，占用内存比较大，中庸的方法：namedtuple</li>
</ul>
<h3 id="定义临时变量提升可读性"><a class="header" href="#定义临时变量提升可读性">定义临时变量提升可读性</a></h3>
<p>有时，我们的代码里会出现一些复杂的表达式，像下面这样：</p>
<pre><code class="language-python"># 为所有性别为女性，或者级别大于 3 的活跃用户发放 10000 个金币
if user.is_active and (user.sex == 'female' or user.level &gt; 3):
    user.add_coins(10000)
    return
</code></pre>
<p>看见 <code>if</code> 后面那一长串了吗？有点难读对不对？但是如果我们把它赋值成一个临时变量，
就能给读者一个心理缓冲，提高可读性：</p>
<pre><code># 为所有性别为女性，或者级别大于 3 的活跃用户发放 10000 个金币
user_is_eligible = user.is_active and (user.sex == 'female' or user.level &gt; 3):

if user_is_eligible:
    user.add_coins(10000)
    return
</code></pre>
<p>定义临时变量可以提高可读性。但有时，把不必要的东西赋值成临时变量反而会让代码显得啰嗦：</p>
<pre><code class="language-python">def get_best_trip_by_user_id(user_id):

    # 心理活动：『嗯，这个值未来说不定会修改/二次使用』，让我们先把它定义成变量吧！
    user = get_user(user_id)
    trip = get_best_trip(user_id)
    result = {
        'user': user,
        'trip': trip
    }
    return result
</code></pre>
<p>其实，你所想的『未来』永远不会来，这段代码里的三个临时变量完全可以去掉，变成这样：</p>
<pre><code class="language-python">def get_best_trip_by_user_id(user_id):
    return {
        'user': get_user(user_id),
        'trip': get_best_trip(user_id)
    }
</code></pre>
<p>没必要为了那些可能出现的变动，牺牲代码当前的可读性。如果以后有定义变量的需求，那就以后再加吧。</p>
<h3 id="尽量不要使用-globals-和-locals"><a class="header" href="#尽量不要使用-globals-和-locals">尽量不要使用 globals() 和 locals()</a></h3>
<p><strong>global</strong></p>
<pre><code class="language-python">a = 10
def foo():
    b = 10
    a = 5
    return a + b

foo()
</code></pre>
<pre><code>15
</code></pre>
<pre><code class="language-python">a = 10
def foo():
    b = 10
    print(a)
    a = 5
    return a + b

foo()
</code></pre>
<pre><code>---------------------------------------------------------------------------

UnboundLocalError                         Traceback (most recent call last)

&lt;ipython-input-6-f16f46128f1b&gt; in &lt;module&gt;
      6     return a + b
      7 
----&gt; 8 foo()


&lt;ipython-input-6-f16f46128f1b&gt; in foo()
      2 def foo():
      3     b = 10
----&gt; 4     print(a)
      5     a = 5
      6     return a + b


UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>从上面两个例子可以看出，定义在 foo 内的 a 变量作用域只局限于 foo，是一个局部变量，foo 中的变量 a 并不是全局变量 a。所以才会没有初始化局部变量然后报异常的情况。</p>
<p>想要在 foo 中访问全局变量，就要用到 <strong>global</strong> 声明：</p>
<pre><code class="language-python">a = 10
def foo():
    b = 10
    global a
    print(id(a))

print(id(a))
foo()
</code></pre>
<pre><code>1470015552
1470015552
</code></pre>
<p><strong>locals()</strong></p>
<p><code>locals()</code> 返回局部环境中的所有环境变量，存放在 dict 中返回。可以用于传参：</p>
<pre><code class="language-python">def render_trip_page(request, user_id, trip_id):
    user = User.objects.get(id=user_id)
    trip = get_object_or_404(Trip, pk=trip_id)
    is_suggested = is_suggested(user, trip)
    # 利用 locals() 节约了三行代码，我是个天才！
    return render(request, 'trip.html', locals())
</code></pre>
<p>等价于：</p>
<pre><code>return render(request, 'trip.html', {
    'user': user,
    'trip': trip,
    'is_suggested': is_suggested
})
</code></pre>
<p><code>locals()</code> 在实际开发中不推荐使用，因为代码可读性差，如果函数比较长，那么后面代码维护的时候，就很难快速弄清楚到底传入了什么参数。</p>
<p><strong>The Zen of Python</strong>: <strong>Explicit is better than implicit.（显式优于隐式）</strong></p>
<h2 id="2-条件分支"><a class="header" href="#2-条件分支">2. 条件分支</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-packages"><a class="header" href="#python-packages">Python Packages</a></h1>
<p>[TOC]</p>
<h2 id="packages-and-module-tutorial"><a class="header" href="#packages-and-module-tutorial">Packages and Module Tutorial</a></h2>
<p><a href="https://docs.python.org/3/tutorial/modules.html#packages">官方文档</a></p>
<h3 id="demo-1"><a class="header" href="#demo-1">Demo</a></h3>
<p>层级关系：package —&gt; subpackage —&gt; module —&gt; (class/function/static variable)</p>
<p>import 只能 import 到 module 层级</p>
<p>而 from xxx import xxx 可以 import 最底层</p>
<pre><code>sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py        # module
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre>
<h3 id="__init__py-作用"><a class="header" href="#__init__py-作用"><code>__init__.py 作用</code></a></h3>
<p>The <code>__init__.py</code> files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as <code>string</code>, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, <code>__init__.py</code> can just be an empty file, but it can also <strong>execute initialization code for the package</strong> or set the <code>__all__</code> variable, described later.</p>
<p><code>__init__.py</code>会在包被导入的时候进行初始化。</p>
<h3 id="如何导包"><a class="header" href="#如何导包">如何导包</a></h3>
<p>Users of the package can import individual modules from the package, for example:</p>
<pre><code class="language-python">import sound.effects.echo # echo 可以是一个 subpackage 或者是 module(.py),不能是一个类，方法或者变量
</code></pre>
<p>This loads the submodule <code>sound.effects.echo</code>. It must be referenced with its full name.</p>
<pre><code class="language-python">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<p>An alternative way of importing the submodule is:</p>
<pre><code class="language-python">from sound.effects import echo
</code></pre>
<p>This also loads the submodule <code>echo</code>, and makes it available without its package prefix, so it can be used as follows:</p>
<pre><code class="language-python">echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<p>Yet another variation is to import the desired function or variable directly:</p>
<pre><code class="language-python">from sound.effects.echo import echofilter # echofilter 可以是一个 subpackage, submodule，也可以是一个方法，一个类，或者一个变量
</code></pre>
<p>Again, this loads the submodule <code>echo</code>, but this makes its function <code>echofilter()</code> directly available:</p>
<pre><code class="language-python">echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<p>Note that when using <code>from package import item</code>, the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The <code>import</code> statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an <a href="https://docs.python.org/3/library/exceptions.html#ImportError"><code>ImportError</code></a> exception is raised.</p>
<p>Contrarily, when using syntax like <code>import item.subitem.subsubitem</code>, each item except for the last must be a package; the last item can be a module or a package but can’t be a class or function or variable defined in the previous item.</p>
<h3 id="__all__"><a class="header" href="#__all__"><code>__all__</code></a></h3>
<p><strong>all 用来限定我  <code>from &lt;module&gt; import *</code>  时，对外暴露哪些模块和变量，起到隐私保护的作用。</strong></p>
<p>It is a list of strings defining what symbols in a module will be exported when <code>from &lt;module&gt; import *</code> is used on the module.</p>
<p>For example, the following code in a <code>foo.py</code> explicitly exports the symbols <code>bar</code> and <code>baz</code>:</p>
<pre><code class="language-py">__all__ = ['bar', 'baz']

waz = 5
bar = 10
def baz(): return 'baz'
</code></pre>
<p>These symbols can then be imported like so:</p>
<pre><code class="language-py">from foo import *

print(bar)
print(baz)

# The following will trigger an exception, as &quot;waz&quot; is not exported by the module
print(waz)
</code></pre>
<p>If the <code>__all__</code> above is commented out, this code will then execute to completion, as the default behaviour of <code>import *</code> is to import all symbols that do not begin with an underscore, from the given namespace.</p>
<p>Reference: https://docs.python.org/tutorial/modules.html#importing-from-a-package</p>
<p><strong>NOTE:</strong> <code>__all__</code> affects the <code>from &lt;module&gt; import *</code> behavior only. Members that are not mentioned in <code>__all__</code> are still accessible from outside the module and can be imported with <code>from &lt;module&gt; import &lt;member&gt;</code>.</p>
<h3 id="import--from-a-package"><a class="header" href="#import--from-a-package">import * from a package</a></h3>
<p>最终结论：不要使用 <code>import * </code></p>
<pre><code class="language-python">from sound.effects import *
</code></pre>
<p>实际上，import * 并不会把所有的 submodule 全部导入，真正的导入规则如下：</p>
<ol>
<li>
<p>如果 sub-package: effects 下的 <code>__init__.py</code> 文件定义了一个 ist called  <code>__all__</code>:</p>
<pre><code class="language-python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>那么只会导入 <code>__all__</code> 中指定的包，也就是所， <code>from sound.effects import *</code> 只会导入 effects 下的三个 submodule.</p>
</li>
<li>
<p>如果没有定义 <code>__all__</code>变量，那么就会导入 effects 中的所有包</p>
</li>
</ol>
<h3 id="intra-import-relative-import"><a class="header" href="#intra-import-relative-import">intra-import, relative import</a></h3>
<p>如果 <code>sound.filters.vocoder</code> module 想要使用 <code>sound.effects.echo</code>模块，因为他们都在 sound package 下，所以可以直接引用: <code>from sound.effects import echo</code></p>
<p>也可以使用相对地址的引用方式</p>
<pre><code class="language-python">from . import echo
from .. import formats
from ..filters import equalizer
</code></pre>
<p>Note that relative imports are based on the name of the current module.</p>
<h2 id="python-打包发布"><a class="header" href="#python-打包发布">Python 打包发布</a></h2>
<p><a href="https://packaging.python.org/tutorials/packaging-projects/">官方教程</a></p>
<p><a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/">官方详细教程</a></p>
<p><a href="https://docs.python.org/3.7/distutils/setupscript.html">Setup 教程</a></p>
<p><a href="https://github.com/pypa/sampleproject">Github Demo</a></p>
<p>上传到官方库的命令：</p>
<pre><code class="language-shell">pip install wheel
python setup.py sdist bdist_wheel # 生成 package
twine upload dist/* # 上传到官方库
</code></pre>
<h2 id="python-pip-tutorial"><a class="header" href="#python-pip-tutorial">Python Pip Tutorial</a></h2>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>用 pip 导包的时候，可能报名并不是 import 名称，例如 dateutil 包，pip 的时候就要导入 <code>pip install python-dateutil</code></p>
<h3 id="pip-install"><a class="header" href="#pip-install">pip install</a></h3>
<pre><code class="language-shell">pip install django # 会安装最新的包
pip install django==1.8.2 # 安装特定版本的包

pip install -r requirement.txt # 根据环境配置文件导包
</code></pre>
<h3 id="pip-list"><a class="header" href="#pip-list">pip list</a></h3>
<pre><code class="language-shell">pip list # 输出所有的包
</code></pre>
<h3 id="pip-freeze"><a class="header" href="#pip-freeze">pip freeze</a></h3>
<pre><code class="language-shell">pip freeze &gt; requirement.txt # 导出所有的包
</code></pre>
<h3 id="pip-升级"><a class="header" href="#pip-升级">pip 升级</a></h3>
<pre><code class="language-shell">pip install --upgrade 包名 # 升级包
pip install --upgrade django==1.11 # 升级到指定保本
</code></pre>
<h3 id="pip-uninstall"><a class="header" href="#pip-uninstall">pip uninstall</a></h3>
<pre><code class="language-shell">pip uninstall xxx
</code></pre>
<h2 id="python-虚拟环境"><a class="header" href="#python-虚拟环境">Python 虚拟环境</a></h2>
<h3 id="pipenv"><a class="header" href="#pipenv">pipenv</a></h3>
<p>官方介绍：https://pypi.org/project/pipenv/</p>
<p>是 pip 和 virtualenv 的组合。</p>
<h3 id="virtualenv"><a class="header" href="#virtualenv">virtualenv</a></h3>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000">廖雪峰教程</a></p>
<p>virtualenv 用来创建一个虚拟的 python 开发环境</p>
<pre><code class="language-shell">pip install virtualenv # 安装该包

# 前提系统应该已经安装了 Python3.7，如果没有安装，则需要 apt-get install python3.7
virtualenv venv --python=python3.7 # 创建一个虚拟的 python 环境，指定 python3.7 的版本
# venv 是 环境所在的文件夹，--python 用于指定 python 版本

source venv/bin/activate # 进入该虚拟环境
deactivate # 退出该虚拟环境

# 删除一个虚拟环境，只需要删除其文件夹即可

# windows 版本：
venv\Scripts\activate 
deactivate
</code></pre>
<h2 id="python-packages-1"><a class="header" href="#python-packages-1">Python Packages</a></h2>
<h3 id="selenium"><a class="header" href="#selenium">Selenium</a></h3>
<p>Windows Anaconda conf:</p>
<pre><code>1. conda install selenium 或者 pip
2. 下载 chromedriver.exe ,在附件中
3. 将 chromedriver.exe 放到 Anaconda 的目录下，就是第一层目录
4. 将 Chrome 浏览器的目录放在 PATH 变量里，目录可以右击图标链接找到：C:\Users\wanshuo\AppData\Local\Google\Chrome\Application
5. 将 chromedriver.exe 放到 Chrome 浏览器所在目录中，即 Application 中

Chrome 版本 要和 ChromeDriver 版本匹配：https://blog.csdn.net/ezreal_tao/article/details/80808729
</code></pre>
<p>Linux conf:</p>
<pre><code>1. pip install selenium==2.48.0
2. 安装Chrome
</code></pre>
<h3 id="dateutil-parser"><a class="header" href="#dateutil-parser">dateutil parser</a></h3>
<p>将时间字符串解析成 datetime</p>
<pre><code>安装
    pip install python-dateutil

导包
    from dateutil import parser

使用
    dateStruct = parser.parse(date_str)
</code></pre>
<h3 id="json-1"><a class="header" href="#json-1">json</a></h3>
<p><strong>加载 json 文件</strong></p>
<pre><code>import json
def load_json(path):
    try:
        with open(path) as json_file:
            my_dict = json.load(json_file)
    except Exception as e:
        print 'load_dict', e
    finally:
        return my_dict
</code></pre>
<p><strong>写入 json 文件</strong></p>
<pre><code>def store_dict(path, data):
    result = True
    try:
        with open(path, 'w') as json_file:
            json_file.write(json.dumps(data))
    except Exception as e:
        print 'store_dict', e
        result = False
    finally:
        return result
</code></pre>
<p><strong>json dumps</strong> 将字典转成 json 字符串，一行 dumps2string</p>
<pre><code>import json
data = {
    'name' : 'ACME',
    'shares' : 100,
    'price' : 542.23
}

json_str = json.dumps(data)
# '{&quot;price&quot;: 542.23, &quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 100}'
</code></pre>
<p><strong>json loads</strong> loads2dict</p>
<pre><code>将 json 编码的字符串转换成一个 python 的数据结构，往往是 dict
</code></pre>
<p><strong>json dump, load</strong>  用于 读取 和 写入 json 文件。</p>
<pre><code>如果你要处理的是文件而不是字符串，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。
# Writing JSON data
with open('data.json', 'w') as f:
    json.dump(data, f)

# Reading data back
with open('data.json', 'r') as f:
    data = json.load(f)
</code></pre>
<h3 id="汉字转拼音-pinyin"><a class="header" href="#汉字转拼音-pinyin">汉字转拼音 pinyin</a></h3>
<pre><code>pip install pinyin

https://pypi.org/project/pinyin/

import pinyin
pinyin.get(&quot;你好&quot;) # nǐhǎo
</code></pre>
<h3 id="wordcloud-词云"><a class="header" href="#wordcloud-词云">wordcloud 词云</a></h3>
<p>生成词云</p>
<pre><code class="language-python"># pip install wordcloud
import matplotlib.pyplot as plt
from wordcloud import WordCloud
# 读取整个文本
text = open(path.join(d, 'constitution.txt')).read()
# 生成一个词云图像
wordcloud = WordCloud(max_font_size=66).generate(text)
plt.figure()
plt.imshow(wordcloud, interpolation=&quot;bilinear&quot;)
plt.axis(&quot;off&quot;)
plt.show()

# 参考：https://blog.csdn.net/qq_34337272/article/details/79552929
</code></pre>
<h3 id="beautifulsoup4"><a class="header" href="#beautifulsoup4">BeautifulSoup4</a></h3>
<p>官方文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">BeautifulSoup</a></p>
<p><strong>fixed problems</strong></p>
<ol>
<li>
<p>解析出文档树出问题</p>
<p>这可能是因为 html 源码存在不规范的地方，而 html.parser 解析器的容错率不高，所以导致了解析出错</p>
<p>解决的方法：</p>
<pre><code class="language-python"># 注意 pip instal lxml
soup = BeautifulSoup(html, &quot;lxml&quot;)
</code></pre>
</li>
</ol>
<h3 id="commands-subprocess"><a class="header" href="#commands-subprocess">commands, subprocess</a></h3>
<p><strong>commands</strong></p>
<pre><code class="language-python">import commands
cmd = &quot;mkdir test&quot; # 建立 test 文件夹
commands.getstatusoutput(cmd) # 获取 cmd 执行结果的 status 和 output，返回一个元组(status, output)，如果执行成功，则 status 为0，如果命令执行失败，则返回一个非 0 的数字，output 为程序执行完的结果。
</code></pre>
<p>Python3.0 以后，commands 被 <a href="https://docs.python.org/2/library/subprocess.html#module-subprocess"><code>subprocess</code></a> 取代。</p>
<p><strong>subprocess</strong></p>
<p>The <a href="https://docs.python.org/2/library/subprocess.html#module-subprocess"><code>subprocess</code></a> module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:</p>
<pre><code>os.system
os.spawn*
os.popen*
popen2.*
commands.*
</code></pre>
<p>Demo:</p>
<pre><code class="language-python">subprocess.getstatusoutput(&quot;cmd&quot;) # 返回 0 表示运行成功，返回 非0 表示失败
</code></pre>
<p>实际上，在代码上，subprocess 可以直接替代 commands</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-exception"><a class="header" href="#python-exception">Python Exception</a></h1>
<p>[TOC]</p>
<h2 id="assert"><a class="header" href="#assert">assert</a></h2>
<p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p>
<pre><code class="language-python">assert expression
</code></pre>
<p>等价于</p>
<pre><code class="language-python">if not expression:
    raise AssertionError
</code></pre>
<h2 id="pep-343-the-with-statement"><a class="header" href="#pep-343-the-with-statement">PEP-343 The &quot;with&quot; Statement</a></h2>
<p><a href="https://www.geeksforgeeks.org/with-statement-in-python/">[with statement in Python]</a></p>
<p>Author: Guido van Rossum, Nick Coghlan </p>
<p>Created: 13-May-2005</p>
<h3 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h3>
<p><strong>with 用于异常发生时，及时释放异常涉及的资源</strong>。</p>
<p><strong><code>with</code></strong> statement in Python is used in exception handling to make the code cleaner and much more readable. It simplifies the management of common resources like file streams. </p>
<pre><code class="language-python"># file handling 
  
# 1) without using with statement 
file = open('file_path', 'w') 
file.write('hello world !') 
file.close() 
  
# 2) without using with statement 
file = open('file_path', 'w') 
try: 
    file.write('hello world') 
finally: 
    file.close() 
    
# using with statement 
with open('file_path', 'w') as file: 
    file.write('hello world !')
    
</code></pre>
<p>Notice that unlike the first two implementations, there is no need to call <code>file.close()</code> when using <code>with</code> statement. The <code>with</code> statement itself <strong>ensures proper acquisition and release of resources</strong>. An exception during the <code>file.write()</code> call in the first implementation can prevent the file from closing properly which may introduce several bugs in the code, i.e. many changes in files do not go into effect until the file is properly closed.</p>
<p>The second approach in the above example takes care of all the exceptions but using the <code>with</code> statement <strong>makes the code compact and much more readable</strong>. Thus, <code>with</code> statement helps avoiding bugs and leaks by ensuring that a resource is properly released when the code using the resource is completely executed. The <code>with</code> statement is <strong>popularly used with file streams</strong>, as shown above and with <strong>Locks, sockets, subprocesses and telnets</strong> etc.</p>
<h3 id="兼容-python2x"><a class="header" href="#兼容-python2x">兼容 Python2.x</a></h3>
<p>In Python 2.5, the new syntax will only be recognized if a future statement is present:</p>
<pre><code class="language-python">from __future__ import with_statement
</code></pre>
<p>This will make both 'with' and 'as' keywords. Without the future statement, using 'with' or 'as' as an identifier will cause a Warning to be issued to stderr.</p>
<p>In Python 2.6, the new syntax will always be recognized; 'with' and 'as' are always keywords.</p>
<h3 id="supporting-the-with-statement-in-user-defined-objects"><a class="header" href="#supporting-the-with-statement-in-user-defined-objects">Supporting the “with” statement in user defined objects</a></h3>
<p><a href="https://www.geeksforgeeks.org/with-statement-in-python/">[with statement in Python]</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-cheetsheet"><a class="header" href="#python-cheetsheet">Python Cheetsheet</a></h1>
<p>[TOC]</p>
<h2 id="python-大佬-和-python-学习资源"><a class="header" href="#python-大佬-和-python-学习资源">Python 大佬 和 Python 学习资源</a></h2>
<ul>
<li>大佬
<ul>
<li>Guido van Rossum</li>
<li>Luciano Ramalho <a href="https://github.com/fluentpython">[Fluent-Python]</a></li>
<li>Julien Danjou  <a href="https://julien.danjou.info/">[Blog]</a>，<a href="http://www.vimlinux.com/lipeng/tmpfile/the-hacker-guide-to-python.pdf">[代表作：The Hacker's Guide To Python]</a></li>
<li>Doug Hellmann  <a href="https://pymotw.com/3/">[Python 3 Module of the Week]</a>, <a href="computer-science-notebook/note-for-python/">[Book: The Python Standard Library by Example]</a> </li>
</ul>
</li>
<li>资源
<ul>
<li><a href="https://github.com/piglei/one-python-craftsman">[Github: Python工匠]</a></li>
</ul>
</li>
</ul>
<h2 id="python-中的一些特殊变量"><a class="header" href="#python-中的一些特殊变量">Python 中的一些特殊变量</a></h2>
<h3 id="__name__"><a class="header" href="#__name__"><code>__name__</code></a></h3>
<p><a href="https://www.freecodecamp.org/news/whats-in-a-python-s-name-506262fe61e8/">[Desc of <code>__name__</code> in FreeCodeCamp]</a></p>
<p><code>__name__</code> 是 Python 的一个变量，如果脚本是主动执行的，那么 <code>__name__</code> 的值就是 <code>__main__</code>，如果脚本是被 import 导入然后执行的，那么 <code>__name__</code> 的值就是脚本的名称。</p>
<pre><code class="language-python"># script1
import script2
print(__name__)
print(script2.__name__)

# script2
print(__name__)


&quot;&quot;&quot;
执行 script2，得到结果：
script2
__main__
script2
&quot;&quot;&quot;
</code></pre>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    pass
</code></pre>
<p>这就解释了，为什么脚本在被导入的时候，上面的代码不会执行的原因。有了 <code>__name__</code>，就可以在脚本中进行代码测试而不污染 import。</p>
<h2 id="python-built-in-functions"><a class="header" href="#python-built-in-functions">Python built-in functions</a></h2>
<p>Python 所有的 built-in functions：</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left">Built-in Functions</th><th style="text-align: left"></th><th></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#abs"><code>abs()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#delattr"><code>delattr()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#hash"><code>hash()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-memoryview"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-set"><code>set()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#all"><code>all()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-dict"><code>dict()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#help"><code>help()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#min"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#setattr"><code>setattr()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#any"><code>any()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#dir"><code>dir()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#hex"><code>hex()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#next"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#slice"><code>slice()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#ascii"><code>ascii()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#divmod"><code>divmod()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#id"><code>id()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#object"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#sorted"><code>sorted()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#bin"><code>bin()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#enumerate"><code>enumerate()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#input"><code>input()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#oct"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#staticmethod"><code>staticmethod()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#bool"><code>bool()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#eval"><code>eval()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#int"><code>int()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#open"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-str"><code>str()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#breakpoint"><code>breakpoint()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#exec"><code>exec()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#ord"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#sum"><code>sum()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-bytearray"><code>bytearray()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#filter"><code>filter()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#issubclass"><code>issubclass()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#pow"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#super"><code>super()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-bytes"><code>bytes()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#float"><code>float()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#iter"><code>iter()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#print"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-tuple"><code>tuple()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#callable"><code>callable()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#format"><code>format()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#len"><code>len()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#property"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#type"><code>type()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#chr"><code>chr()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-frozenset"><code>frozenset()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-list"><code>list()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#func-range"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#vars"><code>vars()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#classmethod"><code>classmethod()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#getattr"><code>getattr()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#locals"><code>locals()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#repr"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#zip"><code>zip()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#compile"><code>compile()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#globals"><code>globals()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#map"><code>map()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#reversed"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#__import__"><code>__import__()</code></a></td></tr>
<tr><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#complex"><code>complex()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#hasattr"><code>hasattr()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#max"><code>max()</code></a></td><td style="text-align: left"><a href="https://docs.python.org/3/library/functions.html#round"><code>round()</code></a></td><td></td></tr>
</tbody></table>
<h3 id="eval"><a class="header" href="#eval"><code>eval()</code></a></h3>
<p><a href="https://www.programiz.com/python-programming/methods/built-in/eval">[Python eval()]</a></p>
<p>Python has an eval() function which evaluates a string of Python code:</p>
<pre><code class="language-python">assert eval(&quot;2 + 3 * len('hello')&quot;) == 17
</code></pre>
<p>eval 函数很危险：<a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">[Eval really is dangerous]</a></p>
<p>Consider a situation where you are using a Unix system (macOS, Linux etc) and you have imported the <code>os</code> module. The os module provides a portable way to use operating system functionalities like reading or writing to a file.</p>
<p>If you allow users to input a value using <code>eval(input())</code>, the user may issue commands to change file or even delete all the files using the command: <code>os.system('rm -rf *')</code>.</p>
<h2 id="python-的几个短板"><a class="header" href="#python-的几个短板">Python 的几个短板</a></h2>
<h3 id="多线程与速度"><a class="header" href="#多线程与速度">多线程与速度</a></h3>
<ul>
<li>速度慢：更关注编程速度，而不是运行速度</li>
<li>不支持多核多线程：Python 仅支持单核的多线程</li>
</ul>
<h3 id="python-打包与独立可执行文件"><a class="header" href="#python-打包与独立可执行文件">Python 打包与独立可执行文件</a></h3>
<p>Python 很难进行打包部署</p>
<h2 id="python-运算符"><a class="header" href="#python-运算符">Python 运算符</a></h2>
<p>备忘几个不常用到的运算符</p>
<h3 id="算数运算符"><a class="header" href="#算数运算符">算数运算符</a></h3>
<table><thead><tr><th>运算符</th><th>解释</th><th>Demo</th></tr></thead><tbody>
<tr><td>**</td><td>幂</td><td><code>2**10 == 1024</code></td></tr>
<tr><td>/</td><td>除 (<strong>结果一定是小数 python3</strong>)</td><td><code>8 / 2 == 4.0</code></td></tr>
<tr><td>//</td><td>取整除（<strong>向下取整</strong>）</td><td><code>9//2 == 4</code></td></tr>
</tbody></table>
<h3 id="比较运算符"><a class="header" href="#比较运算符">比较运算符</a></h3>
<table><thead><tr><th>运算符</th><th>解释</th><th>Demo</th></tr></thead><tbody>
<tr><td>&lt;&gt;</td><td>不等于</td><td><code>2 &lt;&gt; 1</code></td></tr>
<tr><td>10 &lt;= num &lt;= 100</td><td>链式比较</td><td></td></tr>
</tbody></table>
<h3 id="位运算符"><a class="header" href="#位运算符">位运算符</a></h3>
<table><thead><tr><th>运算符</th><th>解释</th><th>Demo</th></tr></thead><tbody>
<tr><td>&amp;</td><td>按位与</td><td></td></tr>
<tr><td>|</td><td>按位或</td><td></td></tr>
<tr><td>^</td><td>按位异或 (相同为0，不同为1）</td><td></td></tr>
<tr><td>~</td><td>按位取反</td><td></td></tr>
<tr><td>&lt;&lt;</td><td>左移（地位补0）</td><td><code>3 &lt;&lt; 2 == 12</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>15 &gt;&gt; 2 == 3</code></td></tr>
</tbody></table>
<h2 id="python-与-c-的语法差异"><a class="header" href="#python-与-c-的语法差异">Python 与 C 的语法差异</a></h2>
<h3 id="数值型--1"><a class="header" href="#数值型--1">数值型 + 1</a></h3>
<p>Python 不能通过 <code>++a</code> 实现自增。</p>
<pre><code class="language-python"># C
int a = 1;
queue[++a] # == queue[2]
prinf(&quot;%d&quot;, a) # a == 2


# Python
a = 1
queue[++a] # == queue[2]
print(a) # 1
</code></pre>
<h2 id="其他问题"><a class="header" href="#其他问题">其他问题</a></h2>
<h3 id="指针和引用的区别"><a class="header" href="#指针和引用的区别">指针和引用的区别</a></h3>
<p>Pointer variable vs Reference variable</p>
<ul>
<li>
<p>引用更像是一个<strong>贴纸</strong>，贴纸上写上内存地址空间的别名（非空），然后贴在这块地址空间上，是一次性的（不能重新赋值）</p>
</li>
<li>
<p>指针首先是一个<strong>指针变量</strong>，这个变量存储着一个地址空间，这个变量可以为空，也可以重新赋值</p>
</li>
</ul>
<h2 id="matplotlib-绘制矢量图"><a class="header" href="#matplotlib-绘制矢量图">Matplotlib 绘制矢量图</a></h2>
<p>最通用的矢量图格式是 pdf 格式，不建议生成 svg 和 eps 格式的矢量图。</p>
<h2 id="python-depolyment"><a class="header" href="#python-depolyment">Python Depolyment</a></h2>
<p><a href="https://beeware.org/">[BeeWare]</a></p>
<p><strong>Write once. Deploy everywhere.</strong></p>
<p>Write your apps in Python and release them on iOS, Android, Windows, MacOS, Linux, Web, and tvOS using rich, native user interfaces. Multiple apps, one codebase, with a fully native user experience on every platform.</p>
<h2 id="python-gui"><a class="header" href="#python-gui">Python GUI</a></h2>
<ul>
<li>
<p>Turn python cmd into GUI application: <a href="https://github.com/chriskiehl/Gooey">Gooey</a></p>
<img align="left" src="computer-science-notebook/note-for-python/assets/image-20200828091512198.png" alt="image-20200828091512198" style="zoom:67%;" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jupyter-notebook"><a class="header" href="#jupyter-notebook">Jupyter-notebook</a></h1>
<p>[TOC]</p>
<p>Jupyter 首先是一款 Notebook，然后也是一款 Python 的开发工具。</p>
<p>我对 Jupyter 的定位：一款能边学 Python 边做笔记的开发工具。</p>
<p>jupyter 支持多语言扩展，只需要安装多语言的内核即可。</p>
<h2 id="install-and-open"><a class="header" href="#install-and-open">Install and open</a></h2>
<p>先安装 Python，然后通过 pip 安装</p>
<pre><code>pip install notebook
</code></pre>
<p>更改 notebook 默认打开的路径</p>
<ol>
<li><code>jupyter notebook --generate-config</code></li>
<li>修改 <code>jupyter_notebook_config.py</code> 中的 <code>c.NotebookApp.notebook_dir</code> 为我们的默认文件夹</li>
<li>右击 JupyterNotebook 快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】。</li>
</ol>
<p>打开 jupyter notebook</p>
<pre><code>jupyter notebook
</code></pre>
<h2 id="why"><a class="header" href="#why">Why</a></h2>
<p>交互性好，环境变量全局保存，适合写 Demo，然后加注释保存，适合写技术文档，避免了一遍在 IDE 上测试，一遍切换到笔记软件机笔记的尴尬。</p>
<p>Jupyter 源文件是纯文本文件，可以直接当成笔记保存下来。</p>
<p>可以转成 markdown 文件直接成为笔记。</p>
<h2 id="使用技巧"><a class="header" href="#使用技巧">使用技巧</a></h2>
<ul>
<li><a href="https://github.com/n-riesco/ijavascript">javascript 支持</a></li>
<li>VSCode中使用 jupyter，jupyter 插件，将 jupyter 的使用场景从浏览器迁移到 vscode 中，并且可以自定义笔记本所在的文件夹。</li>
</ul>
<p><strong>快捷键</strong></p>
<img src="computer-science-notebook/note-for-python/assets/image-20210714091457676.png" alt="image-20210714091457676" style="zoom:80%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="different-methods-in-class"><a class="header" href="#different-methods-in-class">Different methods in class</a></h1>
<p>[TOC]</p>
<ul>
<li><a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">[The definitive guide on how to use static, class or abstract methods in Python]</a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html">[Instance methods]</a></li>
</ul>
<h2 id="how-methods-work-in-python"><a class="header" href="#how-methods-work-in-python">How methods work in Python</a></h2>
<p>A method is a function that is stored as a class attribute. </p>
<p><strong>method 也是对象，也是类的属性：</strong></p>
<pre><code class="language-python">class Pizza(object):
    def __init__(self, size):
        self.size = size
    def get_size(self):
        return self.size
</code></pre>
<pre><code class="language-python">Pizza.get_size
</code></pre>
<pre><code>&lt;function __main__.Pizza.get_size(self)&gt;
</code></pre>
<p>在 python2.x 中，上面的输出结果是 <code>&lt;unbound method Pizza.get_size&gt;</code>, 也就是说这个方法并没有被绑定到一个 object 对象上。所以其不能单独执行。其应该绑定一个 Pizza 的对象（传入 Pizza 对象参数），然后执行。</p>
<p><strong>self 的显式传递：</strong></p>
<pre><code class="language-python">Pizza.get_size(Pizza(24)) # Pizza(24) 就是 self，显示传递
</code></pre>
<pre><code>24
</code></pre>
<p>上面的写法有很多缺点，不够直观，而且很多时候我们并不知到一个类的全名。</p>
<p>Python 进行了优化：<strong>其将类中的所有方法都绑定到了该类的实例上</strong>:</p>
<pre><code class="language-python">Pizza(42).get_size
</code></pre>
<pre><code>&lt;bound method Pizza.get_size of &lt;__main__.Pizza object at 0x06EBD958&gt;&gt;
</code></pre>
<p>从上面的结果可以看出，对象和对象方法是绑定的，<code>Pizza.get_size</code> 被绑定到了新建的对象上。</p>
<p><strong>self 的隐式传递：</strong></p>
<pre><code class="language-python">Pizza(42).get_size() # 等价于 Pizza.get_size(Pizza(24))
</code></pre>
<pre><code>42
</code></pre>
<p>我们不需要再传入任何参数给 <code>get_size()</code> 方法，因为它的 <code>self</code> 参数已经自动被设置成了 Pizza 的实例(Pizza 实例已经被隐式的传递给 <code>get_size</code> 方法)</p>
<pre><code class="language-python">m = Pizza(24).get_size
m()
</code></pre>
<pre><code>24
</code></pre>
<p>从上可看出，<code>get_size</code> 这个方法已经绑定到了 Pizza 实例上，绑定后我们获取方法名就足够了</p>
<p>Indeed, you don't even have to keep a reference to your Pizza object. Its method is bound to the object, so the method is sufficient to itself.</p>
<p>如果我们想要知道这个方法绑定到哪个实例上了，也就是说我们想要<strong>通过方法获取绑定的实例</strong>，我们可以通过以下的操作：</p>
<pre><code class="language-python">m = Pizza(24).get_size
m.__self__ # 获取 method 绑定的实例
</code></pre>
<pre><code>&lt;__main__.Pizza at 0x6ece970&gt;
</code></pre>
<pre><code class="language-python">m.__self__.get_size() # 获取实例后调用该实例绑定的方法
</code></pre>
<pre><code>24
</code></pre>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>You'll write code that belongs to a class, but that doesn't use the object itself at all. 这样我们就不需要先实例化一个对象，再去调用该方法。</p>
<pre><code class="language-python">class Pizza(object):
    @staticmethod # 用装饰器 staticmethod 修饰
    def mix_ingredients(x, y):
        return x + y

    def cook(self):
        return self.mix_ingredients(self.cheese, self.vegetables)
</code></pre>
<pre><code class="language-python">Pizza().cook is Pizza().cook
</code></pre>
<pre><code>False
</code></pre>
<p>实例化两个不同的对象，其绑定的 instancemethod 对象(instancemethod 也是对象，first-class function)也不同。</p>
<pre><code class="language-python">Pizza().mix_ingredients is Pizza.mix_ingredients
</code></pre>
<pre><code>True
</code></pre>
<pre><code class="language-python">Pizza().mix_ingredients is Pizza().mix_ingredients
</code></pre>
<pre><code>True
</code></pre>
<p>staticmethod 并不依赖于对象而存在，在 Java 中，其随着类的加载而加载，其在类的整个声明周期中只有一个实例。
但是 instancemethod 不同，其绑定在每一个不同的 object 上，所以每一个 instancemethod object 都不相同</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>Class methods are methods that are not bound to an object, but to… a class!</p>
<pre><code class="language-python">class Pizza(object):
    radius = 42
    @classmethod
    def get_radius(cls):
        return cls.radius
</code></pre>
<pre><code class="language-python">Pizza.get_radius
</code></pre>
<pre><code>&lt;bound method Pizza.get_radius of &lt;class '__main__.Pizza'&gt;&gt;
</code></pre>
<pre><code class="language-python">Pizza().get_radius
</code></pre>
<pre><code>&lt;bound method Pizza.get_radius of &lt;class '__main__.Pizza'&gt;&gt;
</code></pre>
<pre><code class="language-python">Pizza.get_radius == Pizza().get_radius
</code></pre>
<pre><code>True
</code></pre>
<p>从上面可以看出，classmethod 是和 class 绑定在一块的，其和 staticmethod 类似，在 class 的生命周期内只有一个实例。唯一不同的是，classmethod 要显式的传入一个 class 对象。</p>
<p><strong>classmethod 的使用场景</strong></p>
<p>一个原则：在 method 内如果碰到使用 cls 而又想避免硬编码类名，则使用 classmethod。
例如：工厂设计模式
在 classmethod 内调用传入的对象进行 class 类的实例化，直接使用 cls() 而不需要对类名进行硬编码 Pizza()：</p>
<pre><code class="language-python">class Pizza(object):
    def __init__(self, ingredients):
        self.ingredients = ingredients

    @classmethod
    def from_fridge(cls, fridge):
        return cls(fridge.get_cheese() + fridge.get_vegetables())
</code></pre>
<h2 id="abstract-methods"><a class="header" href="#abstract-methods">Abstract methods</a></h2>
<p>Python 中的 Abstract methods 就是 Java 中的接口。</p>
<p>Python 中最简单的 Abstract method 实现：</p>
<pre><code class="language-python">class Pizza(object):
    def get_radius(self):
        raise NotImplementedError
</code></pre>
<p>任何从继承自 Pizza 的类，都要重写或者实现 <code>get_radius</code> 方法，否则就会抛出异常。但是问题是，如果我们在继承类中忘记实现该方法，那么当我们调用该方法的时候，就会抛出异常。</p>
<p>我们可以使用 <code>abc</code> module 使得异常抛出得更早一些，在类创建的时候，就报错，而不是等待使用该方法时才报错。</p>
<pre><code class="language-python">import abc

class BasePizza(object):
    __metaclass__  = abc.ABCMeta

    @abc.abstractmethod
    def get_radius(self):
         &quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;
</code></pre>
<p>有了 <code>abstractmethod</code> 的装饰器，一旦我们想要对 baseclass 或者继承自 baseclass 但是没有实现 abstractmethod 的类进行实例化时，就会报错</p>
<h2 id="mixing-static-class-and-abstract-methods"><a class="header" href="#mixing-static-class-and-abstract-methods">Mixing static, class and abstract methods</a></h2>
<p>抽象方法可以被包含不同参数的方法所实现：</p>
<pre><code class="language-python">import abc

class BasePizza(object):
    __metaclass__  = abc.ABCMeta

    @abc.abstractmethod
    def get_ingredients(self): # 不要把参数定死了
         &quot;&quot;&quot;Returns the ingredient list.&quot;&quot;&quot;

class Calzone(BasePizza):
    def get_ingredients(self, with_egg=False):
        egg = Egg() if with_egg else None
        return self.ingredients + egg
</code></pre>
<p>可以用静态方法实现抽象方法：</p>
<pre><code class="language-python">import abc

class BasePizza(object):
    __metaclass__  = abc.ABCMeta

    @abc.abstractmethod
    def get_ingredients(self):
         &quot;&quot;&quot;Returns the ingredient list.&quot;&quot;&quot;

class DietPizza(BasePizza):
    @staticmethod
    def get_ingredients():
        return None
</code></pre>
<p><code>classmethod</code> 和 <code>staticmethod</code> 都可以装饰抽象方法。In Python, contrary to methods in Java interfaces, you can have code in your abstract methods and call it via super():</p>
<pre><code class="language-python">import abc

class BasePizza(object):
    __metaclass__  = abc.ABCMeta

    default_ingredients = ['cheese']

    @classmethod
    @abc.abstractmethod
    def get_ingredients(cls):
         &quot;&quot;&quot;Returns the ingredient list.&quot;&quot;&quot;
         return cls.default_ingredients

class DietPizza(BasePizza):
    def get_ingredients(self):
        return ['egg'] + super(DietPizza, self).get_ingredients()
</code></pre>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p><a href="https://docs.python.org/3/reference/datamodel.html">[Instance methods]</a> 实例方法</p>
<p><strong>class 中定义的实例方法，也是一个对象，其属性中包含了方法所在类，方法绑定的实例：</strong></p>
<pre><code class="language-python">pizza = Pizza(24)
dir(pizza.get_size)
</code></pre>
<pre><code>['__call__',
 '__class__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__func__',
 '__ge__',
 '__get__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__self__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']
</code></pre>
<p><strong>获取实例方法绑定的class实例：</strong></p>
<pre><code class="language-python">instance_method = pizza.get_size
instance_method.__self__
</code></pre>
<pre><code>&lt;__main__.Pizza at 0x7114f70&gt;
</code></pre>
<pre><code class="language-python">instance_method.__self__.get_size()
</code></pre>
<pre><code>24
</code></pre>
<p><strong>获取实例方法的名称：</strong></p>
<pre><code class="language-python">instance_method.__name__
</code></pre>
<pre><code>'get_size'
</code></pre>
<p><strong>获取实例方法的 doc:</strong></p>
<pre><code class="language-python">instance_method.__doc__
</code></pre>
<p><strong>获取实例方法所在的 module：</strong></p>
<pre><code class="language-python">instance_method.__module__
</code></pre>
<pre><code>'__main__'
</code></pre>
<p><strong>获取实例方法对象本身：</strong></p>
<pre><code class="language-python">instance_method.__func__
</code></pre>
<pre><code>&lt;function __main__.Pizza.get_size(self)&gt;
</code></pre>
<pre><code class="language-python">instance_method.__func__(Pizza(25))
</code></pre>
<pre><code>25
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pep-1"><a class="header" href="#pep-1">PEP</a></h1>
<p>[TOC]</p>
<h2 id="pep-2"><a class="header" href="#pep-2">PEP</a></h2>
<p>Python Enhancement Proposal.</p>
<p>PEP 提供了大量的语法糖。</p>
<p>PEP stands for Python Enhancement Proposal. A PEP is a design document providing information to the Python community, or describing a new feature for Python or its processes or environment. </p>
<h2 id="pep-8-coding-style"><a class="header" href="#pep-8-coding-style">PEP-8 Coding style</a></h2>
<p><a href="https://www.python.org/dev/peps/pep-0008">[PEP8]</a></p>
<p><strong>PEP8 标准已经被封装成一个工具</strong></p>
<pre><code class="language-shell">pip install pep8
</code></pre>
<pre><code class="language-shell">pep8 hello.py
</code></pre>
<pre><code>pycodestyle ...

  warnings.warn(
method.py:8:1: E302 expected 2 blank lines, found 1
method.py:11:5: E301 expected 1 blank line, found 0
</code></pre>
<p>其他 Python 静态代码检测工具：pyflakes, pylint</p>
<p><strong>代码长度</strong></p>
<p>一行代码长度：79 chars</p>
<p><strong>操作符</strong></p>
<pre><code class="language-python"># Wrong:
# operators sit far away from their operands
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)

# Correct:
# easy to match operators with operands
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</code></pre>
<p><strong>import</strong></p>
<p>Imports should be grouped in the following order:</p>
<ol>
<li>Standard library imports.</li>
<li>Related third party imports.</li>
<li>Local application/library specific imports.</li>
</ol>
<p>You should put a blank line between each group of imports.</p>
<p><strong>模块级 dunder names</strong></p>
<p>Module level &quot;dunders&quot; (i.e. names with two leading and two trailing underscores) such as <code>__all__</code>, <code>__author__</code>, <code>__version__</code>, etc. should be placed after the module docstring but before any import statements <em>except</em> <code>from __future__</code> imports. Python mandates that future-imports must appear in the module before any other code except docstrings:</p>
<pre><code class="language-python">&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
</code></pre>
<p><strong>whitespace 的使用惯例</strong></p>
<pre><code class="language-python"># Correct:
foo = (0,)

# Wrong:
bar = (0, )
</code></pre>
<pre><code class="language-python"># Correct:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

# Wrong:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
</code></pre>
<pre><code class="language-python"># Correct:
def complex(real, imag=0.0):
    return magic(r=real, i=imag)

# Wrong:
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)
</code></pre>
<p><strong>逗号的使用</strong></p>
<pre><code class="language-python"># Correct:
FILES = [
    'setup.cfg',
    'tox.ini', # 可能在后期进行扩展
    ]
initialize(FILES,
           error=True,
           )
# Wrong:
FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)
</code></pre>
<h2 id="pep-343-the-with-statement-1"><a class="header" href="#pep-343-the-with-statement-1">PEP-343 The &quot;with&quot; Statement</a></h2>
<p><a href="https://www.geeksforgeeks.org/with-statement-in-python/">[with statement in Python]</a></p>
<p>Author: Guido van Rossum, Nick Coghlan </p>
<p>Created: 13-May-2005</p>
<h3 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h3>
<p><strong>with 用于异常发生时，及时释放异常涉及的资源</strong>。</p>
<p><strong><code>with</code></strong> statement in Python is used in exception handling to make the code cleaner and much more readable. It simplifies the management of common resources like file streams. </p>
<pre><code class="language-python"># file handling 
  
# 1) without using with statement 
file = open('file_path', 'w') 
file.write('hello world !') 
file.close() 
  
# 2) without using with statement 
file = open('file_path', 'w') 
try: 
    file.write('hello world') 
finally: 
    file.close() 
    
# using with statement 
with open('file_path', 'w') as file: 
    file.write('hello world !')
    
</code></pre>
<p>Notice that unlike the first two implementations, there is no need to call <code>file.close()</code> when using <code>with</code> statement. The <code>with</code> statement itself <strong>ensures proper acquisition and release of resources</strong>. An exception during the <code>file.write()</code> call in the first implementation can prevent the file from closing properly which may introduce several bugs in the code, i.e. many changes in files do not go into effect until the file is properly closed.</p>
<p>The second approach in the above example takes care of all the exceptions but using the <code>with</code> statement <strong>makes the code compact and much more readable</strong>. Thus, <code>with</code> statement helps avoiding bugs and leaks by ensuring that a resource is properly released when the code using the resource is completely executed. The <code>with</code> statement is <strong>popularly used with file streams</strong>, as shown above and with <strong>Locks, sockets, subprocesses and telnets</strong> etc.</p>
<h3 id="兼容-python2x-1"><a class="header" href="#兼容-python2x-1">兼容 Python2.x</a></h3>
<p>In Python 2.5, the new syntax will only be recognized if a future statement is present:</p>
<pre><code class="language-python">from __future__ import with_statement
</code></pre>
<p>This will make both 'with' and 'as' keywords. Without the future statement, using 'with' or 'as' as an identifier will cause a Warning to be issued to stderr.</p>
<p>In Python 2.6, the new syntax will always be recognized; 'with' and 'as' are always keywords.</p>
<h3 id="supporting-the-with-statement-in-user-defined-objects-1"><a class="header" href="#supporting-the-with-statement-in-user-defined-objects-1">Supporting the “with” statement in user defined objects</a></h3>
<p><a href="https://www.geeksforgeeks.org/with-statement-in-python/">[with statement in Python]</a></p>
<h2 id="pep-440-software-version"><a class="header" href="#pep-440-software-version">PEP-440 Software Version</a></h2>
<p>PEP 440 introduces a version format that every Python package, and ideally everyapplication, should follow.</p>
<h3 id="一些官方定义"><a class="header" href="#一些官方定义">一些官方定义</a></h3>
<table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody>
<tr><td>Projects</td><td>&quot;Projects&quot; are software components that are made available for integration. Projects include Python libraries, frameworks, scripts, plugins, applications, collections of data or other resources, and various combinations thereof. Public Python projects are typically registered on the <a href="https://pypi.python.org/">Python Package Index</a>.</td></tr>
<tr><td>Releases</td><td>&quot;Releases&quot; are uniquely identified snapshots of a project.</td></tr>
<tr><td>Distributions</td><td>&quot;Distributions&quot; are the packaged files which are used to publish and distribute a release.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构与算法-python-实现思路"><a class="header" href="#数据结构与算法-python-实现思路">数据结构与算法 Python 实现思路</a></h1>
<p>[TOC]</p>
<h2 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h2>
<p>Python 标准库提供了很多高级数据结构的实现，大多数写 Python 的人，由于对 Python 的标准库了解得不深入，没有使用这些现成的标准库，这么做有几个缺点：</p>
<ul>
<li>
<p>重复造轮子</p>
<p>标准库提供的高级数据结构都是经过高度优化的， 更节省计算资源</p>
</li>
<li>
<p>代码不够 Pythonic</p>
<p>使用标准库能够使得写出的代码更 Pythonic，更加简洁易读</p>
</li>
</ul>
<p>为了更好的利用标准库写出 Pythonic 的代码，我将对 Python 标准库应用于数据结构和算法的情景进行总结。</p>
<h2 id="学习资料-2"><a class="header" href="#学习资料-2">学习资料</a></h2>
<p><a href="https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf">[解决算法和数据结构问题（Python 版）]</a></p>
<h2 id="deque"><a class="header" href="#deque">deque</a></h2>
<p>deque 是双向队列，可以用于</p>
<h3 id="binarytree-level-order-traversal"><a class="header" href="#binarytree-level-order-traversal">BinaryTree Level Order Traversal</a></h3>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode: 102</a></p>
<pre><code class="language-Python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import deque # 导入 deque
        result = []
        if root is None:
            return result
        queue = deque()
        queue.append(root)
        while len(queue) &gt; 0:
            level_node_nums = len(queue)
            level_nodes = []
            for _ in range(level_node_nums):
                node = queue.popleft() # popright
                level_nodes.append(node.val) # append 默认从右边插入，等价于 appendright
                if node.left is not None:
                    queue.append(node.left)
                if node.right is not None:
                    queue.append(node.right)
            result.append(level_nodes)
        return result
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程和多进程"><a class="header" href="#多线程和多进程">多线程和多进程</a></h1>
<p>[TOC]</p>
<h2 id="并行的优点"><a class="header" href="#并行的优点">并行的优点</a></h2>
<p>引入并行机制可以充分利用计算机的资源加速计算。</p>
<p>在计算密集型任务上，多进程强于多线程。在 IO 密集型任务上，多线程稍强于多进程。</p>
<table><thead><tr><th>计算密集型</th><th>IO密集型</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/note-for-python/assets/image-20200106170615876.png" alt="计算密集型任务" /></td><td><img src="computer-science-notebook/note-for-python/assets/image-20200106170855372.png" alt="IO 密集型任务" /></td></tr>
</tbody></table>
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<p><a href="https://docs.python.org/3/library/threading.html#module-threading">官方文档</a></p>
<h2 id="多进程"><a class="header" href="#多进程">多进程</a></h2>
<p><a href="https://docs.python.org/3.4/library/multiprocessing.html?highlight=process">官方文档</a></p>
<h3 id="进程池"><a class="header" href="#进程池">进程池</a></h3>
<p>进程池可以控制进程的个数，从而从一定程度上控制计算机资源的消耗，防止过载。</p>
<pre><code class="language-python">from multiprocessing import Pool # 进程池

def f(x):
    return x*x

if __name__ == '__main__':
    with Pool(5) as p: # 新建一个 5 个进程的进程池，只限用 5 个进程进行计算
        print(p.map(f, range(1000)))

# [1, 4, 9, ……]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<p>[TOC]</p>
<p>毕向东 Java 学习笔记</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<ul>
<li>Java 先编译，再解释执行：
<ol>
<li><code>javac foo.java</code> 编译 Java 源文件生成字节码文件：<code>foo.class</code></li>
<li><code>java foo.class</code> 用虚拟机解释执行字节码文件</li>
</ol>
</li>
</ul>
<h3 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h3>
<ul>
<li>类名：<code>HelloJava</code></li>
<li>类的成员变量、局部变量、成员方法：<code>firstDay</code>，<code>getName()</code></li>
<li>常量：<code>MAX_VALUE</code></li>
</ul>
<h3 id="for-循环"><a class="header" href="#for-循环">for 循环</a></h3>
<p><strong>增强 for 循环</strong></p>
<pre><code class="language-java">for( String name : names ) {
	System.out.print( name );
	System.out.print(&quot;,&quot;);
}
</code></pre>
<p><strong>for 的 while 实现</strong></p>
<pre><code class="language-java">for(;;){
    
}
</code></pre>
<h3 id="位运算"><a class="header" href="#位运算">位运算</a></h3>
<p><strong>&gt;&gt; 和 &gt;&gt;&gt;</strong></p>
<p><code>&gt;&gt;</code> ，正数高位补零，负数高位补一。<code>&gt;&gt;&gt;</code> 正负数都强制高位补 0</p>
<h3 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h3>
<pre><code>java.lang.Number
	Integer
	Short
	Long
	Float
	Double
	Byte
	BigInteger
	BigDecimal
	
</code></pre>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<p>数组是<strong>相同类型</strong>数据的集合。</p>
<h3 id="数组的初始化"><a class="header" href="#数组的初始化">数组的初始化</a></h3>
<pre><code class="language-java">double[] myList;  // 定义一个数组的引用
</code></pre>
<pre><code class="language-java">int[] integers = new int[10]; // 在堆内存中 new 一个数组，堆内存中创建的对象都有默认值
for(int integer : integers){ // 增强 for 循环
    System.out.println(integer);
}

dataType[] arrayRefVar = {value0, value1, ..., valuek};
String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d1&quot;, &quot;a1&quot;};
</code></pre>
<pre><code class="language-java">// new 二维数组
int[][] arr = new int[3][2];
System.out.println(arr.length);
System.out.println(arr[1].length);
int[][] arr = new int[3][];

</code></pre>
<p>匿名数组：</p>
<pre><code class="language-java">public class Test { 
    public static void printArray(int []arr){
        for (int i : arr) {
            System.out.print(i);
        }
    }
    public static void main(String[] args) {
        //Many code
        printArray(new int[]{1,2,3,4,5,6});
        //Many code
    }
}
</code></pre>
<h3 id="常见方法"><a class="header" href="#常见方法">常见方法</a></h3>
<pre><code class="language-java">System.arrayCopy(源数组，从哪开始，目标数组，从哪开始贴，粘几个);
Arrays.sort(被排序的数组);
Arrays.binarySearch(哪个数组，数组中的什么元素);
Arrays.fill(a， 2， 4, 100); //将数组a中2到4的索引的元素替换为100
</code></pre>
<h3 id="内存分配"><a class="header" href="#内存分配">内存分配</a></h3>
<p><strong>栈内存</strong></p>
<p>存储的都是局部变量， 而且变量所属的作用域一旦结束，该变量就自动释放。</p>
<p><strong>堆内存</strong></p>
<p>存储是数组和对象(其实数组就是对象) 凡是new建立在堆中。</p>
<p>特点：</p>
<ol>
<li>每一个实体都有首地址值</li>
<li>堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数是0，小数0.0或者0.0f，boolean false char '\u0000'</li>
<li>垃圾回收机制</li>
</ol>
<p>堆内存的默认初始化值：</p>
<table><thead><tr><th>类型</th><th>默认初始化值</th></tr></thead><tbody>
<tr><td>int</td><td>0</td></tr>
<tr><td>float</td><td>0.0</td></tr>
<tr><td>String</td><td>null</td></tr>
</tbody></table>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p><strong>特点</strong></p>
<ul>
<li>
<p>函数名与类名相同</p>
</li>
<li>
<p>不用定义返回值类型</p>
</li>
<li>
<p>不可以 return</p>
</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>给对象初始化</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>
<p>构造函数是可以重载的，也就是可以有多种对象初始化方式</p>
</li>
<li>
<p>构造函数如果前面加了 void 就变成了一般函数。</p>
</li>
<li>
<p>默认的构造函数，类可以没有构造函数</p>
<p>当一个类中没有定义构造函数时，系统会默认给该类加入一个空参数的构造函数，例如 <code>Person(){}</code> 当自定义构造函数后，默认的构造函数就没了</p>
<p>但是当一个类加入了有参的构造函数时，我们就需要手动加上无参的构造函数，否则会在初始化对象的时候，会因为找不到无参构造器报错</p>
</li>
<li>
<p>什么时候需要构造函数？</p>
<p>分析事物时，该事物一开始就具备某些某些属性或行为，那么将这些 内容定义在构造函数中</p>
</li>
<li>
<p>可以通过私有化构造函数，进而禁止类进行初始化</p>
</li>
</ul>
<h3 id="main-函数"><a class="header" href="#main-函数">main 函数</a></h3>
<pre><code class="language-java">public static void main(String[] args){
    
}
</code></pre>
<ul>
<li>public 权限必须是最大的</li>
<li>static 该函数并没有涉及到成员方法</li>
<li>void 主函数没有具体的返回值</li>
<li>main 不是关键字，是 JVM 识别的固定的名字</li>
<li>String[] args 参数列表，是一个数组类型的参数，元素都是字符串</li>
</ul>
<h3 id="构造代码块"><a class="header" href="#构造代码块">构造代码块</a></h3>
<p><strong>作用</strong></p>
<ul>
<li>定义所有对象的共性，给对象进行初始化，对象一建立就运行，而且先于构造函数执行</li>
<li>每 new 一个对象，构造代码块就运行一次</li>
</ul>
<p><strong>构造代码块和构造函数的区别</strong></p>
<p>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化（对象也许有重载）</p>
<pre><code class="language-java">// 构造代码块是定义每一个对象的共性
{
    System.out.println(&quot;person code run&quot;);
}
</code></pre>
<h3 id="静态代码块"><a class="header" href="#静态代码块">静态代码块</a></h3>
<p>随着类的加载而执行。而且只执行一次。</p>
<p>作用：用于给类进行初始化。</p>
<pre><code class="language-java">static
{
    System.out.println(&quot;static code&quot;);
}
</code></pre>
<h3 id="void"><a class="header" href="#void">void</a></h3>
<p>如果函数没有具体返回值，那么返回值类型可以用 <code>void</code> 来表示，函数中 <code>return</code> 可以不写，也可以写成 <code>return;</code></p>
<h3 id="重载"><a class="header" href="#重载">重载</a></h3>
<p><strong>重载与返回值类型无关</strong>，只看参数类型是否不一样，参数类型不一样并且函数名一样则重载。</p>
<p>java是严谨性语言，如果函数出现的调用的不确定性，会编译失败。</p>
<img align='left' src="computer-science-notebook/note-for-java/assets/clip_image001.png" alt="重载"  />
<h2 id="类"><a class="header" href="#类">类</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<p>成员变量</p>
<ul>
<li>成员变量随着对象的创建而存在，随着对象的消失而消失 </li>
<li>成员变量存在于堆内存的对象中，成员变量都有默认初始化值</li>
</ul>
<h3 id="匿名对象"><a class="header" href="#匿名对象">匿名对象</a></h3>
<pre><code class="language-java">new Car(); // 匿名对象。其实就是定义对象的简写格式。
Car c = new Car();
c.run();
new Car().run();

// 1，当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。
new Car().num = 5;
new Car().color = &quot;green&quot;;
new Car().run();33

// 2，匿名对象可以作为实际参数进行传递。
Car c1 = new Car();
show(c1); // 等价于：
show(new Car());
</code></pre>
<h3 id="private"><a class="header" href="#private">private</a></h3>
<p>私有的内容只在本类中有效，不在子类中生效。</p>
<p>Java 中的 <code>this</code> 对应 Python 中的 <code>self</code> 关键字。</p>
<h3 id="static"><a class="header" href="#static">static</a></h3>
<p><strong>static 的特点</strong></p>
<ol>
<li>static 是一个修饰符，用于修饰成员，可以修饰变量，也可以修饰方法</li>
<li><strong>static 修饰的成员被所有的对象所共享</strong></li>
<li>static 优先于对象存在，因为static的成员随着类的加载就已经存在了</li>
<li>static 修饰的成员多了一种调用方式，就可以直接被类名所调用 【类名.静态成员】</li>
<li>static 修饰的数据是共享数据，对象中的存储的是特有数据</li>
</ol>
<p><strong>静态成员变量的特点</strong></p>
<ol>
<li>静态变量随着类的加载而存在，随着类的消失而消失</li>
<li>静态成员（函数和变量）既可以被对象调用（这种方式在 Java 高版本中不提倡），还可以被类名调用</li>
<li>静态变量称为<strong>类变量</strong></li>
<li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据</li>
<li>静态变量如果设置了 private，则通过类名的方式不能调用</li>
</ol>
<p><strong>静态使用的注意事项</strong></p>
<ol>
<li>静态方法只能访问静态成员。 (<strong>非静态既可以访问静态，又可以访问非静态</strong>)</li>
<li>静态方法中不可以使用this或者super关键字</li>
<li>主函数是静态的</li>
</ol>
<p><strong>static 使用场景</strong></p>
<ol>
<li>
<p>静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以被静态修饰。</p>
<p>只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。 </p>
</li>
<li>
<p>静态方法</p>
<p>函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象中的特有数据。
简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，
但是非静态需要被对象调用，而仅创建对象调用非静态的。没有访问特有数据的方法，该对象的创建是没有意义。</p>
</li>
</ol>
<h3 id="this"><a class="header" href="#this">this</a></h3>
<ul>
<li>当成员变量和局部变量重名，可以用关键字this来区分</li>
<li>this也可以用于在构造函数中调用其他构造函数
注意：只能定义在构造函数的第一行。因为初始化动作要先执行</li>
</ul>
<h3 id="继承"><a class="header" href="#继承">继承</a></h3>
<p><strong>super 和 this</strong></p>
<p>当本类的成员和局部变量同名用this区分。当子父类中的成员变量同名用super区分父类。
this和super的用法很相似。this:代表一个本类对象的引用。super：代表一个父类空间。</p>
<pre><code class="language-java">// Demo
class Zi extends Fu{
    Zi(){
        super(); // Zi 的构造函数，一定会先执行 Fu 的构造函数
    }
}
</code></pre>
<p><strong>构造函数</strong></p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。</p>
<ul>
<li>
<p>super() 显式调用</p>
<p>如果父类中没有定义空参数构造函数，那么子类的构造函数必须用 super() 显式调用。明确要调用父类中哪个构造函数。</p>
</li>
<li>
<p>super() 隐式调用</p>
<p>如果父类定义了空参数构造函数，那么子类的构造函数不用显式 super()</p>
</li>
</ul>
<p>其实不管怎么样，子类都会访问父类的构造函数，所以代码里最好还是显式的把 <code>super()</code> 写出来比较好。</p>
<p>supre语句必须要定义在子类构造函数的第一行。因为父类的初始化动作要先完成。</p>
<p>通过super初始化父类内容时，子类的成员变量并未显示初始化。等super()父类初始化完毕后，才进行子类的成员变量显示初始化。</p>
<p><strong>函数重写(覆盖)</strong></p>
<p>我个人倾向于叫重写。</p>
<p>当子父类中出现成员函数一模一样的情况，会运行子类的函数。
这种现象，称为重写操作。这时函数在子父类中的特性。
函数两个特性</p>
<ol>
<li>重载。同一个类中。 overload</li>
<li>覆盖。子类中。覆盖也称为重写，覆写。 override</li>
</ol>
<p>重写注意事项：</p>
<ol>
<li>子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限</li>
<li>静态只能覆盖静态，或被静态覆盖</li>
</ol>
<p>重写的使用场景：</p>
<ol>
<li>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成.</li>
</ol>
<p><strong>单例设计模式</strong></p>
<pre><code class="language-java">/*
设计模式：对问题行之有效的解决方式。其实它是一种思想。
1,单例设计模式。
解决的问题：就是可以保证一个类在内存中的对象唯一性。
必须对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。
如何保证对象唯一性呢？
1，不允许其他程序用new创建该类对象。
2，在该类创建一个本类实例。
3，对外提供一个方法让其他程序可以获取该对象。
步骤：
1，私有化该类构造函数。
2，通过new在本类中创建一个本类对象。
3，定义一个公有的方法，将创建的对象返回。
*/

//饿汉式
class Single //类一加载，对象就已经存在了。
{
    private static Single s = new Single();
    private Single(){}
    public static Single getInstance(){
    	return s;
    }
}

//懒汉式
class Single2 //类加载进来，没有对象，只有调用了getInstance方法时，才会创建对象。
//延迟加载形式。
{
    private static Single2 s = null;
    private Single2(){}
    public static Single2 getInstance(){
        if(s==null)
        	s = new Single2();
        return s;
    }
}

class SingleDemo{
    public static void main(String[] args){
        Single s1 = Single.getInstance();
        Single s2 = Single.getInstance();
        System.out.println(s1==s2);
    }
}
</code></pre>
<h3 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h3>
<p><strong>概述</strong></p>
<ol>
<li>方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰</li>
<li>抽象方法必须定义在抽象类中。该类必须也被abstract修饰</li>
<li>抽象类不可以被实例化。为什么？因为调用抽象方法没意义。抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。
否则，这个子类还是抽象类</li>
<li>抽象类一定是一个父类，其生来就是要被继承的</li>
</ol>
<p>注意，抽象类可以有构造函数，用于给子类进行初始化。抽象类也可以不定义抽象方法。</p>
<pre><code class="language-java">abstract class Demo{
	Demo(){   
    }
    abstract public abstractFunc(); // 写一个接口协议，要求子类去实现
}
</code></pre>
<p><strong>abstract 关键字</strong></p>
<p>抽象关键字不可以和 private，static，final 同时存在：</p>
<ol>
<li>private：抽象是定义了一个协议，要求子类去实现的，private 私有后，子类就访问不到了</li>
<li>static：抽象方法必须子类实现后才能访问，而 static 修饰后，可以直接通过类名进行访问，冲突了</li>
<li>final：final 定义的属性和方法，就不能修改了，而抽象关键字定义的函数是要被子类继承修改的</li>
</ol>
<p><strong>抽象类和一般类的异同点</strong></p>
<ol>
<li>
<p>相同点</p>
<p>抽象类和一般类都是用来描述事物的，都在内部定了成员</p>
</li>
<li>
<p>不同点</p>
<ol>
<li>一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足</li>
<li>一般类中不能定义抽象方法，只能定非抽象方法，抽象类中可定义抽象方法，同时也可以定义非抽象方法</li>
<li>一般类可以被实例化，抽象类不可以被实例化</li>
</ol>
</li>
</ol>
<h3 id="一个对象的实例化过程"><a class="header" href="#一个对象的实例化过程">一个对象的实例化过程</a></h3>
<p>一个对象的实例化过程 <code>Person p = new Person();</code></p>
<ol>
<li>JVM会读取指定的路径下的Person.class文件，并加载进内存，并会先加载Person的父类(如果有直接的父类的情况下)</li>
<li>在堆内存中的开辟空间，分配地址。并在对象空间中，对对象中的属性进行默认初始化</li>
<li>调用对应的构造函数进行初始化</li>
<li>在构造函数中，第一行会先到调用父类中构造函数进行初始化</li>
<li>父类初始化完毕后，在对子类的属性进行显示初始化</li>
<li>在进行子类构造函数的特定初始化</li>
<li>初始化完毕后，将地址值赋值给引用变量</li>
</ol>
<h3 id="final"><a class="header" href="#final">final</a></h3>
<p>final 关键字的特点：</p>
<p>final关键字：</p>
<ol>
<li>final是一个修饰符，可以修饰<strong>类，方法，变量</strong>。</li>
<li>final修饰的类不可以被继承。</li>
<li>final修饰的方法不可以被覆盖。</li>
<li>final修饰的变量是一个常量，只能赋值一次。</li>
</ol>
<p>为什么要用final修饰变量?</p>
<p>其实在程序如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以它该数据起个名称。
而且这个变量名称的值不能变化，所以加上final固定。
写法规范：常量所有字母都大写，多个单词，中间用_连接。</p>
<pre><code class="language-java">public static final double MY_PI = 3.14;
</code></pre>
<h3 id="接口"><a class="header" href="#接口">接口</a></h3>
<p>接口有点类似鸭子🦆类型。</p>
<p>当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。</p>
<p>接口中的成员都是公共的权限。</p>
<pre><code class="language-java">interface Demo{
    public static final int NUM = 4;
    public abstract void show1();
    public abstract void show2();
}
</code></pre>
<p>只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。</p>
<p><strong>多实现</strong></p>
<p>在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行改良，在java中变成了多实现。一个类可以实现多个接口。</p>
<pre><code class="language-java">// 多继承
interface A{
	public void show(); // abstract 可以省略不写
}

interface Z{
	public int add(int a,int b);
}

class Test implements A,Z{
	public int add(int a,int b){
		return a+b+3;
	}
    public void show(){}
}
</code></pre>
<p><strong>接口的多继承</strong></p>
<pre><code class="language-java">interface CC{
	void show();
}

interface MM{
	void method();
}

interface QQ extends CC, MM //接口与接口之间是继承关系，而且接口可以多继承。
{
	void function();
}

class WW implements QQ{
    //覆盖3个方法。
    public void show(){}
    public void method(){}
    public void function(){}
}
</code></pre>
<p><strong>接口和抽象类比较</strong></p>
<ol>
<li>
<p>相同点</p>
<p>都是不断向上抽取而来的。</p>
</li>
<li>
<p>不同点</p>
<ol>
<li>抽象类需要被继承，而且只能单继承。
接口需要被实现，而且可以多实现。</li>
<li>抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。
接口中只能定义抽象方法，必须由子类去实现。</li>
<li>抽象类的继承，是 is a 关系，在定义该体系的基本共性内容。
接口的实现是 like a 关系，在定义体系额外功能。</li>
</ol>
</li>
</ol>
<h3 id="多态"><a class="header" href="#多态">多态</a></h3>
<p><strong>什么是多态</strong></p>
<p>一个对象有多种特征。一个对象，走起路来像鸭子，叫声也像鸭子，那么这个对象就具有鸭子的特征；同时这个对象还是胎生的，那么其就有哺乳动物的特征。一个对象，多种状态。</p>
<p>多态的一个实际案例：</p>
<pre><code>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
</code></pre>
<pre><code class="language-java">class 动物
{}
class 猫 extends 动物
{}
class 狗 extends 动物
{}
猫 x = new 猫();
动物 x = new 猫(); //一个对象，多种形态。
</code></pre>
<p>猫这类事物即具备者猫的形态，又具备着动物的形态。这就是对象的多态性。
简单说：就是一个对象对应着不同类型。(因为实现了不同的接口)</p>
<p>多态在代码中的体现：父类或者接口的引用指向其子类的对象</p>
<p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<p>多态的弊端：前期定义的内容不能使用(调用)后期子类的特有内容</p>
<p>多态的前提：1. 必须有关系，继承，实现。2. 要有覆盖。</p>
<pre><code class="language-java">abstract class Animal{
	abstract void eat();
}

class Dog extends Animal{
	void eat(){
    System.out.println(&quot;啃骨头&quot;);
    }
    void lookHome(){
        System.out.println(&quot;看家&quot;);
    }
}

class Cat extends Animal{
    void eat(){
    	System.out.println(&quot;吃鱼&quot;);
    }
    void catchMouse(){
    	System.out.println(&quot;抓老鼠&quot;);
    }
}

class Pig extends Animal{
    void eat(){
    	System.out.println(&quot;饲料&quot;);
    }
    void gongDi(){
    	System.out.println(&quot;拱地&quot;);
    }
}

class DuoTaiDemo{
    
    public static void main(String[] args){
        // Cat c = new Cat();
        // c.eat();
        // c.catchMouse();
        Animal a = new Cat(); //自动类型提升，猫对象提升了动物类型。但是特有功能无法s访问。
        //作用就是限制对特有功能的访问。
        //专业讲：向上转型。将子类型隐藏。就不用使用子类的特有方法。
        // a.eat();
        //如果还想用具体动物猫的特有功能。
        //你可以将该对象进行向下转型。
        // Cat c = (Cat)a;//向下转型的目的是为了使用子类中的特有方法。
        // c.eat();
        // c.catchMouse();
        // 注意：对于转型，自始自终都是子类对象在做着类型的变化。
        // Animal a1 = new Dog();
        // Cat c1 = (Cat)a1;//ClassCastException
        /*
        Cat c = new Cat();
        // Dog d = new Dog();
        // c.eat();
        method(c);
        // method(d);
        // method(new Pig());
        */
        method(new Dog());
    }
    public static void method(Animal a){ //Animal a = new Dog();
   		a.eat();
        if(a instanceof Cat){ //instanceof：用于判断对象的具体类型。只能用于引用数据类型判断
        	//通常在向下转型前用于健壮性的判断。
            Cat c = (Cat)a;
            c.catchMouse();
        }else if(a instanceof Dog){
            Dog d = (Dog)a;
            d.lookHome();
        }else{ 
        }
	}
}
</code></pre>
<p><strong>多态时各组成的发化</strong></p>
<p>多态时，成员的特点：</p>
<ol>
<li>成员变量
编译时：参考引用型变量所属的类中的是否有调用的成员变量，有，编译通过，没有，编译失败。
运行时：参考引用型变量所属的类中的是否有调用的成员变量，并运行该所属类中的成员变量。
简单说：编译和运行都参考等号的左边。哦了。</li>
<li>成员函数(非静态)
编译时：参考引用型变量所属的类中的是否有调用的函数。有，编译通过，没有，编译失败。
运行时：参考的是对象所属的类中是否有调用的函数。
简单说：编译看左边，运行看<strong>右边</strong>。（其他都是左边）
因为成员函数存在覆盖特性。</li>
<li>静态函数
编译时：参考引用型变量所属的类中的是否有调用的静态方法。
运行时：参考引用型变量所属的类中的是否有调用的静态方法。
简单说，编译和运行都看左边。
其实对于静态方法，是不需要对象的。直接用类名调用即可。</li>
</ol>
<pre><code class="language-java">package com.wansho.hellojava;

class Fu {
    static int num = 3;
    void show(){
        System.out.println(&quot;fu show&quot;);
    }

    static void method(){
        System.out.println(&quot;fu static method&quot;);
    }
}

class Zi extends Fu {
    static int num = 4;
    void show()
    {
        System.out.println(&quot;zi show&quot;);
    }
    static void method()
    {
        System.out.println(&quot;zi static method&quot;);
    }
}

class DuoTaiDemo3 {
    public static void main(String[] args)
    {
        Fu.method(); // fu static method
        Zi.method(); // zi static method
        Fu f = new Zi();
        System.out.println(f.num); // 可以通过对象访问静态的成员变量 3
        f.method(); // 可以通过对象访问静态的成员变量  fu static method
        f.show(); // zi show
    }
}
</code></pre>
<h3 id="内部类"><a class="header" href="#内部类">内部类</a></h3>
<p>内部类感觉有点类似于闭包。</p>
<p><strong>内部类访问特点</strong></p>
<ol>
<li>内部类可以直接访问外部类中的成员。</li>
<li>外部类要访问内部类，必须建立内部类的对象。</li>
</ol>
<p><strong>使用场景</strong></p>
<p>一般用于类的设计。
分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容。
这时就是还有的事物定义成内部类来描述。
内部类能直接访问外部类中成员， 是因为内部类持有了外部类的引用，即外部类名.this。
内部类也可以存放在局部位置上，但是内部类在局部位置上只能访问局部中被final修饰的局部变量。</p>
<pre><code class="language-java">class Outer{
    private static int num = 31;
    class Inner{// 内部类。
        void show(){
            System.out.println(&quot;show run...&quot;+num);
        }
        /*static void function()//如果内部类中定义了静态成员，该内部类也必须是静态的。
        {
        System.out.println(&quot;function run ....&quot;+num);
        }
        */
    }
    public void method(){
        Inner in = new Inner();
        in.show();
    }
}

class InnerClassDemo
{
    public static void main(String[] args)
    {
        // Outer out = new Outer();
        // out.method();
        
        // 直接访问外部类中的内部类中的成员。
        // Outer.Inner in = new Outer().new Inner();
        // in.show();
        
        //如果内部类是静态的。 相当于一个外部类
        // Outer.Inner in = new Outer.Inner();
        // in.show();
        
        //如果内部类是静态的，成员是静态的。
        // Outer.Inner.function();
    }
}
</code></pre>
<h3 id="匿名内部类"><a class="header" href="#匿名内部类">匿名内部类</a></h3>
<p>匿名内部类， 首先是一个类中类，其次是内部类的简写格式。其实就是一个匿名子类对象。
必须有前提：内部类必须继承或者实现一个外部类或者接口。
格式： new 父类or接口(){子类内容}</p>
<pre><code class="language-java">abstract class Demo{
    abstract void show();
}

class Outer{
    int num = 4;
    /*
    class Inner extends Demo{
        void show(){
        	System.out.println(&quot;show ...&quot;+num);
        }
    }
    */
    public void method(){
        //new Inner().show();
        new Demo(){//匿名内部类。
            void show(){
                System.out.println(&quot;show ........&quot;+num);
            }
        }.show();
    }
}

class InnerClassDemo4{
    public static void main(String[] args){
        new Outer().method();
    }
}
</code></pre>
<p><strong>使用范例</strong></p>
<p>场景一：</p>
<p>当函数参数是接口类型时，而且接口中的方法不超过三个。可以用匿名内部类作为实际参数进行传递</p>
<pre><code class="language-java">interface Inter
{
    void show1();
    void show2();
}

class Outer
{
    /*
    class Inner implements Inter
    {
        public void show1()
        { }
        public void show2()
        { }
    }
    */
    public void method()
    {
        // Inner in = new Inner();
        // in.show1();
        // in.show2();
        Inter in = new Inter(){
            public void show1()
            { }
            public void show2()
            { }
        };
        in.show1();
        in.show2();
    }
}

class InnerClassDemo5
{
    class Inner
    { }
    public static void main(String[] args)
    {
        System.out.println(&quot;Hello World!&quot;);
        /*
        show(new Inter()
        {
        public void show1(){}
        public void show2(){}
        });
        */
        // new Inner();
    }
    public void method()
    {
        new Inner();
    }
    public static void show(Inter in)
    {
        in.show1();
        in.show2();
    }
}
</code></pre>
<p>范例二：</p>
<pre><code class="language-java">class Outer
{
    void method()
    {
        Object obj = new Object()
        {
            public void show()
            {
                System.out.println(&quot;show run&quot;);
            }
        };
        obj.show();//因为匿名内部类这个子类对象被向上转型为了Object类型。
        //这样就不能在使用子类特有的方法了。
    }
}

class InnerClassDemo6
{
    public static void main(String[] args)
    {
        new Outer().method();
    }
}
</code></pre>
<h2 id="异常"><a class="header" href="#异常">异常</a></h2>
<h3 id="定义-2"><a class="header" href="#定义-2">定义</a></h3>
<p>异常：是在<strong>运行时期</strong>发生的不正常情况。</p>
<p>注意是在运行期间，程序在运行时总会发生大大小小的问题，但是我们不能因为一个小问题就停止程序的运行，所以要引入叫做异常的容错机制，对异常进行容错。</p>
<p>在 java 中<strong>用类的形式对不正常情况进行了描述和封装对象</strong>。描述不正常的情况的类，就称为异常类。</p>
<p><strong>以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离。提高阅读性。其实异常就是java通过面向对象的思想将问题封装成了对象。用异常类对其进行描述。不同的问题用不同的类进行具体的描述。 比如角标越界、 空指针等等。</strong>
问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系。 </p>
<p><strong>异常的共性：Throwable</strong></p>
<p>无论是 error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。
//该体系的特点就在于Throwable及其所有的子类都具有可抛性。
可抛性到底指的是什么呢？怎么体现可抛性呢？其实是通过两个关键字来体现的。throws throw , 凡是可以被这两个关键字所操作的类和对象都具备可抛性.</p>
<p>异常子类的后缀名都是用其父类名作为后缀，阅读性很强。</p>
<p><strong>异常分为两类</strong></p>
<ul>
<li>
<p>Error</p>
<p>一般不可处理的。</p>
<p>是由jvm抛出的严重性的问题。这种问题发生一般不针对性处理。直接修改程序</p>
</li>
<li>
<p>Exception</p>
<p>可以处理的。</p>
</li>
</ul>
<pre><code class="language-java">class ExceptionDemo
{
    public static void main(String[] args)
    {
        int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap

    }
    /**
    正常的问题代码的处理
    */
    public static void sleep2(int time)
    {
        if(time&lt;0)
        {
            // 处理办法。
            // 处理办法。
            // 处理办法。

        }
        if(time&gt;100000)
        {
            // 处理办法。
            // 处理办法。
        }
        System.out.println(&quot;我睡。。。 &quot;+time);
    }
    
    /*
    引入异常机制后
    */
    public static void sleep(int time) 
    {
        if(time&lt;0)
        {
            // 抛出 new FuTime();//就代码着时间为负的情况，这个对象中会包含着问题的名称，信息，位置等信息。
        }
        if(time&gt;100000)
        {
            // 抛出 new BigTime();
        }
        System.out.println(&quot;我睡。。。 &quot;+time);
    }
}
/*
class FuTime
{ }
class BigTime
{ }
*/
</code></pre>
<h3 id="自定义异常"><a class="header" href="#自定义异常">自定义异常</a></h3>
<p><strong>一个需求</strong></p>
<p>对于角标是整数不存在，可以用角标越界表示，对于负数为角标的情况，准备用负数角标异常来表示。
负数角标这种异常在java中并没有定义过。那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述。并封装成对象。</p>
<p>如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。</p>
<p><strong>异常的分类</strong></p>
<ol>
<li>编译时被检测的异常</li>
<li>编译时不被检测的异常（运行时异常，必须要让程序停下来，修改之）</li>
</ol>
<p><strong>throws 和 throw</strong></p>
<ol>
<li>throws 使用在函数上，throw 使用在函数内</li>
<li>throws 抛出的是异常类，可以抛出多个，用逗号隔开。throw 抛出的是异常对象</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">class FuShuIndexException extends Exception
{
    FuShuIndexException()
    {}
    FuShuIndexException(String msg)
    {
        super(msg);
    }
}

class Demo
{
    public int method(int[] arr,int index) throws NullPointerException, FuShuIndexException
    {
        if(arr==null)
            throw new NullPointerException(&quot;数组的引用不能为空！ &quot;);
        if(index&gt;=arr.length)
        {
            throw new ArrayIndexOutOfBoundsException(&quot;数组的角标越界啦，哥们，你是不是疯了？： &quot;+index);
        }
        if(index&lt;0)
        {
            throw new FuShuIndexException(&quot;角标变成负数啦！！ &quot;);
        }
        return arr[index];
    }
}

class ExceptionDemo3
{
    public static void main(String[] args) //throws FuShuIndexException
    {
        int[] arr = new int[3];
        Demo d = new Demo();
        int num = d.method(null,-30);
        System.out.println(&quot;num=&quot;+num);
        System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<h3 id="异常的捕捉"><a class="header" href="#异常的捕捉">异常的捕捉</a></h3>
<p>Demo：</p>
<pre><code class="language-java">try
{
    //需要被检测异常的代码。
}
catch(异常类 变量)// 该变量用于接收发生的异常对象
{
    //处理异常的代码。
}
finally
{
    //一定会被执行的代码。
}
</code></pre>
<p><strong>异常处理的原则</strong></p>
<p>异常处理的原则：</p>
<ol>
<li>函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用trycatch捕捉，否则编译失败。</li>
<li>如果调用到了声明异常的函数，要么try catch 要么 throws，否则编译失败。</li>
<li>什么时候catch，什么时候throws 呢？功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决 。</li>
<li>一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">class FuShuIndexException extends Exception
{
    FuShuIndexException(String msg)
    {
        super(msg);
    }
}

class Demo
{
    public int method(int[] arr,int index) // throws NullPointerException,FuShuIndexException
    {
        if(arr==null)
            throw new NullPointerException(&quot;没有任何数组实体&quot;); // throw 后，下面的代码就不执行了
        if(index&lt;0)
            throw new FuShuIndexException();
        return arr[index];
    }
}

class ExceptionDemo4
{
    public static void main(String[] args)
    {
        int[] arr = new int[3];
        Demo d = new Demo();
        try
        {
            int num = d.method(null,-1);
            System.out.println(&quot;num=&quot;+num);
        }
        catch(NullPointerException e)
        {
            System.out.println(e.toString());
        }
        catch(FuShuIndexException e)
        {
            System.out.println(&quot;message:&quot;+e.getMessage());
            System.out.println(&quot;string:&quot;+e.toString());
            e.printStackTrace(); //jvm默认的异常处理机制就是调用异常对象的这个方法。
            System.out.println(&quot;负数角标异常!!!!&quot;);
        }
        /*
        catch(Exception e)//多catch父类的catch放在最下面。
        { }
        */
        System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<p><strong>try catch finally</strong></p>
<p>try catch finally 代码块组合特点：</p>
<ol>
<li>try catch finally</li>
<li>try catch(多个)当没有必要资源需要释放时，可以不用定义finally</li>
<li>try finally 异常无法直接 catch 处理，但是资源需要关闭</li>
</ol>
<p><strong>异常注意事项</strong></p>
<ol>
<li>子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类</li>
<li>如果父类抛出多个异常，那么子类只能抛出父类异常的子集</li>
</ol>
<p>简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。
注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try</p>
<h3 id="异常-demo"><a class="header" href="#异常-demo">异常 Demo</a></h3>
<p>场景</p>
<pre><code>毕老师用电脑上课。
问题领域中涉及两个对象。
毕老师，电脑。
分析其中的问题。
比如电脑蓝屏啦。冒烟啦。
</code></pre>
<pre><code class="language-java">class LanPingException extends Exception
{
    LanPingException(String msg)
    {
        super(msg);
    }
}

class MaoYanException extends Exception
{
    MaoYanException(String msg)
    {
        super(msg);
    }
}

class NoPlanException extends Exception 
{
    NoPlanException(String msg)
    {
        super(msg);
    }
}


class Computer
{
    private int state = 2;
    public void run() throws LanPingException,MaoYanException
    {
        if(state==1)
            throw new LanPingException(&quot;电脑蓝屏啦！！ &quot;);
        if(state==2)
            throw new MaoYanException(&quot;电脑冒烟啦！！ &quot;);
        System.out.println(&quot;电脑运行&quot;);
    }
    public void reset()
    {
        state = 0;
        System.out.println(&quot;电脑重启&quot;);
    }
}

class Teacher
{
    private String name;
    private Computer comp;
    Teacher(String name)
    {
        this.name = name;
        comp = new Computer();
    }
    public void prelect() throws NoPlanException // 没有 catch 的异常则抛出
    {
        try
        {
            comp.run();
            System.out.println(name+&quot;讲课&quot;);
        }
        catch (LanPingException e) // 异常处理
        {
            System.out.println(e.toString());
            comp.reset();
            prelect();
        }
        catch (MaoYanException e)
        {
            System.out.println(e.toString());
            test();
            //可以对电脑进行维修。
            // throw e;
            throw new NoPlanException(&quot;课时进度无法完成，原因： &quot;+e.getMessage()); // 能解决的异常自己解决，不能解决的，抛出异常，让调用者来解决
        }
    }
    public void test()
    {
        System.out.println(&quot;大家练习&quot;);
    }
}

class ExceptionTest
{
    public static void main(String[] args)
    {
        Teacher t = new Teacher(&quot;毕老师&quot;);
        try
        {
            t.prelect();
        }
        catch (NoPlanException e)
        {
            System.out.println(e.toString()+&quot;......&quot;);
            System.out.println(&quot;换人&quot;);
        }
    }
}

/*
com.wansho.hellojava.MaoYanException: 电脑冒烟啦！！ 
大家练习
com.wansho.hellojava.NoPlanException: 课时进度无法完成，原因： 电脑冒烟啦！！ ......
换人
*/
</code></pre>
<h2 id="包机制"><a class="header" href="#包机制">包机制</a></h2>
<p>导包的原则：用到哪个类，就导入哪个类。包在文件系统上的作用体现在文件夹上。</p>
<p>包名的规范：所有字母都小写。</p>
<p><strong>包的重点</strong></p>
<ol>
<li>对类文件进行分类管理</li>
<li>给类提供多层命名空间(namespace)，防止类太多命名冲突了</li>
<li>写在程序文件第一行</li>
<li><strong>类名的全称</strong>是：包名.类名</li>
<li>包也是一种封装方式</li>
</ol>
<h3 id="package-demo"><a class="header" href="#package-demo">package Demo</a></h3>
<pre><code>|---mypack
|---|---PackageDemo.java  
</code></pre>
<pre><code class="language-java">package mypack;

class PackageDemo{
    public static void main(String[] args){
        System.out.println(&quot;hello package&quot;);
    }
}
</code></pre>
<p>编译执行该 Java 文件：</p>
<pre><code class="language-shell">javac PackageDemo.java # 生成 PackageDemo.class 文件

java PackageDemo # 执行 class 文件
#！！！错误: 找不到或无法加载主类 PackageDemo

java mypack.PackageDemo
# hello package
</code></pre>
<p>从上面的例子来看，一旦加入 package 机制后，Java 文件就应该在包名所在的文件夹下，而且类名的全称变成了 <code>包名.类名</code>，单独引用类名会找不到这个人。</p>
<p>javac 可以直接帮我们创建文件夹：</p>
<pre><code class="language-shell">javac -d . PackageDemo.java
java mypack.PackageDemo
</code></pre>
<h3 id="classpath-的作用"><a class="header" href="#classpath-的作用">classpath 的作用</a></h3>
<p>编译 java 源文件生成的 class 文件，都放在 classpath 中，以起到<strong>源文件与 class 文件隔离的作用</strong>。</p>
<p>一篇文章让你弄懂到底什么是classpath - yuan的文章 - 知乎 https://zhuanlan.zhihu.com/p/113234567</p>
<p>classpath其实就是一个路径而已，我们经常在spring的配置文件中这样写：</p>
<pre><code class="language-java">&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;
</code></pre>
<p>这样配置完之后spring就知道mybatis配置文件所在的地方。</p>
<p>那么？这个classpath指向的地方到底是哪里呢？</p>
<p><img src="computer-science-notebook/note-for-java/assets/v2-912d9181496a25f578a970615189c378_r.jpg" alt="img" /></p>
<p><strong>classpath指向的就是打war包之后的classes的位置</strong>。而classes文件夹下就是我们原项目的java文件和resources文件夹里面的内容。</p>
<p>所以上面的代码的意思就是在编译后的classes文件中找mybatis/SqlMapConfig.xml文件。</p>
<hr />
<p>在编译打包后的项目中，根目录是<code>META-INF</code>和<code>WEB-INF</code> 。这个时候，我们可以看到classes这个文件夹，它就是我们要找的classpath。</p>
<p><code>classpath:mybatis/SqlMapConfig.xml</code> 中，classpath 就是指 <code>WEB-INF/classes/</code> 这个目录的路径。需要声明的一点是，使用<code>classpath:</code>这种前缀，<strong>就只能代表一个文件</strong>。</p>
<p>而另一种写法，<code>classpath*:**/mapper/mapping/*Mapper.xml</code>，使用<code>classpath*:</code>这种前缀，<strong>则可以代表多个匹配的文件</strong>；<code>**/mapper/mapping/*Mapper.xml</code>，双星号<code>**</code>表示在任意目录下，也就是说在<code>WEB-INF/classes/</code>下任意层的目录，只要符合后面的文件路径，都会被作为资源文件找到。</p>
<h3 id="包的封装作用和四种权限"><a class="header" href="#包的封装作用和四种权限">包的封装作用和四种权限</a></h3>
<p>包是对类的进一步封装。既然封装了，那么就涉及到外部的访问问题。在包中，只有 <code>public class</code> 才是外部可以访问的 class，不是 public 的 class 都被包封装了。</p>
<p>注意：对外暴露的 public 的 class，其类名要与文件名保持一致。在 public class 中对外暴露的函数也应该是 public 的（默认权限也是封装！）</p>
<p>包与包之间的访问，通过 <code>public</code> 和 <code>protected</code> 关键字来约束。</p>
<p>不同包不允许访问，但如果你是我们的儿子，那么就可以网开一面：<code>protected</code>，**不叫爹不行！**提供给不同包中的子类。</p>
<p>protected 关键字将对象保护在同包中，不同包无法调用 protected 的对象。</p>
<p><strong>java 四种权限</strong></p>
<table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody>
<tr><td>同一类中</td><td>ok</td><td>ok</td><td>ok</td><td>ok</td></tr>
<tr><td>同一包中</td><td>ok</td><td>ok</td><td>ok</td><td>封装</td></tr>
<tr><td>子类中</td><td>ok</td><td>ok</td><td>封装(访问不到)</td><td>封装</td></tr>
<tr><td>不同包中</td><td>ok</td><td>封装</td><td>封装</td><td>封装</td></tr>
</tbody></table>
<p>总结：包与包之间的类进行访问，被访问的包中的类必须是 public 的，被访问的包中的类的方法也必须是 public 的。 </p>
<p>protected：比 default 稍微宽松一点，包外的子类可以访问</p>
<p>default：同包能访问，包外的子类就不能访问了</p>
<p>private：吃独食，子类都访问不了</p>
<img align="left" src="computer-science-notebook/note-for-java/assets/image-20210503084531612.png" alt="image-20210503084531612" style="zoom:80%;" />
<h3 id="import-的作用和规范"><a class="header" href="#import-的作用和规范">import 的作用和规范</a></h3>
<p>import 的作用：简化类名书写！</p>
<pre><code class="language-java">// 没导入之前：
packa.PackageADemo demoA = new packa.PackageADemo();

// 导入后
import packa.PackageADemo; // 导入 packa 下的 PackageADemo 类
PackageADemo demoA = new PackageADemo();

// 导入 packa 中所有的类
import packa.*;
import packa.abc.*; // 两个性质完全不一样
</code></pre>
<p>注意：</p>
<ol>
<li><code>import *</code> 只导入文件夹下的所有类，并不会导入包中包（没有 recursive 的功能）</li>
<li>导包原则：用哪个类，导入哪个类</li>
</ol>
<h3 id="jar-包"><a class="header" href="#jar-包">jar 包</a></h3>
<p><strong>是什么</strong></p>
<p><code>jar</code> 是 Java 的一个命令，用于 Java 程序打包。<code>jar, rar</code>，jar 包就是 Java 的压缩包。</p>
<pre><code class="language-shell">javac -d . JarDemo.java
java pack.JarDemo
jar -cvf haha.jar pack # 压缩

jar -xvf haha.jar # 解压缩

# 以前：./pack
# 压缩后：./haha.jar/pack
</code></pre>
<p>注意：jar 包中打包的是 class 文件，没有必要对源码进行打包。</p>
<p><strong>如何使用 jar 包</strong></p>
<pre><code class="language-shell">set classpath=./haha.jar
java pack.JarDemo
</code></pre>
<h2 id="多线程-1"><a class="header" href="#多线程-1">多线程</a></h2>
<h3 id="垃圾回收线程"><a class="header" href="#垃圾回收线程">垃圾回收线程</a></h3>
<p>JVM 启动的时候，就启动了多个线程，至少有两个线程是我们可以分析出来的：</p>
<ol>
<li>main</li>
<li>负责垃圾回收的线程</li>
</ol>
<pre><code class="language-java">class Demo4 extends Object
{
    @Override
    public void finalize() // 在垃圾回收前调用
    {
        System.out.println(&quot;demo ok&quot;);
    }
}
class ThreadDemo
{
    public static void main(String[] args)
    {
        new Demo4();
        new Demo4();
        new Demo4();
        System.gc(); // 进行垃圾回收
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<p>垃圾回收线程，其执行结果每次都不太一样。</p>
<pre><code>demo ok
demo ok
Hello World!
demo ok

-----------

demo ok
demo ok
demo ok
Hello World!

-----------

demo ok
Hello World!
demo ok
demo ok
</code></pre>
<h3 id="创建线程-继承-thread"><a class="header" href="#创建线程-继承-thread">创建线程-继承 Thread</a></h3>
<p>创建线程方式一：继承Thread类。
步骤：</p>
<ol>
<li>定义一个类继承 Thread 类</li>
<li>覆盖Thread类中的 run 方法</li>
<li>直接创建Thread的子类对象创建线程</li>
<li>调用start方法开启线程并调用线程的任务run方法执行</li>
</ol>
<p>可以通过 Thread 的 getName 获取线程的名称 Thread-编号(从0开始)</p>
<p>Demo：</p>
<pre><code class="language-java">class Demo extends Thread
{
    private String name;
    Demo(String name)
    {
        super(name);
        this.name = name;
    }
    public void run()
    {
        for(int x=0; x&lt;10; x++)
        {
            System.out.println(name+&quot;....x=&quot;+x+&quot;.....name=&quot;+Thread.currentThread().getName());
        }
    }
}

class ThreadDemo2
{
    public static void main(String[] args)
    {
        /*
        创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。
        而运行的指定代码就是这个执行路径的任务。
        jvm创建的主线程的任务都定义在了主函数中。
        而自定义的线程它的任务在哪儿呢？
        Thread类用于描述线程，线程是需要任务的。所以Thread类也对任务的描述。
        这个任务就通过Thread类中的run方法来体现。也就是说， run方法就是封装自定义线程运行任务的函数。
        run方法中定义就是线程要运行的任务代码。
        开启线程是为了运行指定代码，所以只有继承Thread类，并复写run方法。
        将运行的代码定义在run方法中即可。
        */
        Demo d1 = new Demo(&quot;旺财&quot;);
        Demo d2 = new Demo(&quot;xiaoqiang&quot;);
        d1.start();//开启线程，调用run方法。
        d2.start();
        System.out.println(&quot;over....&quot;+Thread.currentThread().getName());
    }
}

/**
over....main
小强....x=0.....name=小强
旺财....x=0.....name=旺财
小强....x=1.....name=小强
小强....x=2.....name=小强
旺财....x=1.....name=旺财
小强....x=3.....name=小强
小强....x=4.....name=小强
旺财....x=2.....name=旺财
小强....x=5.....name=小强
旺财....x=3.....name=旺财
小强....x=6.....name=小强
小强....x=7.....name=小强
小强....x=8.....name=小强
小强....x=9.....name=小强
旺财....x=4.....name=旺财
旺财....x=5.....name=旺财
旺财....x=6.....name=旺财
旺财....x=7.....name=旺财
旺财....x=8.....name=旺财
旺财....x=9.....name=旺财
*/
</code></pre>
<p>多线程的随机性，谁抢到 CPU，谁执行。</p>
<h3 id="创建线程-实现-runnable"><a class="header" href="#创建线程-实现-runnable">创建线程-实现 Runnable</a></h3>
<p>步骤：</p>
<ol>
<li>
<p>定义类实现Runnable接口</p>
</li>
<li>
<p>覆盖接口中的run方法，将线程的任务代码封装到run方法中</p>
</li>
<li>
<p>通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。</p>
<p>为什么？因为线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务。</p>
</li>
<li>
<p>调用线程对象的start方法开启线程</p>
</li>
</ol>
<p>实现Runnable接口的好处：</p>
<ol>
<li>
<p>将线程的任务从线程的子类中分离出来，进行了单独的封装
按照面向对象的思想将任务的封装成对象</p>
</li>
<li>
<p>避免了java单继承的局限性
所以，创建线程的第二种方式较为常用</p>
</li>
</ol>
<pre><code class="language-java">class Demo implements Runnable{//extends Fu //准备扩展Demo类的功能，让其中的内容可以作为线程的任务执行。
    //通过接口的形式完成。
    public void run()
    {
        show();
    }
    public void show()
    {
        for(int x=0; x&lt;20; x++)
        {
            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+x);
        }
    }
}

class ThreadDemo
{
    public static void main(String[] args)
    {
        Demo d = new Demo();
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        t1.start();
        t2.start();
    }
}
</code></pre>
<h3 id="同步和互斥"><a class="header" href="#同步和互斥">同步和互斥</a></h3>
<p><strong>synchronized</strong></p>
<p><a href="https://www.cnblogs.com/weibanggang/p/9470718.html">[synchronized 讲解]</a></p>
<p>synchronized，翻译过来，就是同步的意思，其是 Java 的关键字，是一种同步锁，其修饰的对象有以下几种：</p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<p>详细介绍：</p>
<ol>
<li>
<p>修饰代码块</p>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。</p>
</li>
<li>
<p>修饰一个方法</p>
<p>注意：synchronized 关键字不能被继承，如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以</p>
</li>
<li>
<p>修饰静态方法</p>
<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
</li>
</ol>
<p><strong>卖票问题</strong></p>
<p>线程安全问题产生的原因：</p>
<ol>
<li>多个线程在操作共享的数据</li>
<li>操作共享数据的线程代码有多条
当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。</li>
</ol>
<p>解决思路:</p>
<p>就是将临界区封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在 java 中，用同步代码块就可以解决这个问题。同步代码块的格式：</p>
<pre><code class="language-java">synchronized(对象)
{
	需要被同步的代码 ；
}
</code></pre>
<p>同步的好处：解决了线程的安全问题。
同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。
同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<pre><code class="language-java">class Ticket implements Runnable//extends Thread
{
    private int num = 100;
    Object obj = new Object();
    public void run()
    {
        while(true)
        {
            synchronized(obj)
            {
                if(num&gt;0)
                {
                    try{Thread.sleep(10);}catch (InterruptedException e){}
                    System.out.println(Thread.currentThread().getName()+&quot;.....sale....&quot;+num--);
                }
            }
        }
    }
}

class TicketDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();//创建一个线程任务对象。
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        Thread t3 = new Thread(t);
        Thread t4 = new Thread(t);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
</code></pre>
<p><strong>银行存钱案例</strong></p>
<p>需求:储户，两个，每个都到银行存钱每次存100，共存三次。</p>
<pre><code class="language-java">class Bank
{
    private int sum;
    public synchronized void add(int num) // 同步函数，临界区一次只允许一个进程访问
    {
        sum = sum + num;
        try{Thread.sleep(10);}catch(InterruptedException e){} // 当前进程睡 10 ms
        System.out.println(&quot;sum=&quot;+sum);
    }
}

class Cus implements Runnable // 线程的另一种实现方式
{
    private Bank b = new Bank();
    public void run()
    {
        for(int x=0; x&lt;3; x++)
        {
            b.add(100);
        }
    }
}

class BankDemo
{
    public static void main(String[] args)
    {
        Cus c = new Cus(); // 注意 Cus 对象只创建了一次，也就是说银行这个对象只创建了一次！
        Thread t1 = new Thread(c);
        Thread t2 = new Thread(c);
        t1.start();
        t2.start();
    }
}

/*
sum=100
sum=200
sum=300
sum=400
sum=500
sum=600
*/
</code></pre>
<p><strong>多线程下的单例安全问题</strong></p>
<pre><code class="language-java">/*
多线程下的单例
*/
// 饿汉式不存在多线程安全问题
class Single
{
    private static final Single s = new Single();
    private Single(){}
    public static Single getInstance()
    {
        return s;
    }
}

// 懒汉式
// 加入同步为了解决多线程安全问题。
// 加入双重判断是为了解决效率问题。
class Single
{
    private static Single s = null;
    private Single(){}
    public static Single getInstance()
    {
        if(s==null)
        {
            synchronized(Single.class) // 同步代码块
            {
                if(s==null)
                    // --&gt;0 --&gt;1
                    s = new Single();
            }
        }
     return s;
    }
}

class SingleDemo
{
    public static void main(String[] args)
    {
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<p>注意：synchronized 关键字不能被继承，如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。</p>
<p><strong>死锁 - 同步嵌套(没看懂)</strong></p>
<pre><code class="language-java">class Ticket implements Runnable
{
    private int num = 100;
    Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        if(flag)
            while(true)
            {
                synchronized(obj)
                {
                    show();
                }
            }
     else
         while(true)
             this.show();
    }
    public synchronized void show()
    {
        synchronized(obj)
        {
            if(num&gt;0)
            {
                try{Thread.sleep(10);}catch (InterruptedException e){}
                System.out.println(Thread.currentThread().getName()+&quot;.....sale....&quot;+num--);
            }
        }
    }
}
class DeadLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // System.out.println(&quot;t:&quot;+t);
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>静态同步函数的锁</strong></p>
<p>静态的同步函数使用的锁是该函数所属字节码文件对象，可以用 getClass 方法获取，也可以用当前类名.class 表示。</p>
<pre><code class="language-java">class Ticket implements Runnable
{
    private static int num = 100;
    // Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        // System.out.println(&quot;this:&quot;+this.getClass());
        if(flag)
            while(true)
            {
                synchronized(Ticket.class)//(this.getClass()) 此处因为对静态变量进行访问，所以取得得锁是类
                {
                    if(num&gt;0)
                    {
                        try{Thread.sleep(10);}catch (InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+&quot;.....obj....&quot;+num--); // 此处非静态方法可以访问静态变量
                    }
                }
            }
        else
            while(true)
                this.show();
    }
    public static synchronized void show()
    {
        if(num&gt;0)
        {
            try{Thread.sleep(10);}catch (InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+&quot;.....function....&quot;+num--);
        }
    }
}
class StaticSynFunctionLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // Class clazz = t.getClass();
        //
        // Class clazz = Ticket.class;
        // System.out.println(&quot;t:&quot;+t.getClass());
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>同步函数 vs 同步代码块</strong></p>
<p>同步函数和同步代码块的区别：</p>
<ol>
<li>同步函数的锁是固定的this</li>
<li>同步代码块的锁是任意的对象</li>
<li>建议使用同步代码块</li>
</ol>
<pre><code class="language-java">class Ticket implements Runnable
{
    private int num = 100;
    // Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        // System.out.println(&quot;this:&quot;+this);
        if(flag)
            while(true)
            {
                synchronized(this) // 此处因为对类变量进行访问，所以取得的锁是对象
                {
                    if(num&gt;0)
                    {
                        try{Thread.sleep(10);}catch (InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+&quot;.....obj....&quot;+num--);
                    }
                }
            }
        else
            while(true)
                this.show();
    }
    public synchronized void show()
    {
        if(num&gt;0)
        {
            try{Thread.sleep(10);}catch (InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+&quot;.....function....&quot;+num--);
        }
    }
}

class SynFunctionLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // System.out.println(&quot;t:&quot;+t);
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>总结</strong></p>
<ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态变量或方法，则它取得的锁是对类，该类所有的对象同一把锁</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码 </li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li>
</ol>
<h3 id="join"><a class="header" href="#join">join()</a></h3>
<p>Java 官方解释：Waits for this thread to die.</p>
<p>当调用了 Thread.Join()方法后,当前线程会立即被执行,其他所有的线程会被暂停执行。当这个线程执行完后,其他线程才会继续执行。</p>
<pre><code class="language-java">class Demo implements Runnable
{
    public void run()
    {
        for(int x=0; x&lt;50; x++)
        {
            System.out.println(Thread.currentThread().toString()+&quot;.....&quot;+x);
            Thread.yield(); // 线程进入就绪状态，让出 CPU 使用权
        }
    }
}

class JoinDemo
{
    public static void main(String[] args) throws Exception
    {
        Demo d = new Demo();
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        t1.start();
        t2.start();
        t2.setPriority(Thread.MAX_PRIORITY); // 设置线程运行级别
        t1.join(); // t1 先执行完再说
        for(int x=0; x&lt;50; x++)
        {
            System.out.println(Thread.currentThread()+&quot;.....&quot;+x);
        }
    }
}
</code></pre>
<h3 id="线程间通信"><a class="header" href="#线程间通信">线程间通信</a></h3>
<p>线程间通讯：多个线程在处理同一资源，但是任务却不同。</p>
<p>生产者和消费者，就是一种典型的线程间通信。</p>
<pre><code class="language-java">//资源
class Resource
{
    String name;
    String sex;
}

//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true)
        {
            synchronized(r)
            {
                if(x==0)
                {
                    r.name = &quot;mike&quot;;
                    r.sex = &quot;nan&quot;;
                }
                else
                {
                    r.name = &quot;丽丽&quot;;
                    r.sex = &quot;女女女女女女&quot;;
                }
            }
            x = (x+1)%2;
        }
    }
}
//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            synchronized(r)
            {
                System.out.println(r.name+&quot;.....&quot;+r.sex);
            }
        }
    }
}
class ResourceDemo
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource();
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p>上面的代码只是一个演示代码，没有进行线程间的同步，只是一种理想化的生产消费。下面加入 wait 和 notify 进行进程之间的协作。</p>
<h3 id="wait--notify"><a class="header" href="#wait--notify">wait / notify</a></h3>
<p>等待/唤醒机制。
涉及的方法：</p>
<ol>
<li>wait(): 让线程处于冻结（阻塞）状态，被wait的线程会被存储到线程池中</li>
<li>notify(): Wakes up a single thread that is waiting on this object's monitor.</li>
<li>notifyAll(): Wakes up all threads that are waiting on this object's monitor.</li>
</ol>
<p>这些方法都必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p>
<p>以上三个方法，都是定义在 Object 基类中的类方法。因为这些方法是监视器的方法。监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。</p>
<p><strong>一个生产者和一个消费者</strong></p>
<pre><code class="language-java">//资源
class Resource
{
    String name;
    String sex;
    boolean flag = false;
}

//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true) // 这个线程一直跑
        {
            synchronized(r) // r 当成一把 lock
            {
                if(r.flag) // 有资源了，就阻塞
                    try{r.wait();}catch(InterruptedException e){}
                if(x==0) // 生产者交替生产两个产品：mike 和 丽丽
                {
                    r.name = &quot;mike&quot;;
                    r.sex = &quot;man&quot;;
                }
                else
                {
                    r.name = &quot;丽丽&quot;;
                    r.sex = &quot;女女女女女女&quot;;
                }
                r.flag = true; // 标记有资源，然后唤醒消费者来消费
                r.notify();
            }
            x = (x+1)%2; 
        }
    }
}
//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            synchronized(r)
            {
                if(!r.flag) // 没资源，就阻塞，等有资源再消费
                    try{r.wait();}catch(InterruptedException e){}
                System.out.println(&quot;消费：&quot; + r.name+&quot;.....&quot;+r.sex); // 有资源，消费 r
                r.flag = false; // 消费完后，置空，然后唤醒沉睡的生产者进程
                r.notify();
            }
        }
    }
}

class ResourceDemo2
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource(); 
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p><strong>另一种实现</strong></p>
<pre><code class="language-java">class Resource
{
    private String name;
    private String sex;
    private boolean flag = false;
    public synchronized void set(String name,String sex)
    {
        if(flag)
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.sex = sex;
        flag = true;
        this.notify();
    }
    public synchronized void out()
    {
        if(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(name+&quot;...+....&quot;+sex);
        flag = false;
        notify();
    }
}
//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true)
        {
            if(x==0)
            {
                r.set(&quot;mike&quot;,&quot;nan&quot;);
            }
            else
            {
                r.set(&quot;丽丽&quot;,&quot;女女女女女女&quot;);
            }
            x = (x+1)%2;
        }
    }
}

//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.out();
        }
    }
}

class ResourceDemo3
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource();
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p>实际上，第一个例子才是最恰当的，生产和消费的行为被封装在了生产者和消费者上，而第二个例子，生产和消费的行为被绑定到了商品上，不符合常识。</p>
<p><strong>wait 和 sleep 的区别</strong></p>
<p>区别：</p>
<ol>
<li>wait可以指定时间也可以不指定。sleep必须指定时间</li>
<li>在同步中时，对cpu的执行权和锁的处理不同
wait：释放执行权，释放锁。
sleep:释放执行权，不释放锁。 （也就是不释放临界区，其他线程干等着，不符合让权等待）</li>
<li></li>
</ol>
<h3 id="多生产者与消费者"><a class="header" href="#多生产者与消费者">多生产者与消费者</a></h3>
<p>多生产者，多消费者的问题。
if 判断标记，只有一次，会导致不该运行的线程运行了。出现了数据错误的情况。
while 判断标记，解决了线程获取执行权后，是否要运行！
<code>notify</code>: 只能唤醒一个线程，如果本方唤醒了本方，没有意义。而且while判断标记+notify会导致死锁。
<code>notifyAll</code>: 解决了本方线程一定会唤醒对方线程的问题。</p>
<pre><code class="language-java">class Resource
{
    private String name;
    private int count = 1;
    private boolean flag = false;
    public synchronized void set(String name) // 生产
    {
        while(flag)
            try{this.wait();}catch(InterruptedException e){} // 有鸭子，就进入阻塞状态
        this.name = name + count;// 没鸭，生产 烤鸭1 烤鸭2 烤鸭3
        count++; //2 3 4
        System.out.println(Thread.currentThread().getName()+&quot;... 生产者...&quot;+this.name); // 生产烤鸭1 生产烤鸭2 生产烤鸭3
        flag = true; // 表示有鸭子
        notifyAll(); // 唤醒所有阻塞线程，生产者被唤醒则 wait，消费者被唤醒，则消费
    }
    public synchronized void out()// 消费
    {
        while(!flag)
            try{this.wait();}catch(InterruptedException e){} // 没鸭子，进入阻塞状态
        System.out.println(Thread.currentThread().getName()+&quot;... 消费者........&quot;+this.name);//消费烤鸭1
        flag = false;
        notifyAll(); // 唤醒了对方的所有线程
    }
}

class Producer implements Runnable
{
    private Resource r;
    Producer(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.set(&quot;烤鸭&quot;);
        }
    }
}

class Consumer implements Runnable
{
    private Resource r;
    Consumer(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.out();
        }
    }
}

class ProducerConsumerDemo
{
    public static void main(String[] args)
    {
        Resource r = new Resource();
        Producer pro = new Producer(r);
        Consumer con = new Consumer(r);
        Thread t0 = new Thread(pro);
        Thread t1 = new Thread(pro);
        Thread t2 = new Thread(con);
        Thread t3 = new Thread(con);
        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<p>上面这个例子，仍然还是一个简单的生产一个，消费一个的例子，只是加入了多个生产者和消费者。</p>
<h3 id="停止线程"><a class="header" href="#停止线程">停止线程</a></h3>
<p>停止线程：</p>
<ol>
<li><code>interrupt</code> 方法</li>
<li>run 方法结束</li>
</ol>
<p>怎么控制线程的任务结束呢?</p>
<p>任务中都会有循环结构，只要控制住循环就可以结束任务。控制循环通常就用定义标记来完成。
但是如果线程处于了阻塞状态，无法读取标记。如何结束呢？可以使用 <code>interrupt()</code> 方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格。强制动作会发生 InterruptedException，要处理。</p>
<pre><code class="language-java">class StopThread implements Runnable
{
    private boolean flag = true;
    public synchronized void run()
    {
        while(flag)
        {
            try
            {
                wait(); //t0 t1
            }
            catch (InterruptedException e)
            {
                System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+e);
                flag = false;
            }
            System.out.println(Thread.currentThread().getName()+ &quot;......++++&quot;); // 被唤醒后，这句话还会执行
        }
    }
    public void setFlag()
    {
        flag = false;
    }
}

class StopThreadDemo
{
    public static void main(String[] args)
    {
       	 StopThread st = new StopThread();
         Thread t1 = new Thread(st);
         Thread t2 = new Thread(st);
         t1.start();
         t2.setDaemon(true); // t2 设置为守护进程，主线程 main 和 用户线程 t1 执行完后，自动结束
         t2.start();
         int num = 1;
         for(;;)
         {
             if(++num==50)
             {
                 // st.setFlag();
                 t1.interrupt();
                 // t2.interrupt();
                 break;
             }
             System.out.println(&quot;main....&quot;+num);
         }
         System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<p><strong>守护线程和用户线程</strong></p>
<p><code>setDaemon(true)</code></p>
<p>Marks this thread as either a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#isDaemon--">daemon</a> thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</p>
<p>守护线程类似于守护进程，优先级低于用户线程和用户进程。</p>
<h3 id="多线程总结"><a class="header" href="#多线程总结">多线程总结</a></h3>
<pre><code>多线程总结：
1，进程和线程的概念。
|--进程：
|--线程：
2， jvm中的多线程体现。
|--主线程，垃圾回收线程，自定义线程。以及他们运行的代码的位置。
3，什么时候使用多线程，多线程的好处是什么？创建线程的目的？
|--当需要多部分代码同时执行的时候，可以使用。
4，创建线程的两种方式。★★★★★
|--继承 Thread
|--步骤
|--实现 Runnable
|--步骤
|--两种方式的区别？
5，线程的5种状态。
对于执行资格和执行权在状态中的具体特点。
|--被创建：
|--运行：
|--冻结：
|--临时阻塞：
|--消亡：
6，线程的安全问题。★★★★★
|--安全问题的原因：
|--解决的思想：
|--解决的体现： synchronized
|--同步的前提：但是加上同步还出现安全问题，就需要用前提来思考。
|--同步的两种表现方法和区别：
|--同步的好处和弊端：
|--单例的懒汉式。
|--死锁。
7，线程间的通信。等待/唤醒机制。
|--概念：多个线程，不同任务，处理同一资源。
|--等待唤醒机制。使用了锁上的 wait notify notifyAll. ★★★★★
|--生产者/消费者的问题。并多生产和多消费的问题。 while判断标记。用notifyAll唤醒对方。 ★
★★★★
|--JDK1.5以后出现了更好的方案，★★★
Lock接口替代了synchronized
Condition接口替代了Object中的监视方法，并将监视器方法封装成了Condition
和以前不同的是，以前一个锁上只能有一组监视器方法。现在，一个Lock锁上可以多组监视器方法对
象。
可以实现一组负责生产者，一组负责消费者。
|--wait和sleep的区别。★★★★★
8，停止线程的方式。
|--原理：
|--表现： --中断。
9，线程常见的一些方法。
|--setDaemon()
|--join();
|--优先级
|--yield();
|--在开发时，可以使用匿名内部类来完成局部的路径开辟。
</code></pre>
<h2 id="常用类-api"><a class="header" href="#常用类-api">常用类 API</a></h2>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p><strong>构造函数</strong></p>
<pre><code class="language-java">public class StringConstructorDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 将字节数组或者字符数组转成字符串可以通过String类的构造函数完成。
         */
        stringConstructorDemo2();
        stringConstructorDemo();
    }
    private static void stringConstructorDemo2() {
        char[] arr = {'w','a','p','q','x'};
        String s = new String(arr,1,3); // apq
        System.out.println(&quot;s=&quot;+s);
    }
    public static void stringConstructorDemo() {
        String s = new String(); // 等价于 String s = &quot;&quot;; 不等效String s = null;
        byte[] arr = {97,66,67,68}; // aBCD
        String s1 = new String(arr);
        System.out.println(&quot;s1=&quot;+s1);
    }
}
</code></pre>
<p><strong>字符串对象一旦被初始化就不会被改变</strong></p>
<p>字符串在内存中会存储到两个地方：</p>
<ol>
<li>
<p>常量池</p>
<pre><code class="language-java">String s = &quot;abc&quot;; // &quot;abc&quot;存储在字符串常量池中。
String s1 = &quot;abc&quot;;
System.out.println(s==s1); // true
</code></pre>
</li>
<li>
<p>堆内存</p>
<pre><code class="language-java">String s = &quot;abc&quot;; // 创建一个字符串对象在常量池中。
String s1 = new String(&quot;abc&quot;); // 创建两个对象一个new一个字符串对象在堆内存中。
System.out.println(s==s1); // false
System.out.println(s.equals(s1));
</code></pre>
</li>
</ol>
<p><strong>String 类方法及使用</strong></p>
<pre><code class="language-java">public class StringMethodDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 按照面向对象的思想对字符串进行功能分类。
         * &quot;abcd&quot;
         *
         * 1,获取：
         * 1.1 获取字符串中字符的个数(长度).
         * int length();
         * 1.2 根据位置获取字符。
         * char charAt(int index);
         * 1.3 根据字符获取在字符串中的第一次出现的位置.
         * int indexOf(int ch)
         * int indexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置
         * int indexOf(String str);
         * int indexOf(String str,int fromIndex);
         * 根据字符串获取在字符串中的第一次出现的位置.
         * int lastIndexOf(int ch)
         * int lastIndexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置
         * int lastIndexOf(String str);
         * int lastIndexOf(String str,int fromIndex);
         * 1.4 获取字符串中一部分字符串。也叫子串.
         * String substring(int beginIndex, int endIndex)//包含begin 不包含end 。
         * String substring(int beginIndex);
         *
         *
         * 2，转换。
         * 2.1 将字符串变成字符串数组(字符串的切割)
         * String[] split(String regex):涉及到正则表达式.
         * 2.2 将字符串变成字符数组。
         * char[] toCharArray();
         * 2.3 将字符串变成字节数组。
         * byte[] getBytes();
         * 2.4 将字符串中的字母转成大小写。
         * String toUpperCase():大写
         * String toLowerCase():小写
         * 2.5 将字符串中的内容进行替换
         * String replace(char oldch,char newch);
         * String replace(String s1,String s2);
         * 2.6 将字符串两端的空格去除。
         * String trim();
         * 2.7 将字符串进行连接 。
         * String concat(string);
         *
         * 3，判断
         * 3.1 两个字符串内容是否相同啊？
         * boolean equals(Object obj);
         * boolean equalsIgnoreCase(string str);忽略大写比较字符串内容。
         * 3.2 字符串中是否包含指定字符串？
         * boolean contains(string str);
         * 3.3 字符串是否以指定字符串开头。是否以指定字符串结尾。
         * boolean startsWith(string);
         * boolean endsWith(string);
         *
         * 4，比较。
         *
         */
        stringMethodDemo_4();
        // System.out.println(&quot;abc&quot;.concat(&quot;kk&quot;));
        // System.out.println(&quot;abc&quot;+&quot;kk&quot;);
        // System.out.println(String.valueOf(4)+1);
        // System.out.println(&quot;&quot;+4+1);
    }
    private static void stringMethodDemo_4() {
        System.out.println(&quot;abc&quot;.compareTo(&quot;aqz&quot;)); // -15
        /*
        * int num = 'b' - 'q';
        * System.out.println(String.valueOf(num));
        * */
    }
    private static void stringMethodDemo_3() {
        String s = &quot;abc&quot;;
        System.out.println(s.equals(&quot;ABC&quot;.toLowerCase()));
        System.out.println(s.equalsIgnoreCase(&quot;ABC&quot;));
        System.out.println(s.contains(&quot;cc&quot;));
        String str = &quot;ArrayDemo.java&quot;;
        System.out.println(str.startsWith(&quot;Array&quot;));
        System.out.println(str.endsWith(&quot;.java&quot;));
        System.out.println(str.contains(&quot;Demo&quot;));
    }
    private static void stringMethodDemo_2() {
        String s = &quot;张三,李四,王五&quot;;
        String[] arr = s.split(&quot;,&quot;);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
        char[] chs = s.toCharArray();
        for (int i = 0; i &lt; chs.length; i++) {
            System.out.println(chs[i]);
        }
        s = &quot;ab你&quot;;
        byte[] bytes = s.getBytes();
        for (int i = 0; i &lt; bytes.length; i++) {
            System.out.println(bytes[i]);
        }
        System.out.println(&quot;Abc&quot;.toUpperCase());
        String s1 = &quot;java&quot;;
        String s2 = s1.replace('q', 'z');
        System.out.println(s1==s2);//true
        System.out.println(&quot;-&quot;+&quot; ab c &quot;.trim()+&quot;-&quot;);
    }
    private static void stringMethodDemo_1() {
        String s = &quot;abcdae&quot;;
        System.out.println(&quot;length:&quot;+s.length());//6
        System.out.println(&quot;char:&quot;+s.charAt(2));//c//StringIndexOutOfBoundsException
        System.out.println(&quot;index:&quot;+s.indexOf('k'));//0//-1 我们可以根据-1，来判断该字符或者字符串是否存在。
        System.out.println(&quot;lastIndex:&quot;+s.lastIndexOf('a'));//4
        System.out.println(&quot;substring:&quot;+s.substring(2,4));
    }
}

</code></pre>
<p><strong>字符串比较</strong></p>
<pre><code class="language-java">/*
* 1，给定一个字符串数组。按照字典顺序进行从小到大的排序。
* {&quot;nba&quot;,&quot;abc&quot;,&quot;cba&quot;,&quot;zz&quot;,&quot;qq&quot;,&quot;haha&quot;}
*
* 思路：
* 1,对数组排序。可以用选择，冒泡都行。
* 2,for嵌套和比较以及换位。
* 3,问题：以前排的是整数，比较用的比较运算符，可是现在是字符串对象。
* 字符串对象怎么比较呢？爽了，对象中提供了用于字符串对象比较的功能。
*/
public class StringTest_1 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        String[] arr = { &quot;nba&quot;, &quot;abc&quot;, &quot;cba&quot;, &quot;zz&quot;, &quot;qq&quot;, &quot;haha&quot; };
        printArray(arr);
        sortString(arr);
        printArray(arr);
    }
    public static void sortString(String[] arr) {
        for (int i = 0; i &lt; arr.length - 1; i++) {
            for (int j = i + 1; j &lt; arr.length; j++) {
                if(arr[i].compareTo(arr[j])&gt;0) // 字符串比较用compareTo方法
                    swap(arr,i,j);
            }
                                                 }
    }
    private static void swap(String[] arr, int i, int j) {
        String temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void printArray(String[] arr) {
        System.out.print(&quot;[&quot;);
        for (int i = 0; i &lt; arr.length; i++) {
            if (i != arr.length - 1)
                System.out.print(arr[i] + &quot;, &quot;);
            else
                System.out.println(arr[i] + &quot;]&quot;);
        }
    }
}
</code></pre>
<p><strong>字符串格式化</strong> </p>
<p>MessageFormat</p>
<pre><code class="language-java">String deleteSql =
                &quot;delete from \n&quot; +
                &quot;  {0} \n&quot; +
                &quot;where \n&quot; +
                &quot;  {1} in (\n&quot; +
                &quot;    select \n&quot; +
                &quot;      {1} \n&quot; +
                &quot;    from \n&quot; +
                &quot;      (select * from {0}) as {0}_copy \n&quot; +
                &quot;      left join \n&quot; +
                &quot;      (select *, \&quot;{4}\&quot; as \&quot;{4}\&quot; from {2}) as {2}_copy \n&quot; +
                &quot;      on \n&quot; +
                &quot;      {0}_copy.{1} = {2}_copy.{3} \n&quot; +
                &quot;    where \n&quot; +
                &quot;      {2}_copy.{4} is NULL\n&quot; +
                &quot;  );&quot;;
deleteSql = MessageFormat.format(deleteSql, mainTableName, mainPrKeyName, subTableName, subPrKeyName, joinNULLFlag);
</code></pre>
<p>jdk 的 bug，MessageFormat doesn't replace {0} if followed by word with apostrophe。对于单引号，需要用两个单引号来显示：</p>
<pre><code class="language-java">String deleteSql =
                &quot;delete from \n&quot; +
                &quot;  {0} \n&quot; +
                &quot;where \n&quot; +
                &quot;  {1} in (\n&quot; +
                &quot;    select \n&quot; +
                &quot;      {1} \n&quot; +
                &quot;    from \n&quot; +
                &quot;      (select * from {0}) {0}_copy \n&quot; +
                &quot;      left join \n&quot; +
                &quot;      (select {2}.*, ''{4}'' {4} from {2}) {2}_copy \n&quot; +
                &quot;      on \n&quot; +
                &quot;      {0}_copy.{1} = {2}_copy.{3} \n&quot; +
                &quot;    where \n&quot; +
                &quot;      {2}_copy.{4} is NULL\n&quot; +
                &quot;  );&quot;;
</code></pre>
<p>StringBuffer 可以传入 bool 值 和 数值，统一转成字符串再存入 StringBuffer.</p>
<pre><code class="language-java">public class StringBufferDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * StringBuffer:就是字符串缓冲区。
        * 用于存储数据的容器。
        * 特点：
        * 1，长度的可变的。
        * 2，可以存储不同类型数据。
        * 3，最终要转成字符串进行使用。
        * 4，可以对字符串进行修改。
        *
        * 既然是一个容器对象。应该具备什么功能呢？
        * 1，添加：
        * StringBuffer append(data);
        * StringBuffer insert(index,data);
        * 2，删除：
        * StringBuffer delete(start,end):包含头，不包含尾。
        * StringBuffer deleteCharAt(int index):删除指定位置的元素
        * 3，查找：
        * char charAt(index);
        * int indexOf(string);
        * int lastIndexOf(string);
        * 4， 修改：
        * StringBuffer replace(start,end,string);
        * void setCharAt(index,char);
        *
        * 增删改查 C(create)U(update)R(read)D(delete)
        */
        bufferMethodDemo();
    }
    private static void bufferMethodDemo_2() {
        StringBuffer sb = new StringBuffer(&quot;abce&quot;);
        // sb.delete(1, 3);//ae
        //清空缓冲区。
        // sb.delete(0,sb.length());
        // sb = new StringBuffer();
        // sb.replace(1, 3, &quot;nba&quot;);
        // sb.setCharAt(2, 'q');
        // sb.setLength(10);
        // System.out.println(&quot;sb:&quot;+sb);
        // System.out.println(&quot;len:&quot;+sb.length());
        System.out.println(sb.reverse());
    }
    private static void bufferMethodDemo_1() {
        StringBuffer sb = new StringBuffer(&quot;abce&quot;);
        // sb.append(&quot;xixi&quot;);
        sb.insert(2, &quot;qq&quot;);
        System.out.println(sb.toString());
    }
    public static void bufferMethodDemo(){
        //创建缓冲区对象。
        StringBuffer sb = new StringBuffer();
        sb.append(4).append(false); //.append(&quot;haha&quot;);
        sb.insert(1, &quot;haha&quot;);
        // sb.append(true);
        System.out.println(sb);
    }
}
</code></pre>
<pre><code class="language-java">/*
* jdk1.5以后出现了功能和StringBuffer一模一样的对象。就是StringBuilder
*
* 不同的是：
* StringBuffer 是线程同步的。通常用于多线程。
* StringBuilder是线程不同步的。通常用于单线程。 它的出现提高效率。
*
* jdk升级：
* 1，简化书写。
* 2，提高效率。
* 3，增加安全性。
*/
</code></pre>
<h3 id="包装类"><a class="header" href="#包装类">包装类</a></h3>
<pre><code class="language-java">package com.wansho.hellojava;

public class WrapperDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 基本数据类型对象包装类。
         * 为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操
         * 作。
         * 用于描述该对象的类就称为基本数据类型对象包装类。
         *
         * byte Byte
         * short Short
         * int Integer
         * long Long
         * float Float
         * double Double
         * char Character
         * booleanBoolean
         *
         * 该包装对象主要用基本类型和字符串之间的转换。
         *
         * 基本类型---&gt;字符串
         * 1,基本类型数值 + &quot;&quot;
         * 2,用 String 类中的静态方法 valueOf(基本类型数值);
         * 3,用 Integer 的静态方法 valueOf(基本类型数值);
         *
         * 字符串---&gt;基本类型
         * 1,使用包装类中的静态方法 xxx parseXxx(&quot;xxx类型的字符串&quot;);*****
         * int parseInt(&quot;intstring&quot;);
         * long parseLong(&quot;longstring&quot;);
         * boolean parseBoolean(&quot;booleanstring&quot;);
         * 只有Character没有parse方法
         * 2,如果字符串被Integer进行对象的封装。
         * 可使用另一个非静态的方法， intValue();
         * 将一个Integer对象转成基本数据类型值。
         */
         System.out.println(Integer.MAX_VALUE);
         System.out.println(Integer.toBinaryString(-6));
         int num = 4;
         Integer i = new Integer(5);
         int x = Integer.parseInt(&quot;123&quot;);
         System.out.println(Integer.parseInt(&quot;123&quot;)+1);
         i = new Integer(&quot;123&quot;);
         System.out.println(i.intValue());
        /*
         * 整数具备不同的进制体现。
         *
         * 十进制--&gt;其他进制。
         * toBinaryString
         * toOctalString
         * toHexString
         *
         * 其他进制--&gt;十进制。
         * parseInt(&quot;string&quot;,radix)
         *
         */
        // 十进制--&gt;其他进制。
        System.out.println(Integer.toBinaryString(60));
        System.out.println(Integer.toOctalString(60));
        System.out.println(Integer.toHexString(60));
        // System.out.println(Integer.toString(60,16));
        // 其他进制--&gt;十进制。
        // System.out.println(Integer.parseInt(&quot;3c&quot;,16));
        Integer a = new Integer(&quot;89&quot;);
        Integer b = new Integer(300);
        System.out.println(a==b);
        System.out.println(a.equals(b));
        // System.out.println(3&gt;3);
        System.out.println(a.compareTo(b));

    }
}
</code></pre>
<p><strong>自动装箱拆箱</strong></p>
<pre><code class="language-java">public class WrapperDemo2 {
    public static void main(String[] args) {
        int num = 4;
        num = num + 5;
        Integer i = 4; // i = new Integer(4); 自动装箱 简化书写。
        i = i + 6; // i = new Integer(i.intValue() + 6); // i.intValue() 自动拆箱
        // show(55);//
        Integer a = new Integer(128);
        Integer b = new Integer(128);
        System.out.println(a==b); // false 两个对象
        System.out.println(a.equals(b)); // true 值是相同的
        Integer x = 129; // jdk1.5以后，自动装箱，如果装箱的是一个字节，那么该数据会被共享不会重新开辟空间。
        Integer y = 129;
        System.out.println(x==y); // false
        System.out.println(x.equals(y)); //true
    }
}
</code></pre>
<pre><code class="language-java">import java.util.Arrays;
/*
* 对一个字符串中的数值进行从小到大的排序。
*
* &quot;20 78 9 -7 88 36 29&quot;
*
* 思路：
* 1，排序， 我很熟。可是我只熟int。
* 2，如何获取到这个字符串中的这些需要排序的数值？
* 发现这个字符串中其实都是空格来对数值进行分隔的。
* 所以就想到用字符串对象的切割方法将大串变成多个小串。
* 3，数值最终变成小字符串，怎么变成一个int数呢？135
* 字符串--&gt;基本类型 可以使用包装类。
*
*
*/
public class WrapperTest {
    private static final String SPACE_SEPARATOR = &quot; &quot;;
    /**
* @param args
*/
    public static void main(String[] args) {
        String numStr = &quot;20 78 9 -7 88 36 29&quot;;
        System.out.println(numStr);
        numStr = sortStringNumber(numStr);
        System.out.println(numStr);
    }
    /**
*
* @param numStr
* @return
*/
    public static String sortStringNumber(String numStr) {
        //1,将字符串变成字符串数组。
        String[] str_arr = stringToArray(numStr);
        //2,将字符串数组变成int数组。
        int[] num_arr = toIntArray(str_arr);
        //3,对int数组排序。
        mySortArray(num_arr);
        //4,将排序后的int数组变成字符串。
        String temp = arrayToString(num_arr);
        return temp;
    }
    public static String arrayToString(int[] num_arr) {
        StringBuilder sb = new StringBuilder();136
            for(int x = 0; x&lt;num_arr.length; x++){
                if(x!=num_arr.length-1)
                    sb.append(num_arr[x]+SPACE_SEPARATOR);
                else
                    sb.append(num_arr[x]);
            }
        return sb.toString();
    }
    public static void mySortArray(int[] num_arr) {
        Arrays.sort(num_arr);
    }
    public static int[] toIntArray(String[] str_arr) {
        int[] arr = new int[str_arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = Integer.parseInt(str_arr[i]);
        }
        return arr;
    }
    /**
* @param numStr
*/
    public static String[] stringToArray(String numStr) {
        String[] str_arr = numStr.split(SPACE_SEPARATOR);
        return str_arr;
    }
}
</code></pre>
<h3 id="泛型"><a class="header" href="#泛型">泛型</a></h3>
<p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。</p>
<p><strong>泛型的作用</strong></p>
<p><a href="https://www.oracle.com/cn/technical-resources/articles/java/juneau-generics.html">Oracle 泛型：工作原理及其重要性</a></p>
<p>在学习容器依赖，我一直忽视了两个很重要的点：</p>
<ol>
<li>
<p>容器可以同时存储不同类型的数据，例如 String 类型，Integer 类型，如果一个容器存储了不同类型的对象，不就乱套了</p>
<pre><code class="language-java">ArrayList list = new ArrayList();
list.add(&quot;abc&quot;);
list.add(new Integer(19));
Iterator it = list.iterator();
while(it.hasNext()){
    System.out.println(it.next() + &quot;&quot;);
}
/*
abc
19
*/
</code></pre>
</li>
<li>
<p>在定义容器变量的时候，并没有定义该容器存储的对象类型，这不对劲</p>
<p>在 C 语言中，我们定义结构体数组的时候，都会指定数组存储的对象类型，Java 的容器虽然不同于数组，但是其在定义容器的时候，不定义容器存储的数据类型，就感觉不对劲。</p>
<p>泛型相当于是定义了容器的存储类型</p>
</li>
</ol>
<p>Generics 的具体介绍，参考 <a href="computer-science-notebook/note-for-java/detailed-generics.html">Detailed-Generics</a></p>
<pre><code class="language-java">public class Tool&lt;QQ&gt;{ // 泛型类，类中操作的引用数据类型不确定的时候，就使用泛型来表示。 
    private QQ q;
    public QQ getObject() {
        return q;
    }
    public void setObject(QQ object) {
        this.q = object;
    }
    /**
    * 将泛型定义在方法上。
    * @param str
    */
    public &lt;W&gt; void show(W str){
        System.out.println(&quot;show : &quot;+str.toString());
    }
    public void print(QQ str){
        System.out.println(&quot;print : &quot;+str);
    }
    /**
    * 当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型，
    * 只能将泛型定义在方法上。
    * @param obj
    */
    public static &lt;Y&gt; void method(Y obj){
        System.out.println(&quot;method:&quot;+obj);
    }
}
</code></pre>
<p><strong>&lt;? super E&gt; &lt;? extend E&gt;</strong></p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo2 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        ArrayList&lt;Person&gt; al = new ArrayList&lt;Person&gt;();
        al.add(new Person(&quot;abc&quot;,30));
        al.add(new Person(&quot;abc4&quot;,34));
        ArrayList&lt;Student&gt; al2 = new ArrayList&lt;Student&gt;();
        al2.add(new Student(&quot;stu1&quot;,11));
        al2.add(new Student(&quot;stu2&quot;,22));
        ArrayList&lt;String&gt; al3 = new ArrayList&lt;String&gt;();
        al3.add(&quot;stu3331&quot;);
        al3.add(&quot;stu33332&quot;);
        printCollection(al2);
        printCollection(al);
    }
    /**
    * 迭代并打印集合中元素。
    *
    * 可以对类型进行限定：
    * ? extends E:接收E类型或者E的子类型对象。上限！
    *
    * ? super E ：接收E类型或者E的父类型。下限！
    * @param al
    */
    public static void printCollection(Collection&lt;? extends Person&gt; al)
    {//Collection&lt;Dog&gt; al = new ArrayList&lt;Dog&gt;()
        Iterator&lt;? extends Person&gt; it = al.iterator();
        while(it.hasNext()){
            // T str = it.next();
            // System.out.println(str);
            // System.out.println(it.next().toString());
            Person p = it.next();
            System.out.println(p.getName()+&quot;:&quot;+p.getAge());
        }
    }
    public static void printCollection(Collection&lt;? super Student&gt; al){
        Iterator&lt;? super Student&gt; it = al.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}



/*
* class TreeSet&lt;Worker&gt;
* {
* Tree(Comparator&lt;? super Worker&gt; comp);
* }
*
* 什么时候用下限呢？通常对集合中的元素进行取出操作时，可以是用下限。
*
*/
class CompByName implements Comparator&lt;Person&gt;{
    @Override
    public int compare(Person o1, Person o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByStuName implements Comparator&lt;Student&gt;{
    @Override
    public int compare(Student o1, Student o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByWorkerName implements Comparator&lt;Worker&gt;{
    @Override
    public int compare(Worker o1, Worker o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
</code></pre>
<p>存储用上限：</p>
<pre><code class="language-java">package cn.itcast.p5.generic.advance.demo;
import java.util.ArrayList;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo3 {
    public static void main(String[] args) {
        ArrayList&lt;Person&gt; al1 = new ArrayList&lt;Person&gt;();
        al1.add(new Person(&quot;abc&quot;, 30));
        al1.add(new Person(&quot;abc4&quot;, 34));
        ArrayList&lt;Student&gt; al2 = new ArrayList&lt;Student&gt;();
        al2.add(new Student(&quot;stu1&quot;, 11));
        al2.add(new Student(&quot;stu2&quot;, 22));
        ArrayList&lt;Worker&gt; al3 = new ArrayList&lt;Worker&gt;();
        al3.add(new Worker(&quot;stu1&quot;, 11));
        al3.add(new Worker(&quot;stu2&quot;, 22));
        ArrayList&lt;String&gt; al4 = new ArrayList&lt;String&gt;();
        al4.add(&quot;abcdeef&quot;);
        // al1.addAll(al4);//错误，类型不匹配。
        al1.addAll(al2);
        al1.addAll(al3);
        System.out.println(al1.size());
    }
}

/*
* 一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。
*/
class MyCollection&lt;E&gt; {
    public void add(E e) {
    }
    public void addAll(MyCollection&lt;? extends E&gt; e) {
    }
}
</code></pre>
<p>取出用下限：</p>
<pre><code class="language-java">package cn.itcast.p5.generic.advance.demo;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo4 {
    public static void main(String[] args) {
        TreeSet&lt;Person&gt; al1 = new TreeSet&lt;Person&gt;(new CompByName());
        al1.add(new Person(&quot;abc4&quot;,34));
        al1.add(new Person(&quot;abc1&quot;,30));
        al1.add(new Person(&quot;abc2&quot;,38));
        TreeSet&lt;Student&gt; al2 = new TreeSet&lt;Student&gt;(new CompByName());
        al2.add(new Student(&quot;stu1&quot;,11));
        al2.add(new Student(&quot;stu7&quot;,20));
        al2.add(new Student(&quot;stu2&quot;,22));
        TreeSet&lt;Worker&gt; al3 = new TreeSet&lt;Worker&gt;();
        al3.add(new Worker(&quot;stu1&quot;,11));
        al3.add(new Worker(&quot;stu2&quot;,22));
        TreeSet&lt;String&gt; al4 = new TreeSet&lt;String&gt;();
        al4.add(&quot;abcdeef&quot;);
        // al1.addAll(al4);//错误，类型不匹配。
        // al1.addAll(al2);
        // al1.addAll(al3);
        // System.out.println(al1.size());
        Iterator&lt;Student&gt; it = al2.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}

/*
* class TreeSet&lt;Worker&gt;
* {
* Tree(Comparator&lt;? super Worker&gt; comp);
* }
*
* 什么时候用下限呢？通常对集合中的元素进行取出操作时，可以是用下限。
*
*/
class CompByName implements Comparator&lt;Person&gt;{
    @Override
    public int compare(Person o1, Person o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}

class CompByStuName implements Comparator&lt;Student&gt;{
    @Override
    public int compare(Student o1, Student o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByWorkerName implements Comparator&lt;Worker&gt;{
    @Override
    public int compare(Worker o1, Worker o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
</code></pre>
<h4 id="函数的可变参数"><a class="header" href="#函数的可变参数">函数的可变参数</a></h4>
<pre><code class="language-java">public class ParamterDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        // int sum = add(4,5);
        // System.out.println(&quot;sum=&quot;+sum);
        // int sum1 = add(4,5,6);
        // System.out.println(&quot;sum1=&quot;+sum1);
        // int[] arr = {5,1,4,7,3};
        // int sum = add(arr);
        // System.out.println(&quot;sum=&quot;+sum);
        // int[] arr1 = {5,1,4,7,3,9,8,7,6};
        // int sum1 = add(arr1);
        // System.out.println(&quot;sum1=&quot;+sum1);
        int sum = newAdd(5,1,4,7,3);
        System.out.println(&quot;sum=&quot;+sum);
        int sum1 = newAdd(5,1,2,7,3,9,8,7,6);
        System.out.println(&quot;sum1=&quot;+sum1);
    }
    /*
    * 函数的可变参数。
    * 其实就是一个数组，但是接收的是数组的元素。
    * 自动将这些元素封装成数组。简化了调用者的书写。
    * 注意：可变参数类型，必须定义在参数列表的结尾。
    */
    public static int newAdd(int a,int... arr){
        int sum = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            sum+=arr[i];
        }
        return sum;
        // System.out.println(arr);
        // return 0;
    }
    public static int add(int[] arr){
        int sum = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            sum+=arr[i];
        }
        return sum;
    }
    public static int add(int a,int b){
        return a+b;
    }
    public static int add(int a,int b,int c){
        return a+b+c;
    }
}
</code></pre>
<h4 id="静态导入"><a class="header" href="#静态导入">静态导入</a></h4>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
import static java.util.Collections.*;//静态导入，其实导入的是类中的静态成员。
//import static java.util.Collections.max;//静态导入，其实到入的是类中的静态成员。
import static java.lang.System.*;
public class StaticImportDemo {
    /**
* @param args
*/
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abc3&quot;);
        list.add(&quot;abc7&quot;);
        list.add(&quot;abc1&quot;);
        out.println(list);
        sort(list);
        System.out.println(list);
        String max = max(list);
        System.out.println(&quot;max=&quot;+max);
    }
}
</code></pre>
<h4 id="日期类"><a class="header" href="#日期类">日期类</a></h4>
<p>Demo1</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.Calendar;
public class CalendarDemo {
    public static void main(String[] args) {
        Calendar c = Calendar.getInstance();
        int year = 2012;
        showDays(year);
    }
    public static void showDays(int year) {
        Calendar c = Calendar.getInstance();
        c.set(year, 2, 1); // java Calendar 中的月数是从 0 开始计数，此处输入的时间是 3 月 1 日
        c.add(Calendar.DAY_OF_MONTH, -1);
        showDate(c);
    }
    public static void showDate(Calendar c) {
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH)+1;
        int day = c.get(Calendar.DAY_OF_MONTH);
        int week = c.get(Calendar.DAY_OF_WEEK);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+getWeek(week));
    }
    public static String getWeek(int i) {
        String[] weeks = {&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;};
        return weeks[i];
    }
}

</code></pre>
<p>Demo2</p>
<pre><code class="language-java">import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo {
    /**
    * @param args
    * @throws ParseException
    */
    public static void main(String[] args) throws ParseException {
        methodDemo_3();
    }
    /**
    * 将日期格式的字符串--&gt;日期对象。
    * 使用的是 DateFormat 类中的 parse() 方法。
    *
    * @throws ParseException
    */
    public static void methodDemo_3() throws ParseException {
        String str_date = &quot;2012年4月19日&quot;;
        str_date = &quot;2011---8---17&quot;;
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        dateFormat = new SimpleDateFormat(&quot;yyyy---MM---dd&quot;);
        Date date = dateFormat.parse(str_date);
        System.out.println(date);
    }
    /**
    * 对日期对象进行格式化。
    * 将日期对象--&gt;日期格式的字符串。
    * 使用的是DateFormat类中的format方法。
    *
    */
    public static void methodDemo_2() {
        Date date = new Date();
        //获取日期格式对象。具体着默认的风格。 FULL LONG等可以指定风格。
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);
        // System.out.println(dateFormat);
        //如果风格是自定义的如何解决呢？
        dateFormat = new SimpleDateFormat(&quot;yyyy--MM--dd&quot;);
        String str_date = dateFormat.format(date);
        System.out.println(str_date);
    }
    /**
    * 日期对象和毫秒值之间的转换。
    *
    * 毫秒值--&gt;日期对象 ：
    * 1，通过Date对象的构造方法 new Date(timeMillis);
    * 2，还可以通过setTime设置。
    * 因为可以通过Date对象的方法对该日期中的各个字段(年月日等)进行操作。
    *
    * 日期对象--&gt;毫秒值：
    * 2， getTime方法。
    * 因为可以通过具体的数值进行运算。
    */
    public static void methodDemo_1() {
        long time = System.currentTimeMillis();//
        // System.out.println(time);//1335671230671
        Date date = new Date();//将当前日期和时间封装成Date对象。
        System.out.println(date);//Sun Apr 29 11:48:02 CST 2012
        Date date2 = new Date(1335664696656l);//将指定毫秒值封装成Date对象。
        System.out.println(date2);
    }
}
</code></pre>
<p>Demo3</p>
<pre><code class="language-java">import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/* 练习：
* &quot;2012-3-17&quot;到&quot;2012-4-6&quot;
* 中间有多少天？
* 思路：
* 两个日期相减就哦了。
* 咋减呢？
* 必须要有两个可以进行减法运算的数。
* 能减可以是毫秒值。如何获取毫秒值？通过date对象。
* 如何获取date对象呢？可以将字符串转成date对象。
*
* 1,将日期格式的字符串转成Date对象。
* 2,将Date对象转成毫秒值。
* 3，相减，在变成天数
*
*/
public class DateTest {
    /**
    * @param args
    * @throws ParseException
    */
    public static void main(String[] args) throws ParseException {
        String str_date1 = &quot;2012-3-17&quot;;
        String str_date2 = &quot;2012-4-18&quot;;
        test(str_date1,str_date2);
    }
    public static void test(String str_date1,String str_date2) throws ParseException
    {
        //1,将日期字符串转成日期对象。
        //定义日期格式对象。
        DateFormat dateFormat = DateFormat.getDateInstance();
        dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date1 = dateFormat.parse(str_date1);
        Date date2 = dateFormat.parse(str_date2);
        long time1 = date1.getTime();
        long time2 = date2.getTime();
        long time = Math.abs(time1-time2);
        int day = getDay(time);
        System.out.println(day);
    }
    private static int getDay(long time) {
        int day = (int)(time/1000/60/60/24);
        return day;
    }
}
</code></pre>
<h4 id="math类"><a class="header" href="#math类">Math类</a></h4>
<pre><code class="language-java">import java.util.Random;
public class MathDemo {
    public static void main(String[] args) {
        /*
        * Math:提供了操作数学运算的方法， 都是静态的。
        * 常用的方法：
        * ceil():返回大于参数的最小整数。 向上取整
        * floor():返回小于参数的最大整数。向下取整
        * round():返回四舍五入的整数。   四舍五入
        * pow(a,b):a的b次方。
        */
        double d1 = Math.ceil(12.56);
        double d2 = Math.floor(12.56);
        double d3 = Math.round(12.46);
        // sop(&quot;d1=&quot;+d1);
        // sop(&quot;d2=&quot;+d2);
        // sop(&quot;d3=&quot;+d3);
        // double d = Math.pow(10, 2);
        // sop(&quot;d=&quot;+d);
        Random r = new Random();
        for (int i = 0; i &lt; 10; i++) {
            // double d = Math.ceil(Math.random()*10);
            // double d = (int)(Math.random()*6+1);
            // double d = (int)(r.nextDouble()*6+1);
            int d = r.nextInt(6)+1;
            System.out.println(d);
        }
    }
    public static void sop(String string) {
        System.out.println(string);
    }
}
</code></pre>
<h4 id="runtime-类"><a class="header" href="#runtime-类">Runtime 类</a></h4>
<p>Every Java application has a single instance of class <code>Runtime</code> that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the <code>getRuntime</code> method.</p>
<p>An application cannot create its own instance of this class.</p>
<pre><code class="language-java">import java.io.IOException;
public class RuntimeDemo {
    /**
    * @param args
    * @throws IOException
    * @throws InterruptedException
    */
    public static void main(String[] args) throws IOException, InterruptedException
    {
        /*
        * Runtime:没有构造方法摘要，说明该类不可以创建对象。
        * 又发现还有非静态的方法。说明该类应该提供静态的返回该类对象的方法。
        * 而且只有一个，说明Runtime类使用了单例设计模式。
        *
        */
        Runtime r = Runtime.getRuntime();
        // execute: 执行。 xxx.exe
        Process p = r.exec(&quot;notepad.exe&quot;);
        Thread.sleep(5000);
        p.destroy();
    }
}
</code></pre>
<h4 id="system-类"><a class="header" href="#system-类">System 类</a></h4>
<p>java.lang.System</p>
<p>Among the facilities provided by the <code>System</code> class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array.</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.Set;
public class SystemDemo {
    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * System: 类中的方法和属性都是静态的。
        * 常见方法：
        * long currentTimeMillis();获取当前时间的毫秒值。
        */
        // long l1 = 1335664696656l;//System.currentTimeMillis();
        // System.out.println(l1/1000/60/60/24);//1335664696656
        // code..
        // long l2 = System.currentTimeMillis();
        // System.out.println(l2-l1);
        System.out.println(&quot;hello-&quot;+LINE_SEPARATOR+&quot; world&quot;);
        // demo_1();
        //给系统设置一些属性信息。这些信息是全局，其他程序都可以使用。
        // System.setProperty(&quot;myclasspath&quot;, &quot;c:\myclass&quot;);
    }
    public static void demo_1(){
        //获取系统的属性信息，并存储到了Properties集合中。
        /*
        * properties集合中存储都是String类型的键和值。
        * 最好使用它自己的存储和取出的方法来完成元素的操作。
        */
        Properties prop = System.getProperties();
        Set&lt;String&gt; nameSet = prop.stringPropertyNames();
        for(String name : nameSet){
            String value = prop.getProperty(name);
            System.out.println(name+&quot;::&quot;+value);
        }
    }
}
</code></pre>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<pre><code>Collection
	List
		ArrayList
		LinkedList
		Stack
		Vector
	Set
		HashSet
			LinkedHashSet (存储顺序不变)
		TreeSet
	Map
		HashMap
			LinkedHashMap (存储顺序不变)
		HashTable
		TreeMap
	Queue
	Deque
	SortedSet
</code></pre>
<pre><code>泛型：
	jdk1.5出现的安全机制。
	
	好处：
        1，将运行时期的问题 ClassCastException 转到了编译时期。
        2，避免了强制转换的麻烦。
    &lt;&gt;:什么时候用？
    	当操作的引用数据类型不确定的时候。就使用&lt;&gt;。将要操作的引用数据类型传入即可.
		其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型 。
	
	泛型技术是给编译器使用的技术, 用于编译时期。确保了类型的安全。
	运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。
	为什么擦除呢？因为为了兼容运行的类加载器。
	
	泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。

	泛型的通配符： ? 未知类型。

	泛型的限定：
		? extends E: 接收E类型或者E的子类型对象。上限
			一般存储对象的时候用。比如 添加元素 addAll.
		? super E: 接收E类型或者E的父类型对象。 下限。
			一般取出对象的时候用。比如比较器。
--------------------------------------------------------------------------------
集合的一些技巧：

需要唯一吗？
	需要： Set
		需要制定顺序：
			需要： TreeSet
			不需要： HashSet
			但是想要一个和存储一致的顺序(有序):LinkedHashSet
	不需要： List
		需要频繁增删吗？
			需要： LinkedList
			不需要： ArrayList
			
如何记录每一个容器的结构和所属体系呢？看名字！
List
|--ArrayList
|--LinkedList
Set
|--HashSet
|--TreeSet
后缀名就是该集合所属的体系。
前缀名就是该集合的数据结构。
看到array：就要想到数组，就要想到查询快，有角标.
看到link：就要想到链表，就要想到增删快，就要想要 add get remove+frist last的方法
看到hash:就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。
看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable， Comparator 。
而且通常这些常用的集合容器都是不同步的。
--------------------------------------------------------------------------------
Map：一次添加一对元素。 Collection 一次添加一个元素。
Map也称为双列集合， Collection集合称为单列集合。
其实map集合中存储的就是键值对。map集合中必须保证键的唯一性。

常用方法：
    1，添加。
        value put(key,value):返回前一个和key关联的值，如果没有返回null.
        2，删除。186
        void clear():清空map集合。
        value remove(key):根据指定的key翻出这个键值对。
    3，判断。
        boolean containsKey(key):
        boolean containsValue(value):
        boolean isEmpty();
    4，获取。
        value get(key):通过键获取值，如果没有该键返回null.当然可以通过返回null，来判断是否包含指定键。
        int size(): 获取键值对的个数。
        
Map常用的子类：
|--Hashtable :内部结构是哈希表，是同步的。不允许null作为键， null作为值。
|--Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。
|--HashMap : 内部结构是哈希表，不是同步的。允许null作为键， null作为值。
|--TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。
</code></pre>
<p><strong>集合遍历总结</strong></p>
<pre><code class="language-java">//遍历List方法1，使用普通for循环：
for (int i = 0; i &lt; list.size(); i++) {
    String temp=(String)list.get(i);
    System.out.println(temp);
    //list.remove(i);//遍历删除元素，不过不推荐这种方式！
}
//遍历List方法2，使用增强for循环（应该使用泛型定义类型！）：
for(String temp:list){
    System.out.println(temp);
}
//遍历List方法3，使用Iterator迭代器：
for(Iterator iter=list.iterator();iter.hasNext();){
    String temp=(String)iter.next();
    System.out.println(temp);
}

Iterator iter=c.iterator();
while(iter.hasNext()){
    Object obj=iter.next();
    iter.remove();//如果要遍历删除集合中的元素，建议使用这种方式！
    System.out.println(obj);
}
//遍历Set方法1，使用增强for循环：
for(String temp:set){
    System.out.println(temp);
}
//遍历Set方法2，使用Iterator迭代器：
for(Iterator iter=list.iterator();iter.hasNext();){
    String temp=(String)iter.next();
    System.out.println(temp);
}
//遍历Map
Map&lt;Integer, Man&gt; maps=new HashMap&lt;Integer, Man&gt;();
Set&lt;Integer&gt; keySet=maps.keySet();
for(Integer id:keySet){
    System.out.println(maps.get(id).name);
}
</code></pre>
<h2 id="io-流"><a class="header" href="#io-流">I/O 流</a></h2>
<h3 id="是什么-3"><a class="header" href="#是什么-3">是什么</a></h3>
<p>I，Input：将外存中的数据读取到内存中</p>
<p>O，Output：将内存中的数据写入到外存中</p>
<h3 id="字符流字节流"><a class="header" href="#字符流字节流">字符流，字节流</a></h3>
<p>一个字符由多个字节组成！</p>
<p>IO 流分为字符流和字节流：</p>
<ul>
<li>
<p>字符流：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。在对这个文字进行操作。简单说：<strong>字节流+编码表</strong></p>
<p>顶层父类：Reader, Writer</p>
</li>
<li>
<p>字节流：顾名思义，计算机中的字节，8 位为一字节</p>
<p>顶层父类：InputStream, OutputStream</p>
</li>
</ul>
<p>这些体系的子类都以父类名作为后缀。而且子类名的前缀就是该对象的功能。</p>
<h3 id="转换流"><a class="header" href="#转换流">转换流</a></h3>
<p>FileReader 和 FileWriter 是转换流的子类！</p>
<p>Demo 将键盘的输入转换成大写，并输出到控制台：</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
public class TransStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        //字节流。键盘的输入，是字节流……
        InputStream in = System.in;
        // int ch = in.read();
        // System.out.println(ch);
        // int ch1 = in.read();
        // System.out.println(ch1);
        //将字节转成字符的桥梁。装换流。
        InputStreamReader isr = new InputStreamReader(in);
        // int ch = isr.read();
        // System.out.println((char)ch);
        //字符流。
        BufferedReader bufr = new BufferedReader(isr);
        OutputStream out = System.out;t
        OutputStreamWriter osw = new OutputStreamWriter(out);
        BufferedWriter bufw = new BufferedWriter(osw);
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            // System.out.println(line.toUpperCase());
            // osw.write(line.toUpperCase()+&quot;\r\n&quot;);
            // osw.flush();
            bufw.write(line.toUpperCase());
            bufw.newLine();
            bufw.flush();
        }
    }
}
</code></pre>
<p>功能相同的两行代码：</p>
<pre><code class="language-java">/*
* 这两句代码的功能是等同的。
* FileWriter：其实就是转换流指定了本机默认码表的体现。而且这个转换流的子类对象，可以方
* 便操作文本文件。
* 简单说：操作文件的字节流+本机默认的编码表。
* 这是按照默认码表来操作文件的便捷类。
*
* 如果操作文本文件需要明确具体的编码。 FileWriter就不行了。必须用转换流。
*/
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;gbk_3.txt&quot;), &quot;GBK&quot;);
FileWriter fw = new FileWriter(&quot;gbk_1.txt&quot;);
</code></pre>
<h3 id="file-过滤器"><a class="header" href="#file-过滤器">File, 过滤器</a></h3>
<p><strong>File</strong></p>
<pre><code class="language-java">import java.io.File;
public class FileDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        // constructorDemo();
    }
    public static void constructorDemo() {
        //可以将一个已存在的，或者不存在的文件或者目录封装成file对象。
        File f1 = new File(&quot;c:\\a.txt&quot;);
        File f2 = new File(&quot;c:\\&quot;,&quot;a.txt&quot;);
        File f = new File(&quot;c:\\&quot;);
        File f3 = new File(f,&quot;a.txt&quot;);
        File f4 = new File(&quot;c:&quot;+File.separator+&quot;abc&quot;+File.separator+&quot;a.txt&quot;);
        System.out.println(f4); // 在 Windows 上执行打印的是：c:\abc\a.txt
    }
}
</code></pre>
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.util.Date;
public class FileMethodDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * File对象的常见方法。
        *
        * 1，获取。
        * 1.1 获取文件名称。
        * 1.2 获取文件路径。
        * 1.3 获取文件大小。
        * 1.4 获取文件修改时间。
        *
        * 2，创建与删除。
        *
        * 3，判断。
        *
        * 4， 重命名
        *
        */
        // getDemo();
        // createAndDeleteDemo();
        // isDemo();
        // renameToDemo();
        // listRootsDemo();
    }
    public static void listRootsDemo() {
        File file = new File(&quot;d:\\&quot;);
        System.out.println(&quot;getFreeSpace:&quot;+file.getFreeSpace());
        System.out.println(&quot;getTotalSpace:&quot;+file.getTotalSpace());
        System.out.println(&quot;getUsableSpace:&quot;+file.getUsableSpace());
        // File[] files = File.listRoots();
        // for(File file : files){
        // System.out.println(file);
        // }
    }
    public static void renameToDemo() { // 移动文件
        File f1 = new File(&quot;c:\\9.mp3&quot;);
        File f2 = new File(&quot;d:\\aa.mp3&quot;);
        boolean b = f1.renameTo(f2);
        System.out.println(&quot;b=&quot;+b);
    }
    public static void isDemo() throws IOException{
        File f = new File(&quot;aaa&quot;);
        // f.mkdir();
        f.createNewFile();
        // boolean b = f.exists();
        // System.out.println(&quot;b=&quot;+b);
        // 最好先判断是否存在。
        System.out.println(f.isFile());
        System.out.println(f.isDirectory());
    }
    public static void createAndDeleteDemo() throws IOException {
        File dir = new File(&quot;abc\\q\\e\\c\\z\\r\\w\\y\\f\\e\\g\\s&quot;);
        // boolean b = dir.mkdir();//make directory
        // System.out.println(&quot;b=&quot;+b);
        // dir.mkdirs();//创建多级目录
        System.out.println(dir.delete());
        // System.out.println(dir.delete());
        // 文件的创建和删除。
        // File file = new File(&quot;file.txt&quot;);
        /*
        * 和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。
        *
        */
        // boolean b = file.createNewFile();
        // System.out.println(&quot;b=&quot;+b);
        // boolean b = file.delete();
        // System.out.println(&quot;b=&quot;+b);
    }
    public static void getDemo(){
        // File file = new File(&quot;E:\\java0331\\day22e\\a.txt&quot;);
        File file = new File(&quot;a.txt&quot;);
        String name = file.getName();
        String absPath = file.getAbsolutePath();//绝对路径。
        String path = file.getPath();
        long len = file.length();
        long time = file.lastModified();
        Date date = new Date(time);
        DateFormat dateFormat =
            DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);
        String str_time = dateFormat.format(date);
        System.out.println(&quot;parent:&quot;+file.getParent());226
            System.out.println(&quot;name:&quot;+name);
        System.out.println(&quot;absPath:&quot;+absPath);
        System.out.println(&quot;path:&quot;+path);
        System.out.println(&quot;len:&quot;+len);
        System.out.println(&quot;time:&quot;+time);
        System.out.println(&quot;str_time:&quot;+str_time);
    }
}

</code></pre>
<p><strong>三种常见过滤器</strong></p>
<ol>
<li>
<p>后缀名过滤器</p>
<pre><code class="language-java">public class FilterByJava implements FilenameFilter {
    @Override
    public boolean accept(File dir, String name) {
        // System.out.println(dir+&quot;---&quot;+name);
        return name.endsWith(&quot;.java&quot;);
    }
}
</code></pre>
</li>
<li>
<p>根据后缀名可以指定任意后缀名过滤的过滤器</p>
<pre><code class="language-java">import java.io.File;
import java.io.FilenameFilter;
public class SuffixFilter implements FilenameFilter {
    private String suffix ;
    public SuffixFilter(String suffix) {
        super();
        this.suffix = suffix;
    }
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(suffix);
    }
}
</code></pre>
</li>
<li>
<p>隐藏属性过滤器</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileFilter;
public class FilterByHidden implements FileFilter {
    @Override
    public boolean accept(File pathname) {
        return !pathname.isHidden();
    }
}
</code></pre>
</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">import java.io.File;
import cn.itcast.io.p2.filter.FilterByHidden;
import cn.itcast.io.p2.filter.SuffixFilter;
public class FileListDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        listDemo_2();
    }
    public static void listDemo_3() {
        File dir = new File(&quot;c:\\&quot;);
        File[] files = dir.listFiles(new FilterByHidden());
        for(File file : files){
            System.out.println(file);
        }
    }
    public static void listDemo_2() {
        File dir = new File(&quot;c:\\&quot;);
        String[] names = dir.list(new SuffixFilter(&quot;.txt&quot;));
        for(String name : names){
            System.out.println(name);
        }
    }
}
</code></pre>
<h3 id="io流操作规律"><a class="header" href="#io流操作规律">IO流操作规律</a></h3>
<p>想要知道开发时用到哪些对象。只要通过四个明确即可。</p>
<ol>
<li>
<p>明确源和目的(汇)
源： InputStream Reader
目的： OutputStream Writer</p>
</li>
<li>
<p>明确数据是否是纯文本数据。
源：是纯文本： Reader
否： InputStream
目的：是纯文本 Writer
否： OutputStream
到这里，就可以明确需求中具体要使用哪个体系。</p>
</li>
<li>
<p>明确具体的设备。
源设备：</p>
<p>硬盘： File
键盘： System.in
内存：数组
网络： Socket流</p>
<p>目的设备：</p>
<p>硬盘： File
控制台： System.out
内存：数组
网络： Socket流</p>
</li>
<li>
<p>是否需要其他额外功能。
1，是否需要高效(缓冲区);
是，就加上buffer.
2，转换？</p>
</li>
</ol>
<p>举例：</p>
<pre><code>--------------------------------------------------------------------------------
需求1：复制一个文本文件。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2,是否是纯文本？
是！
源： Reader
目的： Writer
3,明确具体设备。
源：
硬盘： File
目的：
硬盘： File
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4,需要额外功能吗？
需要，需要高效。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
--------------------------------------------------------------------------------
需求2：读取键盘录入信息，并写入到一个文件中。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确设备
源：
键盘。 System.in
目的：
硬盘。 File
InputStream in = System.in;
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
这样做可以完成，但是麻烦。将读取的字节数据转成字符串。再由字符流操作。
4，需要额外功能吗？
需要。转换。 将字节流转成字符流。因为名确的源是Reader，这样操作文本数据做便捷。
所以要将已有的字节流转成字符流。使用字节--&gt;字符 。 InputStreamReader
InputStreamReader isr = new InputStreamReader(System.in);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
还需要功能吗？
需要：想高效。
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
-------------------------------------------------------------------------------
需求3：将一个文本文件数据显示在控制台上。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确具体设备
源：
硬盘： File
目的：
控制台： System.out
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStream out = System.out;//PrintStream
4，需要额外功能吗？
需要，转换。
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(System.out);
需要，高效。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
--------------------------------------------------------------------------------
需求4：读取键盘录入数据，显示在控制台上。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确设备。
源：
键盘： System.in
目的：
控制台： System.out
InputStream in = System.in;
OutputStream out = System.out;
4，明确额外功能？
需要转换，因为都是字节流，但是操作的却是文本数据。
所以使用字符流操作起来更为便捷。
InputStreamReader isr = new InputStreamReader(System.in);
OutputStreamWriter osw = new OutputStreamWriter(System.out);
为了将其高效。
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
--------------------------------------------------------------------------------
5，将一个中文字符串数据按照指定的编码表写入到一个文本文件中.
1，目的。 OutputStream， Writer
2，是纯文本， Writer。
3，设备：硬盘File
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
fw.write(&quot;你好&quot;);
注意：既然需求中已经明确了指定编码表的动作。
那就不可以使用FileWriter，因为FileWriter内部是使用默认的本地码表。
只能使用其父类。 OutputStreamWriter.
OutputStreamWriter 接 收 一 个 字 节 输 出 流 对 象 ， 既 然 是 操 作 文 件 ， 那 么 该 对 象 应 该 是
FileOutputStream
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;),charsetName);
需要高效吗？
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;),charsetName));
什么时候使用转换流呢？
1，源或者目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。
提高对文本操作的便捷。
2，一旦操作文本涉及到具体的指定编码表时，必须使用转换流
</code></pre>
<h3 id="其他-2"><a class="header" href="#其他-2">其他</a></h3>
<h4 id="properties-集合io流"><a class="header" href="#properties-集合io流">Properties 集合+IO流</a></h4>
<p>Properties = map + io</p>
<p>* Properties集合：
* 特点：
* 1，该集合中的键和值都是字符串类型。
* 2，集合中的数据可以保存到流中，或者从流获取。</p>
<ul>
<li></li>
</ul>
<p>* 通常该集合用于操作以键值对形式存在的配置文件。</p>
<p>Demo：</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.Set;
public class PropertiesDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * Map
        * |--Hashtable
        * |--Properties:
        *
        * Properties集合：
        * 特点：
        * 1，该集合中的键和值都是字符串类型。
        * 2，集合中的数据可以保存到流中，或者从流获取。
        *
        * 通常该集合用于操作以键值对形式存在的配置文件。
        */
        // methodDemo_4();
        // myLoad();
        test();
    }
    //对已有的配置文件中的信息进行修改。
    /*
    * 读取这个文件。
    * 并将这个文件中的键值数据存储到集合中。
    * 在通过集合对数据进行修改。
    * 在通过流将修改后的数据存储到文件中。
    */
    public static void test() throws IOException{
        //读取这个文件。
        File file = new File(&quot;info.txt&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileReader fr = new FileReader(file);
        //创建集合存储配置信息。
        Properties prop = new Properties();
        //将流中信息存储到集合中。
        prop.load(fr);
        prop.setProperty(&quot;wangwu&quot;, &quot;16&quot;);
        FileWriter fw = new FileWriter(file);
        prop.store(fw,&quot;&quot;);
        // prop.list(System.out);
        fw.close();
        fr.close();
    }
    //模拟一下load方法。
    public static void myLoad() throws IOException{
        Properties prop = new Properties();
        BufferedReader bufr = new BufferedReader(new FileReader(&quot;info.txt&quot;));
        String line = null;
        while((line=bufr.readLine())!=null){
            if(line.startsWith(&quot;#&quot;))
                continue;
            String[] arr = line.split(&quot;=&quot;);
                // System.out.println(arr[0]+&quot;::&quot;+arr[1]);
                prop.setProperty(arr[0], arr[1]);
        }
        prop.list(System.out);
        bufr.close();
    }
    public static void methodDemo_4() throws IOException {
        Properties prop = new Properties();
        //集合中的数据来自于一个文件。
        //注意；必须要保证该文件中的数据是键值对。
        //需要使用到读取流。
        FileInputStream fis = new FileInputStream(&quot;info.txt&quot;);
        //使用load方法。
        prop.load(fis);
        prop.list(System.out);
    }
    public static void methodDemo_3() throws IOException {
        Properties prop = new Properties();
        //存储元素。
        prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        //想要将这些集合中的字符串键值信息持久化存储到文件中。
        //需要关联输出流。
        FileOutputStream fos = new FileOutputStream(&quot;info.txt&quot;);
        //将集合中数据存储到文件中，使用store方法。
        prop.store(fos, &quot;info&quot;);
        fos.close();
    }
        /**
        * 演示Properties集合和流对象相结合的功能。
        */
        public static void methodDemo_2(){
        Properties prop = new Properties();
        //存储元素。
        // prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        // prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        // prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        // prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        prop = System.getProperties();
        prop.list(System.out);
    }
    /*
    * Properties集合的存和取。
    */
    public static void propertiesDemo(){
        //创建一个Properties集合。
        Properties prop = new Properties();
        //存储元素。
        prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        //修改元素。
        prop.setProperty(&quot;wangwu&quot;,&quot;26&quot;);
        //取出所有元素。
        Set&lt;String&gt; names = prop.stringPropertyNames();
        for(String name : names){
            String value = prop.getProperty(name);
            System.out.println(name+&quot;:&quot;+value);
        }
    }
}
</code></pre>
<p>Demo 用Properties定义一个程序运行次数的程序：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
/*
* 定义功能，获取一个应用程序运行的次数，如果超过5次，给出使用次数已到请注册的提示。并不要在运行
程序。
*
* 思路：
* 1，应该有计数器。
* 每次程序启动都需要计数一次,并且是在原有的次数上进行计数。
* 2，计数器就是一个变量。 突然冒出一想法，程序启动时候进行计数，计数器必须存在于内存并进行运算。
* 可是程序一结束，计数器消失了。那么再次启动该程序，计数器又重新被初始化了。
* 而我们需要多次启动同一个应用程序，使用的是同一个计数器。
* 这就需要计数器的生命周期变长，从内存存储到硬盘文件中。
*
* 3,如何使用这个计数器呢？
* 首先，程序启动时，应该先读取这个用于记录计数器信息的配置文件。
* 获取上一次计数器次数。 并进行试用次数的判断。
* 其次，对该次数进行自增，并自增后的次数重新存储到配置文件中。
*
*
* 4，文件中的信息该如何进行存储并体现。
* 直接存储次数值可以，但是不明确该数据的含义。 所以起名字就变得很重要。
* 这就有了名字和值的对应，所以可以使用键值对。
* 可是映射关系map集合搞定，又需要读取硬盘上的数据，所以 map+io = Properties.
*/
public class PropertiesTest {
    /**
* @param args
* @throws IOException
* @throws Exception
*/
    public static void main(String[] args) throws IOException {
        getAppCount();
    }
    public static void getAppCount() throws IOException{
        //将配置文件封装成File对象。
        File confile = new File(&quot;count.properties&quot;);
        if(!confile.exists()){
            confile.createNewFile();
        }
        FileInputStream fis = new FileInputStream(confile);
        Properties prop = new Properties();
        prop.load(fis);
        //从集合中通过键获取次数。
        String value = prop.getProperty(&quot;time&quot;);
        //定义计数器。记录获取到的次数。
        int count =0;
        if(value!=null){
            count = Integer.parseInt(value);
            if(count&gt;=5){
                // System.out.println(&quot;使用次数已到，请注册，给钱！ &quot;);
                // return;
                throw new RuntimeException(&quot;使用次数已到，请注册，给钱！ &quot;);
            }
        }
        count++;
        //将改变后的次数重新存储到集合中。
        prop.setProperty(&quot;time&quot;, count+&quot;&quot;);
        FileOutputStream fos = new FileOutputStream(confile);
        prop.store(fos, &quot;&quot;);
        fos.close();
        fis.close();
    }
}
</code></pre>
<p>Demo 建立一个指定扩展名文件的列表：</p>
<pre><code class="language-java">import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/*
* 获取指定目录下，指定扩展名的文件(包含子目录中的)
* 这些文件的绝对路径写入到一个文本文件中。
*
* 简单说，就是建立一个指定扩展名的文件的列表。
*
* 思路：
* 1，必须进行深度遍历。
* 2，要在遍历的过程中进行过滤。将符合条件的内容都存储到容器中。
* 3，对容器中的内容进行遍历并将绝对路径写入到文件中。
*/
public class Test {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        File dir = new File(&quot;e:\\java0331&quot;);
        FilenameFilter filter = new FilenameFilter(){
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(&quot;.java&quot;);
            }
        };
        List&lt;File&gt; list = new ArrayList&lt;File&gt;();
        getFiles(dir,filter,list);
        File destFile = new File(dir,&quot;javalist.txt&quot;);
        write2File(list,destFile);
    }
    /**
    * 对指定目录中的内容进行深度遍历，并按照指定过滤器，进行过滤，
    * 将过滤后的内容存储到指定容器List中。
    * @param dir
    * @param filter
    * @param list
    */
    public static void getFiles(File dir,FilenameFilter filter,List&lt;File&gt; list){
        File[] files = dir.listFiles();
        for(File file : files){
            if(file.isDirectory()){
                //递归啦！
                getFiles(file,filter,list);
            }else{
                //对遍历到的文件进行过滤器的过滤。将符合条件File对象，存储到List集合中。
                if(filter.accept(dir, file.getName())){
                    list.add(file);
                }
            }
        }
    }
    public static void write2File(List&lt;File&gt; list,File destFile)throws IOException{
        BufferedWriter bufw = null;
        try {
            bufw = new BufferedWriter(new FileWriter(destFile));
            for(File file : list){
                bufw.write(file.getAbsolutePath());
                bufw.newLine();
                bufw.flush();
            }
        } /*catch(IOException e){
        throw new RuntimeException(&quot;写入失败&quot;);
        }*/finally{
            if(bufw!=null)
                try {
                    bufw.close();
                } catch (IOException e) {
                    throw new RuntimeException(&quot;关闭失败&quot;);
                }
        }
    }
}
</code></pre>
<h4 id="打印流"><a class="header" href="#打印流">打印流</a></h4>
<p>打印流也是输出流的装饰流。</p>
<p>PrintStream  PrintWriter</p>
<pre><code class="language-java">import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
public class PrintStreamDemo {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        /*
         * PrintStream: 字节打印流
         * 1, 提供了打印方法可以对多种数据类型值进行打印。并保持数据的表示形式。
         * 2，它不抛 IOException
         *
         * 构造函数，接收三种类型的值：
         * 1，字符串路径。
         * 2，File 对象。
         * 3，字节输出流。
         */
        PrintStream out = new PrintStream(&quot;print.txt&quot;);
        // int by = read();
        // write(by);
        out.write(610); // 只写最低8位，
        out.print(97); // 将97先变成字符保持原样将数据打印到目的地。
        out.close();
    }
}
</code></pre>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
public class PrintWriterDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * PrintWriter：字符打印流。
        * 构造函数参数：
        * 1，字符串路径。
        * 2， File对象。
        * 3，字节输出流。
        * 4，字符输出流。
        *
        */
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new FileWriter(&quot;out.txt&quot;),true);
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            out.println(line.toUpperCase());
            // out.flush();
        }
        out.close();
        bufr.close();
    }
}
</code></pre>
<h4 id="sequenceinputstream-enumeration"><a class="header" href="#sequenceinputstream-enumeration">SequenceInputStream, Enumeration</a></h4>
<p>SequenceInputStream 接收一个枚举类型的对象</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
public class SequenceInputStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
    /*
    * 需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。
    */
    // Vector&lt;FileInputStream&gt; v = new Vector&lt;FileInputStream&gt;();
    // v.add(new FileInputStream(&quot;1.txt&quot;));
    // v.add(new FileInputStream(&quot;2.txt&quot;));
    // v.add(new FileInputStream(&quot;3.txt&quot;));
    // Enumeration&lt;FileInputStream&gt; en = v.elements();
    ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
    for(int x=1; x&lt;=3; x++){
        al.add(new FileInputStream(x+&quot;.txt&quot;));
    }
    Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
    /*
    final Iterator&lt;FileInputStream&gt; it = al.iterator();
    Enumeration&lt;FileInputStream&gt; en = new Enumeration&lt;FileInputStream&gt;(){
    @Override
    public boolean hasMoreElements() {
    return it.hasNext();
    }
    @Override
    public FileInputStream nextElement() {
    return it.next();
    }
    };*/
    SequenceInputStream sis = new SequenceInputStream(en);
    FileOutputStream fos = new FileOutputStream(&quot;1234.txt&quot;);
    byte[] buf = new byte[1024];
    int len = 0;
    while((len=sis.read(buf))!=-1){
        fos.write(buf,0,len);
    }
    fos.close();
    sis.close();
}
}
</code></pre>
<h4 id="demos-1"><a class="header" href="#demos-1">Demos</a></h4>
<p><strong>文件切割与合并</strong></p>
<p>文件切割：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
/*
* 文件切割器。
*/
public class SplitFileDemo {
    
    private static final int SIZE = 1024 * 1024;
    /**
    * @param args
    * @throws Exception
    */
    public static void main(String[] args) throws Exception {
        File file = new File(&quot;c:\\aa.mp3&quot;);
        splitFile_2(file);
    }
    private static void splitFile_2(File file) throws IOException {
        // 用读取流关联源文件。
        FileInputStream fis = new FileInputStream(file);
        // 定义一个1M的缓冲区。
        byte[] buf = new byte[SIZE];
        // 创建目的。245
        FileOutputStream fos = null;
        int len = 0;
        int count = 1;
        /*
        * 切割文件时，必须记录住被切割文件的名称，以及切割出来碎片文件的个数。 以方便于合并。
        * 这个信息为了进行描述，使用键值对的方式。用到了properties对象
        *
        */
        Properties prop = new Properties();
        File dir = new File(&quot;c:\\partfiles&quot;);
        if (!dir.exists())
            dir.mkdirs();
        while ((len = fis.read(buf)) != -1) {
            fos = new FileOutputStream(new File(dir, (count++) + &quot;.part&quot;));
            fos.write(buf, 0, len);
            fos.close();
        }
        //将被切割文件的信息保存到prop集合中。
        prop.setProperty(&quot;partcount&quot;, count+&quot;&quot;);
        prop.setProperty(&quot;filename&quot;, file.getName());
        fos = new FileOutputStream(new File(dir,count+&quot;.properties&quot;));
        //将prop集合中的数据存储到文件中。
        prop.store(fos, &quot;save file info&quot;);
        fos.close();
        fis.close();
    }
    public static void splitFile(File file) throws IOException {
        // 用读取流关联源文件。
        FileInputStream fis = new FileInputStream(file);
        // 定义一个 1M 的缓冲区。
        byte[] buf = new byte[SIZE];
        // 创建目的。
        FileOutputStream fos = null;
        int len = 0;
        int count = 1;
        File dir = new File(&quot;c:\\partfiles&quot;);
        if (!dir.exists())
            dir.mkdirs();
        while ((len = fis.read(buf)) != -1) {
            fos = new FileOutputStream(new File(dir, (count++) + &quot;.part&quot;));
            fos.write(buf, 0, len);
        }
        fos.close();
        fis.close();
    }
}
</code></pre>
<p>文件合并：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Properties;
public class MergeFile {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        File dir = new File(&quot;c:\\partfiles&quot;);
        mergeFile_2(dir);
    }
    public static void mergeFile_2(File dir) throws IOException {
        /*
        * 获取指定目录下的配置文件对象。
        */
        File[] files = dir.listFiles(new SuffixFilter(&quot;.properties&quot;));
        if(files.length!=1)
            throw new RuntimeException(dir+&quot;,该目录下没有properties扩展名的文件或者不唯一&quot;);//记录配置文件对象。
        File confile = files[0];
        //获取该文件中的信息================================================。
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream(confile);
        prop.load(fis);
        String filename = prop.getProperty(&quot;filename&quot;);
        int count = Integer.parseInt(prop.getProperty(&quot;partcount&quot;));
        //获取该目录下的所有碎片文件。 ==============================================
        File[] partFiles = dir.listFiles(new SuffixFilter(&quot;.part&quot;));
        if(partFiles.length!=(count-1)){
            throw new RuntimeException(&quot; 碎片文件不符合要求，个数不对!应该&quot;+count+&quot;个&quot;);
        }
        //将碎片文件和流对象关联 并存储到集合中。
        ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
        for(int x=0; x&lt;partFiles.length; x++){
            al.add(new FileInputStream(partFiles[x]));
        }
        //将多个流合并成一个序列流。
        Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
        SequenceInputStream sis = new SequenceInputStream(en);
        FileOutputStream fos = new FileOutputStream(new File(dir,filename));
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=sis.read(buf))!=-1){
            fos.write(buf,0,len);
        }
        fos.close();
        sis.close();
    }
    public static void mergeFile(File dir) throws IOException{
        ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
        for(int x=1; x&lt;=3 ;x++){
            al.add(new FileInputStream(new File(dir,x+&quot;.part&quot;)));
        }
        Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
        SequenceInputStream sis = new SequenceInputStream(en);
        FileOutputStream fos = new FileOutputStream(new File(dir,&quot;1.bmp&quot;));
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=sis.read(buf))!=-1){
            fos.write(buf,0,len);
        }
        fos.close();
        sis.close();
    }
}
</code></pre>
<h4 id="serializable-objectstream"><a class="header" href="#serializable-objectstream">Serializable, ObjectStream</a></h4>
<p>序列化和反序列化。序列化：将对象存储到文件中。</p>
<pre><code class="language-java">import java.io.Serializable;
/*
* Serializable:用于给被序列化的类加入ID号。
* 用于判断类和对象是否是同一个版本。
*/
public class Person implements Serializable/*标记接口*/ {
    /**
    * transient:非静态数据不想被序列化可以使用这个关键字修饰。
    */
    private static final long serialVersionUID = 9527l;
    private transient String name;
    private static int age;
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import cn.itcast.io.p2.bean.Person;

public class ObjectStreamDemo {
    /**
    * @param args
    * @throws IOException
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws IOException, ClassNotFoundException
    {
        // writeObj();
        readObj();
    }
    public static void readObj() throws IOException, ClassNotFoundException {
        ObjectInputStream ois = new ObjectInputStream(new
                                                      FileInputStream(&quot;obj.object&quot;));
        //对象的反序列化。
        Person p = (Person)ois.readObject();
        System.out.println(p.getName()+&quot;:&quot;+p.getAge());
        ois.close();
    }
    public static void writeObj() throws IOException, IOException {
        ObjectOutputStream oos = new ObjectOutputStream(new
                                                        FileOutputStream(&quot;obj.object&quot;));
        //对象序列化。 被序列化的对象必须实现Serializable接口。
        oos.writeObject(new Person(&quot;小强&quot;,30));
        oos.close();
    }
}
</code></pre>
<h4 id="randomaccessfile"><a class="header" href="#randomaccessfile">RandomAccessFile</a></h4>
<h4 id="pipedstream"><a class="header" href="#pipedstream">PipedStream</a></h4>
<p>管道流</p>
<pre><code class="language-java">import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
public class PipedStream {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        PipedInputStream input = new PipedInputStream();
        PipedOutputStream output = new PipedOutputStream();
        input.connect(output);
           new Thread(new Input(input)).start();
        new Thread(new Output(output)).start();
    }
}
class Input implements Runnable{
    private PipedInputStream in;
    Input(PipedInputStream in){
        this.in = in;
    }
    public void run(){
        try {
            byte[] buf = new byte[1024];
            int len = in.read(buf);
            String s = new String(buf,0,len);
            System.out.println(&quot;s=&quot;+s);
            in.close();
        } catch (Exception e) {
            // TODO: handle exception
        }
    }
}
class Output implements Runnable{
    private PipedOutputStream out;
    Output(PipedOutputStream out){
        this.out = out;
    }
    public void run(){
        try {
            Thread.sleep(5000);
            out.write(&quot;hi，管道来了！ &quot;.getBytes());
        } catch (Exception e) {
            // TODO: handle exception
        }
    }
}
</code></pre>
<h4 id="datastream"><a class="header" href="#datastream">DataStream</a></h4>
<pre><code class="language-java">import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
public class DataSteamDemo {
    /**
* @param args
* @throws IOException
*/
    public static void main(String[] args) throws IOException {
        // writeData();
        readData();
    }
    public static void readData() throws IOException {
        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;));
        String str = dis.readUTF();
        System.out.println(str);
    }
    public static void writeData() throws IOException {
        DataOutputStream dos = new DataOutputStream(new
                                                    FileOutputStream(&quot;data.txt&quot;));
        dos.writeUTF(&quot;你好&quot;);
        dos.close();
    }
}
</code></pre>
<h4 id="bytearraystream"><a class="header" href="#bytearraystream">ByteArrayStream</a></h4>
<p>字节数组流</p>
<pre><code class="language-java">import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
public class ByteArrayStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) {
        ByteArrayInputStream bis = new ByteArrayInputStream(&quot;abcedf&quot;.getBytes());
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        int ch = 0;
        while((ch=bis.read())!=-1){
            bos.write(ch);
        }
        System.out.println(bos.toString());
    }
}
</code></pre>
<h4 id="编解码"><a class="header" href="#编解码">编解码</a></h4>
<p>编码：字符串 --&gt; <strong>字节数组</strong></p>
<p>解码：<strong>字节数组</strong> --&gt; 字符串</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

public class EncodeDemo {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        /*
         * 字符串 --&gt; 字节数组：编码。
         * 字节数组 --&gt; 字符串：解码。
         *
         * 你好： GBK: -60 -29 -70 -61
         *
         * 你好: utf-8: -28 -67 -96 -27 -91 -67
         *
         *
         * 如果你编错了，解不出来。
         * 如果编对了，解错了，有可能有救。
         */
        String str = &quot;谢谢&quot;;
        byte[] buf = str.getBytes(&quot;gbk&quot;); // 编码
        String s1 = new String(buf,&quot;UTF-8&quot;); // 解码，解错了
        System.out.println(&quot;s1=&quot;+s1); // лл
        byte[] buf2 = s1.getBytes(&quot;UTF-8&quot;);//获取源字节.
        printBytes(buf2); // -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -17 -65 -67 -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -48 -69 -48 -69
        String s2 = new String(buf2,&quot;GBK&quot;); // 解码，解对了
        System.out.println(&quot;s2=&quot;+s2);
        // encodeDemo(str);
    }
    /**
     * @param str
     * @throws UnsupportedEncodingException
     */
    public static void encodeDemo(String str)
            throws UnsupportedEncodingException {
        //编码；
        byte[] buf = str.getBytes(&quot;UTF-8&quot;);
        // printBytes(buf);
        //解码：
        String s1 = new String(buf,&quot;UTF-8&quot;);
        System.out.println(&quot;s1=&quot;+s1);
    }
    private static void printBytes(byte[] buf) {
        for(byte b : buf){
            System.out.print(b +&quot; &quot;);
        }
    }
}
</code></pre>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<pre><code>IO流：
输入流：
输出流：
字节流：
字符流：
	为了处理文字数据方便而出现的对象。
    其实这些对象的内部使用的还是字节流(因为文字最终也是字节数据)
    只不过，通过字节流读取了相对应的字节数，没有对这些字节直接操作。
    而是去查了指定的(本机默认的)编码表，获取到了对应的文字。
    简单说：字符流就是 ： 字节流+编码表。
--------------------------------------------------------------------------------
缓冲区：
	提高效率的，提高谁的效率？提高流的操作数据的效率。
	所以创建缓冲区之前必须先有流。
	缓冲区的基本思想：其实就是定义容器将数据进行临时存储。
	对于缓冲区对象，其实就是将这个容器进行了封装，并提供了更多高效的操作方法。
	缓冲区可以提高流的操作效率。
	其实是使用了一种设计思想完成。设计模式：装饰设计模式。
	
缓冲区的设计原理，装饰设计模式的由来：
    Writer
        |--TextWriter
        |--MediaWriter
    现在要对该体系中的对象进行功能的增强。增强的最常见手段就是缓冲区。
    先将数据写到缓冲区中，再将缓冲区中的数据一次性写到目的地。
    按照之前学习过的基本的思想，那就是对对象中的写方法进行覆盖。
    产生已有的对象子类，复写write方法。不往目的地写，而是往缓冲区写。
    所以这个体系会变成这样。
    Writer
    |--TextWriter write:往目的地
    |--BufferTextWriter write：往缓冲区写
    |--MediaWriter
    |--BufferMediaWriter
    想要写一些其他数据。就会子类。 DataWriter，为了提高其效率，还要创建该类的子类。 BufferDataWriter
    Writer
    |--TextWriter write:往目的地
    |--BufferTextWriter write：往缓冲区写
    |--MediaWriter
    |--BufferMediaWriter
    |--DataWriter
    |--BufferDataWriter
    发现这个体系相当的麻烦。每产生一个子类都要有一个高效的子类。
    而且这写高效的子类使用的功能原理都一样，都是缓冲区原理。无论数据是什么。
    都是通过缓冲区临时存储提高效率的。
    那么， 对于这个体系就可以进行优化，因为没有必要让每一个对象都具备相同功能的子类。
    哪个对象想要进行效率的提高，只要让缓冲区对其操作即可。也就说，单独将缓冲区进行封装变成对象。
    //它的出现为了提高对象的效率。所以必须在创建它的时候先有需要被提高效率的对象
    class BufferWriter
    {
    [];
    BufferedWriter(Writer w)
    { }
    /*
    BufferWriter(TextWriter w)
    { }
    BufferedWriter(MediaWriter w)
    { }
    */
    }
    BufferWriter的出现增强了Writer中的write方法。
    但是增强过后， BufferWriter对外提供的还是write方法。只不过是高效的。
    所以写的实质没有变，那么BufferWriter也是Writer中的一员。
    所以体系就会变成这样。
    Writer
    |--TextWriter
    |--MediaWriter
    |--BufferWriter
    |--DataWriter
    BufferWriter出现了避免了继承体系关系的臃肿，比继承更为灵活。
    如果是为了增强功能，这样方式解决起来更为方便。
    所以就把这种优化，总结出来，起个名字：装饰设计模式。
    装饰类和被装饰类肯定所属于同一个体系。
    既然明确了BufferedReader由来。
    我们也可以独立完成缓冲区的建立
    原理；
    1，使用流的read方法从源中读取一批数据存储到缓冲区的数组中。
    2，通过计数器记录住存储的元素个数。
    3，通过数组的角标来获取数组中的元素(从缓冲区中取数据).
    4，指针会不断的自增，当增到数组长度，会归0.计数器会自减，当减到0时，就在从源拿一批数据进缓冲区。
    
内容补足：
MyBufferedReader
LineNumberReader ：可以定义行号。

--------------------------------------------------------------------------------
字符流：
    FileReader
    FileWriter
    BufferedReader
    BufferedWriter
    
字节流：
	InputStream OutputStream
	
操作文件的字节流对象
    FileOutputStream
    FileInputStream
    BufferedOutputStream
    BufferedInputStream

--------------------------------------------------------------------------------
转换流：
InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));
InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;gbk&quot;);
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;));
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),&quot;gbk&quot;);

转换流：字节流+编码表。
转换流的子类： FileReader， FileWriter：字节流+本地默认码表(GBK)。
如果操作文本文件使用的本地默认编码表完成编码。可以使用FileReader，或者FileWriter。因为这样写简
便。
如果对操作的文本文件需要使用指定编码表进行编解码操作，这时必须使用转换流来完成。

--------------------------------------------------------------------------------
IO流的操作规律总结：
1，明确体系：
数据源： InputStream ， Reader
数据汇： OutputStream， Writer
2，明确数据：因为数据分两种：字节，字符。
数据源：是否是纯文本数据呢？
是： Reader
否： InputStream
数据汇：
是： Writer
否： OutputStream
到这里就可以明确具体要使用哪一个体系了。
剩下的就是要明确使用这个体系中的哪个对象。
3，明确设备：
数据源：
键盘： System.in
硬盘： FileXXX
内存：数组。
网络： socket socket.getInputStream();
数据汇：
控制台： System.out
硬盘： FileXXX
内存：数组
网络： socket socket.getOutputStream();
4，明确额外功能：
1，需要转换？是，使用转换流。 InputStreamReader OutputStreamWriter
2，需要高效？是，使用缓冲区。 Buffered
3，需要其他？
--------------------------------------------------------------------------------
1，复制一个文本文件。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘上的一个文件。 FileReader
目的：硬盘上的一个文件。 FileWriter269
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4，需要额外功能吗？
需要，高效，使用buffer
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
2，读取键盘录入，将数据存储到一个文件中。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：键盘， System.in
目的：硬盘， FileWriter
InputStream in = System.in;
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
4，需要额外功能吗？
需要，因为源明确的体系时Reader。可是源的设备是System.in。
所以为了方便于操作文本数据，将源转成字符流。需要转换流。 InputStreamReader
InputStreamReader isr = new InputStreamReader(System.in);
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
需要高效不?需要。 Buffer
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;));
3，读取一个文本文件，将数据展现在控制台上。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘文件， FileReader。
目的：控制台： System.out。
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStream out = System.out;
4，需要额外功能？
因为源是文本数据，确定是Writer体系。所以为了方便操作字符数据，
需要使用字符流，但是目的又是一个字节输出流。
需要一个转换流， OutputStreamWriter
FileReader fr = new FileReader(&quot;a.txt&quot;);270
OutputStreamWriter osw = new OutputStreamWriter(System.out);
需要高效吗？需要。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new
OutputStreamWriter(System.out));
4，读取键盘录入，将数据展现在控制台上。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：键盘： System.in
目的：控制台： System.out
InputStream in = System.in;
OutputStream out = System.out;
4，需要额外功能吗？
因为处理的数据是文本数据，同时确定是字符流体系。
为方便操作字符数据的可以将源和目的都转成字符流。使用转换流。
为了提高效率，使用Buffer
BufferedReader bufr =new BufferedReader(new
InputStreamReader(Systme.in));
BufferedWriter bufw = new BufferedWriter(new
OutputStreamWriter(System.out));
5，读取一个文本文件，将文件按照指定的编码表UTF-8进行存储，保存到另一个文件中。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘： FileReader.
目的：硬盘： FileWriter
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4，额外功能：
注意：目的中虽然是一个文件，但是需要指定编码表。
而直接操作文本文件的FileWriter本身内置的是本地默认码表。无法明确具体指定码表。271
这时就需要转换功能。 OutputStreamWriter,而这个转换流需要接受一个字节输出流，而且
对应的目的是一个文件。这时就使用字节输出流中的操作文件的流对象。 FileOutputStream.
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(new
FileOutputStream(&quot;b.txt&quot;),&quot;UTF-8&quot;);
需要高效吗？
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw =
new BufferedWriter(new OutputStreamWriter(new
FileOutputStream(&quot;b.txt&quot;),&quot;UTF-8&quot;));
目前为止， 10个流对象重点掌握。
字符流：
FileReader
FileWriter
BufferedReader
BufferedWriter
InputStreamReader
OutputStreamWrier
字节流：
FileInputStream
FileOutputStream
BufferedInputStream
BufferedOutputStream

--------------------------------------------------------------------------------
File类：
用于将文件和文件夹封装成对象。
1，创建。
boolean createNewFile():如果该文件不存在，会创建，如果已存在，则不创建。不会像输出流
一样会覆盖。
boolean mkdir();
boolean mkdirs();
2，删除。
boolean delete();
void deleteOnExit();
3，获取：
String getAbsolutePath();
String getPath();
String getParent();
String getName();
long length();
long lastModified();
4，判断：
boolean exists();
boolean isFile();
boolean isDirectory();
5，

--------------------------------------------------------------------------------
IO中的其他功能流对象：

打印流：
    PrintStream：字节打印流。
    特点：
    1，构造函数接收File对象，字符串路径，字节输出流。意味着打印目的可以有很多。
    2，该对象具备特有的方法 打印方法 print println,可以打印任何类型的数据。
    3，特有的print方法可以保持任意类型数据表现形式的原样性，将数据输出到目的地。
    对于OutputStream父类中的write，是将数据的最低字节写出去。
    PrintWriter：字符打印流。
    特点：
    1，当操作的数据是字符时，可以选择PrintWriter，比PrintStream要方便。
    2，它的构造函数可以接收 File对象，字符串路径，字节输出流，字符输出流。
    3，构造函数中，如果参数是输出流，那么可以通过指定另一个参数true完成自动刷新，该true对
    println方法有效。
    什么时候用？
    当需要保证数据表现的原样性时，就可以使用打印流的打印方法来完成，这样更为方便。
    保证原样性的原理：其实就是将数据变成字符串，在进行写入操作
    
SequenceInputStream:
    特点：
    1，将多个字节读取流和并成一个读取流，将多个源合并成一个源，操作起来方便。
    2，需要的枚举接口可以通过Collections.enumeration(collection);
    
ObjectInputStream 和 ObjectOutputStream
    对象的序列化和反序列化。
    writeObject readObject273
    Serializable标记接口
    关键字： transient
    
RandomAccessFile:
    特点：
    1，即可读取，又可以写入。
    2，内部维护了一个大型的byte数组，通过对数组的操作完成读取和写入。
    3，通过getFilePointer方法获取指针的位置，还可以通过seek方法设置指针的位置。
    4，该对象的内容应该封装了字节输入流和字节输出流。
    5，该对象只能操作文件。
    通过seek方法操作指针，可以从这个数组中的任意位置上进行读和写
    可以完成对数据的修改。
    但是要注意：数据必须有规律。
    
管道流：需要和多线程技术相结合的流对象。
    PipedOutputStream
    PipedInputStream
    
用操作基本数据类型值的对象：
    DataInputStream
    DataOutputStream
    
设备是内存的流对象。
    ByteArrayInputStream ByteArrayOutputStream
    CharArrayReader CharArrayWriter
    
--------------------------------------------------------------------------------
IO流体系：

字符流：
Reader
    |--BufferedReader:
    |--LineNumberReader
    |--CharArrayReader
    |--StringReader
    |--InputStreamReaer
    |--FileReader
Writer
    |--BufferedWriter
    |--CharArrayWriter
    |--StringWriter
    |--OutputStreamWriter
    |--FileWriter
    |--PrintWriter
    
字节流：
InputStream
    |--FileInputStream:
    |--FilterInputStream
    |--BufferedInputStream
    |--DataInputStream
    |--ByteArrayInputStream
    |--ObjectInputStream
    |--SequenceInputStream
    |--PipedInputStream
OutputStream
    |--FileOutputStream
    |--FilterOutputStream
    |--BufferedOutputStream
    |--DataOutputStream
    |--ByteArrayOutputStream
    |--ObjectOutputStream
    |--PipedOutputStream
    |--PrintStream
</code></pre>
<h2 id="网络编程"><a class="header" href="#网络编程">网络编程</a></h2>
<h3 id="ip"><a class="header" href="#ip">IP</a></h3>
<pre><code class="language-java">import java.net.InetAddress;
import java.net.UnknownHostException;
public class IPDemo {
    /**
     * @param args
     * @throws UnknownHostException
     */
    public static void main(String[] args) throws UnknownHostException {
        //获取本地主机ip地址对象。
        InetAddress ip = InetAddress.getLocalHost();
        //获取其他主机的ip地址对象。
        //ip = InetAddress.getByName(&quot;220.181.38.150&quot;);
        //InetAddress.getByName(&quot;my_think&quot;);
        System.out.println(ip.getHostAddress()); // 获取 IP 地址
        System.out.println(ip.getHostName()); // 获取域名
    }
}
</code></pre>
<h3 id="udp"><a class="header" href="#udp">UDP</a></h3>
<p><strong>send</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
public class UDPSendDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;发送端启动......&quot;);
        /*
        * 创建UDP传输的发送端。
        * 思路：
        * 1，建立udp的socket服务。
        * 2，将要发送的数据封装到数据包中。
        * 3，通过udp的socket服务将数据包发送出去。
        * 4，关闭socket服务。
        */
        //1, udpsocket服务。使用DatagramSocket对象。
        DatagramSocket ds = new DatagramSocket(8888);
        //2, 将要发送的数据封装到数据包中。
        String str = &quot;udp传输演示：哥们来了！ &quot;;
        // 使用DatagramPacket将数据封装到的该对象包中。
        byte[] buf = str.getBytes();
        DatagramPacket dp = new
            DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.100&quot;),10000);
        //3，通过udp的socket服务将数据包发送出去。使用send方法。
        ds.send(dp);
        //4，关闭资源。
        ds.close();
    }
}
</code></pre>
<p><strong>receive</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class UDPReceDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;接收端启动......&quot;);
        /*
        * 建立UDP接收端的思路。
        * 1，建立udp socket服务,因为是要接收数据，必须要明确一个端口号。
        * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据.
        * 3，使用socket服务的receive方法将接收的数据存储到数据包中。
        * 4，通过数据包的方法解析数据包中的数据。
        * 5，关闭资源
        */
        //1,建立udp socket服务。
        DatagramSocket ds = new DatagramSocket(10000);
        //2,创建数据包。
        byte[] buf = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buf,buf.length);
        //3,使用接收方法将数据存储到数据包中。
        ds.receive(dp);//阻塞式的。
        //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
        String ip = dp.getAddress().getHostAddress();
        int port = dp.getPort();
        String text = new String(dp.getData(),0,dp.getLength());
        System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+text);
        //5,关闭资源。
        ds.close();
    }
}
</code></pre>
<p><strong>交互</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
public class UDPSendDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;发送端启动......&quot;);
        /*
        * 创建UDP传输的发送端。
        * 思路：
        * 1，建立udp的socket服务。
        * 2，将要发送的数据封装到数据包中。
        * 3，通过udp的socket服务将数据包发送出去。
        * 4，关闭socket服务。
        */
        //1,udpsocket服务。使用DatagramSocket对象。
        DatagramSocket ds = new DatagramSocket(8888);
        // String str = &quot;udp传输演示：哥们来了！ &quot;;
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        String line = null;
        while((line=bufr.readLine())!=null){
            byte[] buf = line.getBytes();
            DatagramPacket dp =
                new
                DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.100&quot;),10000);
            ds.send(dp);
            if(&quot;886&quot;.equals(line))
                break;
        }
        //4，关闭资源。
        ds.close();
    }
}

//（信息接收端）
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class UDPReceDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;接收端启动......&quot;);
        /*
        * 建立UDP接收端的思路。
        * 1，建立udp socket服务,因为是要接收数据，必须要明确一个端口号。
        * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据.
        * 3，使用socket服务的receive方法将接收的数据存储到数据包中。
        * 4，通过数据包的方法解析数据包中的数据。
        * 5，关闭资源
        */
        //1,建立udp socket服务。
        DatagramSocket ds = new DatagramSocket(10000);
        while(true){
            //2,创建数据包。
            byte[] buf = new byte[1024];
            DatagramPacket dp = new DatagramPacket(buf,buf.length);
            //3,使用接收方法将数据存储到数据包中。
            ds.receive(dp);//阻塞式的。
            //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
            String ip = dp.getAddress().getHostAddress();
            int port = dp.getPort();
            String text = new String(dp.getData(),0,dp.getLength());
            System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+text);
        }
        //5,关闭资源。
        // ds.close();
    }
}
</code></pre>
<p><strong>UDP 聊天程序，多线程</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
public class Send implements Runnable {
    private DatagramSocket ds;
    public Send(DatagramSocket ds){
        this.ds = ds;
    }
    @Override
    public void run() {
        try {
            BufferedReader bufr = new BufferedReader(new
                                                     InputStreamReader(System.in));
            String line = null;
            while((line=bufr.readLine())!=null){
                byte[] buf = line.getBytes();
                DatagramPacket dp =
                    new
                    DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.255&quot;),10001);
                ds.send(dp);
                if(&quot;886&quot;.equals(line))
                    break;
            }
            ds.close();
        } catch (Exception e) {
        }
    }
}
//（接收端）
package cn.itcast.net.p3.chat;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class Rece implements Runnable {
    private DatagramSocket ds;
    public Rece(DatagramSocket ds) {
        this.ds = ds;
    }
    @Override
    public void run() {
        try {
            while (true) {
                // 2,创建数据包。
                byte[] buf = new byte[1024];
                DatagramPacket dp = new DatagramPacket(buf, buf.length);
                // 3,使用接收方法将数据存储到数据包中。
                ds.receive(dp);// 阻塞式的。
                // 4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
                String ip = dp.getAddress().getHostAddress();
                int port = dp.getPort();
                String text = new String(dp.getData(), 0, dp.getLength());
                System.out.println(ip + &quot;::&quot; + text);
                if(text.equals(&quot;886&quot;)){
                    System.out.println(ip+&quot;....退出聊天室&quot;);
                }
            }
        } catch (Exception e) {
        }
    }
}

// 开启发送和接收两个线程开始运行聊天
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.SocketException;
public class ChatDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        DatagramSocket send = new DatagramSocket();
        DatagramSocket rece = new DatagramSocket(10001);
        new Thread(new Send(send)).start();
        new Thread(new Rece(rece)).start();
    }
}
</code></pre>
<h3 id="tcp"><a class="header" href="#tcp">TCP</a></h3>
<p><strong>客户端</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class ClientDemo {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //客户端发数据到服务端
        /*
        * Tcp传输，客户端建立的过程。
        * 1，创建tcp客户端socket服务。使用的是Socket对象。
        * 建议该对象一创建就明确目的地。要连接的主机。
        * 2，如果连接建立成功，说明数据传输通道已建立。
        * 该通道就是socket流 ,是底层建立好的。 既然是流，说明这里既有输入，又有输出。
        * 想要输入或者输出流对象，可以找Socket来获取。
        * 可以通过getOutputStream(),和getInputStream()来获取两个字节流。
        * 3，使用输出流，将数据写出。
        * 4，关闭资源。
        */
        //创建客户端socket服务。
        Socket socket = new Socket(&quot;192.168.1.100&quot;,10002);
        //获取socket流中的输出流。
        OutputStream out = socket.getOutputStream();
        //使用输出流将指定的数据写出去。
        out.write(&quot;tcp演示：哥们又来了!&quot;.getBytes());
        //关闭资源。
        socket.close();
    }
}
</code></pre>
<p><strong>服务端</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        // 服务端接收客户端发送过来的数据，并打印在控制台上。
        /*
        * 建立tcp服务端的思路：
        * 1，创建服务端socket服务。通过ServerSocket对象。
        * 2，服务端必须对外提供一个端口，否则客户端无法连接。
        * 3，获取连接过来的客户端对象。
        * 4，通过客户端对象获取socket流读取客户端发来的数据
        * 并打印在控制台上。
        * 5，关闭资源。关客户端，关服务端。
        */
        //1创建服务端对象。
        ServerSocket ss = new ServerSocket(10002);
        //2,获取连接过来的客户端对象。
        Socket s = ss.accept();//阻塞式.
        String ip = s.getInetAddress().getHostAddress();
        //3，通过socket对象获取输入流，要读取客户端发来的数据
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(ip+&quot;:&quot;+text);
        s.close();
        ss.close();
    }
}
</code></pre>
<p><strong>交互</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class ClientDemo2 {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //客户端发数据到服务端
        /*
        * Tcp传输，客户端建立的过程。
        * 1，创建tcp客户端socket服务。使用的是Socket对象。
        * 建议该对象一创建就明确目的地。要连接的主机。
        * 2，如果连接建立成功，说明数据传输通道已建立。
        * 该通道就是socket流 ,是底层建立好的。 既然是流，说明这里既有输入，又有输出。
        * 想要输入或者输出流对象，可以找Socket来获取。
        * 可以通过getOutputStream(),和getInputStream()来获取两个字节流。
        * 3，使用输出流，将数据写出。
        * 4，关闭资源。
        */
        Socket socket = new Socket(&quot;192.168.1.100&quot;, 10002);
        OutputStream out = socket.getOutputStream();
        out.write(&quot;tcp演示：哥们又来了!&quot;.getBytes());
        // 读取服务端返回的数据,使用 socket 读取流。
        InputStream in = socket.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(text);
        //关闭资源。
        socket.close();
    }
}
//（服务端）
package cn.itcast.net.p4.tcp;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        // 服务端接收客户端发送过来的数据，并打印在控制台上。
        /*
        * 建立tcp服务端的思路：
        * 1，创建服务端socket服务。通过ServerSocket对象。
        * 2，服务端必须对外提供一个端口，否则客户端无法连接。
        * 3，获取连接过来的客户端对象。
        * 4，通过客户端对象获取socket流读取客户端发来的数据
        * 并打印在控制台上。
        * 5，关闭资源。关客户端，关服务端。
        */
        //1创建服务端对象。
        ServerSocket ss = new ServerSocket(10002);
        //2,获取连接过来的客户端对象。
        Socket s = ss.accept();
        String ip = s.getInetAddress().getHostAddress();
        //3，通过socket对象获取输入流，要读取客户端发来的数据
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(ip+&quot;:&quot;+text);
        //使用客户端socket对象的输出流给客户端返回数据
        OutputStream out = s.getOutputStream();
        out.write(&quot;收到&quot;.getBytes());
        s.close();
        ss.close();
    }
}
</code></pre>
<p>**TCP创建一个英文大写服务器  **</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;
public class TransClient {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        /*
        * 思路：
        * 客户端：
        * 1，需要先有socket端点。
        * 2，客户端的数据源：键盘。
        * 3，客户端的目的： socket.
        * 4，接收服务端的数据，源： socket。
        * 5，将数据显示在打印出来：目的：控制台.
        * 6，在这些流中操作的数据，都是文本数据。
        * 转换客户端:
        * 1,创建socket客户端对象。
        * 2,获取键盘录入。
        * 3，将录入的信息发送给socket输出流。
        */
        //1,创建socket客户端对象。
        Socket s = new Socket(&quot;192.168.1.100&quot;,10004);
        //2，获取键盘录入。
        BufferedReader bufr =
            new BufferedReader(new InputStreamReader(System.in));
        //3,socket输出流。
        // new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        //4,socket输入流，读取服务端返回的大写数据
        BufferedReader bufIn = new BufferedReader(new
                                                  InputStreamReader(s.getInputStream()));
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            // out.print(line+&quot;\r\n&quot;);
            // out.flush();
            out.println(line);
            //读取服务端发回的一行大写数。
            String upperStr = bufIn.readLine();
            System.out.println(upperStr);
        }
        s.close();
    }
}

//（服务端）
package cn.itcast.net.p5.tcptest;
import java.io.BufferedReader;292
    import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
public class TransServer {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * 转换服务端。
        * 分析：
        * 1， serversocket服务。
        * 2，获取socket对象。
        * 3，源： socket，读取客户端发过来的需要转换的数据。
        * 4，目的：显示在控制台上。
        * 5，将数据转成大写发给客户端。
        */
        //1,
        ServerSocket ss = new ServerSocket(10004);
        //2,获取socket对象。
        Socket s = ss.accept();
        //获取ip.
        String ip = s.getInetAddress().getHostAddress();
        System.out.println(ip+&quot;......connected&quot;);
        //3,获取socket读取流，并装饰。
        BufferedReader bufIn = new BufferedReader(new
                                                  InputStreamReader(s.getInputStream()));
        //4,获取socket的输出流，并装饰。
        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        String line = null;
        while((line=bufIn.readLine())!=null){
            System.out.println(line);
            out.println(line.toUpperCase());
            // out.print(line.toUpperCase()+&quot;\r\n&quot;);
            // out.flush();
        }
        s.close();
        ss.close();
    }
}
</code></pre>
<p><strong>上传图片</strong></p>
<pre><code class="language-java">import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class UploadTask implements Runnable {
    private static final int SIZE = 1024*1024*2;
    private Socket s;
    public UploadTask(Socket s) {
        this.s = s;
    }
    @Override
    public void run() {
        int count = 0;
        String ip = s.getInetAddress().getHostAddress();
        System.out.println(ip + &quot;.....connected&quot;);
        try{
            // 读取客户端发来的数据。
            InputStream in = s.getInputStream();
            // 将读取到数据存储到一个文件中。
            File dir = new File(&quot;c:\\pic&quot;);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            File file = new File(dir, ip + &quot;.jpg&quot;);
            //如果文件已经存在于服务端
            while(file.exists()){
                file = new File(dir,ip+&quot;(&quot;+(++count)+&quot;).jpg&quot;);
            }
            FileOutputStream fos = new FileOutputStream(file);
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = in.read(buf)) != -1) {
                fos.write(buf, 0, len);
                if(file.length()&gt;SIZE){
                    System.out.println(ip+&quot;文件体积过大&quot;);
                    fos.close();
                    s.close();
                    System.out.println(ip+&quot;....&quot;+file.delete());
                    return ;
                }
            }
            // 获取socket输出流， 将上传成功字样发给客户端。
            OutputStream out = s.getOutputStream();
            out.write(&quot;上传成功&quot;.getBytes());
            fos.close();
            s.close();
        }catch(IOException e){
        }
    }
}
//（上传的客户端）
package cn.itcast.net.p1.uploadpic;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class UploadPicClient {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //1,创建客户端socket。
        Socket s = new Socket(&quot;192.168.1.100&quot;,10006);
        //2,读取客户端要上传的图片文件。
        FileInputStream fis = new FileInputStream(&quot;c:\\0.bmp&quot;);
        //3,获取socket输出流，将读到图片数据发送给服务端。
        OutputStream out = s.getOutputStream();
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=fis.read(buf))!=-1){
            out.write(buf,0,len);
        }
        //告诉服务端说：这边的数据发送完毕。让服务端停止读取。
        s.shutdownOutput();
        //读取服务端发回的内容。
        InputStream in = s.getInputStream();
        byte[] bufIn = new byte[1024];
        int lenIn = in.read(buf);
        String text = new String(buf,0,lenIn);
        System.out.println(text);
        fis.close();
        s.close();
    }
}
//（上传的服务端）
package cn.itcast.net.p1.uploadpic;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class UploadPicServer {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        //创建tcp的socket服务端。
        ServerSocket ss = new ServerSocket(10006);
        while(true){
            Socket s = ss.accept();
            new Thread(new UploadTask(s)).start();
        }
        //获取客户端。
        // ss.close();
    }
}
</code></pre>
<p><strong>网络编程小结</strong></p>
<pre><code>最常见的客户端：
浏览器 ： IE。
最常见的服务端：
服务器： Tomcat。
为了了解其原理：
自定义服务端，使用已有的客户端IE，了解一下客户端给服务端发了什么请求？
发送的请求是：
GET / HTTP/1.1 请求行 请求方式 /myweb/1.html 请求的资源路径 http协议版本。
请求消息头 . 属性名：属性值
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
application/x-shockwave-flash,
application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*
Accept: */*
Accept-Language: zh-cn,zu;q=0.5
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.2)
Host: 192.168.1.100:9090
//Host: www.huyouni.com:9090
Connection: Keep-Alive
//空行
//请求体。
//服务端发回应答消息。
HTTP/1.1 200 OK //应答行， http的协议版本 应答状态码 应答状态描述信息
应答消息属性信息。 属性名：属性值
Server: Apache-Coyote/1.1
ETag: W/&quot;199-1323480176984&quot;
Last-Modified: Sat, 10 Dec 2011 01:22:56 GMT
Content-Type: text/html
Content-Length: 199
Date: Fri, 11 May 2012 07:51:39 GMT
Connection: close
//空行
//应答体。
&lt;html&gt;303
&lt;head&gt;
&lt;title&gt;这是我的网页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;欢迎光临&lt;/h1&gt;
&lt;font size='5' color=&quot;red&quot;&gt;这是一个tomcat服务器中的资源。是一个html网页。 &lt;/font&gt;
&lt;/body&gt;
&lt;/html&gt;
--------------------------------------------------------------------------------
网络结构，
1,C/S client/server
特点：
该结构的软件，客户端和服务端都需要编写。
可发成本较高，维护较为麻烦。
好处：
客户端在本地可以分担一部分运算。
2,B/S browser/server
特点：
该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。
开发成本相对低，维护更为简单。
缺点：所有运算都要在服务端完成。
</code></pre>
<h2 id="反射机制"><a class="header" href="#反射机制">反射机制</a></h2>
<h3 id="什么是反射机制类的解剖"><a class="header" href="#什么是反射机制类的解剖">什么是反射机制（类的解剖）</a></h3>
<pre><code class="language-java">/*
* JAVA反射机制是在运行状态中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法；
* 对于任意一个对象，都能够调用它的任意一个方法和属性；
* 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
*
*
* 动态获取类中信息，就是java反射 。
* 可以理解为对类的解剖。
*
* 要想要对字节码文件进行解剖，必须要有字节码文件对象.
* 如何获取字节码文件对象呢？
*
*/
</code></pre>
<pre><code class="language-java">public class ReflectDemo {
    /**
    * @param args
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws ClassNotFoundException {
        getClassObject_3();
    }
    /*
    * 方式三：
    * 只要通过给定的类的 字符串名称就可以获取该类，更为扩展。
    * 可是用Class类中的方法完成。
    * 该方法就是 forName.
    * 这种方式只要有名称即可，更为方便，扩展性更强。
    */
    public static void getClassObject_3() throws ClassNotFoundException {
        String className = &quot;cn.itcast.bean.Person&quot;;
        Class clazz = Class.forName(className);
        System.out.println(clazz);
    }
    /*
    * 方式二：
    * 2，任何数据类型都具备一个静态的属性.class来获取其对应的Class对象。
    * 相对简单，但是还是要明确用到类中的静态成员。
    * 还是不够扩展。
    *
    */
    public static void getClassObject_2() {
        Class clazz = Person.class;
        Class clazz1 = Person.class;
        System.out.println(clazz==clazz1);
    }
    /*
    * 获取字节码对象的方式：
    * 1， Object类中的getClass()方法的。
    * 想要用这种方式，必须要明确具体的类，并创建对象。
    * 麻烦 .
    *
    */
    public static void getClassObject_1(){
        Person p = new Person();
        Class clazz = p.getClass();
        Person p1 = new Person();
        Class clazz1 = p1.getClass();
        System.out.println(clazz==clazz1);
    }
}
</code></pre>
<h3 id="类的解剖"><a class="header" href="#类的解剖">类的解剖</a></h3>
<p>获取构造函数：</p>
<pre><code class="language-java">import java.io.FileReader;
import java.lang.reflect.Constructor;
public class ReflectDemo2 {
    /**
    * @param args
    * @throws Exception
    * @throws InstantiationException
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws ClassNotFoundException,
    InstantiationException, Exception {
        createNewObject_2();
    }
    public static void createNewObject_2() throws Exception {
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person(&quot;小强&quot;,39);
        /*
        * 当获取指定名称对应类中的所体现的对象时，
        * 而该对象初始化不使用空参数构造该怎么办呢？
        * 既然是通过指定的构造 函数进行对象的初始化，
        * 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。
        * 该方法是： getConstructor(paramterTypes);
        *
        */
        String name = &quot;cn.itcast.bean.Person&quot;;
        //找寻该名称类文件，并加载进内存，并产生Class对象。
        Class clazz = Class.forName(name);
        //获取到了指定的构造函数对 象。
        Constructor constructor = clazz.getConstructor(String.class,int.class);
        //通过该构造器对象的newInstance方法进行对象的初始化。
        Object obj = constructor.newInstance(&quot;小明&quot;,38);
    }
    public static void createNewObject() throws ClassNotFoundException,
    InstantiationException, IllegalAccessException{
        //早期： new时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，
        // 并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象.
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person();
        //现在：
        String name = &quot;cn.itcast.bean.Person&quot;;
        //找寻该名称类文件，并加载进内存，并产生Class对象。
        Class clazz = Class.forName(name);
        //如何产生该类的对象呢？
        Object obj = clazz.newInstance();
    }
}
</code></pre>
<p>获取字段：</p>
<pre><code class="language-java">import java.lang.reflect.Field;
public class ReflectDemo3 {
    /**
    * @param args
    * @throws Exception
    */
    public static void main(String[] args) throws Exception {
        getFieldDemo();
    }
    /*
    * 获取字节码文件中的字段。
    */
    public static void getFieldDemo() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Field field = null;//clazz.getField(&quot;age&quot;);//只能获取公有的，
        field = clazz.getDeclaredField(&quot;age&quot;);//只获取本类，但包含私有。
        //对私有字段的访问取消权限检查。暴力访问。
        field.setAccessible(true);
        Object obj = clazz.newInstance();
        field.set(obj, 89);
        Object o = field.get(obj);
        System.out.println(o);
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person();
        // p.age = 30;
    }
}
</code></pre>
<p>获取公共函数：</p>
<pre><code class="language-java">import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
public class ReflectDemo4 {
    public ReflectDemo4() {
    }
    /**
* @param args
* @throws Exception
*/
    public static void main(String[] args) throws Exception {
        getMethodDemo_3();
    }
    public static void getMethodDemo_3() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class,int.class);
        Object obj = clazz.newInstance();
        method.invoke(obj, &quot;小强&quot;,89);
    }
    public static void getMethodDemo_2() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method method = clazz.getMethod(&quot;show&quot;, null); //获取空参数一般方法。
        // Object obj = clazz.newInstance();
        Constructor constructor = clazz.getConstructor(String.class,int.class);
        Object obj = constructor.newInstance(&quot;小明&quot;,37);
        method.invoke(obj, null);
    }
    /*
    * 获取指定Class中的所有公共函数。
    */
    public static void getMethodDemo() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method[] methods = clazz.getMethods();//获取的都是公有的方法。
        methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。
        for(Method method : methods){
            System.out.println(method);
        }
    }
}
</code></pre>
<h2 id="正则表达式-2"><a class="header" href="#正则表达式-2">正则表达式</a></h2>
<p>Demos:</p>
<pre><code class="language-java">public class RegexDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        String qq = &quot;123k4567&quot;;
        // checkQQ(qq);
        String regex = &quot;[1-9][0-9]{4,14}&quot;;//正则表达式。
        // boolean b = qq.matches(regex);
        // System.out.println(qq+&quot;:&quot;+b);
        // String str = &quot;aoooooooob&quot;;
        // String reg = &quot;ao{4,6}b&quot;;
        // boolean b = str.matches(reg);
        // System.out.println(str+&quot;:&quot;+b);
    }
    /*
    * 需求：定义一个功能对QQ号进行校验。
    * 要求：长度5~15. 只能是数字， 0不能开头
    */
    public static void checkQQ(String qq){
        int len = qq.length();
        if(len&gt;=5 &amp;&amp; len&lt;=15){
            if(!qq.startsWith(&quot;0&quot;)){
                try {
                    long l = Long.parseLong(qq);
                    System.out.println(l+&quot;:正确&quot;);
                }catch(NumberFormatException e){
                    System.out.println(qq+&quot;:含有非法字符&quot;);
                }
            }else{
                System.out.println(qq+&quot;:不能0开头&quot;);
            }
        }else{
            System.out.println(qq+&quot;:长度错误&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexDemo2 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
    * 正则表达式对字符串的常见操作:
    * 1, 匹配。
    * 其实使用的就是String类中的matches方法。
    *
    * 2，切割。
    * 其实使用的就是String类中的split方法。
    *
    * 3，替换。
    * 其实使用的就是String类中的replaceAll()方法。
    *
    * 4，获取。
    *
    */
        functionDemo_4();
    }
    /*
    * 获取
    * 将正则规则进行对象的封装。
    * Pattern p = Pattern.compile(&quot;a*b&quot;);
    * //通过正则对象的matcher方法字符串相关联。获取要对字符串操作的匹配器对象Matcher .
    * Matcher m = p.matcher(&quot;aaaaab&quot;);
    * //通过Matcher匹配器对象的方法对字符串进行操作。
    * boolean b = m.matches();
    */
    public static void functionDemo_4() {
        String str = &quot;da jia hao,ming tian bu fang jia!&quot;;
        String regex = &quot;\\b[a-z]{3}\\b&quot;;
        //1,将正则封装成对象。
        Pattern p = Pattern.compile(regex);
        //2, 通过正则对象获取匹配器对象。
        Matcher m = p.matcher(str);
        //使用Matcher对象的方法对字符串进行操作。
        //既然要获取三个字母组成的单词
        //查找。 find();
        System.out.println(str);
        while(m.find()){
            System.out.println(m.group());//获取匹配的子序列
            System.out.println(m.start()+&quot;:&quot;+m.end());
        }
    }
    /*
    * 替换
    */
    public static void functionDemo_3() {
        String str = &quot;zhangsanttttxiaoqiangmmmmmmzhaoliu&quot;;
        str = str.replaceAll(&quot;(.)\\1+&quot;, &quot;$1&quot;);
        System.out.println(str);
        String tel = &quot;15800001111&quot;; //158****1111;
        tel = tel.replaceAll(&quot;(\\d{3})\\d{4}(\\d{4})&quot;, &quot;$1****$2&quot;);
        System.out.println(tel);
    }
    /*
    * 切割。
    *
    * 组： ((A)(B(C)))
    */
    public static void functionDemo_2(){
        String str = &quot;zhangsanttttxiaoqiangmmmmmmzhaoliu&quot;;
        String[] names = str.split(&quot;(.)\\1+&quot;); //str.split(&quot;\\.&quot;);
        for(String name : names){
            System.out.println(name);
        }
    }
    /*
    * 演示匹配。
    */
    public static void functionDemo_1(){
        //匹配手机号码是否正确。
        String tel = &quot;15800001111&quot;;
        String regex = &quot;1[358]\\d{9}&quot;;
        boolean b = tel.matches(regex);
        System.out.println(tel+&quot;:&quot;+b);
    }
}
</code></pre>
<h2 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h2>
<p>https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424</p>
<p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类。</p>
<p>Demo:</p>
<pre><code class="language-java">public enum Color {
    RED, GREEN, BLUE;
}
</code></pre>
<p>编译出的 class 大概是这样的：</p>
<pre><code class="language-java">public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
</code></pre>
<p>编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>
<pre><code class="language-java">// name()
String s = Color.RED.name(); // &quot;RED&quot;

// ordinal() 返回定义的常量的顺序，从0开始计数
int n = Color.RED.ordinal(); 
</code></pre>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);
        } else {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
        }
    }
}

enum Weekday {
    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);

    public final int dayValue;
    private final String chinese;

    private Weekday(int dayValue, String chinese) {
        this.dayValue = dayValue;
        this.chinese = chinese;
    }

    @Override
    public String toString() {
        return this.chinese;
    }
}
</code></pre>
<p>注意，enum 在 Java 中是关键字，所以我们不能创建 enum 的包名，如果要在项目中创建枚举类，应该放在 enums 文件夹下！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-1"><a class="header" href="#java-1">Java</a></h1>
<p>[TOC]</p>
<p>毕向东 Java 学习笔记</p>
<h2 id="基础-1"><a class="header" href="#基础-1">基础</a></h2>
<ul>
<li>Java 先编译，再解释执行：
<ol>
<li><code>javac foo.java</code> 编译 Java 源文件生成字节码文件：<code>foo.class</code></li>
<li><code>java foo.class</code> 用虚拟机解释执行字节码文件</li>
</ol>
</li>
</ul>
<h3 id="命名规范-1"><a class="header" href="#命名规范-1">命名规范</a></h3>
<ul>
<li>类名：<code>HelloJava</code></li>
<li>类的成员变量、局部变量、成员方法：<code>firstDay</code>，<code>getName()</code></li>
<li>常量：<code>MAX_VALUE</code></li>
</ul>
<h3 id="for-循环-1"><a class="header" href="#for-循环-1">for 循环</a></h3>
<p><strong>增强 for 循环</strong></p>
<pre><code class="language-java">for( String name : names ) {
	System.out.print( name );
	System.out.print(&quot;,&quot;);
}
</code></pre>
<p><strong>for 的 while 实现</strong></p>
<pre><code class="language-java">for(;;){
    
}
</code></pre>
<h3 id="位运算-1"><a class="header" href="#位运算-1">位运算</a></h3>
<p><strong>&gt;&gt; 和 &gt;&gt;&gt;</strong></p>
<p><code>&gt;&gt;</code> ，正数高位补零，负数高位补一。<code>&gt;&gt;&gt;</code> 正负数都强制高位补 0</p>
<h3 id="基本数据类型-1"><a class="header" href="#基本数据类型-1">基本数据类型</a></h3>
<pre><code>java.lang.Number
	Integer
	Short
	Long
	Float
	Double
	Byte
	BigInteger
	BigDecimal
	
</code></pre>
<h2 id="数组-1"><a class="header" href="#数组-1">数组</a></h2>
<p>数组是<strong>相同类型</strong>数据的集合。</p>
<h3 id="数组的初始化-1"><a class="header" href="#数组的初始化-1">数组的初始化</a></h3>
<pre><code class="language-java">double[] myList;  // 定义一个数组的引用
</code></pre>
<pre><code class="language-java">int[] integers = new int[10]; // 在堆内存中 new 一个数组，堆内存中创建的对象都有默认值
for(int integer : integers){ // 增强 for 循环
    System.out.println(integer);
}

dataType[] arrayRefVar = {value0, value1, ..., valuek};
String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d1&quot;, &quot;a1&quot;};
</code></pre>
<pre><code class="language-java">// new 二维数组
int[][] arr = new int[3][2];
System.out.println(arr.length);
System.out.println(arr[1].length);
int[][] arr = new int[3][];

</code></pre>
<p>匿名数组：</p>
<pre><code class="language-java">public class Test { 
    public static void printArray(int []arr){
        for (int i : arr) {
            System.out.print(i);
        }
    }
    public static void main(String[] args) {
        //Many code
        printArray(new int[]{1,2,3,4,5,6});
        //Many code
    }
}
</code></pre>
<h3 id="常见方法-1"><a class="header" href="#常见方法-1">常见方法</a></h3>
<pre><code class="language-java">System.arrayCopy(源数组，从哪开始，目标数组，从哪开始贴，粘几个);
Arrays.sort(被排序的数组);
Arrays.binarySearch(哪个数组，数组中的什么元素);
Arrays.fill(a， 2， 4, 100); //将数组a中2到4的索引的元素替换为100
</code></pre>
<h3 id="内存分配-1"><a class="header" href="#内存分配-1">内存分配</a></h3>
<p><strong>栈内存</strong></p>
<p>存储的都是局部变量， 而且变量所属的作用域一旦结束，该变量就自动释放。</p>
<p><strong>堆内存</strong></p>
<p>存储是数组和对象(其实数组就是对象) 凡是new建立在堆中。</p>
<p>特点：</p>
<ol>
<li>每一个实体都有首地址值</li>
<li>堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数是0，小数0.0或者0.0f，boolean false char '\u0000'</li>
<li>垃圾回收机制</li>
</ol>
<p>堆内存的默认初始化值：</p>
<table><thead><tr><th>类型</th><th>默认初始化值</th></tr></thead><tbody>
<tr><td>int</td><td>0</td></tr>
<tr><td>float</td><td>0.0</td></tr>
<tr><td>String</td><td>null</td></tr>
</tbody></table>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<h3 id="构造函数-1"><a class="header" href="#构造函数-1">构造函数</a></h3>
<p><strong>特点</strong></p>
<ul>
<li>
<p>函数名与类名相同</p>
</li>
<li>
<p>不用定义返回值类型</p>
</li>
<li>
<p>不可以 return</p>
</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>给对象初始化</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>
<p>构造函数是可以重载的，也就是可以有多种对象初始化方式</p>
</li>
<li>
<p>构造函数如果前面加了 void 就变成了一般函数。</p>
</li>
<li>
<p>默认的构造函数，类可以没有构造函数</p>
<p>当一个类中没有定义构造函数时，系统会默认给该类加入一个空参数的构造函数，例如 <code>Person(){}</code> 当自定义构造函数后，默认的构造函数就没了</p>
<p>但是当一个类加入了有参的构造函数时，我们就需要手动加上无参的构造函数，否则会在初始化对象的时候，会因为找不到无参构造器报错</p>
</li>
<li>
<p>什么时候需要构造函数？</p>
<p>分析事物时，该事物一开始就具备某些某些属性或行为，那么将这些 内容定义在构造函数中</p>
</li>
<li>
<p>可以通过私有化构造函数，进而禁止类进行初始化</p>
</li>
</ul>
<h3 id="main-函数-1"><a class="header" href="#main-函数-1">main 函数</a></h3>
<pre><code class="language-java">public static void main(String[] args){
    
}
</code></pre>
<ul>
<li>public 权限必须是最大的</li>
<li>static 该函数并没有涉及到成员方法</li>
<li>void 主函数没有具体的返回值</li>
<li>main 不是关键字，是 JVM 识别的固定的名字</li>
<li>String[] args 参数列表，是一个数组类型的参数，元素都是字符串</li>
</ul>
<h3 id="构造代码块-1"><a class="header" href="#构造代码块-1">构造代码块</a></h3>
<p><strong>作用</strong></p>
<ul>
<li>定义所有对象的共性，给对象进行初始化，对象一建立就运行，而且先于构造函数执行</li>
<li>每 new 一个对象，构造代码块就运行一次</li>
</ul>
<p><strong>构造代码块和构造函数的区别</strong></p>
<p>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化（对象也许有重载）</p>
<pre><code class="language-java">// 构造代码块是定义每一个对象的共性
{
    System.out.println(&quot;person code run&quot;);
}
</code></pre>
<h3 id="静态代码块-1"><a class="header" href="#静态代码块-1">静态代码块</a></h3>
<p>随着类的加载而执行。而且只执行一次。</p>
<p>作用：用于给类进行初始化。</p>
<pre><code class="language-java">static
{
    System.out.println(&quot;static code&quot;);
}
</code></pre>
<h3 id="void-1"><a class="header" href="#void-1">void</a></h3>
<p>如果函数没有具体返回值，那么返回值类型可以用 <code>void</code> 来表示，函数中 <code>return</code> 可以不写，也可以写成 <code>return;</code></p>
<h3 id="重载-1"><a class="header" href="#重载-1">重载</a></h3>
<p><strong>重载与返回值类型无关</strong>，只看参数类型是否不一样，参数类型不一样并且函数名一样则重载。</p>
<p>java是严谨性语言，如果函数出现的调用的不确定性，会编译失败。</p>
<img align='left' src="computer-science-notebook/note-for-java/assets/clip_image001.png" alt="重载"  />
<h2 id="类-1"><a class="header" href="#类-1">类</a></h2>
<h3 id="定义-3"><a class="header" href="#定义-3">定义</a></h3>
<p>成员变量</p>
<ul>
<li>成员变量随着对象的创建而存在，随着对象的消失而消失 </li>
<li>成员变量存在于堆内存的对象中，成员变量都有默认初始化值</li>
</ul>
<h3 id="匿名对象-1"><a class="header" href="#匿名对象-1">匿名对象</a></h3>
<pre><code class="language-java">new Car(); // 匿名对象。其实就是定义对象的简写格式。
Car c = new Car();
c.run();
new Car().run();

// 1，当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。
new Car().num = 5;
new Car().color = &quot;green&quot;;
new Car().run();33

// 2，匿名对象可以作为实际参数进行传递。
Car c1 = new Car();
show(c1); // 等价于：
show(new Car());
</code></pre>
<h3 id="private-1"><a class="header" href="#private-1">private</a></h3>
<p>私有的内容只在本类中有效，不在子类中生效。</p>
<p>Java 中的 <code>this</code> 对应 Python 中的 <code>self</code> 关键字。</p>
<h3 id="static-1"><a class="header" href="#static-1">static</a></h3>
<p><strong>static 的特点</strong></p>
<ol>
<li>static 是一个修饰符，用于修饰成员，可以修饰变量，也可以修饰方法</li>
<li><strong>static 修饰的成员被所有的对象所共享</strong></li>
<li>static 优先于对象存在，因为static的成员随着类的加载就已经存在了</li>
<li>static 修饰的成员多了一种调用方式，就可以直接被类名所调用 【类名.静态成员】</li>
<li>static 修饰的数据是共享数据，对象中的存储的是特有数据</li>
</ol>
<p><strong>静态成员变量的特点</strong></p>
<ol>
<li>静态变量随着类的加载而存在，随着类的消失而消失</li>
<li>静态成员（函数和变量）既可以被对象调用（这种方式在 Java 高版本中不提倡），还可以被类名调用</li>
<li>静态变量称为<strong>类变量</strong></li>
<li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据</li>
<li>静态变量如果设置了 private，则通过类名的方式不能调用</li>
</ol>
<p><strong>静态使用的注意事项</strong></p>
<ol>
<li>静态方法只能访问静态成员。 (<strong>非静态既可以访问静态，又可以访问非静态</strong>)</li>
<li>静态方法中不可以使用this或者super关键字</li>
<li>主函数是静态的</li>
</ol>
<p><strong>static 使用场景</strong></p>
<ol>
<li>
<p>静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以被静态修饰。</p>
<p>只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。 </p>
</li>
<li>
<p>静态方法</p>
<p>函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象中的特有数据。
简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，
但是非静态需要被对象调用，而仅创建对象调用非静态的。没有访问特有数据的方法，该对象的创建是没有意义。</p>
</li>
</ol>
<h3 id="this-1"><a class="header" href="#this-1">this</a></h3>
<ul>
<li>当成员变量和局部变量重名，可以用关键字this来区分</li>
<li>this也可以用于在构造函数中调用其他构造函数
注意：只能定义在构造函数的第一行。因为初始化动作要先执行</li>
</ul>
<h3 id="继承-1"><a class="header" href="#继承-1">继承</a></h3>
<p><strong>super 和 this</strong></p>
<p>当本类的成员和局部变量同名用this区分。当子父类中的成员变量同名用super区分父类。
this和super的用法很相似。this:代表一个本类对象的引用。super：代表一个父类空间。</p>
<pre><code class="language-java">// Demo
class Zi extends Fu{
    Zi(){
        super(); // Zi 的构造函数，一定会先执行 Fu 的构造函数
    }
}
</code></pre>
<p><strong>构造函数</strong></p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。</p>
<ul>
<li>
<p>super() 显式调用</p>
<p>如果父类中没有定义空参数构造函数，那么子类的构造函数必须用 super() 显式调用。明确要调用父类中哪个构造函数。</p>
</li>
<li>
<p>super() 隐式调用</p>
<p>如果父类定义了空参数构造函数，那么子类的构造函数不用显式 super()</p>
</li>
</ul>
<p>其实不管怎么样，子类都会访问父类的构造函数，所以代码里最好还是显式的把 <code>super()</code> 写出来比较好。</p>
<p>supre语句必须要定义在子类构造函数的第一行。因为父类的初始化动作要先完成。</p>
<p>通过super初始化父类内容时，子类的成员变量并未显示初始化。等super()父类初始化完毕后，才进行子类的成员变量显示初始化。</p>
<p><strong>函数重写(覆盖)</strong></p>
<p>我个人倾向于叫重写。</p>
<p>当子父类中出现成员函数一模一样的情况，会运行子类的函数。
这种现象，称为重写操作。这时函数在子父类中的特性。
函数两个特性</p>
<ol>
<li>重载。同一个类中。 overload</li>
<li>覆盖。子类中。覆盖也称为重写，覆写。 override</li>
</ol>
<p>重写注意事项：</p>
<ol>
<li>子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限</li>
<li>静态只能覆盖静态，或被静态覆盖</li>
</ol>
<p>重写的使用场景：</p>
<ol>
<li>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成.</li>
</ol>
<p><strong>单例设计模式</strong></p>
<pre><code class="language-java">/*
设计模式：对问题行之有效的解决方式。其实它是一种思想。
1,单例设计模式。
解决的问题：就是可以保证一个类在内存中的对象唯一性。
必须对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。
如何保证对象唯一性呢？
1，不允许其他程序用new创建该类对象。
2，在该类创建一个本类实例。
3，对外提供一个方法让其他程序可以获取该对象。
步骤：
1，私有化该类构造函数。
2，通过new在本类中创建一个本类对象。
3，定义一个公有的方法，将创建的对象返回。
*/

//饿汉式
class Single //类一加载，对象就已经存在了。
{
    private static Single s = new Single();
    private Single(){}
    public static Single getInstance(){
    	return s;
    }
}

//懒汉式
class Single2 //类加载进来，没有对象，只有调用了getInstance方法时，才会创建对象。
//延迟加载形式。
{
    private static Single2 s = null;
    private Single2(){}
    public static Single2 getInstance(){
        if(s==null)
        	s = new Single2();
        return s;
    }
}

class SingleDemo{
    public static void main(String[] args){
        Single s1 = Single.getInstance();
        Single s2 = Single.getInstance();
        System.out.println(s1==s2);
    }
}
</code></pre>
<h3 id="抽象类-1"><a class="header" href="#抽象类-1">抽象类</a></h3>
<p><strong>概述</strong></p>
<ol>
<li>方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰</li>
<li>抽象方法必须定义在抽象类中。该类必须也被abstract修饰</li>
<li>抽象类不可以被实例化。为什么？因为调用抽象方法没意义。抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。
否则，这个子类还是抽象类</li>
<li>抽象类一定是一个父类，其生来就是要被继承的</li>
</ol>
<p>注意，抽象类可以有构造函数，用于给子类进行初始化。抽象类也可以不定义抽象方法。</p>
<pre><code class="language-java">abstract class Demo{
	Demo(){   
    }
    abstract public abstractFunc(); // 写一个接口协议，要求子类去实现
}
</code></pre>
<p><strong>abstract 关键字</strong></p>
<p>抽象关键字不可以和 private，static，final 同时存在：</p>
<ol>
<li>private：抽象是定义了一个协议，要求子类去实现的，private 私有后，子类就访问不到了</li>
<li>static：抽象方法必须子类实现后才能访问，而 static 修饰后，可以直接通过类名进行访问，冲突了</li>
<li>final：final 定义的属性和方法，就不能修改了，而抽象关键字定义的函数是要被子类继承修改的</li>
</ol>
<p><strong>抽象类和一般类的异同点</strong></p>
<ol>
<li>
<p>相同点</p>
<p>抽象类和一般类都是用来描述事物的，都在内部定了成员</p>
</li>
<li>
<p>不同点</p>
<ol>
<li>一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足</li>
<li>一般类中不能定义抽象方法，只能定非抽象方法，抽象类中可定义抽象方法，同时也可以定义非抽象方法</li>
<li>一般类可以被实例化，抽象类不可以被实例化</li>
</ol>
</li>
</ol>
<h3 id="一个对象的实例化过程-1"><a class="header" href="#一个对象的实例化过程-1">一个对象的实例化过程</a></h3>
<p>一个对象的实例化过程 <code>Person p = new Person();</code></p>
<ol>
<li>JVM会读取指定的路径下的Person.class文件，并加载进内存，并会先加载Person的父类(如果有直接的父类的情况下)</li>
<li>在堆内存中的开辟空间，分配地址。并在对象空间中，对对象中的属性进行默认初始化</li>
<li>调用对应的构造函数进行初始化</li>
<li>在构造函数中，第一行会先到调用父类中构造函数进行初始化</li>
<li>父类初始化完毕后，在对子类的属性进行显示初始化</li>
<li>在进行子类构造函数的特定初始化</li>
<li>初始化完毕后，将地址值赋值给引用变量</li>
</ol>
<h3 id="final-1"><a class="header" href="#final-1">final</a></h3>
<p>final 关键字的特点：</p>
<p>final关键字：</p>
<ol>
<li>final是一个修饰符，可以修饰<strong>类，方法，变量</strong>。</li>
<li>final修饰的类不可以被继承。</li>
<li>final修饰的方法不可以被覆盖。</li>
<li>final修饰的变量是一个常量，只能赋值一次。</li>
</ol>
<p>为什么要用final修饰变量?</p>
<p>其实在程序如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以它该数据起个名称。
而且这个变量名称的值不能变化，所以加上final固定。
写法规范：常量所有字母都大写，多个单词，中间用_连接。</p>
<pre><code class="language-java">public static final double MY_PI = 3.14;
</code></pre>
<h3 id="接口-1"><a class="header" href="#接口-1">接口</a></h3>
<p>接口有点类似鸭子🦆类型。</p>
<p>当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。</p>
<p>接口中的成员都是公共的权限。</p>
<pre><code class="language-java">interface Demo{
    public static final int NUM = 4;
    public abstract void show1();
    public abstract void show2();
}
</code></pre>
<p>只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。</p>
<p><strong>多实现</strong></p>
<p>在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行改良，在java中变成了多实现。一个类可以实现多个接口。</p>
<pre><code class="language-java">// 多继承
interface A{
	public void show(); // abstract 可以省略不写
}

interface Z{
	public int add(int a,int b);
}

class Test implements A,Z{
	public int add(int a,int b){
		return a+b+3;
	}
    public void show(){}
}
</code></pre>
<p><strong>接口的多继承</strong></p>
<pre><code class="language-java">interface CC{
	void show();
}

interface MM{
	void method();
}

interface QQ extends CC, MM //接口与接口之间是继承关系，而且接口可以多继承。
{
	void function();
}

class WW implements QQ{
    //覆盖3个方法。
    public void show(){}
    public void method(){}
    public void function(){}
}
</code></pre>
<p><strong>接口和抽象类比较</strong></p>
<ol>
<li>
<p>相同点</p>
<p>都是不断向上抽取而来的。</p>
</li>
<li>
<p>不同点</p>
<ol>
<li>抽象类需要被继承，而且只能单继承。
接口需要被实现，而且可以多实现。</li>
<li>抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。
接口中只能定义抽象方法，必须由子类去实现。</li>
<li>抽象类的继承，是 is a 关系，在定义该体系的基本共性内容。
接口的实现是 like a 关系，在定义体系额外功能。</li>
</ol>
</li>
</ol>
<h3 id="多态-1"><a class="header" href="#多态-1">多态</a></h3>
<p><strong>什么是多态</strong></p>
<p>一个对象有多种特征。一个对象，走起路来像鸭子，叫声也像鸭子，那么这个对象就具有鸭子的特征；同时这个对象还是胎生的，那么其就有哺乳动物的特征。一个对象，多种状态。</p>
<p>多态的一个实际案例：</p>
<pre><code>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
</code></pre>
<pre><code class="language-java">class 动物
{}
class 猫 extends 动物
{}
class 狗 extends 动物
{}
猫 x = new 猫();
动物 x = new 猫(); //一个对象，多种形态。
</code></pre>
<p>猫这类事物即具备者猫的形态，又具备着动物的形态。这就是对象的多态性。
简单说：就是一个对象对应着不同类型。(因为实现了不同的接口)</p>
<p>多态在代码中的体现：父类或者接口的引用指向其子类的对象</p>
<p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<p>多态的弊端：前期定义的内容不能使用(调用)后期子类的特有内容</p>
<p>多态的前提：1. 必须有关系，继承，实现。2. 要有覆盖。</p>
<pre><code class="language-java">abstract class Animal{
	abstract void eat();
}

class Dog extends Animal{
	void eat(){
    System.out.println(&quot;啃骨头&quot;);
    }
    void lookHome(){
        System.out.println(&quot;看家&quot;);
    }
}

class Cat extends Animal{
    void eat(){
    	System.out.println(&quot;吃鱼&quot;);
    }
    void catchMouse(){
    	System.out.println(&quot;抓老鼠&quot;);
    }
}

class Pig extends Animal{
    void eat(){
    	System.out.println(&quot;饲料&quot;);
    }
    void gongDi(){
    	System.out.println(&quot;拱地&quot;);
    }
}

class DuoTaiDemo{
    
    public static void main(String[] args){
        // Cat c = new Cat();
        // c.eat();
        // c.catchMouse();
        Animal a = new Cat(); //自动类型提升，猫对象提升了动物类型。但是特有功能无法s访问。
        //作用就是限制对特有功能的访问。
        //专业讲：向上转型。将子类型隐藏。就不用使用子类的特有方法。
        // a.eat();
        //如果还想用具体动物猫的特有功能。
        //你可以将该对象进行向下转型。
        // Cat c = (Cat)a;//向下转型的目的是为了使用子类中的特有方法。
        // c.eat();
        // c.catchMouse();
        // 注意：对于转型，自始自终都是子类对象在做着类型的变化。
        // Animal a1 = new Dog();
        // Cat c1 = (Cat)a1;//ClassCastException
        /*
        Cat c = new Cat();
        // Dog d = new Dog();
        // c.eat();
        method(c);
        // method(d);
        // method(new Pig());
        */
        method(new Dog());
    }
    public static void method(Animal a){ //Animal a = new Dog();
   		a.eat();
        if(a instanceof Cat){ //instanceof：用于判断对象的具体类型。只能用于引用数据类型判断
        	//通常在向下转型前用于健壮性的判断。
            Cat c = (Cat)a;
            c.catchMouse();
        }else if(a instanceof Dog){
            Dog d = (Dog)a;
            d.lookHome();
        }else{ 
        }
	}
}
</code></pre>
<p><strong>多态时各组成的发化</strong></p>
<p>多态时，成员的特点：</p>
<ol>
<li>成员变量
编译时：参考引用型变量所属的类中的是否有调用的成员变量，有，编译通过，没有，编译失败。
运行时：参考引用型变量所属的类中的是否有调用的成员变量，并运行该所属类中的成员变量。
简单说：编译和运行都参考等号的左边。哦了。</li>
<li>成员函数(非静态)
编译时：参考引用型变量所属的类中的是否有调用的函数。有，编译通过，没有，编译失败。
运行时：参考的是对象所属的类中是否有调用的函数。
简单说：编译看左边，运行看<strong>右边</strong>。（其他都是左边）
因为成员函数存在覆盖特性。</li>
<li>静态函数
编译时：参考引用型变量所属的类中的是否有调用的静态方法。
运行时：参考引用型变量所属的类中的是否有调用的静态方法。
简单说，编译和运行都看左边。
其实对于静态方法，是不需要对象的。直接用类名调用即可。</li>
</ol>
<pre><code class="language-java">package com.wansho.hellojava;

class Fu {
    static int num = 3;
    void show(){
        System.out.println(&quot;fu show&quot;);
    }

    static void method(){
        System.out.println(&quot;fu static method&quot;);
    }
}

class Zi extends Fu {
    static int num = 4;
    void show()
    {
        System.out.println(&quot;zi show&quot;);
    }
    static void method()
    {
        System.out.println(&quot;zi static method&quot;);
    }
}

class DuoTaiDemo3 {
    public static void main(String[] args)
    {
        Fu.method(); // fu static method
        Zi.method(); // zi static method
        Fu f = new Zi();
        System.out.println(f.num); // 可以通过对象访问静态的成员变量 3
        f.method(); // 可以通过对象访问静态的成员变量  fu static method
        f.show(); // zi show
    }
}
</code></pre>
<h3 id="内部类-1"><a class="header" href="#内部类-1">内部类</a></h3>
<p>内部类感觉有点类似于闭包。</p>
<p><strong>内部类访问特点</strong></p>
<ol>
<li>内部类可以直接访问外部类中的成员。</li>
<li>外部类要访问内部类，必须建立内部类的对象。</li>
</ol>
<p><strong>使用场景</strong></p>
<p>一般用于类的设计。
分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容。
这时就是还有的事物定义成内部类来描述。
内部类能直接访问外部类中成员， 是因为内部类持有了外部类的引用，即外部类名.this。
内部类也可以存放在局部位置上，但是内部类在局部位置上只能访问局部中被final修饰的局部变量。</p>
<pre><code class="language-java">class Outer{
    private static int num = 31;
    class Inner{// 内部类。
        void show(){
            System.out.println(&quot;show run...&quot;+num);
        }
        /*static void function()//如果内部类中定义了静态成员，该内部类也必须是静态的。
        {
        System.out.println(&quot;function run ....&quot;+num);
        }
        */
    }
    public void method(){
        Inner in = new Inner();
        in.show();
    }
}

class InnerClassDemo
{
    public static void main(String[] args)
    {
        // Outer out = new Outer();
        // out.method();
        
        // 直接访问外部类中的内部类中的成员。
        // Outer.Inner in = new Outer().new Inner();
        // in.show();
        
        //如果内部类是静态的。 相当于一个外部类
        // Outer.Inner in = new Outer.Inner();
        // in.show();
        
        //如果内部类是静态的，成员是静态的。
        // Outer.Inner.function();
    }
}
</code></pre>
<h3 id="匿名内部类-1"><a class="header" href="#匿名内部类-1">匿名内部类</a></h3>
<p>匿名内部类， 首先是一个类中类，其次是内部类的简写格式。其实就是一个匿名子类对象。
必须有前提：内部类必须继承或者实现一个外部类或者接口。
格式： new 父类or接口(){子类内容}</p>
<pre><code class="language-java">abstract class Demo{
    abstract void show();
}

class Outer{
    int num = 4;
    /*
    class Inner extends Demo{
        void show(){
        	System.out.println(&quot;show ...&quot;+num);
        }
    }
    */
    public void method(){
        //new Inner().show();
        new Demo(){//匿名内部类。
            void show(){
                System.out.println(&quot;show ........&quot;+num);
            }
        }.show();
    }
}

class InnerClassDemo4{
    public static void main(String[] args){
        new Outer().method();
    }
}
</code></pre>
<p><strong>使用范例</strong></p>
<p>场景一：</p>
<p>当函数参数是接口类型时，而且接口中的方法不超过三个。可以用匿名内部类作为实际参数进行传递</p>
<pre><code class="language-java">interface Inter
{
    void show1();
    void show2();
}

class Outer
{
    /*
    class Inner implements Inter
    {
        public void show1()
        { }
        public void show2()
        { }
    }
    */
    public void method()
    {
        // Inner in = new Inner();
        // in.show1();
        // in.show2();
        Inter in = new Inter(){
            public void show1()
            { }
            public void show2()
            { }
        };
        in.show1();
        in.show2();
    }
}

class InnerClassDemo5
{
    class Inner
    { }
    public static void main(String[] args)
    {
        System.out.println(&quot;Hello World!&quot;);
        /*
        show(new Inter()
        {
        public void show1(){}
        public void show2(){}
        });
        */
        // new Inner();
    }
    public void method()
    {
        new Inner();
    }
    public static void show(Inter in)
    {
        in.show1();
        in.show2();
    }
}
</code></pre>
<p>范例二：</p>
<pre><code class="language-java">class Outer
{
    void method()
    {
        Object obj = new Object()
        {
            public void show()
            {
                System.out.println(&quot;show run&quot;);
            }
        };
        obj.show();//因为匿名内部类这个子类对象被向上转型为了Object类型。
        //这样就不能在使用子类特有的方法了。
    }
}

class InnerClassDemo6
{
    public static void main(String[] args)
    {
        new Outer().method();
    }
}
</code></pre>
<h2 id="异常-1"><a class="header" href="#异常-1">异常</a></h2>
<h3 id="定义-4"><a class="header" href="#定义-4">定义</a></h3>
<p>异常：是在<strong>运行时期</strong>发生的不正常情况。</p>
<p>注意是在运行期间，程序在运行时总会发生大大小小的问题，但是我们不能因为一个小问题就停止程序的运行，所以要引入叫做异常的容错机制，对异常进行容错。</p>
<p>在 java 中<strong>用类的形式对不正常情况进行了描述和封装对象</strong>。描述不正常的情况的类，就称为异常类。</p>
<p><strong>以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离。提高阅读性。其实异常就是java通过面向对象的思想将问题封装成了对象。用异常类对其进行描述。不同的问题用不同的类进行具体的描述。 比如角标越界、 空指针等等。</strong>
问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系。 </p>
<p><strong>异常的共性：Throwable</strong></p>
<p>无论是 error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。
//该体系的特点就在于Throwable及其所有的子类都具有可抛性。
可抛性到底指的是什么呢？怎么体现可抛性呢？其实是通过两个关键字来体现的。throws throw , 凡是可以被这两个关键字所操作的类和对象都具备可抛性.</p>
<p>异常子类的后缀名都是用其父类名作为后缀，阅读性很强。</p>
<p><strong>异常分为两类</strong></p>
<ul>
<li>
<p>Error</p>
<p>一般不可处理的。</p>
<p>是由jvm抛出的严重性的问题。这种问题发生一般不针对性处理。直接修改程序</p>
</li>
<li>
<p>Exception</p>
<p>可以处理的。</p>
</li>
</ul>
<pre><code class="language-java">class ExceptionDemo
{
    public static void main(String[] args)
    {
        int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap

    }
    /**
    正常的问题代码的处理
    */
    public static void sleep2(int time)
    {
        if(time&lt;0)
        {
            // 处理办法。
            // 处理办法。
            // 处理办法。

        }
        if(time&gt;100000)
        {
            // 处理办法。
            // 处理办法。
        }
        System.out.println(&quot;我睡。。。 &quot;+time);
    }
    
    /*
    引入异常机制后
    */
    public static void sleep(int time) 
    {
        if(time&lt;0)
        {
            // 抛出 new FuTime();//就代码着时间为负的情况，这个对象中会包含着问题的名称，信息，位置等信息。
        }
        if(time&gt;100000)
        {
            // 抛出 new BigTime();
        }
        System.out.println(&quot;我睡。。。 &quot;+time);
    }
}
/*
class FuTime
{ }
class BigTime
{ }
*/
</code></pre>
<h3 id="自定义异常-1"><a class="header" href="#自定义异常-1">自定义异常</a></h3>
<p><strong>一个需求</strong></p>
<p>对于角标是整数不存在，可以用角标越界表示，对于负数为角标的情况，准备用负数角标异常来表示。
负数角标这种异常在java中并没有定义过。那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述。并封装成对象。</p>
<p>如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。</p>
<p><strong>异常的分类</strong></p>
<ol>
<li>编译时被检测的异常</li>
<li>编译时不被检测的异常（运行时异常，必须要让程序停下来，修改之）</li>
</ol>
<p><strong>throws 和 throw</strong></p>
<ol>
<li>throws 使用在函数上，throw 使用在函数内</li>
<li>throws 抛出的是异常类，可以抛出多个，用逗号隔开。throw 抛出的是异常对象</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">class FuShuIndexException extends Exception
{
    FuShuIndexException()
    {}
    FuShuIndexException(String msg)
    {
        super(msg);
    }
}

class Demo
{
    public int method(int[] arr,int index) throws NullPointerException, FuShuIndexException
    {
        if(arr==null)
            throw new NullPointerException(&quot;数组的引用不能为空！ &quot;);
        if(index&gt;=arr.length)
        {
            throw new ArrayIndexOutOfBoundsException(&quot;数组的角标越界啦，哥们，你是不是疯了？： &quot;+index);
        }
        if(index&lt;0)
        {
            throw new FuShuIndexException(&quot;角标变成负数啦！！ &quot;);
        }
        return arr[index];
    }
}

class ExceptionDemo3
{
    public static void main(String[] args) //throws FuShuIndexException
    {
        int[] arr = new int[3];
        Demo d = new Demo();
        int num = d.method(null,-30);
        System.out.println(&quot;num=&quot;+num);
        System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<h3 id="异常的捕捉-1"><a class="header" href="#异常的捕捉-1">异常的捕捉</a></h3>
<p>Demo：</p>
<pre><code class="language-java">try
{
    //需要被检测异常的代码。
}
catch(异常类 变量)// 该变量用于接收发生的异常对象
{
    //处理异常的代码。
}
finally
{
    //一定会被执行的代码。
}
</code></pre>
<p><strong>异常处理的原则</strong></p>
<p>异常处理的原则：</p>
<ol>
<li>函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用trycatch捕捉，否则编译失败。</li>
<li>如果调用到了声明异常的函数，要么try catch 要么 throws，否则编译失败。</li>
<li>什么时候catch，什么时候throws 呢？功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决 。</li>
<li>一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">class FuShuIndexException extends Exception
{
    FuShuIndexException(String msg)
    {
        super(msg);
    }
}

class Demo
{
    public int method(int[] arr,int index) // throws NullPointerException,FuShuIndexException
    {
        if(arr==null)
            throw new NullPointerException(&quot;没有任何数组实体&quot;); // throw 后，下面的代码就不执行了
        if(index&lt;0)
            throw new FuShuIndexException();
        return arr[index];
    }
}

class ExceptionDemo4
{
    public static void main(String[] args)
    {
        int[] arr = new int[3];
        Demo d = new Demo();
        try
        {
            int num = d.method(null,-1);
            System.out.println(&quot;num=&quot;+num);
        }
        catch(NullPointerException e)
        {
            System.out.println(e.toString());
        }
        catch(FuShuIndexException e)
        {
            System.out.println(&quot;message:&quot;+e.getMessage());
            System.out.println(&quot;string:&quot;+e.toString());
            e.printStackTrace(); //jvm默认的异常处理机制就是调用异常对象的这个方法。
            System.out.println(&quot;负数角标异常!!!!&quot;);
        }
        /*
        catch(Exception e)//多catch父类的catch放在最下面。
        { }
        */
        System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<p><strong>try catch finally</strong></p>
<p>try catch finally 代码块组合特点：</p>
<ol>
<li>try catch finally</li>
<li>try catch(多个)当没有必要资源需要释放时，可以不用定义finally</li>
<li>try finally 异常无法直接 catch 处理，但是资源需要关闭</li>
</ol>
<p><strong>异常注意事项</strong></p>
<ol>
<li>子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类</li>
<li>如果父类抛出多个异常，那么子类只能抛出父类异常的子集</li>
</ol>
<p>简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。
注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try</p>
<h3 id="异常-demo-1"><a class="header" href="#异常-demo-1">异常 Demo</a></h3>
<p>场景</p>
<pre><code>毕老师用电脑上课。
问题领域中涉及两个对象。
毕老师，电脑。
分析其中的问题。
比如电脑蓝屏啦。冒烟啦。
</code></pre>
<pre><code class="language-java">class LanPingException extends Exception
{
    LanPingException(String msg)
    {
        super(msg);
    }
}

class MaoYanException extends Exception
{
    MaoYanException(String msg)
    {
        super(msg);
    }
}

class NoPlanException extends Exception 
{
    NoPlanException(String msg)
    {
        super(msg);
    }
}


class Computer
{
    private int state = 2;
    public void run() throws LanPingException,MaoYanException
    {
        if(state==1)
            throw new LanPingException(&quot;电脑蓝屏啦！！ &quot;);
        if(state==2)
            throw new MaoYanException(&quot;电脑冒烟啦！！ &quot;);
        System.out.println(&quot;电脑运行&quot;);
    }
    public void reset()
    {
        state = 0;
        System.out.println(&quot;电脑重启&quot;);
    }
}

class Teacher
{
    private String name;
    private Computer comp;
    Teacher(String name)
    {
        this.name = name;
        comp = new Computer();
    }
    public void prelect() throws NoPlanException // 没有 catch 的异常则抛出
    {
        try
        {
            comp.run();
            System.out.println(name+&quot;讲课&quot;);
        }
        catch (LanPingException e) // 异常处理
        {
            System.out.println(e.toString());
            comp.reset();
            prelect();
        }
        catch (MaoYanException e)
        {
            System.out.println(e.toString());
            test();
            //可以对电脑进行维修。
            // throw e;
            throw new NoPlanException(&quot;课时进度无法完成，原因： &quot;+e.getMessage()); // 能解决的异常自己解决，不能解决的，抛出异常，让调用者来解决
        }
    }
    public void test()
    {
        System.out.println(&quot;大家练习&quot;);
    }
}

class ExceptionTest
{
    public static void main(String[] args)
    {
        Teacher t = new Teacher(&quot;毕老师&quot;);
        try
        {
            t.prelect();
        }
        catch (NoPlanException e)
        {
            System.out.println(e.toString()+&quot;......&quot;);
            System.out.println(&quot;换人&quot;);
        }
    }
}

/*
com.wansho.hellojava.MaoYanException: 电脑冒烟啦！！ 
大家练习
com.wansho.hellojava.NoPlanException: 课时进度无法完成，原因： 电脑冒烟啦！！ ......
换人
*/
</code></pre>
<h2 id="包机制-1"><a class="header" href="#包机制-1">包机制</a></h2>
<p>导包的原则：用到哪个类，就导入哪个类。包在文件系统上的作用体现在文件夹上。</p>
<p>包名的规范：所有字母都小写。</p>
<p><strong>包的重点</strong></p>
<ol>
<li>对类文件进行分类管理</li>
<li>给类提供多层命名空间(namespace)，防止类太多命名冲突了</li>
<li>写在程序文件第一行</li>
<li><strong>类名的全称</strong>是：包名.类名</li>
<li>包也是一种封装方式</li>
</ol>
<h3 id="package-demo-1"><a class="header" href="#package-demo-1">package Demo</a></h3>
<pre><code>|---mypack
|---|---PackageDemo.java  
</code></pre>
<pre><code class="language-java">package mypack;

class PackageDemo{
    public static void main(String[] args){
        System.out.println(&quot;hello package&quot;);
    }
}
</code></pre>
<p>编译执行该 Java 文件：</p>
<pre><code class="language-shell">javac PackageDemo.java # 生成 PackageDemo.class 文件

java PackageDemo # 执行 class 文件
#！！！错误: 找不到或无法加载主类 PackageDemo

java mypack.PackageDemo
# hello package
</code></pre>
<p>从上面的例子来看，一旦加入 package 机制后，Java 文件就应该在包名所在的文件夹下，而且类名的全称变成了 <code>包名.类名</code>，单独引用类名会找不到这个人。</p>
<p>javac 可以直接帮我们创建文件夹：</p>
<pre><code class="language-shell">javac -d . PackageDemo.java
java mypack.PackageDemo
</code></pre>
<h3 id="classpath-的作用-1"><a class="header" href="#classpath-的作用-1">classpath 的作用</a></h3>
<p>编译 java 源文件生成的 class 文件，都放在 classpath 中，以起到<strong>源文件与 class 文件隔离的作用</strong>。</p>
<p>一篇文章让你弄懂到底什么是classpath - yuan的文章 - 知乎 https://zhuanlan.zhihu.com/p/113234567</p>
<p>classpath其实就是一个路径而已，我们经常在spring的配置文件中这样写：</p>
<pre><code class="language-java">&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;
</code></pre>
<p>这样配置完之后spring就知道mybatis配置文件所在的地方。</p>
<p>那么？这个classpath指向的地方到底是哪里呢？</p>
<p><img src="computer-science-notebook/note-for-java/assets/v2-912d9181496a25f578a970615189c378_r.jpg" alt="img" /></p>
<p><strong>classpath指向的就是打war包之后的classes的位置</strong>。而classes文件夹下就是我们原项目的java文件和resources文件夹里面的内容。</p>
<p>所以上面的代码的意思就是在编译后的classes文件中找mybatis/SqlMapConfig.xml文件。</p>
<hr />
<p>在编译打包后的项目中，根目录是<code>META-INF</code>和<code>WEB-INF</code> 。这个时候，我们可以看到classes这个文件夹，它就是我们要找的classpath。</p>
<p><code>classpath:mybatis/SqlMapConfig.xml</code> 中，classpath 就是指 <code>WEB-INF/classes/</code> 这个目录的路径。需要声明的一点是，使用<code>classpath:</code>这种前缀，<strong>就只能代表一个文件</strong>。</p>
<p>而另一种写法，<code>classpath*:**/mapper/mapping/*Mapper.xml</code>，使用<code>classpath*:</code>这种前缀，<strong>则可以代表多个匹配的文件</strong>；<code>**/mapper/mapping/*Mapper.xml</code>，双星号<code>**</code>表示在任意目录下，也就是说在<code>WEB-INF/classes/</code>下任意层的目录，只要符合后面的文件路径，都会被作为资源文件找到。</p>
<h3 id="包的封装作用和四种权限-1"><a class="header" href="#包的封装作用和四种权限-1">包的封装作用和四种权限</a></h3>
<p>包是对类的进一步封装。既然封装了，那么就涉及到外部的访问问题。在包中，只有 <code>public class</code> 才是外部可以访问的 class，不是 public 的 class 都被包封装了。</p>
<p>注意：对外暴露的 public 的 class，其类名要与文件名保持一致。在 public class 中对外暴露的函数也应该是 public 的（默认权限也是封装！）</p>
<p>包与包之间的访问，通过 <code>public</code> 和 <code>protected</code> 关键字来约束。</p>
<p>不同包不允许访问，但如果你是我们的儿子，那么就可以网开一面：<code>protected</code>，**不叫爹不行！**提供给不同包中的子类。</p>
<p>protected 关键字将对象保护在同包中，不同包无法调用 protected 的对象。</p>
<p><strong>java 四种权限</strong></p>
<table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody>
<tr><td>同一类中</td><td>ok</td><td>ok</td><td>ok</td><td>ok</td></tr>
<tr><td>同一包中</td><td>ok</td><td>ok</td><td>ok</td><td>封装</td></tr>
<tr><td>子类中</td><td>ok</td><td>ok</td><td>封装(访问不到)</td><td>封装</td></tr>
<tr><td>不同包中</td><td>ok</td><td>封装</td><td>封装</td><td>封装</td></tr>
</tbody></table>
<p>总结：包与包之间的类进行访问，被访问的包中的类必须是 public 的，被访问的包中的类的方法也必须是 public 的。 </p>
<p>protected：比 default 稍微宽松一点，包外的子类可以访问</p>
<p>default：同包能访问，包外的子类就不能访问了</p>
<p>private：吃独食，子类都访问不了</p>
<img align="left" src="computer-science-notebook/note-for-java/assets/image-20210503084531612.png" alt="image-20210503084531612" style="zoom:80%;" />
<h3 id="import-的作用和规范-1"><a class="header" href="#import-的作用和规范-1">import 的作用和规范</a></h3>
<p>import 的作用：简化类名书写！</p>
<pre><code class="language-java">// 没导入之前：
packa.PackageADemo demoA = new packa.PackageADemo();

// 导入后
import packa.PackageADemo; // 导入 packa 下的 PackageADemo 类
PackageADemo demoA = new PackageADemo();

// 导入 packa 中所有的类
import packa.*;
import packa.abc.*; // 两个性质完全不一样
</code></pre>
<p>注意：</p>
<ol>
<li><code>import *</code> 只导入文件夹下的所有类，并不会导入包中包（没有 recursive 的功能）</li>
<li>导包原则：用哪个类，导入哪个类</li>
</ol>
<h3 id="jar-包-1"><a class="header" href="#jar-包-1">jar 包</a></h3>
<p><strong>是什么</strong></p>
<p><code>jar</code> 是 Java 的一个命令，用于 Java 程序打包。<code>jar, rar</code>，jar 包就是 Java 的压缩包。</p>
<pre><code class="language-shell">javac -d . JarDemo.java
java pack.JarDemo
jar -cvf haha.jar pack # 压缩

jar -xvf haha.jar # 解压缩

# 以前：./pack
# 压缩后：./haha.jar/pack
</code></pre>
<p>注意：jar 包中打包的是 class 文件，没有必要对源码进行打包。</p>
<p><strong>如何使用 jar 包</strong></p>
<pre><code class="language-shell">set classpath=./haha.jar
java pack.JarDemo
</code></pre>
<h2 id="多线程-2"><a class="header" href="#多线程-2">多线程</a></h2>
<h3 id="垃圾回收线程-1"><a class="header" href="#垃圾回收线程-1">垃圾回收线程</a></h3>
<p>JVM 启动的时候，就启动了多个线程，至少有两个线程是我们可以分析出来的：</p>
<ol>
<li>main</li>
<li>负责垃圾回收的线程</li>
</ol>
<pre><code class="language-java">class Demo4 extends Object
{
    @Override
    public void finalize() // 在垃圾回收前调用
    {
        System.out.println(&quot;demo ok&quot;);
    }
}
class ThreadDemo
{
    public static void main(String[] args)
    {
        new Demo4();
        new Demo4();
        new Demo4();
        System.gc(); // 进行垃圾回收
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<p>运行结果：</p>
<p>垃圾回收线程，其执行结果每次都不太一样。</p>
<pre><code>demo ok
demo ok
Hello World!
demo ok

-----------

demo ok
demo ok
demo ok
Hello World!

-----------

demo ok
Hello World!
demo ok
demo ok
</code></pre>
<h3 id="创建线程-继承-thread-1"><a class="header" href="#创建线程-继承-thread-1">创建线程-继承 Thread</a></h3>
<p>创建线程方式一：继承Thread类。
步骤：</p>
<ol>
<li>定义一个类继承 Thread 类</li>
<li>覆盖Thread类中的 run 方法</li>
<li>直接创建Thread的子类对象创建线程</li>
<li>调用start方法开启线程并调用线程的任务run方法执行</li>
</ol>
<p>可以通过 Thread 的 getName 获取线程的名称 Thread-编号(从0开始)</p>
<p>Demo：</p>
<pre><code class="language-java">class Demo extends Thread
{
    private String name;
    Demo(String name)
    {
        super(name);
        this.name = name;
    }
    public void run()
    {
        for(int x=0; x&lt;10; x++)
        {
            System.out.println(name+&quot;....x=&quot;+x+&quot;.....name=&quot;+Thread.currentThread().getName());
        }
    }
}

class ThreadDemo2
{
    public static void main(String[] args)
    {
        /*
        创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。
        而运行的指定代码就是这个执行路径的任务。
        jvm创建的主线程的任务都定义在了主函数中。
        而自定义的线程它的任务在哪儿呢？
        Thread类用于描述线程，线程是需要任务的。所以Thread类也对任务的描述。
        这个任务就通过Thread类中的run方法来体现。也就是说， run方法就是封装自定义线程运行任务的函数。
        run方法中定义就是线程要运行的任务代码。
        开启线程是为了运行指定代码，所以只有继承Thread类，并复写run方法。
        将运行的代码定义在run方法中即可。
        */
        Demo d1 = new Demo(&quot;旺财&quot;);
        Demo d2 = new Demo(&quot;xiaoqiang&quot;);
        d1.start();//开启线程，调用run方法。
        d2.start();
        System.out.println(&quot;over....&quot;+Thread.currentThread().getName());
    }
}

/**
over....main
小强....x=0.....name=小强
旺财....x=0.....name=旺财
小强....x=1.....name=小强
小强....x=2.....name=小强
旺财....x=1.....name=旺财
小强....x=3.....name=小强
小强....x=4.....name=小强
旺财....x=2.....name=旺财
小强....x=5.....name=小强
旺财....x=3.....name=旺财
小强....x=6.....name=小强
小强....x=7.....name=小强
小强....x=8.....name=小强
小强....x=9.....name=小强
旺财....x=4.....name=旺财
旺财....x=5.....name=旺财
旺财....x=6.....name=旺财
旺财....x=7.....name=旺财
旺财....x=8.....name=旺财
旺财....x=9.....name=旺财
*/
</code></pre>
<p>多线程的随机性，谁抢到 CPU，谁执行。</p>
<h3 id="创建线程-实现-runnable-1"><a class="header" href="#创建线程-实现-runnable-1">创建线程-实现 Runnable</a></h3>
<p>步骤：</p>
<ol>
<li>
<p>定义类实现Runnable接口</p>
</li>
<li>
<p>覆盖接口中的run方法，将线程的任务代码封装到run方法中</p>
</li>
<li>
<p>通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。</p>
<p>为什么？因为线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务。</p>
</li>
<li>
<p>调用线程对象的start方法开启线程</p>
</li>
</ol>
<p>实现Runnable接口的好处：</p>
<ol>
<li>
<p>将线程的任务从线程的子类中分离出来，进行了单独的封装
按照面向对象的思想将任务的封装成对象</p>
</li>
<li>
<p>避免了java单继承的局限性
所以，创建线程的第二种方式较为常用</p>
</li>
</ol>
<pre><code class="language-java">class Demo implements Runnable{//extends Fu //准备扩展Demo类的功能，让其中的内容可以作为线程的任务执行。
    //通过接口的形式完成。
    public void run()
    {
        show();
    }
    public void show()
    {
        for(int x=0; x&lt;20; x++)
        {
            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+x);
        }
    }
}

class ThreadDemo
{
    public static void main(String[] args)
    {
        Demo d = new Demo();
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        t1.start();
        t2.start();
    }
}
</code></pre>
<h3 id="同步和互斥-1"><a class="header" href="#同步和互斥-1">同步和互斥</a></h3>
<p><strong>synchronized</strong></p>
<p><a href="https://www.cnblogs.com/weibanggang/p/9470718.html">[synchronized 讲解]</a></p>
<p>synchronized，翻译过来，就是同步的意思，其是 Java 的关键字，是一种同步锁，其修饰的对象有以下几种：</p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<p>详细介绍：</p>
<ol>
<li>
<p>修饰代码块</p>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。</p>
</li>
<li>
<p>修饰一个方法</p>
<p>注意：synchronized 关键字不能被继承，如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以</p>
</li>
<li>
<p>修饰静态方法</p>
<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
</li>
</ol>
<p><strong>卖票问题</strong></p>
<p>线程安全问题产生的原因：</p>
<ol>
<li>多个线程在操作共享的数据</li>
<li>操作共享数据的线程代码有多条
当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。</li>
</ol>
<p>解决思路:</p>
<p>就是将临界区封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在 java 中，用同步代码块就可以解决这个问题。同步代码块的格式：</p>
<pre><code class="language-java">synchronized(对象)
{
	需要被同步的代码 ；
}
</code></pre>
<p>同步的好处：解决了线程的安全问题。
同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。
同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<pre><code class="language-java">class Ticket implements Runnable//extends Thread
{
    private int num = 100;
    Object obj = new Object();
    public void run()
    {
        while(true)
        {
            synchronized(obj)
            {
                if(num&gt;0)
                {
                    try{Thread.sleep(10);}catch (InterruptedException e){}
                    System.out.println(Thread.currentThread().getName()+&quot;.....sale....&quot;+num--);
                }
            }
        }
    }
}

class TicketDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();//创建一个线程任务对象。
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        Thread t3 = new Thread(t);
        Thread t4 = new Thread(t);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
</code></pre>
<p><strong>银行存钱案例</strong></p>
<p>需求:储户，两个，每个都到银行存钱每次存100，共存三次。</p>
<pre><code class="language-java">class Bank
{
    private int sum;
    public synchronized void add(int num) // 同步函数，临界区一次只允许一个进程访问
    {
        sum = sum + num;
        try{Thread.sleep(10);}catch(InterruptedException e){} // 当前进程睡 10 ms
        System.out.println(&quot;sum=&quot;+sum);
    }
}

class Cus implements Runnable // 线程的另一种实现方式
{
    private Bank b = new Bank();
    public void run()
    {
        for(int x=0; x&lt;3; x++)
        {
            b.add(100);
        }
    }
}

class BankDemo
{
    public static void main(String[] args)
    {
        Cus c = new Cus(); // 注意 Cus 对象只创建了一次，也就是说银行这个对象只创建了一次！
        Thread t1 = new Thread(c);
        Thread t2 = new Thread(c);
        t1.start();
        t2.start();
    }
}

/*
sum=100
sum=200
sum=300
sum=400
sum=500
sum=600
*/
</code></pre>
<p><strong>多线程下的单例安全问题</strong></p>
<pre><code class="language-java">/*
多线程下的单例
*/
// 饿汉式不存在多线程安全问题
class Single
{
    private static final Single s = new Single();
    private Single(){}
    public static Single getInstance()
    {
        return s;
    }
}

// 懒汉式
// 加入同步为了解决多线程安全问题。
// 加入双重判断是为了解决效率问题。
class Single
{
    private static Single s = null;
    private Single(){}
    public static Single getInstance()
    {
        if(s==null)
        {
            synchronized(Single.class) // 同步代码块
            {
                if(s==null)
                    // --&gt;0 --&gt;1
                    s = new Single();
            }
        }
     return s;
    }
}

class SingleDemo
{
    public static void main(String[] args)
    {
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<p>注意：synchronized 关键字不能被继承，如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。</p>
<p><strong>死锁 - 同步嵌套(没看懂)</strong></p>
<pre><code class="language-java">class Ticket implements Runnable
{
    private int num = 100;
    Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        if(flag)
            while(true)
            {
                synchronized(obj)
                {
                    show();
                }
            }
     else
         while(true)
             this.show();
    }
    public synchronized void show()
    {
        synchronized(obj)
        {
            if(num&gt;0)
            {
                try{Thread.sleep(10);}catch (InterruptedException e){}
                System.out.println(Thread.currentThread().getName()+&quot;.....sale....&quot;+num--);
            }
        }
    }
}
class DeadLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // System.out.println(&quot;t:&quot;+t);
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>静态同步函数的锁</strong></p>
<p>静态的同步函数使用的锁是该函数所属字节码文件对象，可以用 getClass 方法获取，也可以用当前类名.class 表示。</p>
<pre><code class="language-java">class Ticket implements Runnable
{
    private static int num = 100;
    // Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        // System.out.println(&quot;this:&quot;+this.getClass());
        if(flag)
            while(true)
            {
                synchronized(Ticket.class)//(this.getClass()) 此处因为对静态变量进行访问，所以取得得锁是类
                {
                    if(num&gt;0)
                    {
                        try{Thread.sleep(10);}catch (InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+&quot;.....obj....&quot;+num--); // 此处非静态方法可以访问静态变量
                    }
                }
            }
        else
            while(true)
                this.show();
    }
    public static synchronized void show()
    {
        if(num&gt;0)
        {
            try{Thread.sleep(10);}catch (InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+&quot;.....function....&quot;+num--);
        }
    }
}
class StaticSynFunctionLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // Class clazz = t.getClass();
        //
        // Class clazz = Ticket.class;
        // System.out.println(&quot;t:&quot;+t.getClass());
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>同步函数 vs 同步代码块</strong></p>
<p>同步函数和同步代码块的区别：</p>
<ol>
<li>同步函数的锁是固定的this</li>
<li>同步代码块的锁是任意的对象</li>
<li>建议使用同步代码块</li>
</ol>
<pre><code class="language-java">class Ticket implements Runnable
{
    private int num = 100;
    // Object obj = new Object();
    boolean flag = true;
    public void run()
    {
        // System.out.println(&quot;this:&quot;+this);
        if(flag)
            while(true)
            {
                synchronized(this) // 此处因为对类变量进行访问，所以取得的锁是对象
                {
                    if(num&gt;0)
                    {
                        try{Thread.sleep(10);}catch (InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+&quot;.....obj....&quot;+num--);
                    }
                }
            }
        else
            while(true)
                this.show();
    }
    public synchronized void show()
    {
        if(num&gt;0)
        {
            try{Thread.sleep(10);}catch (InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+&quot;.....function....&quot;+num--);
        }
    }
}

class SynFunctionLockDemo
{
    public static void main(String[] args)
    {
        Ticket t = new Ticket();
        // System.out.println(&quot;t:&quot;+t);
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        try{Thread.sleep(10);}catch(InterruptedException e){}
        t.flag = false;
        t2.start();
    }
}
</code></pre>
<p><strong>总结</strong></p>
<ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态变量或方法，则它取得的锁是对类，该类所有的对象同一把锁</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码 </li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li>
</ol>
<h3 id="join-1"><a class="header" href="#join-1">join()</a></h3>
<p>Java 官方解释：Waits for this thread to die.</p>
<p>当调用了 Thread.Join()方法后,当前线程会立即被执行,其他所有的线程会被暂停执行。当这个线程执行完后,其他线程才会继续执行。</p>
<pre><code class="language-java">class Demo implements Runnable
{
    public void run()
    {
        for(int x=0; x&lt;50; x++)
        {
            System.out.println(Thread.currentThread().toString()+&quot;.....&quot;+x);
            Thread.yield(); // 线程进入就绪状态，让出 CPU 使用权
        }
    }
}

class JoinDemo
{
    public static void main(String[] args) throws Exception
    {
        Demo d = new Demo();
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        t1.start();
        t2.start();
        t2.setPriority(Thread.MAX_PRIORITY); // 设置线程运行级别
        t1.join(); // t1 先执行完再说
        for(int x=0; x&lt;50; x++)
        {
            System.out.println(Thread.currentThread()+&quot;.....&quot;+x);
        }
    }
}
</code></pre>
<h3 id="线程间通信-1"><a class="header" href="#线程间通信-1">线程间通信</a></h3>
<p>线程间通讯：多个线程在处理同一资源，但是任务却不同。</p>
<p>生产者和消费者，就是一种典型的线程间通信。</p>
<pre><code class="language-java">//资源
class Resource
{
    String name;
    String sex;
}

//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true)
        {
            synchronized(r)
            {
                if(x==0)
                {
                    r.name = &quot;mike&quot;;
                    r.sex = &quot;nan&quot;;
                }
                else
                {
                    r.name = &quot;丽丽&quot;;
                    r.sex = &quot;女女女女女女&quot;;
                }
            }
            x = (x+1)%2;
        }
    }
}
//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            synchronized(r)
            {
                System.out.println(r.name+&quot;.....&quot;+r.sex);
            }
        }
    }
}
class ResourceDemo
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource();
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p>上面的代码只是一个演示代码，没有进行线程间的同步，只是一种理想化的生产消费。下面加入 wait 和 notify 进行进程之间的协作。</p>
<h3 id="wait--notify-1"><a class="header" href="#wait--notify-1">wait / notify</a></h3>
<p>等待/唤醒机制。
涉及的方法：</p>
<ol>
<li>wait(): 让线程处于冻结（阻塞）状态，被wait的线程会被存储到线程池中</li>
<li>notify(): Wakes up a single thread that is waiting on this object's monitor.</li>
<li>notifyAll(): Wakes up all threads that are waiting on this object's monitor.</li>
</ol>
<p>这些方法都必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p>
<p>以上三个方法，都是定义在 Object 基类中的类方法。因为这些方法是监视器的方法。监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。</p>
<p><strong>一个生产者和一个消费者</strong></p>
<pre><code class="language-java">//资源
class Resource
{
    String name;
    String sex;
    boolean flag = false;
}

//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true) // 这个线程一直跑
        {
            synchronized(r) // r 当成一把 lock
            {
                if(r.flag) // 有资源了，就阻塞
                    try{r.wait();}catch(InterruptedException e){}
                if(x==0) // 生产者交替生产两个产品：mike 和 丽丽
                {
                    r.name = &quot;mike&quot;;
                    r.sex = &quot;man&quot;;
                }
                else
                {
                    r.name = &quot;丽丽&quot;;
                    r.sex = &quot;女女女女女女&quot;;
                }
                r.flag = true; // 标记有资源，然后唤醒消费者来消费
                r.notify();
            }
            x = (x+1)%2; 
        }
    }
}
//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            synchronized(r)
            {
                if(!r.flag) // 没资源，就阻塞，等有资源再消费
                    try{r.wait();}catch(InterruptedException e){}
                System.out.println(&quot;消费：&quot; + r.name+&quot;.....&quot;+r.sex); // 有资源，消费 r
                r.flag = false; // 消费完后，置空，然后唤醒沉睡的生产者进程
                r.notify();
            }
        }
    }
}

class ResourceDemo2
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource(); 
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p><strong>另一种实现</strong></p>
<pre><code class="language-java">class Resource
{
    private String name;
    private String sex;
    private boolean flag = false;
    public synchronized void set(String name,String sex)
    {
        if(flag)
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.sex = sex;
        flag = true;
        this.notify();
    }
    public synchronized void out()
    {
        if(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(name+&quot;...+....&quot;+sex);
        flag = false;
        notify();
    }
}
//输入
class Input implements Runnable
{
    Resource r ;
    // Object obj = new Object();
    Input(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        int x = 0;
        while(true)
        {
            if(x==0)
            {
                r.set(&quot;mike&quot;,&quot;nan&quot;);
            }
            else
            {
                r.set(&quot;丽丽&quot;,&quot;女女女女女女&quot;);
            }
            x = (x+1)%2;
        }
    }
}

//输出
class Output implements Runnable
{
    Resource r;
    // Object obj = new Object();
    Output(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.out();
        }
    }
}

class ResourceDemo3
{
    public static void main(String[] args)
    {
        //创建资源。
        Resource r = new Resource();
        //创建任务。
        Input in = new Input(r);
        Output out = new Output(r);
        //创建线程，执行路径。
        Thread t1 = new Thread(in);
        Thread t2 = new Thread(out);
        //开启线程
        t1.start();
        t2.start();
    }
}
</code></pre>
<p>实际上，第一个例子才是最恰当的，生产和消费的行为被封装在了生产者和消费者上，而第二个例子，生产和消费的行为被绑定到了商品上，不符合常识。</p>
<p><strong>wait 和 sleep 的区别</strong></p>
<p>区别：</p>
<ol>
<li>wait可以指定时间也可以不指定。sleep必须指定时间</li>
<li>在同步中时，对cpu的执行权和锁的处理不同
wait：释放执行权，释放锁。
sleep:释放执行权，不释放锁。 （也就是不释放临界区，其他线程干等着，不符合让权等待）</li>
<li></li>
</ol>
<h3 id="多生产者与消费者-1"><a class="header" href="#多生产者与消费者-1">多生产者与消费者</a></h3>
<p>多生产者，多消费者的问题。
if 判断标记，只有一次，会导致不该运行的线程运行了。出现了数据错误的情况。
while 判断标记，解决了线程获取执行权后，是否要运行！
<code>notify</code>: 只能唤醒一个线程，如果本方唤醒了本方，没有意义。而且while判断标记+notify会导致死锁。
<code>notifyAll</code>: 解决了本方线程一定会唤醒对方线程的问题。</p>
<pre><code class="language-java">class Resource
{
    private String name;
    private int count = 1;
    private boolean flag = false;
    public synchronized void set(String name) // 生产
    {
        while(flag)
            try{this.wait();}catch(InterruptedException e){} // 有鸭子，就进入阻塞状态
        this.name = name + count;// 没鸭，生产 烤鸭1 烤鸭2 烤鸭3
        count++; //2 3 4
        System.out.println(Thread.currentThread().getName()+&quot;... 生产者...&quot;+this.name); // 生产烤鸭1 生产烤鸭2 生产烤鸭3
        flag = true; // 表示有鸭子
        notifyAll(); // 唤醒所有阻塞线程，生产者被唤醒则 wait，消费者被唤醒，则消费
    }
    public synchronized void out()// 消费
    {
        while(!flag)
            try{this.wait();}catch(InterruptedException e){} // 没鸭子，进入阻塞状态
        System.out.println(Thread.currentThread().getName()+&quot;... 消费者........&quot;+this.name);//消费烤鸭1
        flag = false;
        notifyAll(); // 唤醒了对方的所有线程
    }
}

class Producer implements Runnable
{
    private Resource r;
    Producer(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.set(&quot;烤鸭&quot;);
        }
    }
}

class Consumer implements Runnable
{
    private Resource r;
    Consumer(Resource r)
    {
        this.r = r;
    }
    public void run()
    {
        while(true)
        {
            r.out();
        }
    }
}

class ProducerConsumerDemo
{
    public static void main(String[] args)
    {
        Resource r = new Resource();
        Producer pro = new Producer(r);
        Consumer con = new Consumer(r);
        Thread t0 = new Thread(pro);
        Thread t1 = new Thread(pro);
        Thread t2 = new Thread(con);
        Thread t3 = new Thread(con);
        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<p>上面这个例子，仍然还是一个简单的生产一个，消费一个的例子，只是加入了多个生产者和消费者。</p>
<h3 id="停止线程-1"><a class="header" href="#停止线程-1">停止线程</a></h3>
<p>停止线程：</p>
<ol>
<li><code>interrupt</code> 方法</li>
<li>run 方法结束</li>
</ol>
<p>怎么控制线程的任务结束呢?</p>
<p>任务中都会有循环结构，只要控制住循环就可以结束任务。控制循环通常就用定义标记来完成。
但是如果线程处于了阻塞状态，无法读取标记。如何结束呢？可以使用 <code>interrupt()</code> 方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格。强制动作会发生 InterruptedException，要处理。</p>
<pre><code class="language-java">class StopThread implements Runnable
{
    private boolean flag = true;
    public synchronized void run()
    {
        while(flag)
        {
            try
            {
                wait(); //t0 t1
            }
            catch (InterruptedException e)
            {
                System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+e);
                flag = false;
            }
            System.out.println(Thread.currentThread().getName()+ &quot;......++++&quot;); // 被唤醒后，这句话还会执行
        }
    }
    public void setFlag()
    {
        flag = false;
    }
}

class StopThreadDemo
{
    public static void main(String[] args)
    {
       	 StopThread st = new StopThread();
         Thread t1 = new Thread(st);
         Thread t2 = new Thread(st);
         t1.start();
         t2.setDaemon(true); // t2 设置为守护进程，主线程 main 和 用户线程 t1 执行完后，自动结束
         t2.start();
         int num = 1;
         for(;;)
         {
             if(++num==50)
             {
                 // st.setFlag();
                 t1.interrupt();
                 // t2.interrupt();
                 break;
             }
             System.out.println(&quot;main....&quot;+num);
         }
         System.out.println(&quot;over&quot;);
    }
}
</code></pre>
<p><strong>守护线程和用户线程</strong></p>
<p><code>setDaemon(true)</code></p>
<p>Marks this thread as either a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#isDaemon--">daemon</a> thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</p>
<p>守护线程类似于守护进程，优先级低于用户线程和用户进程。</p>
<h3 id="多线程总结-1"><a class="header" href="#多线程总结-1">多线程总结</a></h3>
<pre><code>多线程总结：
1，进程和线程的概念。
|--进程：
|--线程：
2， jvm中的多线程体现。
|--主线程，垃圾回收线程，自定义线程。以及他们运行的代码的位置。
3，什么时候使用多线程，多线程的好处是什么？创建线程的目的？
|--当需要多部分代码同时执行的时候，可以使用。
4，创建线程的两种方式。★★★★★
|--继承 Thread
|--步骤
|--实现 Runnable
|--步骤
|--两种方式的区别？
5，线程的5种状态。
对于执行资格和执行权在状态中的具体特点。
|--被创建：
|--运行：
|--冻结：
|--临时阻塞：
|--消亡：
6，线程的安全问题。★★★★★
|--安全问题的原因：
|--解决的思想：
|--解决的体现： synchronized
|--同步的前提：但是加上同步还出现安全问题，就需要用前提来思考。
|--同步的两种表现方法和区别：
|--同步的好处和弊端：
|--单例的懒汉式。
|--死锁。
7，线程间的通信。等待/唤醒机制。
|--概念：多个线程，不同任务，处理同一资源。
|--等待唤醒机制。使用了锁上的 wait notify notifyAll. ★★★★★
|--生产者/消费者的问题。并多生产和多消费的问题。 while判断标记。用notifyAll唤醒对方。 ★
★★★★
|--JDK1.5以后出现了更好的方案，★★★
Lock接口替代了synchronized
Condition接口替代了Object中的监视方法，并将监视器方法封装成了Condition
和以前不同的是，以前一个锁上只能有一组监视器方法。现在，一个Lock锁上可以多组监视器方法对
象。
可以实现一组负责生产者，一组负责消费者。
|--wait和sleep的区别。★★★★★
8，停止线程的方式。
|--原理：
|--表现： --中断。
9，线程常见的一些方法。
|--setDaemon()
|--join();
|--优先级
|--yield();
|--在开发时，可以使用匿名内部类来完成局部的路径开辟。
</code></pre>
<h2 id="常用类-api-1"><a class="header" href="#常用类-api-1">常用类 API</a></h2>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p><strong>构造函数</strong></p>
<pre><code class="language-java">public class StringConstructorDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 将字节数组或者字符数组转成字符串可以通过String类的构造函数完成。
         */
        stringConstructorDemo2();
        stringConstructorDemo();
    }
    private static void stringConstructorDemo2() {
        char[] arr = {'w','a','p','q','x'};
        String s = new String(arr,1,3); // apq
        System.out.println(&quot;s=&quot;+s);
    }
    public static void stringConstructorDemo() {
        String s = new String(); // 等价于 String s = &quot;&quot;; 不等效String s = null;
        byte[] arr = {97,66,67,68}; // aBCD
        String s1 = new String(arr);
        System.out.println(&quot;s1=&quot;+s1);
    }
}
</code></pre>
<p><strong>字符串对象一旦被初始化就不会被改变</strong></p>
<p>字符串在内存中会存储到两个地方：</p>
<ol>
<li>
<p>常量池</p>
<pre><code class="language-java">String s = &quot;abc&quot;; // &quot;abc&quot;存储在字符串常量池中。
String s1 = &quot;abc&quot;;
System.out.println(s==s1); // true
</code></pre>
</li>
<li>
<p>堆内存</p>
<pre><code class="language-java">String s = &quot;abc&quot;; // 创建一个字符串对象在常量池中。
String s1 = new String(&quot;abc&quot;); // 创建两个对象一个new一个字符串对象在堆内存中。
System.out.println(s==s1); // false
System.out.println(s.equals(s1));
</code></pre>
</li>
</ol>
<p><strong>String 类方法及使用</strong></p>
<pre><code class="language-java">public class StringMethodDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 按照面向对象的思想对字符串进行功能分类。
         * &quot;abcd&quot;
         *
         * 1,获取：
         * 1.1 获取字符串中字符的个数(长度).
         * int length();
         * 1.2 根据位置获取字符。
         * char charAt(int index);
         * 1.3 根据字符获取在字符串中的第一次出现的位置.
         * int indexOf(int ch)
         * int indexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置
         * int indexOf(String str);
         * int indexOf(String str,int fromIndex);
         * 根据字符串获取在字符串中的第一次出现的位置.
         * int lastIndexOf(int ch)
         * int lastIndexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置
         * int lastIndexOf(String str);
         * int lastIndexOf(String str,int fromIndex);
         * 1.4 获取字符串中一部分字符串。也叫子串.
         * String substring(int beginIndex, int endIndex)//包含begin 不包含end 。
         * String substring(int beginIndex);
         *
         *
         * 2，转换。
         * 2.1 将字符串变成字符串数组(字符串的切割)
         * String[] split(String regex):涉及到正则表达式.
         * 2.2 将字符串变成字符数组。
         * char[] toCharArray();
         * 2.3 将字符串变成字节数组。
         * byte[] getBytes();
         * 2.4 将字符串中的字母转成大小写。
         * String toUpperCase():大写
         * String toLowerCase():小写
         * 2.5 将字符串中的内容进行替换
         * String replace(char oldch,char newch);
         * String replace(String s1,String s2);
         * 2.6 将字符串两端的空格去除。
         * String trim();
         * 2.7 将字符串进行连接 。
         * String concat(string);
         *
         * 3，判断
         * 3.1 两个字符串内容是否相同啊？
         * boolean equals(Object obj);
         * boolean equalsIgnoreCase(string str);忽略大写比较字符串内容。
         * 3.2 字符串中是否包含指定字符串？
         * boolean contains(string str);
         * 3.3 字符串是否以指定字符串开头。是否以指定字符串结尾。
         * boolean startsWith(string);
         * boolean endsWith(string);
         *
         * 4，比较。
         *
         */
        stringMethodDemo_4();
        // System.out.println(&quot;abc&quot;.concat(&quot;kk&quot;));
        // System.out.println(&quot;abc&quot;+&quot;kk&quot;);
        // System.out.println(String.valueOf(4)+1);
        // System.out.println(&quot;&quot;+4+1);
    }
    private static void stringMethodDemo_4() {
        System.out.println(&quot;abc&quot;.compareTo(&quot;aqz&quot;)); // -15
        /*
        * int num = 'b' - 'q';
        * System.out.println(String.valueOf(num));
        * */
    }
    private static void stringMethodDemo_3() {
        String s = &quot;abc&quot;;
        System.out.println(s.equals(&quot;ABC&quot;.toLowerCase()));
        System.out.println(s.equalsIgnoreCase(&quot;ABC&quot;));
        System.out.println(s.contains(&quot;cc&quot;));
        String str = &quot;ArrayDemo.java&quot;;
        System.out.println(str.startsWith(&quot;Array&quot;));
        System.out.println(str.endsWith(&quot;.java&quot;));
        System.out.println(str.contains(&quot;Demo&quot;));
    }
    private static void stringMethodDemo_2() {
        String s = &quot;张三,李四,王五&quot;;
        String[] arr = s.split(&quot;,&quot;);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
        char[] chs = s.toCharArray();
        for (int i = 0; i &lt; chs.length; i++) {
            System.out.println(chs[i]);
        }
        s = &quot;ab你&quot;;
        byte[] bytes = s.getBytes();
        for (int i = 0; i &lt; bytes.length; i++) {
            System.out.println(bytes[i]);
        }
        System.out.println(&quot;Abc&quot;.toUpperCase());
        String s1 = &quot;java&quot;;
        String s2 = s1.replace('q', 'z');
        System.out.println(s1==s2);//true
        System.out.println(&quot;-&quot;+&quot; ab c &quot;.trim()+&quot;-&quot;);
    }
    private static void stringMethodDemo_1() {
        String s = &quot;abcdae&quot;;
        System.out.println(&quot;length:&quot;+s.length());//6
        System.out.println(&quot;char:&quot;+s.charAt(2));//c//StringIndexOutOfBoundsException
        System.out.println(&quot;index:&quot;+s.indexOf('k'));//0//-1 我们可以根据-1，来判断该字符或者字符串是否存在。
        System.out.println(&quot;lastIndex:&quot;+s.lastIndexOf('a'));//4
        System.out.println(&quot;substring:&quot;+s.substring(2,4));
    }
}

</code></pre>
<p><strong>字符串比较</strong></p>
<pre><code class="language-java">/*
* 1，给定一个字符串数组。按照字典顺序进行从小到大的排序。
* {&quot;nba&quot;,&quot;abc&quot;,&quot;cba&quot;,&quot;zz&quot;,&quot;qq&quot;,&quot;haha&quot;}
*
* 思路：
* 1,对数组排序。可以用选择，冒泡都行。
* 2,for嵌套和比较以及换位。
* 3,问题：以前排的是整数，比较用的比较运算符，可是现在是字符串对象。
* 字符串对象怎么比较呢？爽了，对象中提供了用于字符串对象比较的功能。
*/
public class StringTest_1 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        String[] arr = { &quot;nba&quot;, &quot;abc&quot;, &quot;cba&quot;, &quot;zz&quot;, &quot;qq&quot;, &quot;haha&quot; };
        printArray(arr);
        sortString(arr);
        printArray(arr);
    }
    public static void sortString(String[] arr) {
        for (int i = 0; i &lt; arr.length - 1; i++) {
            for (int j = i + 1; j &lt; arr.length; j++) {
                if(arr[i].compareTo(arr[j])&gt;0) // 字符串比较用compareTo方法
                    swap(arr,i,j);
            }
                                                 }
    }
    private static void swap(String[] arr, int i, int j) {
        String temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void printArray(String[] arr) {
        System.out.print(&quot;[&quot;);
        for (int i = 0; i &lt; arr.length; i++) {
            if (i != arr.length - 1)
                System.out.print(arr[i] + &quot;, &quot;);
            else
                System.out.println(arr[i] + &quot;]&quot;);
        }
    }
}
</code></pre>
<p><strong>字符串格式化</strong> </p>
<p>MessageFormat</p>
<pre><code class="language-java">String deleteSql =
                &quot;delete from \n&quot; +
                &quot;  {0} \n&quot; +
                &quot;where \n&quot; +
                &quot;  {1} in (\n&quot; +
                &quot;    select \n&quot; +
                &quot;      {1} \n&quot; +
                &quot;    from \n&quot; +
                &quot;      (select * from {0}) as {0}_copy \n&quot; +
                &quot;      left join \n&quot; +
                &quot;      (select *, \&quot;{4}\&quot; as \&quot;{4}\&quot; from {2}) as {2}_copy \n&quot; +
                &quot;      on \n&quot; +
                &quot;      {0}_copy.{1} = {2}_copy.{3} \n&quot; +
                &quot;    where \n&quot; +
                &quot;      {2}_copy.{4} is NULL\n&quot; +
                &quot;  );&quot;;
deleteSql = MessageFormat.format(deleteSql, mainTableName, mainPrKeyName, subTableName, subPrKeyName, joinNULLFlag);
</code></pre>
<p>jdk 的 bug，MessageFormat doesn't replace {0} if followed by word with apostrophe。对于单引号，需要用两个单引号来显示：</p>
<pre><code class="language-java">String deleteSql =
                &quot;delete from \n&quot; +
                &quot;  {0} \n&quot; +
                &quot;where \n&quot; +
                &quot;  {1} in (\n&quot; +
                &quot;    select \n&quot; +
                &quot;      {1} \n&quot; +
                &quot;    from \n&quot; +
                &quot;      (select * from {0}) {0}_copy \n&quot; +
                &quot;      left join \n&quot; +
                &quot;      (select {2}.*, ''{4}'' {4} from {2}) {2}_copy \n&quot; +
                &quot;      on \n&quot; +
                &quot;      {0}_copy.{1} = {2}_copy.{3} \n&quot; +
                &quot;    where \n&quot; +
                &quot;      {2}_copy.{4} is NULL\n&quot; +
                &quot;  );&quot;;
</code></pre>
<p>StringBuffer 可以传入 bool 值 和 数值，统一转成字符串再存入 StringBuffer.</p>
<pre><code class="language-java">public class StringBufferDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * StringBuffer:就是字符串缓冲区。
        * 用于存储数据的容器。
        * 特点：
        * 1，长度的可变的。
        * 2，可以存储不同类型数据。
        * 3，最终要转成字符串进行使用。
        * 4，可以对字符串进行修改。
        *
        * 既然是一个容器对象。应该具备什么功能呢？
        * 1，添加：
        * StringBuffer append(data);
        * StringBuffer insert(index,data);
        * 2，删除：
        * StringBuffer delete(start,end):包含头，不包含尾。
        * StringBuffer deleteCharAt(int index):删除指定位置的元素
        * 3，查找：
        * char charAt(index);
        * int indexOf(string);
        * int lastIndexOf(string);
        * 4， 修改：
        * StringBuffer replace(start,end,string);
        * void setCharAt(index,char);
        *
        * 增删改查 C(create)U(update)R(read)D(delete)
        */
        bufferMethodDemo();
    }
    private static void bufferMethodDemo_2() {
        StringBuffer sb = new StringBuffer(&quot;abce&quot;);
        // sb.delete(1, 3);//ae
        //清空缓冲区。
        // sb.delete(0,sb.length());
        // sb = new StringBuffer();
        // sb.replace(1, 3, &quot;nba&quot;);
        // sb.setCharAt(2, 'q');
        // sb.setLength(10);
        // System.out.println(&quot;sb:&quot;+sb);
        // System.out.println(&quot;len:&quot;+sb.length());
        System.out.println(sb.reverse());
    }
    private static void bufferMethodDemo_1() {
        StringBuffer sb = new StringBuffer(&quot;abce&quot;);
        // sb.append(&quot;xixi&quot;);
        sb.insert(2, &quot;qq&quot;);
        System.out.println(sb.toString());
    }
    public static void bufferMethodDemo(){
        //创建缓冲区对象。
        StringBuffer sb = new StringBuffer();
        sb.append(4).append(false); //.append(&quot;haha&quot;);
        sb.insert(1, &quot;haha&quot;);
        // sb.append(true);
        System.out.println(sb);
    }
}
</code></pre>
<pre><code class="language-java">/*
* jdk1.5以后出现了功能和StringBuffer一模一样的对象。就是StringBuilder
*
* 不同的是：
* StringBuffer 是线程同步的。通常用于多线程。
* StringBuilder是线程不同步的。通常用于单线程。 它的出现提高效率。
*
* jdk升级：
* 1，简化书写。
* 2，提高效率。
* 3，增加安全性。
*/
</code></pre>
<h3 id="包装类-1"><a class="header" href="#包装类-1">包装类</a></h3>
<pre><code class="language-java">package com.wansho.hellojava;

public class WrapperDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * 基本数据类型对象包装类。
         * 为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操
         * 作。
         * 用于描述该对象的类就称为基本数据类型对象包装类。
         *
         * byte Byte
         * short Short
         * int Integer
         * long Long
         * float Float
         * double Double
         * char Character
         * booleanBoolean
         *
         * 该包装对象主要用基本类型和字符串之间的转换。
         *
         * 基本类型---&gt;字符串
         * 1,基本类型数值 + &quot;&quot;
         * 2,用 String 类中的静态方法 valueOf(基本类型数值);
         * 3,用 Integer 的静态方法 valueOf(基本类型数值);
         *
         * 字符串---&gt;基本类型
         * 1,使用包装类中的静态方法 xxx parseXxx(&quot;xxx类型的字符串&quot;);*****
         * int parseInt(&quot;intstring&quot;);
         * long parseLong(&quot;longstring&quot;);
         * boolean parseBoolean(&quot;booleanstring&quot;);
         * 只有Character没有parse方法
         * 2,如果字符串被Integer进行对象的封装。
         * 可使用另一个非静态的方法， intValue();
         * 将一个Integer对象转成基本数据类型值。
         */
         System.out.println(Integer.MAX_VALUE);
         System.out.println(Integer.toBinaryString(-6));
         int num = 4;
         Integer i = new Integer(5);
         int x = Integer.parseInt(&quot;123&quot;);
         System.out.println(Integer.parseInt(&quot;123&quot;)+1);
         i = new Integer(&quot;123&quot;);
         System.out.println(i.intValue());
        /*
         * 整数具备不同的进制体现。
         *
         * 十进制--&gt;其他进制。
         * toBinaryString
         * toOctalString
         * toHexString
         *
         * 其他进制--&gt;十进制。
         * parseInt(&quot;string&quot;,radix)
         *
         */
        // 十进制--&gt;其他进制。
        System.out.println(Integer.toBinaryString(60));
        System.out.println(Integer.toOctalString(60));
        System.out.println(Integer.toHexString(60));
        // System.out.println(Integer.toString(60,16));
        // 其他进制--&gt;十进制。
        // System.out.println(Integer.parseInt(&quot;3c&quot;,16));
        Integer a = new Integer(&quot;89&quot;);
        Integer b = new Integer(300);
        System.out.println(a==b);
        System.out.println(a.equals(b));
        // System.out.println(3&gt;3);
        System.out.println(a.compareTo(b));

    }
}
</code></pre>
<p><strong>自动装箱拆箱</strong></p>
<pre><code class="language-java">public class WrapperDemo2 {
    public static void main(String[] args) {
        int num = 4;
        num = num + 5;
        Integer i = 4; // i = new Integer(4); 自动装箱 简化书写。
        i = i + 6; // i = new Integer(i.intValue() + 6); // i.intValue() 自动拆箱
        // show(55);//
        Integer a = new Integer(128);
        Integer b = new Integer(128);
        System.out.println(a==b); // false 两个对象
        System.out.println(a.equals(b)); // true 值是相同的
        Integer x = 129; // jdk1.5以后，自动装箱，如果装箱的是一个字节，那么该数据会被共享不会重新开辟空间。
        Integer y = 129;
        System.out.println(x==y); // false
        System.out.println(x.equals(y)); //true
    }
}
</code></pre>
<pre><code class="language-java">import java.util.Arrays;
/*
* 对一个字符串中的数值进行从小到大的排序。
*
* &quot;20 78 9 -7 88 36 29&quot;
*
* 思路：
* 1，排序， 我很熟。可是我只熟int。
* 2，如何获取到这个字符串中的这些需要排序的数值？
* 发现这个字符串中其实都是空格来对数值进行分隔的。
* 所以就想到用字符串对象的切割方法将大串变成多个小串。
* 3，数值最终变成小字符串，怎么变成一个int数呢？135
* 字符串--&gt;基本类型 可以使用包装类。
*
*
*/
public class WrapperTest {
    private static final String SPACE_SEPARATOR = &quot; &quot;;
    /**
* @param args
*/
    public static void main(String[] args) {
        String numStr = &quot;20 78 9 -7 88 36 29&quot;;
        System.out.println(numStr);
        numStr = sortStringNumber(numStr);
        System.out.println(numStr);
    }
    /**
*
* @param numStr
* @return
*/
    public static String sortStringNumber(String numStr) {
        //1,将字符串变成字符串数组。
        String[] str_arr = stringToArray(numStr);
        //2,将字符串数组变成int数组。
        int[] num_arr = toIntArray(str_arr);
        //3,对int数组排序。
        mySortArray(num_arr);
        //4,将排序后的int数组变成字符串。
        String temp = arrayToString(num_arr);
        return temp;
    }
    public static String arrayToString(int[] num_arr) {
        StringBuilder sb = new StringBuilder();136
            for(int x = 0; x&lt;num_arr.length; x++){
                if(x!=num_arr.length-1)
                    sb.append(num_arr[x]+SPACE_SEPARATOR);
                else
                    sb.append(num_arr[x]);
            }
        return sb.toString();
    }
    public static void mySortArray(int[] num_arr) {
        Arrays.sort(num_arr);
    }
    public static int[] toIntArray(String[] str_arr) {
        int[] arr = new int[str_arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = Integer.parseInt(str_arr[i]);
        }
        return arr;
    }
    /**
* @param numStr
*/
    public static String[] stringToArray(String numStr) {
        String[] str_arr = numStr.split(SPACE_SEPARATOR);
        return str_arr;
    }
}
</code></pre>
<h3 id="泛型-1"><a class="header" href="#泛型-1">泛型</a></h3>
<p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。</p>
<p><strong>泛型的作用</strong></p>
<p><a href="https://www.oracle.com/cn/technical-resources/articles/java/juneau-generics.html">Oracle 泛型：工作原理及其重要性</a></p>
<p>在学习容器依赖，我一直忽视了两个很重要的点：</p>
<ol>
<li>
<p>容器可以同时存储不同类型的数据，例如 String 类型，Integer 类型，如果一个容器存储了不同类型的对象，不就乱套了</p>
<pre><code class="language-java">ArrayList list = new ArrayList();
list.add(&quot;abc&quot;);
list.add(new Integer(19));
Iterator it = list.iterator();
while(it.hasNext()){
    System.out.println(it.next() + &quot;&quot;);
}
/*
abc
19
*/
</code></pre>
</li>
<li>
<p>在定义容器变量的时候，并没有定义该容器存储的对象类型，这不对劲</p>
<p>在 C 语言中，我们定义结构体数组的时候，都会指定数组存储的对象类型，Java 的容器虽然不同于数组，但是其在定义容器的时候，不定义容器存储的数据类型，就感觉不对劲。</p>
<p>泛型相当于是定义了容器的存储类型</p>
</li>
</ol>
<p>Generics 的具体介绍，参考 <a href="computer-science-notebook/note-for-java/detailed-generics.html">Detailed-Generics</a></p>
<pre><code class="language-java">public class Tool&lt;QQ&gt;{ // 泛型类，类中操作的引用数据类型不确定的时候，就使用泛型来表示。 
    private QQ q;
    public QQ getObject() {
        return q;
    }
    public void setObject(QQ object) {
        this.q = object;
    }
    /**
    * 将泛型定义在方法上。
    * @param str
    */
    public &lt;W&gt; void show(W str){
        System.out.println(&quot;show : &quot;+str.toString());
    }
    public void print(QQ str){
        System.out.println(&quot;print : &quot;+str);
    }
    /**
    * 当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型，
    * 只能将泛型定义在方法上。
    * @param obj
    */
    public static &lt;Y&gt; void method(Y obj){
        System.out.println(&quot;method:&quot;+obj);
    }
}
</code></pre>
<p><strong>&lt;? super E&gt; &lt;? extend E&gt;</strong></p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo2 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        ArrayList&lt;Person&gt; al = new ArrayList&lt;Person&gt;();
        al.add(new Person(&quot;abc&quot;,30));
        al.add(new Person(&quot;abc4&quot;,34));
        ArrayList&lt;Student&gt; al2 = new ArrayList&lt;Student&gt;();
        al2.add(new Student(&quot;stu1&quot;,11));
        al2.add(new Student(&quot;stu2&quot;,22));
        ArrayList&lt;String&gt; al3 = new ArrayList&lt;String&gt;();
        al3.add(&quot;stu3331&quot;);
        al3.add(&quot;stu33332&quot;);
        printCollection(al2);
        printCollection(al);
    }
    /**
    * 迭代并打印集合中元素。
    *
    * 可以对类型进行限定：
    * ? extends E:接收E类型或者E的子类型对象。上限！
    *
    * ? super E ：接收E类型或者E的父类型。下限！
    * @param al
    */
    public static void printCollection(Collection&lt;? extends Person&gt; al)
    {//Collection&lt;Dog&gt; al = new ArrayList&lt;Dog&gt;()
        Iterator&lt;? extends Person&gt; it = al.iterator();
        while(it.hasNext()){
            // T str = it.next();
            // System.out.println(str);
            // System.out.println(it.next().toString());
            Person p = it.next();
            System.out.println(p.getName()+&quot;:&quot;+p.getAge());
        }
    }
    public static void printCollection(Collection&lt;? super Student&gt; al){
        Iterator&lt;? super Student&gt; it = al.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}



/*
* class TreeSet&lt;Worker&gt;
* {
* Tree(Comparator&lt;? super Worker&gt; comp);
* }
*
* 什么时候用下限呢？通常对集合中的元素进行取出操作时，可以是用下限。
*
*/
class CompByName implements Comparator&lt;Person&gt;{
    @Override
    public int compare(Person o1, Person o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByStuName implements Comparator&lt;Student&gt;{
    @Override
    public int compare(Student o1, Student o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByWorkerName implements Comparator&lt;Worker&gt;{
    @Override
    public int compare(Worker o1, Worker o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
</code></pre>
<p>存储用上限：</p>
<pre><code class="language-java">package cn.itcast.p5.generic.advance.demo;
import java.util.ArrayList;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo3 {
    public static void main(String[] args) {
        ArrayList&lt;Person&gt; al1 = new ArrayList&lt;Person&gt;();
        al1.add(new Person(&quot;abc&quot;, 30));
        al1.add(new Person(&quot;abc4&quot;, 34));
        ArrayList&lt;Student&gt; al2 = new ArrayList&lt;Student&gt;();
        al2.add(new Student(&quot;stu1&quot;, 11));
        al2.add(new Student(&quot;stu2&quot;, 22));
        ArrayList&lt;Worker&gt; al3 = new ArrayList&lt;Worker&gt;();
        al3.add(new Worker(&quot;stu1&quot;, 11));
        al3.add(new Worker(&quot;stu2&quot;, 22));
        ArrayList&lt;String&gt; al4 = new ArrayList&lt;String&gt;();
        al4.add(&quot;abcdeef&quot;);
        // al1.addAll(al4);//错误，类型不匹配。
        al1.addAll(al2);
        al1.addAll(al3);
        System.out.println(al1.size());
    }
}

/*
* 一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。
*/
class MyCollection&lt;E&gt; {
    public void add(E e) {
    }
    public void addAll(MyCollection&lt;? extends E&gt; e) {
    }
}
</code></pre>
<p>取出用下限：</p>
<pre><code class="language-java">package cn.itcast.p5.generic.advance.demo;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;
import cn.itcast.p2.bean.Person;
import cn.itcast.p2.bean.Student;
import cn.itcast.p2.bean.Worker;
public class GenericAdvanceDemo4 {
    public static void main(String[] args) {
        TreeSet&lt;Person&gt; al1 = new TreeSet&lt;Person&gt;(new CompByName());
        al1.add(new Person(&quot;abc4&quot;,34));
        al1.add(new Person(&quot;abc1&quot;,30));
        al1.add(new Person(&quot;abc2&quot;,38));
        TreeSet&lt;Student&gt; al2 = new TreeSet&lt;Student&gt;(new CompByName());
        al2.add(new Student(&quot;stu1&quot;,11));
        al2.add(new Student(&quot;stu7&quot;,20));
        al2.add(new Student(&quot;stu2&quot;,22));
        TreeSet&lt;Worker&gt; al3 = new TreeSet&lt;Worker&gt;();
        al3.add(new Worker(&quot;stu1&quot;,11));
        al3.add(new Worker(&quot;stu2&quot;,22));
        TreeSet&lt;String&gt; al4 = new TreeSet&lt;String&gt;();
        al4.add(&quot;abcdeef&quot;);
        // al1.addAll(al4);//错误，类型不匹配。
        // al1.addAll(al2);
        // al1.addAll(al3);
        // System.out.println(al1.size());
        Iterator&lt;Student&gt; it = al2.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}

/*
* class TreeSet&lt;Worker&gt;
* {
* Tree(Comparator&lt;? super Worker&gt; comp);
* }
*
* 什么时候用下限呢？通常对集合中的元素进行取出操作时，可以是用下限。
*
*/
class CompByName implements Comparator&lt;Person&gt;{
    @Override
    public int compare(Person o1, Person o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}

class CompByStuName implements Comparator&lt;Student&gt;{
    @Override
    public int compare(Student o1, Student o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
class CompByWorkerName implements Comparator&lt;Worker&gt;{
    @Override
    public int compare(Worker o1, Worker o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge():temp;
    }
}
</code></pre>
<h4 id="函数的可变参数-1"><a class="header" href="#函数的可变参数-1">函数的可变参数</a></h4>
<pre><code class="language-java">public class ParamterDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        // int sum = add(4,5);
        // System.out.println(&quot;sum=&quot;+sum);
        // int sum1 = add(4,5,6);
        // System.out.println(&quot;sum1=&quot;+sum1);
        // int[] arr = {5,1,4,7,3};
        // int sum = add(arr);
        // System.out.println(&quot;sum=&quot;+sum);
        // int[] arr1 = {5,1,4,7,3,9,8,7,6};
        // int sum1 = add(arr1);
        // System.out.println(&quot;sum1=&quot;+sum1);
        int sum = newAdd(5,1,4,7,3);
        System.out.println(&quot;sum=&quot;+sum);
        int sum1 = newAdd(5,1,2,7,3,9,8,7,6);
        System.out.println(&quot;sum1=&quot;+sum1);
    }
    /*
    * 函数的可变参数。
    * 其实就是一个数组，但是接收的是数组的元素。
    * 自动将这些元素封装成数组。简化了调用者的书写。
    * 注意：可变参数类型，必须定义在参数列表的结尾。
    */
    public static int newAdd(int a,int... arr){
        int sum = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            sum+=arr[i];
        }
        return sum;
        // System.out.println(arr);
        // return 0;
    }
    public static int add(int[] arr){
        int sum = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            sum+=arr[i];
        }
        return sum;
    }
    public static int add(int a,int b){
        return a+b;
    }
    public static int add(int a,int b,int c){
        return a+b+c;
    }
}
</code></pre>
<h4 id="静态导入-1"><a class="header" href="#静态导入-1">静态导入</a></h4>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
import static java.util.Collections.*;//静态导入，其实导入的是类中的静态成员。
//import static java.util.Collections.max;//静态导入，其实到入的是类中的静态成员。
import static java.lang.System.*;
public class StaticImportDemo {
    /**
* @param args
*/
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abc3&quot;);
        list.add(&quot;abc7&quot;);
        list.add(&quot;abc1&quot;);
        out.println(list);
        sort(list);
        System.out.println(list);
        String max = max(list);
        System.out.println(&quot;max=&quot;+max);
    }
}
</code></pre>
<h4 id="日期类-1"><a class="header" href="#日期类-1">日期类</a></h4>
<p>Demo1</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.Calendar;
public class CalendarDemo {
    public static void main(String[] args) {
        Calendar c = Calendar.getInstance();
        int year = 2012;
        showDays(year);
    }
    public static void showDays(int year) {
        Calendar c = Calendar.getInstance();
        c.set(year, 2, 1); // java Calendar 中的月数是从 0 开始计数，此处输入的时间是 3 月 1 日
        c.add(Calendar.DAY_OF_MONTH, -1);
        showDate(c);
    }
    public static void showDate(Calendar c) {
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH)+1;
        int day = c.get(Calendar.DAY_OF_MONTH);
        int week = c.get(Calendar.DAY_OF_WEEK);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+getWeek(week));
    }
    public static String getWeek(int i) {
        String[] weeks = {&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;};
        return weeks[i];
    }
}

</code></pre>
<p>Demo2</p>
<pre><code class="language-java">import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo {
    /**
    * @param args
    * @throws ParseException
    */
    public static void main(String[] args) throws ParseException {
        methodDemo_3();
    }
    /**
    * 将日期格式的字符串--&gt;日期对象。
    * 使用的是 DateFormat 类中的 parse() 方法。
    *
    * @throws ParseException
    */
    public static void methodDemo_3() throws ParseException {
        String str_date = &quot;2012年4月19日&quot;;
        str_date = &quot;2011---8---17&quot;;
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        dateFormat = new SimpleDateFormat(&quot;yyyy---MM---dd&quot;);
        Date date = dateFormat.parse(str_date);
        System.out.println(date);
    }
    /**
    * 对日期对象进行格式化。
    * 将日期对象--&gt;日期格式的字符串。
    * 使用的是DateFormat类中的format方法。
    *
    */
    public static void methodDemo_2() {
        Date date = new Date();
        //获取日期格式对象。具体着默认的风格。 FULL LONG等可以指定风格。
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);
        // System.out.println(dateFormat);
        //如果风格是自定义的如何解决呢？
        dateFormat = new SimpleDateFormat(&quot;yyyy--MM--dd&quot;);
        String str_date = dateFormat.format(date);
        System.out.println(str_date);
    }
    /**
    * 日期对象和毫秒值之间的转换。
    *
    * 毫秒值--&gt;日期对象 ：
    * 1，通过Date对象的构造方法 new Date(timeMillis);
    * 2，还可以通过setTime设置。
    * 因为可以通过Date对象的方法对该日期中的各个字段(年月日等)进行操作。
    *
    * 日期对象--&gt;毫秒值：
    * 2， getTime方法。
    * 因为可以通过具体的数值进行运算。
    */
    public static void methodDemo_1() {
        long time = System.currentTimeMillis();//
        // System.out.println(time);//1335671230671
        Date date = new Date();//将当前日期和时间封装成Date对象。
        System.out.println(date);//Sun Apr 29 11:48:02 CST 2012
        Date date2 = new Date(1335664696656l);//将指定毫秒值封装成Date对象。
        System.out.println(date2);
    }
}
</code></pre>
<p>Demo3</p>
<pre><code class="language-java">import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/* 练习：
* &quot;2012-3-17&quot;到&quot;2012-4-6&quot;
* 中间有多少天？
* 思路：
* 两个日期相减就哦了。
* 咋减呢？
* 必须要有两个可以进行减法运算的数。
* 能减可以是毫秒值。如何获取毫秒值？通过date对象。
* 如何获取date对象呢？可以将字符串转成date对象。
*
* 1,将日期格式的字符串转成Date对象。
* 2,将Date对象转成毫秒值。
* 3，相减，在变成天数
*
*/
public class DateTest {
    /**
    * @param args
    * @throws ParseException
    */
    public static void main(String[] args) throws ParseException {
        String str_date1 = &quot;2012-3-17&quot;;
        String str_date2 = &quot;2012-4-18&quot;;
        test(str_date1,str_date2);
    }
    public static void test(String str_date1,String str_date2) throws ParseException
    {
        //1,将日期字符串转成日期对象。
        //定义日期格式对象。
        DateFormat dateFormat = DateFormat.getDateInstance();
        dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date1 = dateFormat.parse(str_date1);
        Date date2 = dateFormat.parse(str_date2);
        long time1 = date1.getTime();
        long time2 = date2.getTime();
        long time = Math.abs(time1-time2);
        int day = getDay(time);
        System.out.println(day);
    }
    private static int getDay(long time) {
        int day = (int)(time/1000/60/60/24);
        return day;
    }
}
</code></pre>
<h4 id="math类-1"><a class="header" href="#math类-1">Math类</a></h4>
<pre><code class="language-java">import java.util.Random;
public class MathDemo {
    public static void main(String[] args) {
        /*
        * Math:提供了操作数学运算的方法， 都是静态的。
        * 常用的方法：
        * ceil():返回大于参数的最小整数。 向上取整
        * floor():返回小于参数的最大整数。向下取整
        * round():返回四舍五入的整数。   四舍五入
        * pow(a,b):a的b次方。
        */
        double d1 = Math.ceil(12.56);
        double d2 = Math.floor(12.56);
        double d3 = Math.round(12.46);
        // sop(&quot;d1=&quot;+d1);
        // sop(&quot;d2=&quot;+d2);
        // sop(&quot;d3=&quot;+d3);
        // double d = Math.pow(10, 2);
        // sop(&quot;d=&quot;+d);
        Random r = new Random();
        for (int i = 0; i &lt; 10; i++) {
            // double d = Math.ceil(Math.random()*10);
            // double d = (int)(Math.random()*6+1);
            // double d = (int)(r.nextDouble()*6+1);
            int d = r.nextInt(6)+1;
            System.out.println(d);
        }
    }
    public static void sop(String string) {
        System.out.println(string);
    }
}
</code></pre>
<h4 id="runtime-类-1"><a class="header" href="#runtime-类-1">Runtime 类</a></h4>
<p>Every Java application has a single instance of class <code>Runtime</code> that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the <code>getRuntime</code> method.</p>
<p>An application cannot create its own instance of this class.</p>
<pre><code class="language-java">import java.io.IOException;
public class RuntimeDemo {
    /**
    * @param args
    * @throws IOException
    * @throws InterruptedException
    */
    public static void main(String[] args) throws IOException, InterruptedException
    {
        /*
        * Runtime:没有构造方法摘要，说明该类不可以创建对象。
        * 又发现还有非静态的方法。说明该类应该提供静态的返回该类对象的方法。
        * 而且只有一个，说明Runtime类使用了单例设计模式。
        *
        */
        Runtime r = Runtime.getRuntime();
        // execute: 执行。 xxx.exe
        Process p = r.exec(&quot;notepad.exe&quot;);
        Thread.sleep(5000);
        p.destroy();
    }
}
</code></pre>
<h4 id="system-类-1"><a class="header" href="#system-类-1">System 类</a></h4>
<p>java.lang.System</p>
<p>Among the facilities provided by the <code>System</code> class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array.</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.Set;
public class SystemDemo {
    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * System: 类中的方法和属性都是静态的。
        * 常见方法：
        * long currentTimeMillis();获取当前时间的毫秒值。
        */
        // long l1 = 1335664696656l;//System.currentTimeMillis();
        // System.out.println(l1/1000/60/60/24);//1335664696656
        // code..
        // long l2 = System.currentTimeMillis();
        // System.out.println(l2-l1);
        System.out.println(&quot;hello-&quot;+LINE_SEPARATOR+&quot; world&quot;);
        // demo_1();
        //给系统设置一些属性信息。这些信息是全局，其他程序都可以使用。
        // System.setProperty(&quot;myclasspath&quot;, &quot;c:\myclass&quot;);
    }
    public static void demo_1(){
        //获取系统的属性信息，并存储到了Properties集合中。
        /*
        * properties集合中存储都是String类型的键和值。
        * 最好使用它自己的存储和取出的方法来完成元素的操作。
        */
        Properties prop = System.getProperties();
        Set&lt;String&gt; nameSet = prop.stringPropertyNames();
        for(String name : nameSet){
            String value = prop.getProperty(name);
            System.out.println(name+&quot;::&quot;+value);
        }
    }
}
</code></pre>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<pre><code>Collection
	List
		ArrayList
		LinkedList
		Stack
		Vector
	Set
		HashSet
			LinkedHashSet (存储顺序不变)
		TreeSet
	Map
		HashMap
			LinkedHashMap (存储顺序不变)
		HashTable
		TreeMap
	Queue
	Deque
	SortedSet
</code></pre>
<pre><code>泛型：
	jdk1.5出现的安全机制。
	
	好处：
        1，将运行时期的问题 ClassCastException 转到了编译时期。
        2，避免了强制转换的麻烦。
    &lt;&gt;:什么时候用？
    	当操作的引用数据类型不确定的时候。就使用&lt;&gt;。将要操作的引用数据类型传入即可.
		其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型 。
	
	泛型技术是给编译器使用的技术, 用于编译时期。确保了类型的安全。
	运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。
	为什么擦除呢？因为为了兼容运行的类加载器。
	
	泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。

	泛型的通配符： ? 未知类型。

	泛型的限定：
		? extends E: 接收E类型或者E的子类型对象。上限
			一般存储对象的时候用。比如 添加元素 addAll.
		? super E: 接收E类型或者E的父类型对象。 下限。
			一般取出对象的时候用。比如比较器。
--------------------------------------------------------------------------------
集合的一些技巧：

需要唯一吗？
	需要： Set
		需要制定顺序：
			需要： TreeSet
			不需要： HashSet
			但是想要一个和存储一致的顺序(有序):LinkedHashSet
	不需要： List
		需要频繁增删吗？
			需要： LinkedList
			不需要： ArrayList
			
如何记录每一个容器的结构和所属体系呢？看名字！
List
|--ArrayList
|--LinkedList
Set
|--HashSet
|--TreeSet
后缀名就是该集合所属的体系。
前缀名就是该集合的数据结构。
看到array：就要想到数组，就要想到查询快，有角标.
看到link：就要想到链表，就要想到增删快，就要想要 add get remove+frist last的方法
看到hash:就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。
看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable， Comparator 。
而且通常这些常用的集合容器都是不同步的。
--------------------------------------------------------------------------------
Map：一次添加一对元素。 Collection 一次添加一个元素。
Map也称为双列集合， Collection集合称为单列集合。
其实map集合中存储的就是键值对。map集合中必须保证键的唯一性。

常用方法：
    1，添加。
        value put(key,value):返回前一个和key关联的值，如果没有返回null.
        2，删除。186
        void clear():清空map集合。
        value remove(key):根据指定的key翻出这个键值对。
    3，判断。
        boolean containsKey(key):
        boolean containsValue(value):
        boolean isEmpty();
    4，获取。
        value get(key):通过键获取值，如果没有该键返回null.当然可以通过返回null，来判断是否包含指定键。
        int size(): 获取键值对的个数。
        
Map常用的子类：
|--Hashtable :内部结构是哈希表，是同步的。不允许null作为键， null作为值。
|--Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。
|--HashMap : 内部结构是哈希表，不是同步的。允许null作为键， null作为值。
|--TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。
</code></pre>
<p><strong>集合遍历总结</strong></p>
<pre><code class="language-java">//遍历List方法1，使用普通for循环：
for (int i = 0; i &lt; list.size(); i++) {
    String temp=(String)list.get(i);
    System.out.println(temp);
    //list.remove(i);//遍历删除元素，不过不推荐这种方式！
}
//遍历List方法2，使用增强for循环（应该使用泛型定义类型！）：
for(String temp:list){
    System.out.println(temp);
}
//遍历List方法3，使用Iterator迭代器：
for(Iterator iter=list.iterator();iter.hasNext();){
    String temp=(String)iter.next();
    System.out.println(temp);
}

Iterator iter=c.iterator();
while(iter.hasNext()){
    Object obj=iter.next();
    iter.remove();//如果要遍历删除集合中的元素，建议使用这种方式！
    System.out.println(obj);
}
//遍历Set方法1，使用增强for循环：
for(String temp:set){
    System.out.println(temp);
}
//遍历Set方法2，使用Iterator迭代器：
for(Iterator iter=list.iterator();iter.hasNext();){
    String temp=(String)iter.next();
    System.out.println(temp);
}
//遍历Map
Map&lt;Integer, Man&gt; maps=new HashMap&lt;Integer, Man&gt;();
Set&lt;Integer&gt; keySet=maps.keySet();
for(Integer id:keySet){
    System.out.println(maps.get(id).name);
}
</code></pre>
<h2 id="io-流-1"><a class="header" href="#io-流-1">I/O 流</a></h2>
<h3 id="是什么-4"><a class="header" href="#是什么-4">是什么</a></h3>
<p>I，Input：将外存中的数据读取到内存中</p>
<p>O，Output：将内存中的数据写入到外存中</p>
<h3 id="字符流字节流-1"><a class="header" href="#字符流字节流-1">字符流，字节流</a></h3>
<p>一个字符由多个字节组成！</p>
<p>IO 流分为字符流和字节流：</p>
<ul>
<li>
<p>字符流：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。在对这个文字进行操作。简单说：<strong>字节流+编码表</strong></p>
<p>顶层父类：Reader, Writer</p>
</li>
<li>
<p>字节流：顾名思义，计算机中的字节，8 位为一字节</p>
<p>顶层父类：InputStream, OutputStream</p>
</li>
</ul>
<p>这些体系的子类都以父类名作为后缀。而且子类名的前缀就是该对象的功能。</p>
<h3 id="转换流-1"><a class="header" href="#转换流-1">转换流</a></h3>
<p>FileReader 和 FileWriter 是转换流的子类！</p>
<p>Demo 将键盘的输入转换成大写，并输出到控制台：</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
public class TransStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        //字节流。键盘的输入，是字节流……
        InputStream in = System.in;
        // int ch = in.read();
        // System.out.println(ch);
        // int ch1 = in.read();
        // System.out.println(ch1);
        //将字节转成字符的桥梁。装换流。
        InputStreamReader isr = new InputStreamReader(in);
        // int ch = isr.read();
        // System.out.println((char)ch);
        //字符流。
        BufferedReader bufr = new BufferedReader(isr);
        OutputStream out = System.out;t
        OutputStreamWriter osw = new OutputStreamWriter(out);
        BufferedWriter bufw = new BufferedWriter(osw);
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            // System.out.println(line.toUpperCase());
            // osw.write(line.toUpperCase()+&quot;\r\n&quot;);
            // osw.flush();
            bufw.write(line.toUpperCase());
            bufw.newLine();
            bufw.flush();
        }
    }
}
</code></pre>
<p>功能相同的两行代码：</p>
<pre><code class="language-java">/*
* 这两句代码的功能是等同的。
* FileWriter：其实就是转换流指定了本机默认码表的体现。而且这个转换流的子类对象，可以方
* 便操作文本文件。
* 简单说：操作文件的字节流+本机默认的编码表。
* 这是按照默认码表来操作文件的便捷类。
*
* 如果操作文本文件需要明确具体的编码。 FileWriter就不行了。必须用转换流。
*/
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;gbk_3.txt&quot;), &quot;GBK&quot;);
FileWriter fw = new FileWriter(&quot;gbk_1.txt&quot;);
</code></pre>
<h3 id="file-过滤器-1"><a class="header" href="#file-过滤器-1">File, 过滤器</a></h3>
<p><strong>File</strong></p>
<pre><code class="language-java">import java.io.File;
public class FileDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        // constructorDemo();
    }
    public static void constructorDemo() {
        //可以将一个已存在的，或者不存在的文件或者目录封装成file对象。
        File f1 = new File(&quot;c:\\a.txt&quot;);
        File f2 = new File(&quot;c:\\&quot;,&quot;a.txt&quot;);
        File f = new File(&quot;c:\\&quot;);
        File f3 = new File(f,&quot;a.txt&quot;);
        File f4 = new File(&quot;c:&quot;+File.separator+&quot;abc&quot;+File.separator+&quot;a.txt&quot;);
        System.out.println(f4); // 在 Windows 上执行打印的是：c:\abc\a.txt
    }
}
</code></pre>
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.util.Date;
public class FileMethodDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * File对象的常见方法。
        *
        * 1，获取。
        * 1.1 获取文件名称。
        * 1.2 获取文件路径。
        * 1.3 获取文件大小。
        * 1.4 获取文件修改时间。
        *
        * 2，创建与删除。
        *
        * 3，判断。
        *
        * 4， 重命名
        *
        */
        // getDemo();
        // createAndDeleteDemo();
        // isDemo();
        // renameToDemo();
        // listRootsDemo();
    }
    public static void listRootsDemo() {
        File file = new File(&quot;d:\\&quot;);
        System.out.println(&quot;getFreeSpace:&quot;+file.getFreeSpace());
        System.out.println(&quot;getTotalSpace:&quot;+file.getTotalSpace());
        System.out.println(&quot;getUsableSpace:&quot;+file.getUsableSpace());
        // File[] files = File.listRoots();
        // for(File file : files){
        // System.out.println(file);
        // }
    }
    public static void renameToDemo() { // 移动文件
        File f1 = new File(&quot;c:\\9.mp3&quot;);
        File f2 = new File(&quot;d:\\aa.mp3&quot;);
        boolean b = f1.renameTo(f2);
        System.out.println(&quot;b=&quot;+b);
    }
    public static void isDemo() throws IOException{
        File f = new File(&quot;aaa&quot;);
        // f.mkdir();
        f.createNewFile();
        // boolean b = f.exists();
        // System.out.println(&quot;b=&quot;+b);
        // 最好先判断是否存在。
        System.out.println(f.isFile());
        System.out.println(f.isDirectory());
    }
    public static void createAndDeleteDemo() throws IOException {
        File dir = new File(&quot;abc\\q\\e\\c\\z\\r\\w\\y\\f\\e\\g\\s&quot;);
        // boolean b = dir.mkdir();//make directory
        // System.out.println(&quot;b=&quot;+b);
        // dir.mkdirs();//创建多级目录
        System.out.println(dir.delete());
        // System.out.println(dir.delete());
        // 文件的创建和删除。
        // File file = new File(&quot;file.txt&quot;);
        /*
        * 和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。
        *
        */
        // boolean b = file.createNewFile();
        // System.out.println(&quot;b=&quot;+b);
        // boolean b = file.delete();
        // System.out.println(&quot;b=&quot;+b);
    }
    public static void getDemo(){
        // File file = new File(&quot;E:\\java0331\\day22e\\a.txt&quot;);
        File file = new File(&quot;a.txt&quot;);
        String name = file.getName();
        String absPath = file.getAbsolutePath();//绝对路径。
        String path = file.getPath();
        long len = file.length();
        long time = file.lastModified();
        Date date = new Date(time);
        DateFormat dateFormat =
            DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);
        String str_time = dateFormat.format(date);
        System.out.println(&quot;parent:&quot;+file.getParent());226
            System.out.println(&quot;name:&quot;+name);
        System.out.println(&quot;absPath:&quot;+absPath);
        System.out.println(&quot;path:&quot;+path);
        System.out.println(&quot;len:&quot;+len);
        System.out.println(&quot;time:&quot;+time);
        System.out.println(&quot;str_time:&quot;+str_time);
    }
}

</code></pre>
<p><strong>三种常见过滤器</strong></p>
<ol>
<li>
<p>后缀名过滤器</p>
<pre><code class="language-java">public class FilterByJava implements FilenameFilter {
    @Override
    public boolean accept(File dir, String name) {
        // System.out.println(dir+&quot;---&quot;+name);
        return name.endsWith(&quot;.java&quot;);
    }
}
</code></pre>
</li>
<li>
<p>根据后缀名可以指定任意后缀名过滤的过滤器</p>
<pre><code class="language-java">import java.io.File;
import java.io.FilenameFilter;
public class SuffixFilter implements FilenameFilter {
    private String suffix ;
    public SuffixFilter(String suffix) {
        super();
        this.suffix = suffix;
    }
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(suffix);
    }
}
</code></pre>
</li>
<li>
<p>隐藏属性过滤器</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileFilter;
public class FilterByHidden implements FileFilter {
    @Override
    public boolean accept(File pathname) {
        return !pathname.isHidden();
    }
}
</code></pre>
</li>
</ol>
<p>Demo：</p>
<pre><code class="language-java">import java.io.File;
import cn.itcast.io.p2.filter.FilterByHidden;
import cn.itcast.io.p2.filter.SuffixFilter;
public class FileListDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        listDemo_2();
    }
    public static void listDemo_3() {
        File dir = new File(&quot;c:\\&quot;);
        File[] files = dir.listFiles(new FilterByHidden());
        for(File file : files){
            System.out.println(file);
        }
    }
    public static void listDemo_2() {
        File dir = new File(&quot;c:\\&quot;);
        String[] names = dir.list(new SuffixFilter(&quot;.txt&quot;));
        for(String name : names){
            System.out.println(name);
        }
    }
}
</code></pre>
<h3 id="io流操作规律-1"><a class="header" href="#io流操作规律-1">IO流操作规律</a></h3>
<p>想要知道开发时用到哪些对象。只要通过四个明确即可。</p>
<ol>
<li>
<p>明确源和目的(汇)
源： InputStream Reader
目的： OutputStream Writer</p>
</li>
<li>
<p>明确数据是否是纯文本数据。
源：是纯文本： Reader
否： InputStream
目的：是纯文本 Writer
否： OutputStream
到这里，就可以明确需求中具体要使用哪个体系。</p>
</li>
<li>
<p>明确具体的设备。
源设备：</p>
<p>硬盘： File
键盘： System.in
内存：数组
网络： Socket流</p>
<p>目的设备：</p>
<p>硬盘： File
控制台： System.out
内存：数组
网络： Socket流</p>
</li>
<li>
<p>是否需要其他额外功能。
1，是否需要高效(缓冲区);
是，就加上buffer.
2，转换？</p>
</li>
</ol>
<p>举例：</p>
<pre><code>--------------------------------------------------------------------------------
需求1：复制一个文本文件。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2,是否是纯文本？
是！
源： Reader
目的： Writer
3,明确具体设备。
源：
硬盘： File
目的：
硬盘： File
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4,需要额外功能吗？
需要，需要高效。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
--------------------------------------------------------------------------------
需求2：读取键盘录入信息，并写入到一个文件中。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确设备
源：
键盘。 System.in
目的：
硬盘。 File
InputStream in = System.in;
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
这样做可以完成，但是麻烦。将读取的字节数据转成字符串。再由字符流操作。
4，需要额外功能吗？
需要。转换。 将字节流转成字符流。因为名确的源是Reader，这样操作文本数据做便捷。
所以要将已有的字节流转成字符流。使用字节--&gt;字符 。 InputStreamReader
InputStreamReader isr = new InputStreamReader(System.in);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
还需要功能吗？
需要：想高效。
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
-------------------------------------------------------------------------------
需求3：将一个文本文件数据显示在控制台上。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确具体设备
源：
硬盘： File
目的：
控制台： System.out
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStream out = System.out;//PrintStream
4，需要额外功能吗？
需要，转换。
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(System.out);
需要，高效。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
--------------------------------------------------------------------------------
需求4：读取键盘录入数据，显示在控制台上。
1,明确源和目的。
源： InputStream Reader
目的： OutputStream Writer
2，是否是纯文本呢？
是，
源： Reader
目的： Writer
3，明确设备。
源：
键盘： System.in
目的：
控制台： System.out
InputStream in = System.in;
OutputStream out = System.out;
4，明确额外功能？
需要转换，因为都是字节流，但是操作的却是文本数据。
所以使用字符流操作起来更为便捷。
InputStreamReader isr = new InputStreamReader(System.in);
OutputStreamWriter osw = new OutputStreamWriter(System.out);
为了将其高效。
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
--------------------------------------------------------------------------------
5，将一个中文字符串数据按照指定的编码表写入到一个文本文件中.
1，目的。 OutputStream， Writer
2，是纯文本， Writer。
3，设备：硬盘File
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
fw.write(&quot;你好&quot;);
注意：既然需求中已经明确了指定编码表的动作。
那就不可以使用FileWriter，因为FileWriter内部是使用默认的本地码表。
只能使用其父类。 OutputStreamWriter.
OutputStreamWriter 接 收 一 个 字 节 输 出 流 对 象 ， 既 然 是 操 作 文 件 ， 那 么 该 对 象 应 该 是
FileOutputStream
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;),charsetName);
需要高效吗？
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;),charsetName));
什么时候使用转换流呢？
1，源或者目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。
提高对文本操作的便捷。
2，一旦操作文本涉及到具体的指定编码表时，必须使用转换流
</code></pre>
<h3 id="其他-3"><a class="header" href="#其他-3">其他</a></h3>
<h4 id="properties-集合io流-1"><a class="header" href="#properties-集合io流-1">Properties 集合+IO流</a></h4>
<p>Properties = map + io</p>
<p>* Properties集合：
* 特点：
* 1，该集合中的键和值都是字符串类型。
* 2，集合中的数据可以保存到流中，或者从流获取。</p>
<ul>
<li></li>
</ul>
<p>* 通常该集合用于操作以键值对形式存在的配置文件。</p>
<p>Demo：</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.Set;
public class PropertiesDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * Map
        * |--Hashtable
        * |--Properties:
        *
        * Properties集合：
        * 特点：
        * 1，该集合中的键和值都是字符串类型。
        * 2，集合中的数据可以保存到流中，或者从流获取。
        *
        * 通常该集合用于操作以键值对形式存在的配置文件。
        */
        // methodDemo_4();
        // myLoad();
        test();
    }
    //对已有的配置文件中的信息进行修改。
    /*
    * 读取这个文件。
    * 并将这个文件中的键值数据存储到集合中。
    * 在通过集合对数据进行修改。
    * 在通过流将修改后的数据存储到文件中。
    */
    public static void test() throws IOException{
        //读取这个文件。
        File file = new File(&quot;info.txt&quot;);
        if(!file.exists()){
            file.createNewFile();
        }
        FileReader fr = new FileReader(file);
        //创建集合存储配置信息。
        Properties prop = new Properties();
        //将流中信息存储到集合中。
        prop.load(fr);
        prop.setProperty(&quot;wangwu&quot;, &quot;16&quot;);
        FileWriter fw = new FileWriter(file);
        prop.store(fw,&quot;&quot;);
        // prop.list(System.out);
        fw.close();
        fr.close();
    }
    //模拟一下load方法。
    public static void myLoad() throws IOException{
        Properties prop = new Properties();
        BufferedReader bufr = new BufferedReader(new FileReader(&quot;info.txt&quot;));
        String line = null;
        while((line=bufr.readLine())!=null){
            if(line.startsWith(&quot;#&quot;))
                continue;
            String[] arr = line.split(&quot;=&quot;);
                // System.out.println(arr[0]+&quot;::&quot;+arr[1]);
                prop.setProperty(arr[0], arr[1]);
        }
        prop.list(System.out);
        bufr.close();
    }
    public static void methodDemo_4() throws IOException {
        Properties prop = new Properties();
        //集合中的数据来自于一个文件。
        //注意；必须要保证该文件中的数据是键值对。
        //需要使用到读取流。
        FileInputStream fis = new FileInputStream(&quot;info.txt&quot;);
        //使用load方法。
        prop.load(fis);
        prop.list(System.out);
    }
    public static void methodDemo_3() throws IOException {
        Properties prop = new Properties();
        //存储元素。
        prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        //想要将这些集合中的字符串键值信息持久化存储到文件中。
        //需要关联输出流。
        FileOutputStream fos = new FileOutputStream(&quot;info.txt&quot;);
        //将集合中数据存储到文件中，使用store方法。
        prop.store(fos, &quot;info&quot;);
        fos.close();
    }
        /**
        * 演示Properties集合和流对象相结合的功能。
        */
        public static void methodDemo_2(){
        Properties prop = new Properties();
        //存储元素。
        // prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        // prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        // prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        // prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        prop = System.getProperties();
        prop.list(System.out);
    }
    /*
    * Properties集合的存和取。
    */
    public static void propertiesDemo(){
        //创建一个Properties集合。
        Properties prop = new Properties();
        //存储元素。
        prop.setProperty(&quot;zhangsan&quot;,&quot;30&quot;);
        prop.setProperty(&quot;lisi&quot;,&quot;31&quot;);
        prop.setProperty(&quot;wangwu&quot;,&quot;36&quot;);
        prop.setProperty(&quot;zhaoliu&quot;,&quot;20&quot;);
        //修改元素。
        prop.setProperty(&quot;wangwu&quot;,&quot;26&quot;);
        //取出所有元素。
        Set&lt;String&gt; names = prop.stringPropertyNames();
        for(String name : names){
            String value = prop.getProperty(name);
            System.out.println(name+&quot;:&quot;+value);
        }
    }
}
</code></pre>
<p>Demo 用Properties定义一个程序运行次数的程序：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
/*
* 定义功能，获取一个应用程序运行的次数，如果超过5次，给出使用次数已到请注册的提示。并不要在运行
程序。
*
* 思路：
* 1，应该有计数器。
* 每次程序启动都需要计数一次,并且是在原有的次数上进行计数。
* 2，计数器就是一个变量。 突然冒出一想法，程序启动时候进行计数，计数器必须存在于内存并进行运算。
* 可是程序一结束，计数器消失了。那么再次启动该程序，计数器又重新被初始化了。
* 而我们需要多次启动同一个应用程序，使用的是同一个计数器。
* 这就需要计数器的生命周期变长，从内存存储到硬盘文件中。
*
* 3,如何使用这个计数器呢？
* 首先，程序启动时，应该先读取这个用于记录计数器信息的配置文件。
* 获取上一次计数器次数。 并进行试用次数的判断。
* 其次，对该次数进行自增，并自增后的次数重新存储到配置文件中。
*
*
* 4，文件中的信息该如何进行存储并体现。
* 直接存储次数值可以，但是不明确该数据的含义。 所以起名字就变得很重要。
* 这就有了名字和值的对应，所以可以使用键值对。
* 可是映射关系map集合搞定，又需要读取硬盘上的数据，所以 map+io = Properties.
*/
public class PropertiesTest {
    /**
* @param args
* @throws IOException
* @throws Exception
*/
    public static void main(String[] args) throws IOException {
        getAppCount();
    }
    public static void getAppCount() throws IOException{
        //将配置文件封装成File对象。
        File confile = new File(&quot;count.properties&quot;);
        if(!confile.exists()){
            confile.createNewFile();
        }
        FileInputStream fis = new FileInputStream(confile);
        Properties prop = new Properties();
        prop.load(fis);
        //从集合中通过键获取次数。
        String value = prop.getProperty(&quot;time&quot;);
        //定义计数器。记录获取到的次数。
        int count =0;
        if(value!=null){
            count = Integer.parseInt(value);
            if(count&gt;=5){
                // System.out.println(&quot;使用次数已到，请注册，给钱！ &quot;);
                // return;
                throw new RuntimeException(&quot;使用次数已到，请注册，给钱！ &quot;);
            }
        }
        count++;
        //将改变后的次数重新存储到集合中。
        prop.setProperty(&quot;time&quot;, count+&quot;&quot;);
        FileOutputStream fos = new FileOutputStream(confile);
        prop.store(fos, &quot;&quot;);
        fos.close();
        fis.close();
    }
}
</code></pre>
<p>Demo 建立一个指定扩展名文件的列表：</p>
<pre><code class="language-java">import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/*
* 获取指定目录下，指定扩展名的文件(包含子目录中的)
* 这些文件的绝对路径写入到一个文本文件中。
*
* 简单说，就是建立一个指定扩展名的文件的列表。
*
* 思路：
* 1，必须进行深度遍历。
* 2，要在遍历的过程中进行过滤。将符合条件的内容都存储到容器中。
* 3，对容器中的内容进行遍历并将绝对路径写入到文件中。
*/
public class Test {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        File dir = new File(&quot;e:\\java0331&quot;);
        FilenameFilter filter = new FilenameFilter(){
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(&quot;.java&quot;);
            }
        };
        List&lt;File&gt; list = new ArrayList&lt;File&gt;();
        getFiles(dir,filter,list);
        File destFile = new File(dir,&quot;javalist.txt&quot;);
        write2File(list,destFile);
    }
    /**
    * 对指定目录中的内容进行深度遍历，并按照指定过滤器，进行过滤，
    * 将过滤后的内容存储到指定容器List中。
    * @param dir
    * @param filter
    * @param list
    */
    public static void getFiles(File dir,FilenameFilter filter,List&lt;File&gt; list){
        File[] files = dir.listFiles();
        for(File file : files){
            if(file.isDirectory()){
                //递归啦！
                getFiles(file,filter,list);
            }else{
                //对遍历到的文件进行过滤器的过滤。将符合条件File对象，存储到List集合中。
                if(filter.accept(dir, file.getName())){
                    list.add(file);
                }
            }
        }
    }
    public static void write2File(List&lt;File&gt; list,File destFile)throws IOException{
        BufferedWriter bufw = null;
        try {
            bufw = new BufferedWriter(new FileWriter(destFile));
            for(File file : list){
                bufw.write(file.getAbsolutePath());
                bufw.newLine();
                bufw.flush();
            }
        } /*catch(IOException e){
        throw new RuntimeException(&quot;写入失败&quot;);
        }*/finally{
            if(bufw!=null)
                try {
                    bufw.close();
                } catch (IOException e) {
                    throw new RuntimeException(&quot;关闭失败&quot;);
                }
        }
    }
}
</code></pre>
<h4 id="打印流-1"><a class="header" href="#打印流-1">打印流</a></h4>
<p>打印流也是输出流的装饰流。</p>
<p>PrintStream  PrintWriter</p>
<pre><code class="language-java">import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
public class PrintStreamDemo {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        /*
         * PrintStream: 字节打印流
         * 1, 提供了打印方法可以对多种数据类型值进行打印。并保持数据的表示形式。
         * 2，它不抛 IOException
         *
         * 构造函数，接收三种类型的值：
         * 1，字符串路径。
         * 2，File 对象。
         * 3，字节输出流。
         */
        PrintStream out = new PrintStream(&quot;print.txt&quot;);
        // int by = read();
        // write(by);
        out.write(610); // 只写最低8位，
        out.print(97); // 将97先变成字符保持原样将数据打印到目的地。
        out.close();
    }
}
</code></pre>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
public class PrintWriterDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * PrintWriter：字符打印流。
        * 构造函数参数：
        * 1，字符串路径。
        * 2， File对象。
        * 3，字节输出流。
        * 4，字符输出流。
        *
        */
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new FileWriter(&quot;out.txt&quot;),true);
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            out.println(line.toUpperCase());
            // out.flush();
        }
        out.close();
        bufr.close();
    }
}
</code></pre>
<h4 id="sequenceinputstream-enumeration-1"><a class="header" href="#sequenceinputstream-enumeration-1">SequenceInputStream, Enumeration</a></h4>
<p>SequenceInputStream 接收一个枚举类型的对象</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
public class SequenceInputStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
    /*
    * 需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。
    */
    // Vector&lt;FileInputStream&gt; v = new Vector&lt;FileInputStream&gt;();
    // v.add(new FileInputStream(&quot;1.txt&quot;));
    // v.add(new FileInputStream(&quot;2.txt&quot;));
    // v.add(new FileInputStream(&quot;3.txt&quot;));
    // Enumeration&lt;FileInputStream&gt; en = v.elements();
    ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
    for(int x=1; x&lt;=3; x++){
        al.add(new FileInputStream(x+&quot;.txt&quot;));
    }
    Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
    /*
    final Iterator&lt;FileInputStream&gt; it = al.iterator();
    Enumeration&lt;FileInputStream&gt; en = new Enumeration&lt;FileInputStream&gt;(){
    @Override
    public boolean hasMoreElements() {
    return it.hasNext();
    }
    @Override
    public FileInputStream nextElement() {
    return it.next();
    }
    };*/
    SequenceInputStream sis = new SequenceInputStream(en);
    FileOutputStream fos = new FileOutputStream(&quot;1234.txt&quot;);
    byte[] buf = new byte[1024];
    int len = 0;
    while((len=sis.read(buf))!=-1){
        fos.write(buf,0,len);
    }
    fos.close();
    sis.close();
}
}
</code></pre>
<h4 id="demos-2"><a class="header" href="#demos-2">Demos</a></h4>
<p><strong>文件切割与合并</strong></p>
<p>文件切割：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
/*
* 文件切割器。
*/
public class SplitFileDemo {
    
    private static final int SIZE = 1024 * 1024;
    /**
    * @param args
    * @throws Exception
    */
    public static void main(String[] args) throws Exception {
        File file = new File(&quot;c:\\aa.mp3&quot;);
        splitFile_2(file);
    }
    private static void splitFile_2(File file) throws IOException {
        // 用读取流关联源文件。
        FileInputStream fis = new FileInputStream(file);
        // 定义一个1M的缓冲区。
        byte[] buf = new byte[SIZE];
        // 创建目的。245
        FileOutputStream fos = null;
        int len = 0;
        int count = 1;
        /*
        * 切割文件时，必须记录住被切割文件的名称，以及切割出来碎片文件的个数。 以方便于合并。
        * 这个信息为了进行描述，使用键值对的方式。用到了properties对象
        *
        */
        Properties prop = new Properties();
        File dir = new File(&quot;c:\\partfiles&quot;);
        if (!dir.exists())
            dir.mkdirs();
        while ((len = fis.read(buf)) != -1) {
            fos = new FileOutputStream(new File(dir, (count++) + &quot;.part&quot;));
            fos.write(buf, 0, len);
            fos.close();
        }
        //将被切割文件的信息保存到prop集合中。
        prop.setProperty(&quot;partcount&quot;, count+&quot;&quot;);
        prop.setProperty(&quot;filename&quot;, file.getName());
        fos = new FileOutputStream(new File(dir,count+&quot;.properties&quot;));
        //将prop集合中的数据存储到文件中。
        prop.store(fos, &quot;save file info&quot;);
        fos.close();
        fis.close();
    }
    public static void splitFile(File file) throws IOException {
        // 用读取流关联源文件。
        FileInputStream fis = new FileInputStream(file);
        // 定义一个 1M 的缓冲区。
        byte[] buf = new byte[SIZE];
        // 创建目的。
        FileOutputStream fos = null;
        int len = 0;
        int count = 1;
        File dir = new File(&quot;c:\\partfiles&quot;);
        if (!dir.exists())
            dir.mkdirs();
        while ((len = fis.read(buf)) != -1) {
            fos = new FileOutputStream(new File(dir, (count++) + &quot;.part&quot;));
            fos.write(buf, 0, len);
        }
        fos.close();
        fis.close();
    }
}
</code></pre>
<p>文件合并：</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Properties;
public class MergeFile {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        File dir = new File(&quot;c:\\partfiles&quot;);
        mergeFile_2(dir);
    }
    public static void mergeFile_2(File dir) throws IOException {
        /*
        * 获取指定目录下的配置文件对象。
        */
        File[] files = dir.listFiles(new SuffixFilter(&quot;.properties&quot;));
        if(files.length!=1)
            throw new RuntimeException(dir+&quot;,该目录下没有properties扩展名的文件或者不唯一&quot;);//记录配置文件对象。
        File confile = files[0];
        //获取该文件中的信息================================================。
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream(confile);
        prop.load(fis);
        String filename = prop.getProperty(&quot;filename&quot;);
        int count = Integer.parseInt(prop.getProperty(&quot;partcount&quot;));
        //获取该目录下的所有碎片文件。 ==============================================
        File[] partFiles = dir.listFiles(new SuffixFilter(&quot;.part&quot;));
        if(partFiles.length!=(count-1)){
            throw new RuntimeException(&quot; 碎片文件不符合要求，个数不对!应该&quot;+count+&quot;个&quot;);
        }
        //将碎片文件和流对象关联 并存储到集合中。
        ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
        for(int x=0; x&lt;partFiles.length; x++){
            al.add(new FileInputStream(partFiles[x]));
        }
        //将多个流合并成一个序列流。
        Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
        SequenceInputStream sis = new SequenceInputStream(en);
        FileOutputStream fos = new FileOutputStream(new File(dir,filename));
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=sis.read(buf))!=-1){
            fos.write(buf,0,len);
        }
        fos.close();
        sis.close();
    }
    public static void mergeFile(File dir) throws IOException{
        ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;();
        for(int x=1; x&lt;=3 ;x++){
            al.add(new FileInputStream(new File(dir,x+&quot;.part&quot;)));
        }
        Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);
        SequenceInputStream sis = new SequenceInputStream(en);
        FileOutputStream fos = new FileOutputStream(new File(dir,&quot;1.bmp&quot;));
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=sis.read(buf))!=-1){
            fos.write(buf,0,len);
        }
        fos.close();
        sis.close();
    }
}
</code></pre>
<h4 id="serializable-objectstream-1"><a class="header" href="#serializable-objectstream-1">Serializable, ObjectStream</a></h4>
<p>序列化和反序列化。序列化：将对象存储到文件中。</p>
<pre><code class="language-java">import java.io.Serializable;
/*
* Serializable:用于给被序列化的类加入ID号。
* 用于判断类和对象是否是同一个版本。
*/
public class Person implements Serializable/*标记接口*/ {
    /**
    * transient:非静态数据不想被序列化可以使用这个关键字修饰。
    */
    private static final long serialVersionUID = 9527l;
    private transient String name;
    private static int age;
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import cn.itcast.io.p2.bean.Person;

public class ObjectStreamDemo {
    /**
    * @param args
    * @throws IOException
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws IOException, ClassNotFoundException
    {
        // writeObj();
        readObj();
    }
    public static void readObj() throws IOException, ClassNotFoundException {
        ObjectInputStream ois = new ObjectInputStream(new
                                                      FileInputStream(&quot;obj.object&quot;));
        //对象的反序列化。
        Person p = (Person)ois.readObject();
        System.out.println(p.getName()+&quot;:&quot;+p.getAge());
        ois.close();
    }
    public static void writeObj() throws IOException, IOException {
        ObjectOutputStream oos = new ObjectOutputStream(new
                                                        FileOutputStream(&quot;obj.object&quot;));
        //对象序列化。 被序列化的对象必须实现Serializable接口。
        oos.writeObject(new Person(&quot;小强&quot;,30));
        oos.close();
    }
}
</code></pre>
<h4 id="randomaccessfile-1"><a class="header" href="#randomaccessfile-1">RandomAccessFile</a></h4>
<h4 id="pipedstream-1"><a class="header" href="#pipedstream-1">PipedStream</a></h4>
<p>管道流</p>
<pre><code class="language-java">import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
public class PipedStream {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        PipedInputStream input = new PipedInputStream();
        PipedOutputStream output = new PipedOutputStream();
        input.connect(output);
           new Thread(new Input(input)).start();
        new Thread(new Output(output)).start();
    }
}
class Input implements Runnable{
    private PipedInputStream in;
    Input(PipedInputStream in){
        this.in = in;
    }
    public void run(){
        try {
            byte[] buf = new byte[1024];
            int len = in.read(buf);
            String s = new String(buf,0,len);
            System.out.println(&quot;s=&quot;+s);
            in.close();
        } catch (Exception e) {
            // TODO: handle exception
        }
    }
}
class Output implements Runnable{
    private PipedOutputStream out;
    Output(PipedOutputStream out){
        this.out = out;
    }
    public void run(){
        try {
            Thread.sleep(5000);
            out.write(&quot;hi，管道来了！ &quot;.getBytes());
        } catch (Exception e) {
            // TODO: handle exception
        }
    }
}
</code></pre>
<h4 id="datastream-1"><a class="header" href="#datastream-1">DataStream</a></h4>
<pre><code class="language-java">import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
public class DataSteamDemo {
    /**
* @param args
* @throws IOException
*/
    public static void main(String[] args) throws IOException {
        // writeData();
        readData();
    }
    public static void readData() throws IOException {
        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;));
        String str = dis.readUTF();
        System.out.println(str);
    }
    public static void writeData() throws IOException {
        DataOutputStream dos = new DataOutputStream(new
                                                    FileOutputStream(&quot;data.txt&quot;));
        dos.writeUTF(&quot;你好&quot;);
        dos.close();
    }
}
</code></pre>
<h4 id="bytearraystream-1"><a class="header" href="#bytearraystream-1">ByteArrayStream</a></h4>
<p>字节数组流</p>
<pre><code class="language-java">import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
public class ByteArrayStreamDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) {
        ByteArrayInputStream bis = new ByteArrayInputStream(&quot;abcedf&quot;.getBytes());
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        int ch = 0;
        while((ch=bis.read())!=-1){
            bos.write(ch);
        }
        System.out.println(bos.toString());
    }
}
</code></pre>
<h4 id="编解码-1"><a class="header" href="#编解码-1">编解码</a></h4>
<p>编码：字符串 --&gt; <strong>字节数组</strong></p>
<p>解码：<strong>字节数组</strong> --&gt; 字符串</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

public class EncodeDemo {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        /*
         * 字符串 --&gt; 字节数组：编码。
         * 字节数组 --&gt; 字符串：解码。
         *
         * 你好： GBK: -60 -29 -70 -61
         *
         * 你好: utf-8: -28 -67 -96 -27 -91 -67
         *
         *
         * 如果你编错了，解不出来。
         * 如果编对了，解错了，有可能有救。
         */
        String str = &quot;谢谢&quot;;
        byte[] buf = str.getBytes(&quot;gbk&quot;); // 编码
        String s1 = new String(buf,&quot;UTF-8&quot;); // 解码，解错了
        System.out.println(&quot;s1=&quot;+s1); // лл
        byte[] buf2 = s1.getBytes(&quot;UTF-8&quot;);//获取源字节.
        printBytes(buf2); // -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -17 -65 -67 -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -48 -69 -48 -69
        String s2 = new String(buf2,&quot;GBK&quot;); // 解码，解对了
        System.out.println(&quot;s2=&quot;+s2);
        // encodeDemo(str);
    }
    /**
     * @param str
     * @throws UnsupportedEncodingException
     */
    public static void encodeDemo(String str)
            throws UnsupportedEncodingException {
        //编码；
        byte[] buf = str.getBytes(&quot;UTF-8&quot;);
        // printBytes(buf);
        //解码：
        String s1 = new String(buf,&quot;UTF-8&quot;);
        System.out.println(&quot;s1=&quot;+s1);
    }
    private static void printBytes(byte[] buf) {
        for(byte b : buf){
            System.out.print(b +&quot; &quot;);
        }
    }
}
</code></pre>
<h3 id="总结-3"><a class="header" href="#总结-3">总结</a></h3>
<pre><code>IO流：
输入流：
输出流：
字节流：
字符流：
	为了处理文字数据方便而出现的对象。
    其实这些对象的内部使用的还是字节流(因为文字最终也是字节数据)
    只不过，通过字节流读取了相对应的字节数，没有对这些字节直接操作。
    而是去查了指定的(本机默认的)编码表，获取到了对应的文字。
    简单说：字符流就是 ： 字节流+编码表。
--------------------------------------------------------------------------------
缓冲区：
	提高效率的，提高谁的效率？提高流的操作数据的效率。
	所以创建缓冲区之前必须先有流。
	缓冲区的基本思想：其实就是定义容器将数据进行临时存储。
	对于缓冲区对象，其实就是将这个容器进行了封装，并提供了更多高效的操作方法。
	缓冲区可以提高流的操作效率。
	其实是使用了一种设计思想完成。设计模式：装饰设计模式。
	
缓冲区的设计原理，装饰设计模式的由来：
    Writer
        |--TextWriter
        |--MediaWriter
    现在要对该体系中的对象进行功能的增强。增强的最常见手段就是缓冲区。
    先将数据写到缓冲区中，再将缓冲区中的数据一次性写到目的地。
    按照之前学习过的基本的思想，那就是对对象中的写方法进行覆盖。
    产生已有的对象子类，复写write方法。不往目的地写，而是往缓冲区写。
    所以这个体系会变成这样。
    Writer
    |--TextWriter write:往目的地
    |--BufferTextWriter write：往缓冲区写
    |--MediaWriter
    |--BufferMediaWriter
    想要写一些其他数据。就会子类。 DataWriter，为了提高其效率，还要创建该类的子类。 BufferDataWriter
    Writer
    |--TextWriter write:往目的地
    |--BufferTextWriter write：往缓冲区写
    |--MediaWriter
    |--BufferMediaWriter
    |--DataWriter
    |--BufferDataWriter
    发现这个体系相当的麻烦。每产生一个子类都要有一个高效的子类。
    而且这写高效的子类使用的功能原理都一样，都是缓冲区原理。无论数据是什么。
    都是通过缓冲区临时存储提高效率的。
    那么， 对于这个体系就可以进行优化，因为没有必要让每一个对象都具备相同功能的子类。
    哪个对象想要进行效率的提高，只要让缓冲区对其操作即可。也就说，单独将缓冲区进行封装变成对象。
    //它的出现为了提高对象的效率。所以必须在创建它的时候先有需要被提高效率的对象
    class BufferWriter
    {
    [];
    BufferedWriter(Writer w)
    { }
    /*
    BufferWriter(TextWriter w)
    { }
    BufferedWriter(MediaWriter w)
    { }
    */
    }
    BufferWriter的出现增强了Writer中的write方法。
    但是增强过后， BufferWriter对外提供的还是write方法。只不过是高效的。
    所以写的实质没有变，那么BufferWriter也是Writer中的一员。
    所以体系就会变成这样。
    Writer
    |--TextWriter
    |--MediaWriter
    |--BufferWriter
    |--DataWriter
    BufferWriter出现了避免了继承体系关系的臃肿，比继承更为灵活。
    如果是为了增强功能，这样方式解决起来更为方便。
    所以就把这种优化，总结出来，起个名字：装饰设计模式。
    装饰类和被装饰类肯定所属于同一个体系。
    既然明确了BufferedReader由来。
    我们也可以独立完成缓冲区的建立
    原理；
    1，使用流的read方法从源中读取一批数据存储到缓冲区的数组中。
    2，通过计数器记录住存储的元素个数。
    3，通过数组的角标来获取数组中的元素(从缓冲区中取数据).
    4，指针会不断的自增，当增到数组长度，会归0.计数器会自减，当减到0时，就在从源拿一批数据进缓冲区。
    
内容补足：
MyBufferedReader
LineNumberReader ：可以定义行号。

--------------------------------------------------------------------------------
字符流：
    FileReader
    FileWriter
    BufferedReader
    BufferedWriter
    
字节流：
	InputStream OutputStream
	
操作文件的字节流对象
    FileOutputStream
    FileInputStream
    BufferedOutputStream
    BufferedInputStream

--------------------------------------------------------------------------------
转换流：
InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));
InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;gbk&quot;);
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;));
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),&quot;gbk&quot;);

转换流：字节流+编码表。
转换流的子类： FileReader， FileWriter：字节流+本地默认码表(GBK)。
如果操作文本文件使用的本地默认编码表完成编码。可以使用FileReader，或者FileWriter。因为这样写简
便。
如果对操作的文本文件需要使用指定编码表进行编解码操作，这时必须使用转换流来完成。

--------------------------------------------------------------------------------
IO流的操作规律总结：
1，明确体系：
数据源： InputStream ， Reader
数据汇： OutputStream， Writer
2，明确数据：因为数据分两种：字节，字符。
数据源：是否是纯文本数据呢？
是： Reader
否： InputStream
数据汇：
是： Writer
否： OutputStream
到这里就可以明确具体要使用哪一个体系了。
剩下的就是要明确使用这个体系中的哪个对象。
3，明确设备：
数据源：
键盘： System.in
硬盘： FileXXX
内存：数组。
网络： socket socket.getInputStream();
数据汇：
控制台： System.out
硬盘： FileXXX
内存：数组
网络： socket socket.getOutputStream();
4，明确额外功能：
1，需要转换？是，使用转换流。 InputStreamReader OutputStreamWriter
2，需要高效？是，使用缓冲区。 Buffered
3，需要其他？
--------------------------------------------------------------------------------
1，复制一个文本文件。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘上的一个文件。 FileReader
目的：硬盘上的一个文件。 FileWriter269
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4，需要额外功能吗？
需要，高效，使用buffer
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
2，读取键盘录入，将数据存储到一个文件中。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：键盘， System.in
目的：硬盘， FileWriter
InputStream in = System.in;
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
4，需要额外功能吗？
需要，因为源明确的体系时Reader。可是源的设备是System.in。
所以为了方便于操作文本数据，将源转成字符流。需要转换流。 InputStreamReader
InputStreamReader isr = new InputStreamReader(System.in);
FileWriter fw = new FileWriter(&quot;a.txt&quot;);
需要高效不?需要。 Buffer
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;));
3，读取一个文本文件，将数据展现在控制台上。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘文件， FileReader。
目的：控制台： System.out。
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStream out = System.out;
4，需要额外功能？
因为源是文本数据，确定是Writer体系。所以为了方便操作字符数据，
需要使用字符流，但是目的又是一个字节输出流。
需要一个转换流， OutputStreamWriter
FileReader fr = new FileReader(&quot;a.txt&quot;);270
OutputStreamWriter osw = new OutputStreamWriter(System.out);
需要高效吗？需要。
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw = new BufferedWriter(new
OutputStreamWriter(System.out));
4，读取键盘录入，将数据展现在控制台上。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：键盘： System.in
目的：控制台： System.out
InputStream in = System.in;
OutputStream out = System.out;
4，需要额外功能吗？
因为处理的数据是文本数据，同时确定是字符流体系。
为方便操作字符数据的可以将源和目的都转成字符流。使用转换流。
为了提高效率，使用Buffer
BufferedReader bufr =new BufferedReader(new
InputStreamReader(Systme.in));
BufferedWriter bufw = new BufferedWriter(new
OutputStreamWriter(System.out));
5，读取一个文本文件，将文件按照指定的编码表UTF-8进行存储，保存到另一个文件中。
1，明确体系：
源： InputStream ， Reader
目的： OutputStream ， Writer
2，明确数据：
源：是纯文本吗？是 Reader
目的；是纯文本吗？是 Writer
3，明确设备：
源：硬盘： FileReader.
目的：硬盘： FileWriter
FileReader fr = new FileReader(&quot;a.txt&quot;);
FileWriter fw = new FileWriter(&quot;b.txt&quot;);
4，额外功能：
注意：目的中虽然是一个文件，但是需要指定编码表。
而直接操作文本文件的FileWriter本身内置的是本地默认码表。无法明确具体指定码表。271
这时就需要转换功能。 OutputStreamWriter,而这个转换流需要接受一个字节输出流，而且
对应的目的是一个文件。这时就使用字节输出流中的操作文件的流对象。 FileOutputStream.
FileReader fr = new FileReader(&quot;a.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(new
FileOutputStream(&quot;b.txt&quot;),&quot;UTF-8&quot;);
需要高效吗？
BufferedReader bufr = new BufferedReader(new FileReader(&quot;a.txt&quot;));
BufferedWriter bufw =
new BufferedWriter(new OutputStreamWriter(new
FileOutputStream(&quot;b.txt&quot;),&quot;UTF-8&quot;));
目前为止， 10个流对象重点掌握。
字符流：
FileReader
FileWriter
BufferedReader
BufferedWriter
InputStreamReader
OutputStreamWrier
字节流：
FileInputStream
FileOutputStream
BufferedInputStream
BufferedOutputStream

--------------------------------------------------------------------------------
File类：
用于将文件和文件夹封装成对象。
1，创建。
boolean createNewFile():如果该文件不存在，会创建，如果已存在，则不创建。不会像输出流
一样会覆盖。
boolean mkdir();
boolean mkdirs();
2，删除。
boolean delete();
void deleteOnExit();
3，获取：
String getAbsolutePath();
String getPath();
String getParent();
String getName();
long length();
long lastModified();
4，判断：
boolean exists();
boolean isFile();
boolean isDirectory();
5，

--------------------------------------------------------------------------------
IO中的其他功能流对象：

打印流：
    PrintStream：字节打印流。
    特点：
    1，构造函数接收File对象，字符串路径，字节输出流。意味着打印目的可以有很多。
    2，该对象具备特有的方法 打印方法 print println,可以打印任何类型的数据。
    3，特有的print方法可以保持任意类型数据表现形式的原样性，将数据输出到目的地。
    对于OutputStream父类中的write，是将数据的最低字节写出去。
    PrintWriter：字符打印流。
    特点：
    1，当操作的数据是字符时，可以选择PrintWriter，比PrintStream要方便。
    2，它的构造函数可以接收 File对象，字符串路径，字节输出流，字符输出流。
    3，构造函数中，如果参数是输出流，那么可以通过指定另一个参数true完成自动刷新，该true对
    println方法有效。
    什么时候用？
    当需要保证数据表现的原样性时，就可以使用打印流的打印方法来完成，这样更为方便。
    保证原样性的原理：其实就是将数据变成字符串，在进行写入操作
    
SequenceInputStream:
    特点：
    1，将多个字节读取流和并成一个读取流，将多个源合并成一个源，操作起来方便。
    2，需要的枚举接口可以通过Collections.enumeration(collection);
    
ObjectInputStream 和 ObjectOutputStream
    对象的序列化和反序列化。
    writeObject readObject273
    Serializable标记接口
    关键字： transient
    
RandomAccessFile:
    特点：
    1，即可读取，又可以写入。
    2，内部维护了一个大型的byte数组，通过对数组的操作完成读取和写入。
    3，通过getFilePointer方法获取指针的位置，还可以通过seek方法设置指针的位置。
    4，该对象的内容应该封装了字节输入流和字节输出流。
    5，该对象只能操作文件。
    通过seek方法操作指针，可以从这个数组中的任意位置上进行读和写
    可以完成对数据的修改。
    但是要注意：数据必须有规律。
    
管道流：需要和多线程技术相结合的流对象。
    PipedOutputStream
    PipedInputStream
    
用操作基本数据类型值的对象：
    DataInputStream
    DataOutputStream
    
设备是内存的流对象。
    ByteArrayInputStream ByteArrayOutputStream
    CharArrayReader CharArrayWriter
    
--------------------------------------------------------------------------------
IO流体系：

字符流：
Reader
    |--BufferedReader:
    |--LineNumberReader
    |--CharArrayReader
    |--StringReader
    |--InputStreamReaer
    |--FileReader
Writer
    |--BufferedWriter
    |--CharArrayWriter
    |--StringWriter
    |--OutputStreamWriter
    |--FileWriter
    |--PrintWriter
    
字节流：
InputStream
    |--FileInputStream:
    |--FilterInputStream
    |--BufferedInputStream
    |--DataInputStream
    |--ByteArrayInputStream
    |--ObjectInputStream
    |--SequenceInputStream
    |--PipedInputStream
OutputStream
    |--FileOutputStream
    |--FilterOutputStream
    |--BufferedOutputStream
    |--DataOutputStream
    |--ByteArrayOutputStream
    |--ObjectOutputStream
    |--PipedOutputStream
    |--PrintStream
</code></pre>
<h2 id="网络编程-1"><a class="header" href="#网络编程-1">网络编程</a></h2>
<h3 id="ip-1"><a class="header" href="#ip-1">IP</a></h3>
<pre><code class="language-java">import java.net.InetAddress;
import java.net.UnknownHostException;
public class IPDemo {
    /**
     * @param args
     * @throws UnknownHostException
     */
    public static void main(String[] args) throws UnknownHostException {
        //获取本地主机ip地址对象。
        InetAddress ip = InetAddress.getLocalHost();
        //获取其他主机的ip地址对象。
        //ip = InetAddress.getByName(&quot;220.181.38.150&quot;);
        //InetAddress.getByName(&quot;my_think&quot;);
        System.out.println(ip.getHostAddress()); // 获取 IP 地址
        System.out.println(ip.getHostName()); // 获取域名
    }
}
</code></pre>
<h3 id="udp-1"><a class="header" href="#udp-1">UDP</a></h3>
<p><strong>send</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
public class UDPSendDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;发送端启动......&quot;);
        /*
        * 创建UDP传输的发送端。
        * 思路：
        * 1，建立udp的socket服务。
        * 2，将要发送的数据封装到数据包中。
        * 3，通过udp的socket服务将数据包发送出去。
        * 4，关闭socket服务。
        */
        //1, udpsocket服务。使用DatagramSocket对象。
        DatagramSocket ds = new DatagramSocket(8888);
        //2, 将要发送的数据封装到数据包中。
        String str = &quot;udp传输演示：哥们来了！ &quot;;
        // 使用DatagramPacket将数据封装到的该对象包中。
        byte[] buf = str.getBytes();
        DatagramPacket dp = new
            DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.100&quot;),10000);
        //3，通过udp的socket服务将数据包发送出去。使用send方法。
        ds.send(dp);
        //4，关闭资源。
        ds.close();
    }
}
</code></pre>
<p><strong>receive</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class UDPReceDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;接收端启动......&quot;);
        /*
        * 建立UDP接收端的思路。
        * 1，建立udp socket服务,因为是要接收数据，必须要明确一个端口号。
        * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据.
        * 3，使用socket服务的receive方法将接收的数据存储到数据包中。
        * 4，通过数据包的方法解析数据包中的数据。
        * 5，关闭资源
        */
        //1,建立udp socket服务。
        DatagramSocket ds = new DatagramSocket(10000);
        //2,创建数据包。
        byte[] buf = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buf,buf.length);
        //3,使用接收方法将数据存储到数据包中。
        ds.receive(dp);//阻塞式的。
        //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
        String ip = dp.getAddress().getHostAddress();
        int port = dp.getPort();
        String text = new String(dp.getData(),0,dp.getLength());
        System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+text);
        //5,关闭资源。
        ds.close();
    }
}
</code></pre>
<p><strong>交互</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
public class UDPSendDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;发送端启动......&quot;);
        /*
        * 创建UDP传输的发送端。
        * 思路：
        * 1，建立udp的socket服务。
        * 2，将要发送的数据封装到数据包中。
        * 3，通过udp的socket服务将数据包发送出去。
        * 4，关闭socket服务。
        */
        //1,udpsocket服务。使用DatagramSocket对象。
        DatagramSocket ds = new DatagramSocket(8888);
        // String str = &quot;udp传输演示：哥们来了！ &quot;;
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        String line = null;
        while((line=bufr.readLine())!=null){
            byte[] buf = line.getBytes();
            DatagramPacket dp =
                new
                DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.100&quot;),10000);
            ds.send(dp);
            if(&quot;886&quot;.equals(line))
                break;
        }
        //4，关闭资源。
        ds.close();
    }
}

//（信息接收端）
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class UDPReceDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;接收端启动......&quot;);
        /*
        * 建立UDP接收端的思路。
        * 1，建立udp socket服务,因为是要接收数据，必须要明确一个端口号。
        * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据.
        * 3，使用socket服务的receive方法将接收的数据存储到数据包中。
        * 4，通过数据包的方法解析数据包中的数据。
        * 5，关闭资源
        */
        //1,建立udp socket服务。
        DatagramSocket ds = new DatagramSocket(10000);
        while(true){
            //2,创建数据包。
            byte[] buf = new byte[1024];
            DatagramPacket dp = new DatagramPacket(buf,buf.length);
            //3,使用接收方法将数据存储到数据包中。
            ds.receive(dp);//阻塞式的。
            //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
            String ip = dp.getAddress().getHostAddress();
            int port = dp.getPort();
            String text = new String(dp.getData(),0,dp.getLength());
            System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+text);
        }
        //5,关闭资源。
        // ds.close();
    }
}
</code></pre>
<p><strong>UDP 聊天程序，多线程</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
public class Send implements Runnable {
    private DatagramSocket ds;
    public Send(DatagramSocket ds){
        this.ds = ds;
    }
    @Override
    public void run() {
        try {
            BufferedReader bufr = new BufferedReader(new
                                                     InputStreamReader(System.in));
            String line = null;
            while((line=bufr.readLine())!=null){
                byte[] buf = line.getBytes();
                DatagramPacket dp =
                    new
                    DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.255&quot;),10001);
                ds.send(dp);
                if(&quot;886&quot;.equals(line))
                    break;
            }
            ds.close();
        } catch (Exception e) {
        }
    }
}
//（接收端）
package cn.itcast.net.p3.chat;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
public class Rece implements Runnable {
    private DatagramSocket ds;
    public Rece(DatagramSocket ds) {
        this.ds = ds;
    }
    @Override
    public void run() {
        try {
            while (true) {
                // 2,创建数据包。
                byte[] buf = new byte[1024];
                DatagramPacket dp = new DatagramPacket(buf, buf.length);
                // 3,使用接收方法将数据存储到数据包中。
                ds.receive(dp);// 阻塞式的。
                // 4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。
                String ip = dp.getAddress().getHostAddress();
                int port = dp.getPort();
                String text = new String(dp.getData(), 0, dp.getLength());
                System.out.println(ip + &quot;::&quot; + text);
                if(text.equals(&quot;886&quot;)){
                    System.out.println(ip+&quot;....退出聊天室&quot;);
                }
            }
        } catch (Exception e) {
        }
    }
}

// 开启发送和接收两个线程开始运行聊天
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.SocketException;
public class ChatDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        DatagramSocket send = new DatagramSocket();
        DatagramSocket rece = new DatagramSocket(10001);
        new Thread(new Send(send)).start();
        new Thread(new Rece(rece)).start();
    }
}
</code></pre>
<h3 id="tcp-1"><a class="header" href="#tcp-1">TCP</a></h3>
<p><strong>客户端</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class ClientDemo {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //客户端发数据到服务端
        /*
        * Tcp传输，客户端建立的过程。
        * 1，创建tcp客户端socket服务。使用的是Socket对象。
        * 建议该对象一创建就明确目的地。要连接的主机。
        * 2，如果连接建立成功，说明数据传输通道已建立。
        * 该通道就是socket流 ,是底层建立好的。 既然是流，说明这里既有输入，又有输出。
        * 想要输入或者输出流对象，可以找Socket来获取。
        * 可以通过getOutputStream(),和getInputStream()来获取两个字节流。
        * 3，使用输出流，将数据写出。
        * 4，关闭资源。
        */
        //创建客户端socket服务。
        Socket socket = new Socket(&quot;192.168.1.100&quot;,10002);
        //获取socket流中的输出流。
        OutputStream out = socket.getOutputStream();
        //使用输出流将指定的数据写出去。
        out.write(&quot;tcp演示：哥们又来了!&quot;.getBytes());
        //关闭资源。
        socket.close();
    }
}
</code></pre>
<p><strong>服务端</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerDemo {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        // 服务端接收客户端发送过来的数据，并打印在控制台上。
        /*
        * 建立tcp服务端的思路：
        * 1，创建服务端socket服务。通过ServerSocket对象。
        * 2，服务端必须对外提供一个端口，否则客户端无法连接。
        * 3，获取连接过来的客户端对象。
        * 4，通过客户端对象获取socket流读取客户端发来的数据
        * 并打印在控制台上。
        * 5，关闭资源。关客户端，关服务端。
        */
        //1创建服务端对象。
        ServerSocket ss = new ServerSocket(10002);
        //2,获取连接过来的客户端对象。
        Socket s = ss.accept();//阻塞式.
        String ip = s.getInetAddress().getHostAddress();
        //3，通过socket对象获取输入流，要读取客户端发来的数据
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(ip+&quot;:&quot;+text);
        s.close();
        ss.close();
    }
}
</code></pre>
<p><strong>交互</strong></p>
<pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class ClientDemo2 {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //客户端发数据到服务端
        /*
        * Tcp传输，客户端建立的过程。
        * 1，创建tcp客户端socket服务。使用的是Socket对象。
        * 建议该对象一创建就明确目的地。要连接的主机。
        * 2，如果连接建立成功，说明数据传输通道已建立。
        * 该通道就是socket流 ,是底层建立好的。 既然是流，说明这里既有输入，又有输出。
        * 想要输入或者输出流对象，可以找Socket来获取。
        * 可以通过getOutputStream(),和getInputStream()来获取两个字节流。
        * 3，使用输出流，将数据写出。
        * 4，关闭资源。
        */
        Socket socket = new Socket(&quot;192.168.1.100&quot;, 10002);
        OutputStream out = socket.getOutputStream();
        out.write(&quot;tcp演示：哥们又来了!&quot;.getBytes());
        // 读取服务端返回的数据,使用 socket 读取流。
        InputStream in = socket.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(text);
        //关闭资源。
        socket.close();
    }
}
//（服务端）
package cn.itcast.net.p4.tcp;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerDemo2 {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        // 服务端接收客户端发送过来的数据，并打印在控制台上。
        /*
        * 建立tcp服务端的思路：
        * 1，创建服务端socket服务。通过ServerSocket对象。
        * 2，服务端必须对外提供一个端口，否则客户端无法连接。
        * 3，获取连接过来的客户端对象。
        * 4，通过客户端对象获取socket流读取客户端发来的数据
        * 并打印在控制台上。
        * 5，关闭资源。关客户端，关服务端。
        */
        //1创建服务端对象。
        ServerSocket ss = new ServerSocket(10002);
        //2,获取连接过来的客户端对象。
        Socket s = ss.accept();
        String ip = s.getInetAddress().getHostAddress();
        //3，通过socket对象获取输入流，要读取客户端发来的数据
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(ip+&quot;:&quot;+text);
        //使用客户端socket对象的输出流给客户端返回数据
        OutputStream out = s.getOutputStream();
        out.write(&quot;收到&quot;.getBytes());
        s.close();
        ss.close();
    }
}
</code></pre>
<p>**TCP创建一个英文大写服务器  **</p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;
public class TransClient {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        /*
        * 思路：
        * 客户端：
        * 1，需要先有socket端点。
        * 2，客户端的数据源：键盘。
        * 3，客户端的目的： socket.
        * 4，接收服务端的数据，源： socket。
        * 5，将数据显示在打印出来：目的：控制台.
        * 6，在这些流中操作的数据，都是文本数据。
        * 转换客户端:
        * 1,创建socket客户端对象。
        * 2,获取键盘录入。
        * 3，将录入的信息发送给socket输出流。
        */
        //1,创建socket客户端对象。
        Socket s = new Socket(&quot;192.168.1.100&quot;,10004);
        //2，获取键盘录入。
        BufferedReader bufr =
            new BufferedReader(new InputStreamReader(System.in));
        //3,socket输出流。
        // new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        //4,socket输入流，读取服务端返回的大写数据
        BufferedReader bufIn = new BufferedReader(new
                                                  InputStreamReader(s.getInputStream()));
        String line = null;
        while((line=bufr.readLine())!=null){
            if(&quot;over&quot;.equals(line))
                break;
            // out.print(line+&quot;\r\n&quot;);
            // out.flush();
            out.println(line);
            //读取服务端发回的一行大写数。
            String upperStr = bufIn.readLine();
            System.out.println(upperStr);
        }
        s.close();
    }
}

//（服务端）
package cn.itcast.net.p5.tcptest;
import java.io.BufferedReader;292
    import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
public class TransServer {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        /*
        * 转换服务端。
        * 分析：
        * 1， serversocket服务。
        * 2，获取socket对象。
        * 3，源： socket，读取客户端发过来的需要转换的数据。
        * 4，目的：显示在控制台上。
        * 5，将数据转成大写发给客户端。
        */
        //1,
        ServerSocket ss = new ServerSocket(10004);
        //2,获取socket对象。
        Socket s = ss.accept();
        //获取ip.
        String ip = s.getInetAddress().getHostAddress();
        System.out.println(ip+&quot;......connected&quot;);
        //3,获取socket读取流，并装饰。
        BufferedReader bufIn = new BufferedReader(new
                                                  InputStreamReader(s.getInputStream()));
        //4,获取socket的输出流，并装饰。
        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        String line = null;
        while((line=bufIn.readLine())!=null){
            System.out.println(line);
            out.println(line.toUpperCase());
            // out.print(line.toUpperCase()+&quot;\r\n&quot;);
            // out.flush();
        }
        s.close();
        ss.close();
    }
}
</code></pre>
<p><strong>上传图片</strong></p>
<pre><code class="language-java">import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class UploadTask implements Runnable {
    private static final int SIZE = 1024*1024*2;
    private Socket s;
    public UploadTask(Socket s) {
        this.s = s;
    }
    @Override
    public void run() {
        int count = 0;
        String ip = s.getInetAddress().getHostAddress();
        System.out.println(ip + &quot;.....connected&quot;);
        try{
            // 读取客户端发来的数据。
            InputStream in = s.getInputStream();
            // 将读取到数据存储到一个文件中。
            File dir = new File(&quot;c:\\pic&quot;);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            File file = new File(dir, ip + &quot;.jpg&quot;);
            //如果文件已经存在于服务端
            while(file.exists()){
                file = new File(dir,ip+&quot;(&quot;+(++count)+&quot;).jpg&quot;);
            }
            FileOutputStream fos = new FileOutputStream(file);
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = in.read(buf)) != -1) {
                fos.write(buf, 0, len);
                if(file.length()&gt;SIZE){
                    System.out.println(ip+&quot;文件体积过大&quot;);
                    fos.close();
                    s.close();
                    System.out.println(ip+&quot;....&quot;+file.delete());
                    return ;
                }
            }
            // 获取socket输出流， 将上传成功字样发给客户端。
            OutputStream out = s.getOutputStream();
            out.write(&quot;上传成功&quot;.getBytes());
            fos.close();
            s.close();
        }catch(IOException e){
        }
    }
}
//（上传的客户端）
package cn.itcast.net.p1.uploadpic;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
public class UploadPicClient {
    /**
    * @param args
    * @throws IOException
    * @throws UnknownHostException
    */
    public static void main(String[] args) throws UnknownHostException, IOException
    {
        //1,创建客户端socket。
        Socket s = new Socket(&quot;192.168.1.100&quot;,10006);
        //2,读取客户端要上传的图片文件。
        FileInputStream fis = new FileInputStream(&quot;c:\\0.bmp&quot;);
        //3,获取socket输出流，将读到图片数据发送给服务端。
        OutputStream out = s.getOutputStream();
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=fis.read(buf))!=-1){
            out.write(buf,0,len);
        }
        //告诉服务端说：这边的数据发送完毕。让服务端停止读取。
        s.shutdownOutput();
        //读取服务端发回的内容。
        InputStream in = s.getInputStream();
        byte[] bufIn = new byte[1024];
        int lenIn = in.read(buf);
        String text = new String(buf,0,lenIn);
        System.out.println(text);
        fis.close();
        s.close();
    }
}
//（上传的服务端）
package cn.itcast.net.p1.uploadpic;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class UploadPicServer {
    /**
    * @param args
    * @throws IOException
    */
    public static void main(String[] args) throws IOException {
        //创建tcp的socket服务端。
        ServerSocket ss = new ServerSocket(10006);
        while(true){
            Socket s = ss.accept();
            new Thread(new UploadTask(s)).start();
        }
        //获取客户端。
        // ss.close();
    }
}
</code></pre>
<p><strong>网络编程小结</strong></p>
<pre><code>最常见的客户端：
浏览器 ： IE。
最常见的服务端：
服务器： Tomcat。
为了了解其原理：
自定义服务端，使用已有的客户端IE，了解一下客户端给服务端发了什么请求？
发送的请求是：
GET / HTTP/1.1 请求行 请求方式 /myweb/1.html 请求的资源路径 http协议版本。
请求消息头 . 属性名：属性值
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
application/x-shockwave-flash,
application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*
Accept: */*
Accept-Language: zh-cn,zu;q=0.5
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.2)
Host: 192.168.1.100:9090
//Host: www.huyouni.com:9090
Connection: Keep-Alive
//空行
//请求体。
//服务端发回应答消息。
HTTP/1.1 200 OK //应答行， http的协议版本 应答状态码 应答状态描述信息
应答消息属性信息。 属性名：属性值
Server: Apache-Coyote/1.1
ETag: W/&quot;199-1323480176984&quot;
Last-Modified: Sat, 10 Dec 2011 01:22:56 GMT
Content-Type: text/html
Content-Length: 199
Date: Fri, 11 May 2012 07:51:39 GMT
Connection: close
//空行
//应答体。
&lt;html&gt;303
&lt;head&gt;
&lt;title&gt;这是我的网页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;欢迎光临&lt;/h1&gt;
&lt;font size='5' color=&quot;red&quot;&gt;这是一个tomcat服务器中的资源。是一个html网页。 &lt;/font&gt;
&lt;/body&gt;
&lt;/html&gt;
--------------------------------------------------------------------------------
网络结构，
1,C/S client/server
特点：
该结构的软件，客户端和服务端都需要编写。
可发成本较高，维护较为麻烦。
好处：
客户端在本地可以分担一部分运算。
2,B/S browser/server
特点：
该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。
开发成本相对低，维护更为简单。
缺点：所有运算都要在服务端完成。
</code></pre>
<h2 id="反射机制-1"><a class="header" href="#反射机制-1">反射机制</a></h2>
<h3 id="什么是反射机制类的解剖-1"><a class="header" href="#什么是反射机制类的解剖-1">什么是反射机制（类的解剖）</a></h3>
<pre><code class="language-java">/*
* JAVA反射机制是在运行状态中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法；
* 对于任意一个对象，都能够调用它的任意一个方法和属性；
* 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
*
*
* 动态获取类中信息，就是java反射 。
* 可以理解为对类的解剖。
*
* 要想要对字节码文件进行解剖，必须要有字节码文件对象.
* 如何获取字节码文件对象呢？
*
*/
</code></pre>
<pre><code class="language-java">public class ReflectDemo {
    /**
    * @param args
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws ClassNotFoundException {
        getClassObject_3();
    }
    /*
    * 方式三：
    * 只要通过给定的类的 字符串名称就可以获取该类，更为扩展。
    * 可是用Class类中的方法完成。
    * 该方法就是 forName.
    * 这种方式只要有名称即可，更为方便，扩展性更强。
    */
    public static void getClassObject_3() throws ClassNotFoundException {
        String className = &quot;cn.itcast.bean.Person&quot;;
        Class clazz = Class.forName(className);
        System.out.println(clazz);
    }
    /*
    * 方式二：
    * 2，任何数据类型都具备一个静态的属性.class来获取其对应的Class对象。
    * 相对简单，但是还是要明确用到类中的静态成员。
    * 还是不够扩展。
    *
    */
    public static void getClassObject_2() {
        Class clazz = Person.class;
        Class clazz1 = Person.class;
        System.out.println(clazz==clazz1);
    }
    /*
    * 获取字节码对象的方式：
    * 1， Object类中的getClass()方法的。
    * 想要用这种方式，必须要明确具体的类，并创建对象。
    * 麻烦 .
    *
    */
    public static void getClassObject_1(){
        Person p = new Person();
        Class clazz = p.getClass();
        Person p1 = new Person();
        Class clazz1 = p1.getClass();
        System.out.println(clazz==clazz1);
    }
}
</code></pre>
<h3 id="类的解剖-1"><a class="header" href="#类的解剖-1">类的解剖</a></h3>
<p>获取构造函数：</p>
<pre><code class="language-java">import java.io.FileReader;
import java.lang.reflect.Constructor;
public class ReflectDemo2 {
    /**
    * @param args
    * @throws Exception
    * @throws InstantiationException
    * @throws ClassNotFoundException
    */
    public static void main(String[] args) throws ClassNotFoundException,
    InstantiationException, Exception {
        createNewObject_2();
    }
    public static void createNewObject_2() throws Exception {
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person(&quot;小强&quot;,39);
        /*
        * 当获取指定名称对应类中的所体现的对象时，
        * 而该对象初始化不使用空参数构造该怎么办呢？
        * 既然是通过指定的构造 函数进行对象的初始化，
        * 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。
        * 该方法是： getConstructor(paramterTypes);
        *
        */
        String name = &quot;cn.itcast.bean.Person&quot;;
        //找寻该名称类文件，并加载进内存，并产生Class对象。
        Class clazz = Class.forName(name);
        //获取到了指定的构造函数对 象。
        Constructor constructor = clazz.getConstructor(String.class,int.class);
        //通过该构造器对象的newInstance方法进行对象的初始化。
        Object obj = constructor.newInstance(&quot;小明&quot;,38);
    }
    public static void createNewObject() throws ClassNotFoundException,
    InstantiationException, IllegalAccessException{
        //早期： new时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，
        // 并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象.
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person();
        //现在：
        String name = &quot;cn.itcast.bean.Person&quot;;
        //找寻该名称类文件，并加载进内存，并产生Class对象。
        Class clazz = Class.forName(name);
        //如何产生该类的对象呢？
        Object obj = clazz.newInstance();
    }
}
</code></pre>
<p>获取字段：</p>
<pre><code class="language-java">import java.lang.reflect.Field;
public class ReflectDemo3 {
    /**
    * @param args
    * @throws Exception
    */
    public static void main(String[] args) throws Exception {
        getFieldDemo();
    }
    /*
    * 获取字节码文件中的字段。
    */
    public static void getFieldDemo() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Field field = null;//clazz.getField(&quot;age&quot;);//只能获取公有的，
        field = clazz.getDeclaredField(&quot;age&quot;);//只获取本类，但包含私有。
        //对私有字段的访问取消权限检查。暴力访问。
        field.setAccessible(true);
        Object obj = clazz.newInstance();
        field.set(obj, 89);
        Object o = field.get(obj);
        System.out.println(o);
        // cn.itcast.bean.Person p = new cn.itcast.bean.Person();
        // p.age = 30;
    }
}
</code></pre>
<p>获取公共函数：</p>
<pre><code class="language-java">import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
public class ReflectDemo4 {
    public ReflectDemo4() {
    }
    /**
* @param args
* @throws Exception
*/
    public static void main(String[] args) throws Exception {
        getMethodDemo_3();
    }
    public static void getMethodDemo_3() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method method = clazz.getMethod(&quot;paramMethod&quot;, String.class,int.class);
        Object obj = clazz.newInstance();
        method.invoke(obj, &quot;小强&quot;,89);
    }
    public static void getMethodDemo_2() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method method = clazz.getMethod(&quot;show&quot;, null); //获取空参数一般方法。
        // Object obj = clazz.newInstance();
        Constructor constructor = clazz.getConstructor(String.class,int.class);
        Object obj = constructor.newInstance(&quot;小明&quot;,37);
        method.invoke(obj, null);
    }
    /*
    * 获取指定Class中的所有公共函数。
    */
    public static void getMethodDemo() throws Exception {
        Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);
        Method[] methods = clazz.getMethods();//获取的都是公有的方法。
        methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。
        for(Method method : methods){
            System.out.println(method);
        }
    }
}
</code></pre>
<h2 id="正则表达式-3"><a class="header" href="#正则表达式-3">正则表达式</a></h2>
<p>Demos:</p>
<pre><code class="language-java">public class RegexDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        String qq = &quot;123k4567&quot;;
        // checkQQ(qq);
        String regex = &quot;[1-9][0-9]{4,14}&quot;;//正则表达式。
        // boolean b = qq.matches(regex);
        // System.out.println(qq+&quot;:&quot;+b);
        // String str = &quot;aoooooooob&quot;;
        // String reg = &quot;ao{4,6}b&quot;;
        // boolean b = str.matches(reg);
        // System.out.println(str+&quot;:&quot;+b);
    }
    /*
    * 需求：定义一个功能对QQ号进行校验。
    * 要求：长度5~15. 只能是数字， 0不能开头
    */
    public static void checkQQ(String qq){
        int len = qq.length();
        if(len&gt;=5 &amp;&amp; len&lt;=15){
            if(!qq.startsWith(&quot;0&quot;)){
                try {
                    long l = Long.parseLong(qq);
                    System.out.println(l+&quot;:正确&quot;);
                }catch(NumberFormatException e){
                    System.out.println(qq+&quot;:含有非法字符&quot;);
                }
            }else{
                System.out.println(qq+&quot;:不能0开头&quot;);
            }
        }else{
            System.out.println(qq+&quot;:长度错误&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexDemo2 {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
    * 正则表达式对字符串的常见操作:
    * 1, 匹配。
    * 其实使用的就是String类中的matches方法。
    *
    * 2，切割。
    * 其实使用的就是String类中的split方法。
    *
    * 3，替换。
    * 其实使用的就是String类中的replaceAll()方法。
    *
    * 4，获取。
    *
    */
        functionDemo_4();
    }
    /*
    * 获取
    * 将正则规则进行对象的封装。
    * Pattern p = Pattern.compile(&quot;a*b&quot;);
    * //通过正则对象的matcher方法字符串相关联。获取要对字符串操作的匹配器对象Matcher .
    * Matcher m = p.matcher(&quot;aaaaab&quot;);
    * //通过Matcher匹配器对象的方法对字符串进行操作。
    * boolean b = m.matches();
    */
    public static void functionDemo_4() {
        String str = &quot;da jia hao,ming tian bu fang jia!&quot;;
        String regex = &quot;\\b[a-z]{3}\\b&quot;;
        //1,将正则封装成对象。
        Pattern p = Pattern.compile(regex);
        //2, 通过正则对象获取匹配器对象。
        Matcher m = p.matcher(str);
        //使用Matcher对象的方法对字符串进行操作。
        //既然要获取三个字母组成的单词
        //查找。 find();
        System.out.println(str);
        while(m.find()){
            System.out.println(m.group());//获取匹配的子序列
            System.out.println(m.start()+&quot;:&quot;+m.end());
        }
    }
    /*
    * 替换
    */
    public static void functionDemo_3() {
        String str = &quot;zhangsanttttxiaoqiangmmmmmmzhaoliu&quot;;
        str = str.replaceAll(&quot;(.)\\1+&quot;, &quot;$1&quot;);
        System.out.println(str);
        String tel = &quot;15800001111&quot;; //158****1111;
        tel = tel.replaceAll(&quot;(\\d{3})\\d{4}(\\d{4})&quot;, &quot;$1****$2&quot;);
        System.out.println(tel);
    }
    /*
    * 切割。
    *
    * 组： ((A)(B(C)))
    */
    public static void functionDemo_2(){
        String str = &quot;zhangsanttttxiaoqiangmmmmmmzhaoliu&quot;;
        String[] names = str.split(&quot;(.)\\1+&quot;); //str.split(&quot;\\.&quot;);
        for(String name : names){
            System.out.println(name);
        }
    }
    /*
    * 演示匹配。
    */
    public static void functionDemo_1(){
        //匹配手机号码是否正确。
        String tel = &quot;15800001111&quot;;
        String regex = &quot;1[358]\\d{9}&quot;;
        boolean b = tel.matches(regex);
        System.out.println(tel+&quot;:&quot;+b);
    }
}
</code></pre>
<h2 id="枚举类型-1"><a class="header" href="#枚举类型-1">枚举类型</a></h2>
<p>https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424</p>
<p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类。</p>
<p>Demo:</p>
<pre><code class="language-java">public enum Color {
    RED, GREEN, BLUE;
}
</code></pre>
<p>编译出的 class 大概是这样的：</p>
<pre><code class="language-java">public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
</code></pre>
<p>编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>
<pre><code class="language-java">// name()
String s = Color.RED.name(); // &quot;RED&quot;

// ordinal() 返回定义的常量的顺序，从0开始计数
int n = Color.RED.ordinal(); 
</code></pre>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);
        } else {
            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
        }
    }
}

enum Weekday {
    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);

    public final int dayValue;
    private final String chinese;

    private Weekday(int dayValue, String chinese) {
        this.dayValue = dayValue;
        this.chinese = chinese;
    }

    @Override
    public String toString() {
        return this.chinese;
    }
}
</code></pre>
<p>注意，enum 在 Java 中是关键字，所以我们不能创建 enum 的包名，如果要在项目中创建枚举类，应该放在 enums 文件夹下！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合"><a class="header" href="#集合">集合</a></h1>
<p>[TOC]</p>
<h2 id="collection-集合"><a class="header" href="#collection-集合">Collection 集合</a></h2>
<h3 id="collection-接口定义的集合通用方法"><a class="header" href="#collection-接口定义的集合通用方法">Collection 接口定义的集合通用方法</a></h3>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.ArrayList;
import java.util.Collection;
public class CollectionDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        Collection coll = new ArrayList();
        // show(coll);
        Collection c1 = new ArrayList();
        Collection c2 = new ArrayList();
        show(c1,c2);
    }
    public static void show(Collection c1,Collection c2){
        //给c1添加元素。
        c1.add(&quot;abc1&quot;);
        c1.add(&quot;abc2&quot;);
        c1.add(&quot;abc3&quot;);
        c1.add(&quot;abc4&quot;);
        //给c2添加元素。
        c2.add(&quot;abc1&quot;);
        c2.add(&quot;abc2&quot;);
        c2.add(&quot;abc3&quot;);
        c2.add(&quot;abc4&quot;);
        c2.add(&quot;abc5&quot;);
        System.out.println(&quot;c1:&quot;+c1); // c1:[abc1, abc2, abc3, abc4]
        System.out.println(&quot;c2:&quot;+c2);
        //演示addAll
        c1.addAll(c2);//将c2中的元素添加到c1中。
        //演示removeAll
        // boolean b = c1.removeAll(c2); // 将两个集合中的相同元素从调用removeAll的集合中删除。
        // System.out.println(&quot;removeAll:&quot;+b);
        //演示containsAll
        boolean b = c1.containsAll(c2);
        System.out.println(&quot;containsAll:&quot;+b);
        //演示retainAll
        // b = c1.retainAll(c2); // 取交集，保留和指定的集合相同的元素，而删除不同的元素。
        //和removeAll功能相反 。
        // System.out.println(&quot;retainAll:&quot;+b);
        System.out.println(&quot;c1:&quot;+c1);
    }
    public static void show(Collection coll){
        //1,添加元素。 add.
        coll.add(&quot;abc1&quot;);
        coll.add(&quot;abc2&quot;);
        coll.add(&quot;abc3&quot;);
        System.out.println(coll);
        //2，删除元素。 remove
        // coll.remove(&quot;abc2&quot;);//会改变集合的长度
        //清空集合.
        // coll.clear();
        System.out.println(coll.contains(&quot;abc3&quot;));
        System.out.println(coll);
    }
}
</code></pre>
<h3 id="iterator--迭代器"><a class="header" href="#iterator--迭代器">Iterator  迭代器</a></h3>
<p>Collection 接口实现了 Iterable 接口，具备了可迭代的特性</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
public class IteratorDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        Collection coll = new ArrayList();
        coll.add(&quot;abc1&quot;);
        coll.add(&quot;abc2&quot;);
        coll.add(&quot;abc3&quot;);
        coll.add(&quot;abc4&quot;);
        // System.out.println(coll);
        //使用了Collection中的iterator()方法。 调用集合中的迭代器方法，是为了获取集合中的迭代器对象。
        // Iterator it = coll.iterator();
        // while(it.hasNext()){
        // System.out.println(it.next());
        // }
        for(Iterator it = coll.iterator(); it.hasNext(); ){
            System.out.println(it.next());
        }
        // System.out.println(it.next());
        // System.out.println(it.next());
        // System.out.println(it.next()); // java.util.NoSuchElementException
    }
}
</code></pre>
<h3 id="list-1"><a class="header" href="#list-1">List</a></h3>
<h4 id="arraylist-2"><a class="header" href="#arraylist-2">ArrayList</a></h4>
<p>关键字：ListIterator，list.get(i)</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
public class ListDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        List list = new ArrayList();
        show(list);
    }
    public static void show(List list) {
        //添加元素
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        System.out.println(list);
        //插入元素。
        // list.add(1,&quot;abc9&quot;);
        //删除元素。
        // System.out.println(&quot;remove:&quot;+list.remove(2));
        //修改元素。
        // System.out.println(&quot;set:&quot;+list.set(1, &quot;abc8&quot;));
        //获取元素。
        // System.out.println(&quot;get:&quot;+list.get(0));
        //获取子列表。
        // System.out.println(&quot;sublist:&quot;+list.subList(1, 2));
        System.out.println(list);
    }
}
</code></pre>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
public class ListDemo2 {
    /**
     * @param args
     */
    public static void main(String[] args) {
        List list = new ArrayList();
        // show(list);
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        System.out.println(&quot;list:&quot;+list);
        ListIterator it = list.listIterator();//获取列表迭代器对象
        //它可以实现在迭代过程中完成对元素的增删改查。
        //注意：只有list集合具备该迭代功能.
        while(it.hasNext()){
            Object obj = it.next();
            if(obj.equals(&quot;abc2&quot;)){
                it.set(&quot;abc9&quot;); // 改
            }
        }
        System.out.println(&quot;hasNext:&quot;+it.hasNext());
        System.out.println(&quot;hasPrevious:&quot;+it.hasPrevious());
        while(it.hasPrevious()){
            System.out.println(&quot;previous:&quot;+it.previous());
        }
        System.out.println(&quot;list:&quot;+list);
        show(list);
        Iterator itt = list.iterator();
        while(itt.hasNext()) {
            Object obj = it.next();//java.util.ConcurrentModificationException
            //在迭代器过程中，不要使用集合操作元素，容易出现异常。
            //可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更
            //多的操作。
            if (obj.equals(&quot;abc2&quot;)) {
                list.add(&quot;abc9&quot;);
            } else {
                System.out.println(&quot;next:&quot; + obj);
            }
            System.out.println(list);
        }
    }
    public static void show(List list) {
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        list.add(&quot;abc4&quot;);
        Iterator it = list.iterator();
        while(it.hasNext()){
            System.out.println(&quot;next:&quot;+it.next());
        }
        //list特有的取出元素的方式之一。
        for(int x=0; x&lt;list.size(); x++){
            System.out.println(&quot;get:&quot;+list.get(x));
        }
    }
}
</code></pre>
<h4 id="vector"><a class="header" href="#vector">Vector</a></h4>
<p>It is similar to the ArrayList, but with two differences. </p>
<ul>
<li>Vector is synchronized. Vector 是<strong>线程安全</strong>的。</li>
<li>Java Vector contains many legacy methods that are not the part of a collections framework.</li>
</ul>
<pre><code class="language-java">import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

public class VectorDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        Vector v = new Vector();
        v.addElement(&quot;abc1&quot;);
        v.addElement(&quot;abc2&quot;);
        v.addElement(&quot;abc3&quot;);
        v.addElement(&quot;abc4&quot;);
        Enumeration en = v.elements();
        while(en.hasMoreElements()){
            System.out.println(&quot;nextelment:&quot;+en.nextElement());
        }
        Iterator it = v.iterator();
        while(it.hasNext()){
            System.out.println(&quot;next:&quot;+it.next());
        }
    }
}
</code></pre>
<h4 id="linkedlist"><a class="header" href="#linkedlist">LinkedList</a></h4>
<pre><code class="language-java">import java.util.Iterator;
import java.util.LinkedList;
public class LinkedListDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        LinkedList link = new LinkedList();
        link.addFirst(&quot;abc1&quot;);
        link.addFirst(&quot;abc2&quot;);
        link.addFirst(&quot;abc3&quot;);
        link.addFirst(&quot;abc4&quot;);
        // System.out.println(link);
        // System.out.println(link.getFirst());//获取第一个但不删除。
        // System.out.println(link.getFirst());
        // System.out.println(link.removeFirst());//获取元素但是会删除。
        // System.out.println(link.removeFirst());
        while(!link.isEmpty()){
            System.out.println(link.removeLast());
        }
        System.out.println(link);
        // Iterator it = link.iterator();
        // while(it.hasNext()){
        // System.out.println(it.next());
        // }
    }
}
</code></pre>
<h4 id="queue-1"><a class="header" href="#queue-1">Queue</a></h4>
<table><thead><tr><th style="text-align: left">Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>boolean</code></td><td><code>add(E e)</code></td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning <code>true</code> upon success and throwing an <code>IllegalStateException</code> if no space is currently available.</td></tr>
<tr><td style="text-align: left"><code>E</code></td><td><code>element()</code></td><td>Retrieves, but does not remove, the head of this queue.</td></tr>
<tr><td style="text-align: left"><code>boolean</code></td><td><code>offer(E e)</code></td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions.</td></tr>
<tr><td style="text-align: left"><code>E</code></td><td><code>peek()</code></td><td>Retrieves, but does not remove, the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr>
<tr><td style="text-align: left"><code>E</code></td><td><code>poll()</code></td><td>Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr>
<tr><td style="text-align: left"><code>E</code></td><td><code>remove()</code></td><td>Retrieves and removes the head of this queue.</td></tr>
</tbody></table>
<p>add()和remove()方法在失败的时候会抛出异常(不推荐)，用 offer 和 poll 代替。</p>
<p>利用 Queue 进行层次遍历 Demo：</p>
<pre><code class="language-java">public List&lt;Concept&gt; findAllSubConcepts(Concept rootConcept) {
        List&lt;Concept&gt; subConcepts = new ArrayList&lt;&gt;();
        Queue&lt;Concept&gt; queue = new LinkedList&lt;&gt;();
        Concept tmpConcept = null;
        queue.add(rootConcept);
        while(!queue.isEmpty()){
            tmpConcept = queue.remove();
            subConcepts.add(tmpConcept);
            String tmpConceptId = tmpConcept.getId();
            List&lt;Concept&gt; subLevelConcepts = conceptRepo.findConceptsByFId(tmpConceptId);
            queue.addAll(subLevelConcepts);
        }
        return subConcepts;
    }
</code></pre>
<h3 id="set-1"><a class="header" href="#set-1">Set</a></h3>
<h4 id="hashset"><a class="header" href="#hashset">HashSet</a></h4>
<p>HashSet 首先是一个 Set。</p>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Iterator;

public class HashSetDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        HashSet hs = new HashSet();
        hs.add(&quot;hehe&quot;);
        // hs.add(&quot;heihei&quot;);
        hs.add(&quot;hahah&quot;);
        hs.add(&quot;xixii&quot;);
        hs.add(&quot;hehe&quot;);
        Iterator it = hs.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
</code></pre>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.HashSet;
import java.util.Iterator;

class Person{
    private String name;
    private int age;
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    public String getName(){
        return this.name;
    }

    public int getAge(){
        return this.age;
    }


    @Override
    public int hashCode() {
        return name.hashCode() + age * 37; // hash 加盐，防止冲突
    }

    @Override
    public boolean equals(Object obj) {
        if(this == obj){ // 先判断一次内存地址，防止一个对象传入两次
            return true;
        }
        if(!(obj instanceof Person)){ // 健壮性判断
            throw new ClassCastException(&quot;类型不对&quot;);
        }
        Person p = (Person)obj;
        if((p.name.equals(this.name)) &amp;&amp; (p.age==this.age)){ // 此处存疑， name 和 age 都是封装的，为什么可以直接调用？—&gt; 同一个类可以内部调用
            return true;
        }
        return false;
    }
}


/*
 * 往hashSet集合中存储Person对象。如果姓名和年龄相同，视为同一个人。视为相同元素。
 */
public class HashSetTest {
    public static void main(String[] args) {
        HashSet hs = new HashSet();
        /*
         * HashSet集合数据结构是哈希表，所以存储元素的时候，
         * 使用的元素的 hashCode 方法来确定位置，如果位置相同，在通过元素的equals来确定是否相同。
         *
         */
        hs.add(new Person(&quot;lisi4&quot;,24));
        hs.add(new Person(&quot;lisi7&quot;,27));
        hs.add(new Person(&quot;lisi1&quot;,21));
        hs.add(new Person(&quot;lisi9&quot;,29));
        hs.add(new Person(&quot;lisi7&quot;,27));
        Iterator it = hs.iterator();
        while(it.hasNext()){
            Person p = (Person)it.next();
            System.out.println(p);
            System.out.println(p.getName()+&quot;....&quot;+p.getAge());
        }
    }
}
</code></pre>
<h4 id="linkedhashset"><a class="header" href="#linkedhashset">LinkedHashSet</a></h4>
<p>LinkedHashSet 是 hashset 的子类，其能保证对象的插入顺序</p>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        HashSet hs = new LinkedHashSet();
        hs.add(&quot;hahah&quot;);
        hs.add(&quot;hehe&quot;);
        hs.add(&quot;heihei&quot;);
        hs.add(&quot;xixii&quot;);
        // hs.add(&quot;hehe&quot;);
        Iterator it = hs.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
    /*
     *
     * hahah
     * hehe
     * heihei
     * xixii 顺序不变
     * */
}
</code></pre>
<h4 id="treeset-comparator"><a class="header" href="#treeset-comparator">TreeSet Comparator</a></h4>
<p>TreeSet 是有顺序的 Set。</p>
<p>基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator进行排序，具体取决于使用的构造方法。</p>
<p>Comparator 接口：</p>
<p>a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

/**
 * 创建了一个根据Person类的 name 进行排序的比较器。
 */
class ComparatorByName implements Comparator {
    @Override
    public int compare(Object o1, Object o2) {
        Person p1 = (Person)o1;
        Person p2 = (Person)o2;
        int temp = p1.getName().compareTo(p2.getName());
        return temp==0?p1.getAge()-p2.getAge(): temp;
        // return 1;//有序。
    }
}
public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet ts = new TreeSet(new ComparatorByName());
        /*
         * 以 Person 对象年龄进行从小到大的排序。
         *
         */
        ts.add(new Person(&quot;zhangsan&quot;,28));
        ts.add(new Person(&quot;lisi&quot;,21));
        ts.add(new Person(&quot;zhouqi&quot;,29));
        ts.add(new Person(&quot;zhouqi&quot;,25));
        ts.add(new Person(&quot;wangu&quot;,24));
        Iterator it = ts.iterator();
        while(it.hasNext()){
            Person p = (Person)it.next();
            System.out.println(p.getName()+&quot;:&quot;+p.getAge());
        }
        System.out.println(&quot;------------------&quot;);
        demo1();
    }
    public static void demo1() {
        TreeSet ts = new TreeSet();
        ts.add(&quot;abc&quot;);
        ts.add(&quot;zaa&quot;);
        ts.add(&quot;aa&quot;);
        ts.add(&quot;nba&quot;);
        ts.add(&quot;cba&quot;);
        Iterator it = ts.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}

/*
lisi:21
wangu:24
zhangsan:28
zhouqi:25
zhouqi:29
------------------
aa
abc
cba
nba
zaa
*/
</code></pre>
<pre><code class="language-java">import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

/*
定义一个按长度作比较的比较器
*/
class ComparatorByLength implements Comparator {
    @Override
    public int compare(Object o1, Object o2) {
        String s1 = (String)o1;
        String s2 = (String)o2;
        int temp = s1.length()-s2.length();
        return temp==0? s1.compareTo(s2): temp; // 三木运算符，
    }
}
/*
 * 对字符串进行长度排序。
 *
 * &quot;20 18 -1 89 2 67&quot;
 */
public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet ts = new TreeSet(new ComparatorByLength());
        ts.add(&quot;aaaaa&quot;);
        ts.add(&quot;zz&quot;);
        ts.add(&quot;nbaq&quot;);
        ts.add(&quot;cba&quot;);
        ts.add(&quot;abc&quot;);
        Iterator it = ts.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
</code></pre>
<p><strong>另一种实现 Comparable 的方法：让对象实现 Comparable</strong></p>
<pre><code class="language-java">public class Person /*extends Object*/ implements Comparable {
    private String name;
    private int age;
    public Person() {
        super();
    }
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    @Override
    public int hashCode() {
        return name.hashCode()+age*27;
    }
    @Override
    public boolean equals(Object obj) {
        if(this == obj)
            return true;
        if(!(obj instanceof Person))
            throw new ClassCastException(&quot;类型错误&quot;);
        Person p = (Person)obj;
        return this.name.equals(p.name) &amp;&amp; this.age == p.age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String toString(){
        return name+&quot;:&quot;+age;
    }
    @Override
    public int compareTo(Object o) {
        Person p = (Person)o;
        int temp = this.age-p.age;
        return temp==0?this.name.compareTo(p.name):temp;
    }
}
</code></pre>
<h3 id="list-set-总结"><a class="header" href="#list-set-总结">List Set 总结</a></h3>
<ul>
<li>
<p>集合类的使用场景：</p>
<p>对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定。就使用集合容器进行存储。</p>
</li>
<li>
<p>集合特点</p>
<ul>
<li>用于存储对象的容器</li>
<li>集合的长度是可变的</li>
<li>集合中不可以存储基本数据类型值（但是能存储包装类）</li>
</ul>
</li>
<li>
<p>集合容器因为内部的数据结构不同，有多种具体容器。不断的向上抽取，就形成了集合框架。</p>
<ul>
<li>
<p>框架的顶层Collection接口</p>
<pre><code class="language-java">/*
Collection的常见方法：
1，添加。
    boolean add(Object obj):
    boolean addAll(Collection coll):
2，删除。
    boolean remove(object obj):
    boolean removeAll(Collection coll);
    void clear();
3，判断：
    boolean contains(object obj):
    boolean containsAll(Colllection coll);
    boolean isEmpty():判断集合中是否有元素。
4，获取：
    int size():
    Iterator iterator() 取出元素的方式：迭代器。
    该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。
    所以该迭代器对象是在容器中进行内部实现的。
    对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，
    也就是iterator方法。
    Iterator接口就是对所有的Collection容器进行元素取出的公共接口。
    其实就是抓娃娃游戏机中的夹子！
5，其他：
    boolean retainAll(Collection coll); 取交集。
    Object[] toArray(); 将集合转成数组。
*/

</code></pre>
</li>
<li>
<p>Collection
|--List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。
|--Set：元素不能重复,无序。</p>
</li>
<li>
<p>List</p>
<pre><code class="language-java">/*
List:特有的常见方法：有一个共性特点就是都可以操作角标。
1，添加
    void add(index, element);
    void add(index, collection);
2，删除；
	Object remove(index):
3，修改：
	Object set(index,element);
4，获取：
    Object get(index);
    int indexOf(object);
    int lastIndexOf(object);
    List subList(from,to);
    
list集合是可以完成对元素的增删改查。
List:
|--Vector:内部是数组数据结构，是同步的。增删，查询都很慢！
|--ArrayList:内部是数组数据结构，是不同步的。替代了Vector。查询的速度快。
|--LinkedList:内部是链表数据结构，是不同步的。增删元素的速度很快。

LinkedList:
    addFirst();
    addLast():
    jdk1.6
    offerFirst();
    offetLast();
    getFirst();.//获取但不移除，如果链表为空，抛出NoSuchElementException.
    getLast();
    jdk1.6
    peekFirst();//获取但不移除，如果链表为空，返回null.
    peekLast():
    removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException.
    removeLast();
    jdk1.6
    pollFirst();//获取并移除，如果链表为空， 返回null.
    pollLast(); 

*/
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-java">/*
Set接口中的方法和Collection一致。
|--HashSet: 内部数据结构是哈希表 ，是不同步的。
    如何保证该集合的元素唯一性呢？
    是通过对象的hashCode和equals方法来完成对象唯一性的。
    如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。
    如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。
    如果为true，视为相同元素，不存。如果为false，那么视为不同元素，就进行存储。
    
    记住：如果元素要存储到HashSet集合中，必须覆盖 hashCode 方法和 equals 方法。
    一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals， hashCode
    方法。

|--TreeSet:可以对Set集合中的元素进行排序。是不同步的。
    判断元素唯一性的方式：就是根据比较方法的返回结果是否是0，是0，就是相同元素，不存。
    TreeSet对元素进行排序的方式一：(方法一更直观，更符合直觉)
    	让元素自身具备比较功能，元就需要实现Comparable接口。覆盖compareTo方法。
    	如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。怎么办？
    可以使用TreeSet集合第二种排序方式二：
    	让集合自身具备比较功能，定义一个类实现Comparator接口，覆盖compare方法。
    	将该类对象作为参数传递给TreeSet集合的构造函数。
    
if(this.hashCode()== obj.hashCode() &amp;&amp; this.equals(obj))
哈希表确定元素是否相同
1，判断的是两个元素的哈希值是否相同。
如果相同，在判断两个对象的内容是否相同。
2，判断哈希值相同，其实判断的是对象的hashCode的方法。判断内容相同，用的是equals方法。
注意：如果哈希值不同，是不需要判断equals。
*/
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<h3 id="map-vs-collection"><a class="header" href="#map-vs-collection">Map vs Collection</a></h3>
<ol>
<li>Map中一次存储是键值对。Collection中一次存储是单个元素。</li>
<li>Map的存储使用的put方法。Collection存储使用的是add方法。</li>
<li>Map的取出，是讲Map转成Set，在使用迭代器取出。
Collection取出，使用就是迭代器。</li>
<li>如果对象很多，必须使用容器存储。
如果元素存在着映射关系，可以优先考虑使用Map存储或者用数组，如果没有映射关系，可以使用Collection存储。</li>
</ol>
<h3 id="map-demo"><a class="header" href="#map-demo">Map Demo</a></h3>
<pre><code class="language-java">import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class MapDemo {
    public static void main(String[] args) {
        Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
        method_2(map);
    }
    public static void method_2(Map&lt;Integer,String&gt; map){
        map.put(8,&quot;zhaoliu&quot;);
        map.put(2,&quot;zhaoliu&quot;);
        map.put(2,&quot;zhaoliu&quot;);
        map.put(6,&quot;wangcai&quot;);
        Collection&lt;String&gt; values = map.values();
        Iterator&lt;String&gt; it2 = values.iterator();
        while(it2.hasNext()){
            System.out.println(it2.next());
        }
        /*
        * 通过 Map 转成 set 就可以迭代。
        * 找到了另一个方法。 entrySet。
        * 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是 Map.Entry(内部类)
        * 类型(结婚证)
        */
        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();
        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();
        while(it.hasNext()){
            Map.Entry&lt;Integer, String&gt; me = it.next();
            Integer key = me.getKey();
            String value = me.getValue();
            System.out.println(key+&quot;::::&quot;+value);
        }
        //取出 map 中的所有元素。
        //原理，通过 keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，
        //在对每一个键通过map集合的get方法获取其对应的值即可。
        Set&lt;Integer&gt; keySet = map.keySet();
        Iterator&lt;Integer&gt; it = keySet.iterator();
        while(it.hasNext()){
            Integer key = it.next();
            String value = map.get(key);
            System.out.println(key+&quot;:&quot;+value);
        }    
    }
    
    public static void method(Map&lt;Integer,String&gt; map){//学号和姓名
        // 添加元素。
        System.out.println(map.put(100, &quot;wangcai&quot;)); //null
        System.out.println(map.put(100, &quot;xiaoqiang&quot;)); //wangcai 存相同键，值会覆盖。
        map.put(2,&quot;zhangsan&quot;);
        map.put(7,&quot;zhaoliu&quot;);
        //删除。
        // System.out.println(&quot;remove:&quot;+map.remove(2));
        //判断。
        // System.out.println(&quot;containskey:&quot;+map.containsKey(7));
        //获取。
        System.out.println(&quot;get:&quot;+map.get(6));
        System.out.println(map);
        Outer.Inner.show();
    }
}

interface MyMap{
    public static interface MyEntry{//内部接口
        void get();
    }
}
class MyDemo implements MyMap.MyEntry{
    public void get(){}
}
class Outer{
    static class Inner{
        static void show(){}
    }
}
</code></pre>
<h3 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h3>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import cn.itcast.p2.bean.Student;

public class HashMapDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * 将学生对象和学生的归属地通过键与值存储到map集合中。
        */
        HashMap&lt;Student,String&gt; hm = new HashMap&lt;Student,String&gt;();
        hm.put(new Student(&quot;lisi&quot;,38), &quot;北京&quot;);
        hm.put(new Student(&quot;zhaoliu&quot;,24), &quot;上海&quot;);
        hm.put(new Student(&quot;xiaoqiang&quot;,31), &quot;沈阳&quot;);
        hm.put(new Student(&quot;wangcai&quot;,28), &quot;大连&quot;);
        hm.put(new Student(&quot;zhaoliu&quot;,24), &quot;铁岭&quot;);
        // Set&lt;Student&gt; keySet = hm.keySet();
        // Iterator&lt;Student&gt; it = keySet.iterator();
        Iterator&lt;Student&gt; it = hm.keySet().iterator();
        while(it.hasNext()){
            Student key = it.next();
            String value = hm.get(key);
            System.out.println(key.getName()+&quot;:&quot;+key.getAge()+&quot;---&quot;+value);
        }
    }
}
</code></pre>
<h3 id="treemap"><a class="header" href="#treemap">TreeMap</a></h3>
<pre><code class="language-java">import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import cn.itcast.p2.bean.Student;
import cn.itcast.p3.comparator.ComparatorByName;
public class TreeMapDemo {
    /**
* @param args
*/
    public static void main(String[] args) {
        TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;Student,String&gt;(new ComparatorByName());
        tm.put(new Student(&quot;lisi&quot;,38),&quot;北京&quot;);
        tm.put(new Student(&quot;zhaoliu&quot;,24),&quot;上海&quot;);
        tm.put(new Student(&quot;xiaoqiang&quot;,31),&quot;沈阳&quot;);
        tm.put(new Student(&quot;wangcai&quot;,28),&quot;大连&quot;);
        tm.put(new Student(&quot;zhaoliu&quot;,24),&quot;铁岭&quot;);
        Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = tm.entrySet().iterator();
        while(it.hasNext()){
            Map.Entry&lt;Student,String&gt; me = it.next();
            Student key = me.getKey();
            String value = me.getValue();
            System.out.println(key.getName()+&quot;:&quot;+key.getAge()+&quot;---&quot;+value);
        }
    }
}
</code></pre>
<h3 id="linkedhashmap"><a class="header" href="#linkedhashmap">LinkedHashMap</a></h3>
<p>按照顺序存储。</p>
<pre><code class="language-java">import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        File f= null;
        HashMap&lt;Integer,String&gt; hm = new LinkedHashMap&lt;Integer,String&gt;();
        hm.put(7, &quot;zhouqi&quot;);
        hm.put(3, &quot;zhangsan&quot;);
        hm.put(1, &quot;qianyi&quot;);
        hm.put(5, &quot;wangwu&quot;);
        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it = hm.entrySet().iterator();
        while(it.hasNext()){
            Map.Entry&lt;Integer,String&gt; me = it.next();
            Integer key = me.getKey();
            String value = me.getValue();
            System.out.println(key+&quot;:&quot;+value);
        }
    }
}
</code></pre>
<h3 id="map-demo-1"><a class="header" href="#map-demo-1">Map Demo</a></h3>
<pre><code class="language-java">import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
/*
* 练习:
* &quot;fdgavcbsacdfs&quot; 获取该字符串中，每一个字母出现的次数。
* 要求打印结果是： a(2)b(1)...;
* 思路：
* 对于结果的分析发现，字母和次数之间存在着映射的关系。而且这种关系很多。
* 很多就需要存储，能存储映射关系的容器有数组和Map集合。
* 关系一方式有序编号吗？没有！
* 那就是使用Map集合。 又发现可以保证唯一性的一方具备着顺序如 a b c ...
* 所以可以使用TreeMap集合。
*
* 这个集合最终应该存储的是字母和次数的对应关系。
*
* 1，因为操作的是字符串中的字母，所以先将字符串变成字符数组。
* 2，遍历字符数组，用每一个字母作为键去查Map集合这个表。
* 如果该字母键不存在，就将该字母作为键 1作为值存储到map集合中。
* 如果该字母键存在，就将该字母键对应值取出并+1，在将该字母和+1后的值存储到map集合中，
* 键相同值会覆盖。这样就记录住了该字母的次数.
* 3，遍历结束， map集合就记录所有字母的出现的次数。 
*/
public class MapTest {
    /**
    * @param args
    */
    public static void main(String[] args) {
        String str = &quot;fdg+avAdc bs5dDa9c-dfs&quot;;
        String s = getCharCount(str);
        System.out.println(s);
    }
    public static String getCharCount(String str) {
        //将字符串变成字符数组
        char[] chs = str.toCharArray();
        //定义map集合表。
        Map&lt;Character,Integer&gt; map = new TreeMap&lt;Character,Integer&gt;();
        for (int i = 0; i &lt; chs.length; i++) {
            if(!(chs[i]&gt;='a' &amp;&amp; chs[i]&lt;='z' || chs[i]&gt;='A' &amp;&amp; chs[i]&lt;='Z'))
                // if(!(Character.toLowerCase(chs[i])&gt;='a' &amp;&amp;  Character.toLowerCase(chs[i])&lt;='z'))
                continue;
            //将数组中的字母作为键去查map表。
            Integer value = map.get(chs[i]);
            int count = 1;
            //判断值是否为null.
            if(value!=null){
                count = value+1;
            }
            // count++;
            map.put(chs[i], count);
            /*
            if(value==null){
                map.put(chs[i], 1);
                }else{
                map.put(chs[i], value+1);
            }
            */
        }
        return mapToString(map);
    }
    private static String mapToString(Map&lt;Character, Integer&gt; map) {
        StringBuilder sb = new StringBuilder();
        Iterator&lt;Character&gt; it = map.keySet().iterator();
        while(it.hasNext()){
            Character key = it.next();
            Integer value = map.get(key);
            sb.append(key+&quot;(&quot;+value+&quot;)&quot;);
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="工具类"><a class="header" href="#工具类">工具类</a></h2>
<h3 id="collections-集合框架工具类"><a class="header" href="#collections-集合框架工具类">Collections 集合框架工具类</a></h3>
<p>Collections：是集合框架的工具类。（集合工具类）</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;

public class CollectionsDemo {
    public static void main(String[] args) {
        /*
        * Collections：是集合框架的工具类。
        * 里面的方法都是静态的。
        */
        demo_4();
    }
    
    // List
    public static void demo_4() { 
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abcde&quot;);
        list.add(&quot;cba&quot;);
        list.add(&quot;zhangsan&quot;);
        list.add(&quot;zhaoliu&quot;);
        list.add(&quot;xiaoqiang&quot;);
        System.out.println(list);
        
        Collections.replaceAll(list, &quot;cba&quot;, &quot;nba&quot;); // set(indexOf(&quot;cba&quot;),&quot;nba&quot;);
        Collections.shuffle(list); 
        Collections.fill(list, &quot;cc&quot;); // replaces all of the elements of the specified list with the specified element.
        System.out.println(list);
    }
    
    // Set
    public static void demo_3() {
        /*
        TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;(){
        @Override
        public int compare(String o1, String o2) {
        int temp = o2.compareTo(o1);
        return temp;
        }
        });
        */
        TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(Collections.reverseOrder(new ComparatorByLength())); // Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. 
        ts.add(&quot;abc&quot;);
        ts.add(&quot;hahaha&quot;);
        ts.add(&quot;zzz&quot;);
        ts.add(&quot;aa&quot;);
        ts.add(&quot;cba&quot;);
        System.out.println(ts);
    }
    
    // List
    public static void demo_2(){
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abcde&quot;);
        list.add(&quot;cba&quot;);
        list.add(&quot;aa&quot;);
        list.add(&quot;zzz&quot;);
        list.add(&quot;cba&quot;);
        list.add(&quot;nbaa&quot;);
        Collections.sort(list); // Sorts the specified list into ascending order, according to the natural ordering of its elements.
        System.out.println(list);
        int index = Collections.binarySearch(list, &quot;cba&quot;);
        System.out.println(&quot;index=&quot;+index);
        //获取最大值。
        String max = Collections.max(list,new ComparatorByLength());
        System.out.println(&quot;max=&quot;+max);
    }
    
    // List
    public static void demo_1(){
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abcde&quot;);
        list.add(&quot;cba&quot;);
        list.add(&quot;aa&quot;);
        list.add(&quot;zzz&quot;);
        list.add(&quot;cba&quot;);
        list.add(&quot;nbaa&quot;);
        System.out.println(list);
        // 对list集合进行指定顺序的排序。
        // Collections.sort(list);
        // mySort(list);
        // mySort(list,new ComparatorByLength());
        Collections.sort(list, new ComparatorByLength());
        System.out.println(list);
    }
    
    public static &lt;T&gt; void mySort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp){
        for (int i = 0; i &lt; list.size()-1; i++) {
            for (int j = i+1; j &lt; list.size(); j++) {
                if(comp.compare(list.get(i), list.get(j))&gt;0){
                    // T temp = list.get(i);
                    // list.set(i, list.get(j));
                    // list.set(j, temp);
                    Collections.swap(list, i, j); // 交换 List 的值
                }
            }
        }
    }
    
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mySort(List&lt;T&gt; list){
        for (int i = 0; i &lt; list.size()-1; i++) {
            for (int j = i+1; j &lt; list.size(); j++) {
                if(list.get(i).compareTo(list.get(j))&gt;0){
                    // T temp = list.get(i);
                    // list.set(i, list.get(j));
                    // list.set(j, temp);
                    Collections.swap(list, i, j);
                }
            }
        }
    }
}
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>数组工具类。</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.util.Arrays;
import java.util.List;

//数组转成集合。
public class ArraysDemo {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * Arrays：集合框架的工具类。里面的方法都是静态的。
         */
        // int[] arr = {3,1,5,6,3,6};
        // System.out.println(Arrays.toString(arr));
        demo_2();
        demo_1();
    }
    public static void demo_2() {
        /*
         * 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。
         *
         * 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。
         */
        int[] arr = {31,11,51,61};
        List&lt;int[]&gt; list = Arrays.asList(arr);
        System.out.println(list.size()); // 1
    }

    public static void demo_1() {
        /*
         * 重点： List asList(数组)将数组转成集合。
         *
         * 好处：其实可以使用集合的方法操作数组中的元素。
         * 注意：数组的长度是固定的，所以对于集合的增删方法是不可以使用的
         * 否则会发生UnsupportedOperationException
         */
        String[] arr = {&quot;abc&quot;,&quot;haha&quot;,&quot;xixi&quot;};
        boolean b = myContains(arr, &quot;xixi&quot;);
        System.out.println(&quot;contains:&quot;+b);
        List&lt;String&gt; list = Arrays.asList(arr); // Returns a fixed-size list backed by the specified array.
        boolean b1 = list.contains(&quot;xixi&quot;);
        System.out.println(&quot;list contaisn:=&quot;+b1);
        // list.add(&quot;hiahia&quot;); // UnsupportedOperationException
        System.out.println(list);
    }

    public static boolean myContains(String[] arr, String key){
        for (int i = 0; i &lt; arr.length; i++) {
            if(arr[i].equals(key))
                return true;
        }
        return false;
    }
    //toString的经典实现。
    public static String myToString(int[] a){
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;
        StringBuilder b = new StringBuilder();
        b.append('[');
        for (int i = 0; ; i++) {//中间省略条件判断，提高了效率。
            b.append(a[i]);
            if (i == iMax)
                return b.append(']').toString();
            b.append(&quot;, &quot;);
        }
    }
}

</code></pre>
<h2 id="其他-4"><a class="header" href="#其他-4">其他</a></h2>
<h3 id="集合转数组listtoarray"><a class="header" href="#集合转数组listtoarray">集合转数组：list.toArray()</a></h3>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class ToArray {
    public static void main(String[] args) {
        /*
        * 集合转成数组呢？
        *
        * 使用的就是Collection接口中的toArray方法。
        *
        * 集合转成数组：可以对集合中的元素操作的方法进行限定，但不允许对其进行增删。
        */
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        /*
        * toArray方法需要传入一个new好的数组。
        * 长度该如何定义呢？
        * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。
        * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为
        * null。
        * 所以建议，最后长度就指定为，集合的size。
        */
        String[] arr = list.toArray(new String[list.size()]);
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<h3 id="数组转集合-arraysaslist"><a class="header" href="#数组转集合-arraysaslist">数组转集合 Arrays.asList()</a></h3>
<pre><code class="language-java">/*
* 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。
*
* 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。
*/
int[] arr = {31,11,51,61};
List&lt;int[]&gt; list = Arrays.asList(arr);
System.out.println(list.size()); // 1

String[] strings = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
List&lt;String&gt; list2 = Arrays.asList(strings);
System.out.println(list.size()); // 3
</code></pre>
<h3 id="增强-for-循环"><a class="header" href="#增强-for-循环">增强 for 循环</a></h3>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class ForEachDemo {
    /**
    * @param args
    */
    public static void main(String[] args) {
        /*
        * foreach语句：
        * 格式：
        * for(类型 变量 ： Collection集合|数组)
        * {
        *
        * }
        *
        * 传统for和高级for的区别？
        * 传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。
        *
        * 高级for是一种简化形式。
        * 它必须有被遍历的目标。该目标要是数组，要么是Collection单列集合。
        *
        * 对数数组的遍历如果仅仅是获取数组中的元素，可以使用高级for。
        * 如果要对数组的角标进行操作建议使用传统for。
        *
        */
        List&lt;String&gt; list =new ArrayList&lt;String&gt;();
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        for(String s : list){ //简化书写。
            System.out.println(s);
        }
        int[] arr = {3,1,5,7,4};
        for(int i : arr){
            System.out.println(i);
        }
        //可以使用高级for遍历map集合吗？不能直接用，但是可以将map转成单列的set，就可以用了。
        Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;();
        map.put(3,&quot;zhagsan&quot;);
        map.put(1,&quot;wangyi&quot;);
        map.put(7,&quot;wagnwu&quot;);
        map.put(4,&quot;zhagsansan&quot;);
        for(Integer key : map.keySet()){
            String value = map.get(key);
            System.out.println(key+&quot;::&quot;+value);
        }
        for(Map.Entry&lt;Integer,String&gt; me : map.entrySet()){
            Integer key = me.getKey();
            String value = me.getValue();
            System.out.println(key+&quot;:&quot;+value);
        }
        // Iterator&lt;String&gt; it = list.iterator();
        // while(it.hasNext()){
        // System.out.println(it.next());
        // }
    }
}
</code></pre>
<h4 id="-1"><a class="header" href="#-1"></a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>on-java 数组</p>
<p>[TOC]</p>
<h2 id="数组的特性"><a class="header" href="#数组的特性">数组的特性</a></h2>
<p>数组一经定义，长度即固定；数组是线性序列，数据访问很快；数组只能存储一种类型的数据。</p>
<p><strong>Array 和 ArrayList 的区别</strong></p>
<ul>
<li>ArrayList 的效率不如数组： ArrayList将数组封装起来。必要时，它会自动分配更多的数组空间，创建新数组，并将旧数组中的引用移动到新数组。这种灵活性需要开销，所以一个 ArrayList 的效率不如数组</li>
<li>ArrayList 不能存储基本数据类型，Array 可以</li>
</ul>
<h2 id="打印数组"><a class="header" href="#打印数组">打印数组</a></h2>
<pre><code class="language-java">String[] test = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
System.out.println(Arrays.toString(test));
// [1, 2, 3]

Arrays.deepToString() // 打印二维数组
</code></pre>
<h2 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h2>
<p>数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语
法的一部分，也可以显式地创建，比如使用一个 new 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 length成员函数，它能告诉你数组对象中可以存储多少元素。 [ ] 语法是你访问数组对象的唯一方式。</p>
<pre><code class="language-java">BerylliumSphere[] b = new BerylliumSphere[5];

BerylliumSphere[] d = {
    new BerylliumSphere(),
    new BerylliumSphere(),
    new BerylliumSphere()
};

// new 一个二维数组
int[][] a = {
    { 1, 2, 3, },
    { 4, 5, 6, },
};
Arrays.deepToString(a);

// 创建一个三位数组
int[][][] a = new int[2][2][4];
System.out.println(Arrays.deepToString(a));
</code></pre>
<p>你无法找出到底有多少元素存储在数组中，因为 length 只能告诉你数组可以存储多少元素；这就是说，数组对象的大小并不是真正存储在数组中对象的个数。然而，当你创建一个数组对象，其引用将自动初始化为 null，因此你可以通过检查特定数组元素中的引用是否为 null 来判断其中是否有对象。基元数组也有类似的机制，比如自动将数值类型初始化为 0， char 型初始化为 (char)0，布尔类型初始化为 false。</p>
<h2 id="arrays-工具类"><a class="header" href="#arrays-工具类">Arrays 工具类</a></h2>
<p>Array 的工具类是 Arrays；Collection 的工具类是 Collections；String 的工具类是 StringUtils。</p>
<p>不管是数组，还是集合，最后统一转成流来处理。</p>
<table><thead><tr><th>方法</th><th>作用</th><th>备注</th></tr></thead><tbody>
<tr><td>toString</td><td>打印数组</td><td></td></tr>
<tr><td>deepToString</td><td>打印多维数组</td><td></td></tr>
<tr><td>setAll</td><td>使用一个生成器并生成不同的值并填充到数组</td><td>java8 引入</td></tr>
<tr><td>fill</td><td>将单个值复制到整个数组，或者在对象数组的情况下，将相同的引用复制到整个数组</td><td></td></tr>
<tr><td>asList</td><td>获取任何序列或数组，并将其转换为一个 列表集合</td><td></td></tr>
<tr><td>copyOf</td><td>以新的长度创建现有数组的新副本</td><td>比for循环手动复制速度快；浅拷贝</td></tr>
<tr><td>copyOfRange</td><td>创建现有数组的一部分的新副本</td><td></td></tr>
<tr><td>equals</td><td>比较两个数组是否相等</td><td></td></tr>
<tr><td>deepEquals</td><td>多维数组的相等性比较</td><td></td></tr>
<tr><td>stream</td><td>生成数组元素的流</td><td></td></tr>
<tr><td>sort</td><td>排序数组</td><td></td></tr>
<tr><td>binarySearch</td><td>在已排序的数组中查找元素</td><td></td></tr>
<tr><td>parallelPrefix</td><td>使用提供的函数并行累积 (以获得速度)。基本上，就是数组的 reduce()</td><td></td></tr>
<tr><td>stream</td><td>从数组生成流</td><td></td></tr>
</tbody></table>
<h2 id="数组排序"><a class="header" href="#数组排序">数组排序</a></h2>
<pre><code class="language-java">CompType[] a = new CompType[12];
Arrays.setAll(a, n -&gt; CompType.get());
show(&quot;Before sorting&quot;, a);
Arrays.sort(a, Collections.reverseOrder())
show(&quot;After sorting&quot;, a);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-string"><a class="header" href="#java-string">Java String</a></h1>
<p>[TOC]</p>
<h2 id="-的重载与-stringbuilder"><a class="header" href="#-的重载与-stringbuilder">+ 的重载与 StringBuilder</a></h2>
<p>Java 唯一重载的两个操作符：+，+=。<code>+</code> 在 Java 中不仅用于 + 数值，还用于 + 字符串。</p>
<p>Java 的编译器会对字符串 + 的操作用 StringBuilder 进行优化</p>
<pre><code class="language-java">public class Concatenation {
    public static void main(String[] args) {
        String mango = &quot;mango&quot;;
        String s = &quot;abc&quot; + mango + &quot;def&quot; + 47;
        System.out.println(s);
    }
}
</code></pre>
<p>上面的代码，被编译器编译优化为：</p>
<pre><code>public class Concatenation {
  public Concatenation();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String mango
       2: astore_1
       3: new           #3                  // class java/lang/StringBuilder
       6: dup
       7: invokespecial #4                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V
      10: ldc           #5                  // String abc
      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      15: aload_1
      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: ldc           #7                  // String def
      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: bipush        47
      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      32: astore_2
      33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;
      36: aload_2
      37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      40: return
}
</code></pre>
<p>编译器自动引入了 java.lang.StringBuilder 类。虽然源代码中并没有使用 StringBuilder 类，但是编译器却自作主张地使用了它，就因为它更高效。但是编译器远远没有那么智能，还是要显式地创建 StringBuilder，并且如果知道最终字符串的大概长度，那预先指定 StringBuilder 的大小可以避免频繁地重新分配缓冲。</p>
<p>举例：</p>
<pre><code class="language-java">public class WhitherStringBuilder {
    // 编译器会在每一次循环中，都创建一个 StringBuilder
    public String implicit(String[] fields) {
        String result = &quot;&quot;;
        for(String field : fields) {
            result += field;
        }
        return result;
    }
    // 编译器只会创建一个 StringBuilder
    public String explicit(String[] fields) {
        StringBuilder result = new StringBuilder();
        for(String field : fields) {
            result.append(field);
        }
        return result.toString();
    }
}
</code></pre>
<p>因此，当你为一个类编写 toString() 方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但是，如果你要在 toString() 方法中使用循环，且可能有性能问题，那么最好自己创建一个 StringBuilder 对象，用它来构建最终结果。</p>
<p>bad case:</p>
<pre><code class="language-java">// 编译器就会掉入陷阱，从而为你另外创建一个 StringBuilder 对象处理括号内的字符串操作
append(a + &quot;: &quot; + c)
</code></pre>
<p>StringBuilder 的常见方法：</p>
<pre><code>insert
replace
substring
reverse
append
toString
delete
</code></pre>
<p>StringBuilder 是 Java SE5 引入的，在这之前用的是 StringBuffer。后者是线程安全的（参见并发编程），因此开销也会大些。使用 StringBuilder 进行字符串操作更快一点。</p>
<h2 id="字符串方法"><a class="header" href="#字符串方法">字符串方法</a></h2>
<p>列举一些平时会忽略的方法：</p>
<table><thead><tr><th>方法</th><th>作用</th><th>备注</th></tr></thead><tbody>
<tr><td>indexOf</td><td>如果该 String 并不包含此参数，就返回-1；否则返回此参数在 String 中的起始索引。</td><td></td></tr>
<tr><td>lastIndexOf</td><td>lastIndexOf() 是从后往前搜索</td><td></td></tr>
<tr><td>matches</td><td>传入一个正则表达式，返回 boolean 结果，以表明该 String 和给出的正则表达式是否匹配</td><td></td></tr>
<tr><td>split</td><td>按照正则表达式拆分String，返回一个结果数组</td><td></td></tr>
<tr><td>join</td><td>用分隔符拼接字符片段，产生一个新的 String</td><td>java8 引入</td></tr>
<tr><td>replace()</td><td>返回替换字符后的新String 对象。如果没有替换发生，则返回原始的String 对象</td><td>不支持正则表达式</td></tr>
<tr><td>replaceFirst()</td><td>返回替换所有目标字符串后的 String 对象</td><td>支持正则表达式</td></tr>
<tr><td>replaceAll()</td><td>返回替换所有目标字符串后的 String 对象</td><td>支持正则表达式</td></tr>
<tr><td>format()</td><td>返回格式化结果 String</td><td></td></tr>
</tbody></table>
<p>当需要改变字符串的内容时， String 类的方法都会返回一个新的 String 对象。同时，如果内容不改变， String 方法只是返回原始对象的一个引用而已。这可以节约存储空间以及避免额外的开销。 </p>
<h2 id="字符串格式化"><a class="header" href="#字符串格式化">字符串格式化</a></h2>
<img align="left" src="computer-science-notebook/note-for-java/assets/image-20211007183409995.png" alt="image-20211007183409995" style="zoom:70%;" />
<p>demos:</p>
<pre><code class="language-java">// %d 表示一个整数, %f 表示一个浮点数
System.out.printf(&quot;Row 1: [%d %f]%n&quot;, x, y);

// %s 表示一个字符串
String.format(&quot;i love %s&quot;, &quot;you&quot;);
</code></pre>
<h2 id="java-正则表达式"><a class="header" href="#java-正则表达式">Java 正则表达式</a></h2>
<p>反斜线：</p>
<p>Java 中的转义字符是：<code>\\</code>。</p>
<p>在其他语言中， <code>\\</code> 表示 “我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊的意义。 ” 而在 Java 中， <code>\\</code> 的意思是 “我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 ”  例如，如果你想表示一位数字，那么正则表达式应该是 <code>\\d</code>。如果你想插入一个普通的反斜线，应该这样写 <code>\\\</code>。不过换行符和制表符之类的东西只需要使用单反斜线： <code>\n\t</code>。</p>
<img src="computer-science-notebook/note-for-java/assets/image-20211007185544909.png" alt="image-20211007185544909" style="zoom:80%;" />
<img src="computer-science-notebook/note-for-java/assets/image-20211007185627612.png" alt="image-20211007185627612" style="zoom:80%;" />
<img src="computer-science-notebook/note-for-java/assets/image-20211007185700293.png" alt="image-20211007185700293" style="zoom:80%;" />
<p>demos:</p>
<pre><code class="language-java">System.out.println(&quot;-1234&quot;.matches(&quot;-?\\d+&quot;));
System.out.println(&quot;5678&quot;.matches(&quot;-?\\d+&quot;));
System.out.println(&quot;+911&quot;.matches(&quot;-?\\d+&quot;)); // false
// 在正则表达式中，用括号将表达式进行分组，用竖线 | 表示或操作。这个正则表达式表示字符串的起始字符可能是一个 - 或 +，或者二者都没有（因为后面跟着 ? 修饰符）。因为字符 + 在正则表达式中有特殊的意义，所以必须使用 \\ 将其转义，使之成为表达式中的一个普通字符。
System.out.println(&quot;+911&quot;.matches(&quot;(-|\\+)?\\d+&quot;)); // true

// \\W，它的意思是一个非单词字符（如果 W 小写， \\w，则表示一个单词字符）
split(&quot;n\\W+&quot;); // 'n' followed by non-words

s.replaceFirst(&quot;f\\w+&quot;, &quot;located&quot;));
// 将 shrubbery|tree|herring 替换为 banana
s.replaceAll(&quot;shrubbery|tree|herring&quot;,&quot;banana&quot;));
</code></pre>
<h2 id="正则表达式相关类"><a class="header" href="#正则表达式相关类">正则表达式相关类</a></h2>
<p>Pattern, Matcher</p>
<p>注意：group(0) 表示匹配到的整个，如果正则表达式包含括号，则 group(1) 表示匹配到的第一个括号内的内容。</p>
<p>Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.group(0) is equivalent to m.group().</p>
<pre><code class="language-java">/*
* 获取
* 将正则规则进行对象的封装。
* Pattern p = Pattern.compile(&quot;a*b&quot;);
* //通过正则对象的 matcher 方法字符串相关联。获取要对字符串操作的匹配器对象Matcher .
* Matcher m = p.matcher(&quot;aaaaab&quot;);
* //通过Matcher匹配器对象的方法对字符串进行操作。
* boolean b = m.matches();
*/
public static void functionDemo_4() {
    String str = &quot;da jia hao,ming tian bu fang jia!&quot;;
    String regex = &quot;\\b[a-z]{3}\\b&quot;; // \b boundary 例如 \bthe\b 匹配 the 而不是匹配 other
    //1,将正则封装成对象。
    Pattern p = Pattern.compile(regex);
    //2, 通过正则对象获取匹配器对象。
    Matcher m = p.matcher(str);
    //使用Matcher对象的方法对字符串进行操作。
    //既然要获取三个字母组成的单词
    //查找。 find();
    System.out.println(str);
    while(m.find()){
        System.out.println(m.group());//获取匹配的子序列
        System.out.println(m.start() + &quot;:&quot; + m.end()); // Returns the start index of the previous match.
    }
}
</code></pre>
<h2 id="scanner"><a class="header" href="#scanner">Scanner</a></h2>
<pre><code class="language-java">public class ThreatAnalyzer {
    static String threatData =
            &quot;58.27.82.161@08/10/2015\n&quot; +
                    &quot;204.45.234.40@08/11/2015\n&quot; +
                    &quot;58.27.82.161@08/11/2015\n&quot; +
                    &quot;58.27.82.161@08/12/2015\n&quot; +
                    &quot;58.27.82.161@08/12/2015\n&quot; +
                    &quot;[Next log section with different data format]&quot;;
    public static void main(String[] args) {
        Scanner scanner = new Scanner(threatData);
        String pattern = &quot;(\\d+[.]\\d+[.]\\d+[.]\\d+)@&quot; +
                &quot;(\\d{2}/\\d{2}/\\d{4})&quot;;
        while(scanner.hasNext(pattern)) {
            scanner.next(pattern);
            MatchResult match = scanner.match();
            // String wholeMatch = match.group(0); 
            String ip = match.group(1);
            String date = match.group(2);
            System.out.format(
                    &quot;Threat on %s from %s%n&quot;, date,ip);
        }
    }
}
</code></pre>
<h2 id="isempty-isblank"><a class="header" href="#isempty-isblank">isEmpty isBlank</a></h2>
<p>isEmpty: <code>&quot;&quot;, &quot;  &quot;</code></p>
<p>isBlank: <code>&quot;&quot;, &quot;  &quot;, null</code></p>
<p>isBlank 校验的范围更大</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-annotation-学习笔记"><a class="header" href="#java-annotation-学习笔记">Java Annotation 学习笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-datetime"><a class="header" href="#java-datetime">java datetime</a></h1>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>Date 基本上废弃了，仅剩下如下方法：</p>
<pre><code class="language-java">getTime(); // milliseconds since January 1, 1970, 00:00:00 GMT
setTime();
after();
before();
compareTo();
</code></pre>
<p>其获取某一个具体时间的方法，已经被废弃。</p>
<h2 id="java8-datetime"><a class="header" href="#java8-datetime">java8 datetime</a></h2>
<p>java8 引入的新类：LocalDateTime，LocalDate，LocalTime，Instant</p>
<pre><code class="language-java">LocalDate today = LocalDate.now(); 
int year = today.getYear(); 
int month = today.getMonthValue(); 
int day = today.getDayOfMonth();

LocalDate dateOfBirth = LocalDate.of(2010, 01, 14); 

LocalTime time = LocalTime.now();

date1.equals(today);
tommorow.isAfter(today);

LocalTime time = LocalTime.now(); 
LocalTime newTime = time.plusHours(2);

LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);

LocalDate previousYear = today.minus(1, ChronoUnit.YEARS); 
LocalDate nextYear = today.plus(1, YEARS);

Instant timestamp = Instant.now();

LocalDateTime now = LocalDateTime.now();
LocalDateTime morningStartDateTime = LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
                9, 30, 0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-反射"><a class="header" href="#java-反射">Java 反射</a></h1>
<h2 id="类的解剖-2"><a class="header" href="#类的解剖-2">类的解剖</a></h2>
<h2 id="泛型类的解剖"><a class="header" href="#泛型类的解剖">泛型类的解剖</a></h2>
<pre><code class="language-java">public class Student extends Person&lt;Integer, Boolean&gt;{

    public static void main(String[] args) {
        Student student = new Student();
        Class&lt;? extends Student&gt; clazz = student.getClass();
        // getSuperclass()获得该类的父类
        System.out.println(clazz.getSuperclass());

        /***
         * getGenericSuperclass() 获得带有泛型的父类
         * Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型
         */
        Type type = clazz.getGenericSuperclass();
        // generic.Person&lt;java.lang.Integer, java.lang.Boolean&gt;
        System.out.println(type);

        //ParameterizedType参数化类型，即泛型
        ParameterizedType parameterizedType = (ParameterizedType)type;
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        // java.lang.Integer
        System.out.println(actualTypeArguments[0]);
        // java.lang.Boolean
        System.out.println(actualTypeArguments[1]);
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-新特性"><a class="header" href="#java-新特性">Java 新特性</a></h1>
<p>[TOC]</p>
<h2 id="java-7"><a class="header" href="#java-7">Java 7</a></h2>
<h3 id="try-with-resource"><a class="header" href="#try-with-resource">Try with resource</a></h3>
<p>Java 1.7 引入。</p>
<p>类似 Python <code>with open</code> 的新特性。对于实现了 closeable 的子类，可以这么写：</p>
<pre><code class="language-java">try(
	InputStream is = new FileInputStream(&quot;...&quot;);
	OutputStream os = new FileOutputStream(&quot;...&quot;);
){
	//...
}catch (IOException e) {
	//...
}
</code></pre>
<p>替换的代码为：</p>
<pre><code class="language-java">InputStream is = null;
OutputStream os = null;
try {
	//...
} catch (IOException e) {
	//...
}finally{
	try {
		if(os!=null){
			os.close();
		}
		if(is!=null){
			is.close();
		}
	} catch (IOException e2) {
		//...
	}
}
</code></pre>
<p>java 1.7 引入的新特性，自动关闭 closeable 对象。</p>
<p>Demo：</p>
<pre><code class="language-java">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (Statement stmt = conn.createStatement()) {
        try (ResultSet rs = stmt.executeQuery(&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;)) {
            while (rs.next()) {
                long id = rs.getLong(1); // 注意：索引从1开始
                long grade = rs.getLong(2);
                String name = rs.getString(3);
                int gender = rs.getInt(4);
            }
        }
    }
}
</code></pre>
<p><code>Statment</code>和<code>ResultSet</code>都是需要关闭的资源，因此嵌套使用<code>try (resource)</code>确保及时关闭。</p>
<h2 id="java-8"><a class="header" href="#java-8">Java 8</a></h2>
<p>Java8 新特性深入讲解：https://github.com/wmyskxz/MoreThanJava/blob/master/java-base/java8.md</p>
<h3 id="接口默认方法"><a class="header" href="#接口默认方法">接口默认方法</a></h3>
<p>JDK8 引入。</p>
<p>接口中可以定义实现方法了：</p>
<pre><code class="language-java">public interface Sized {
    // 普通抽象方法，默认是public abstract修饰的，没有方法体
    int size();

    /*
     * 默认方法，有方法体
     * 任何一个实现了Sized接口的类都会继承isEmpty的实现
     */
    default boolean isEmpty() {
        return this.size() == 0;
    }
}
</code></pre>
<h3 id="接口静态方法"><a class="header" href="#接口静态方法">接口静态方法</a></h3>
<pre><code class="language-java">// 接口中的静态方法不能继承
interface TestInterface1 {
    static void sayHello(){
        System.out.println(&quot;TestInterface1 Hello&quot;);
    }
}
</code></pre>
<p>通常的做法都是将静态方法放在 <strong>伴随类</strong> <em>(可以理解为操作继承接口的实用工具类)</em> 中</p>
<h2 id="java-10"><a class="header" href="#java-10">Java 10</a></h2>
<h2 id="var"><a class="header" href="#var">var</a></h2>
<p>java 10 引入。</p>
<pre><code class="language-java">var codefx = new URL(&quot;http://codefx.org&quot;);
</code></pre>
<h2 id="string-args"><a class="header" href="#string-args">String... args</a></h2>
<p>Demo：</p>
<pre><code class="language-java">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
</code></pre>
<pre><code class="language-java">function(String... args)
</code></pre>
<pre><code class="language-java">function(String[] args) 
</code></pre>
<p>The only difference between the two is the way you call the function. With String var args you can omit the array creation.</p>
<pre><code class="language-java">public static void main(String[] args) {
    callMe1(new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;});
    callMe2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    // You can also do this
    // callMe2(new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;});
}
public static void callMe1(String[] args) {
    System.out.println(args.getClass() == String[].class); // True
    for (String s : args) {
        System.out.println(s);
    }
}
public static void callMe2(String... args) {
    System.out.println(args.getClass() == String[].class); // True
    for (String s : args) {
        System.out.println(s);
    }
}
</code></pre>
<h2 id="知识点-1"><a class="header" href="#知识点-1">知识点</a></h2>
<h3 id="三目运算符"><a class="header" href="#三目运算符">三目运算符</a></h3>
<p>作用：二选一</p>
<pre><code class="language-java">Object object = (1 == 2? &quot;hello&quot; : &quot;world&quot;); // boolean? value1 : value2
System.out.println(object); // world
</code></pre>
<h3 id="javax"><a class="header" href="#javax">javax</a></h3>
<p>if a package is introduced as an addition to an existing JRE, it comes in as <code>javax</code>.</p>
<p>注意，Tomcat 已经不支持 <code>javax.servlet</code>，转而支持 <code>jakarta.servlet</code></p>
<h3 id="classpath"><a class="header" href="#classpath">classpath</a></h3>
<p>The <code>CLASSPATH</code> variable is one way to tell applications, including the JDK tools, where to look for user classes. (Classes that are part of the JRE, JDK platform, and extensions should be defined through other means, such as the bootstrap class path or the extensions directory.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-log"><a class="header" href="#java-log">Java Log</a></h1>
<p>[TOC]</p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776">廖雪峰 log 教学</a></li>
<li><a href="http://logback.qos.ch/">logback doc</a></li>
</ul>
<h2 id="jdk-logging"><a class="header" href="#jdk-logging">jdk Logging</a></h2>
<p>jdk 自带的日志系统，不常用。</p>
<pre><code class="language-java">// logging
import java.util.logging.Level;
import java.util.logging.Logger;

public class Hello {
    public static void main(String[] args) {
        Logger logger = Logger.getGlobal();
        logger.info(&quot;start process...&quot;);
        logger.warning(&quot;memory is running out...&quot;);
        logger.fine(&quot;ignored.&quot;);
        logger.severe(&quot;process will be terminated...&quot;);
    }
}

/*
Mar 02, 2019 6:32:13 PM Hello main
INFO: start process...
Mar 02, 2019 6:32:13 PM Hello main
WARNING: memory is running out...
Mar 02, 2019 6:32:13 PM Hello main
SEVERE: process will be terminated...
*/
</code></pre>
<p>7 个日志级别</p>
<pre><code>SEVERE
WARNING
INFO
CONFIG
FINE
FINER
FINEST
</code></pre>
<h2 id="commons-logging--log4j"><a class="header" href="#commons-logging--log4j">Commons Logging / Log4j</a></h2>
<h3 id="commons-logging"><a class="header" href="#commons-logging">Commons Logging</a></h3>
<p>第三方日志库，Apache创建的日志模块。</p>
<p>Commons Logging 是接口，Log4J 是实现。</p>
<pre><code class="language-java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Main {
    public static void main(String[] args) {
        Log log = LogFactory.getLog(Main.class);
        log.info(&quot;start...&quot;);
        log.warn(&quot;end.&quot;);
    }
}
</code></pre>
<p>6 个日志级别：</p>
<pre><code>FATAL
ERROR
WARNING
INFO
DEBUG
TRACE
</code></pre>
<p>在实例方法中定义 Log</p>
<pre><code class="language-java">// 在实例方法中引用Log:
public class Person {
    protected final Log log = LogFactory.getLog(getClass()); // 注意此处的 getClass()，这么写的好处是，子类也可以直接使用该 Log 实例
    void foo() {
        log.info(&quot;foo&quot;);
    }
}
</code></pre>
<p>记录异常：</p>
<pre><code class="language-java">try {
    ...
} catch (Exception e) {
    log.error(&quot;got exception!&quot;, e);
}
</code></pre>
<h3 id="log4j"><a class="header" href="#log4j">Log4j</a></h3>
<p>Log4j 是 Commons Logging 的实现，其功能类似于 Django Logging。</p>
<p>Commons Logging 会自动发现并使用 Log4j。</p>
<h2 id="slf4j--logback"><a class="header" href="#slf4j--logback">SLF4J / Logback</a></h2>
<p>SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>
<p>SLF4J + logback 是现在最常用的日志系统。</p>
<p>logback 会自动扫描 classpath 中的 <code>logback.xml</code> 文件。</p>
<h3 id="maven-配置"><a class="header" href="#maven-配置">Maven 配置</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.1.7&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="logback"><a class="header" href="#logback">logback</a></h3>
<p>logback 配置文档详解：https://blog.csdn.net/millery22/article/details/86672284</p>
<ul>
<li>
<p>appender</p>
<p>是用来定义一个写日志记录的组件，常用的appender类有ConsoleAppender和RollingFileAppender，前者个是用来在控制台上打印日志，后者是将日志输出到文件中。</p>
</li>
<li>
<p>layout</p>
<p>是指定日志的布局方式，这个基本都不会去特殊的指定，可以忽略，知道有这个东西即可。</p>
</li>
<li>
<p>encoder</p>
<p>负责把事件转换成字节数组并把字节数组写到合适的输出流。encoder可以指定属性值class，这里对应的类只有一个PatternLayoutEncoder，也是默认值，可以不去指定。</p>
</li>
<li>
<p>filter</p>
<p>过滤器分为三种，logback-classic提供的是两种，分别是常规的过滤器和Turbo过滤器。常用的过滤器就是按照日志级别来控制，将不同级别的日志输出到不同文件中，便于查看日志。如：错误日志输出到xxx-error.log，info日志输出到xxx-info.log中。</p>
</li>
<li>
<p>rollingPolicy</p>
<p>用来设置日志的滚动策略，当达到条件后会自动将条件前的日志生成一个备份日志文件，条件后的日志输出到最新的日志文件中。常用的是按照时间来滚动（使用的类TimeBaseRollingPolicy）,还有一种就是基于索引来实现（使用的类FixedWindowRollingPolicy）</p>
</li>
<li>
<p>triggeringPolicy</p>
<p>日志触发器策略，常用的是日志的大小的控制，当日志达到对应的大小的时候，就会触发。生成新的日志文件。日志大小的控制配合rollingPlicy使用的时候，不同的rollingPolicy会有所不同</p>
</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;

    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
            &lt;charset&gt;utf-8&lt;/charset&gt;
        &lt;/encoder&gt;
        &lt;file&gt;log/jqx-message-push.log&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;
            &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;
        &lt;/triggeringPolicy&gt;
    &lt;/appender&gt;

    &lt;!-- INFO 表示只输出 INFO 级别及以上的日志，FILE 和 CONSOLE 表示该日志配置有两个输出，一个输出到控制台，一个输出到 FILE --&gt;
    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot; /&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>Demo</strong></p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class Main {
    final Logger logger = LoggerFactory.getLogger(getClass());
    logger.info(&quot;Set score {} for Person {} ok.&quot;, score, p.getName());
}

</code></pre>
<pre><code class="language-java">try{
    entityItemRepo.save(entityItem);
}catch (IllegalArgumentException e){
    log.error(&quot;save {} failed&quot;, &quot;entityItem&quot;, e);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-exception"><a class="header" href="#java-exception">java exception</a></h1>
<p>[TOC]</p>
<h2 id="exception-存在的意义"><a class="header" href="#exception-存在的意义">exception 存在的意义</a></h2>
<p>程序开发原理的描述。</p>
<p>异常也是一种返回值！异常将业务代码和异常处理代码解耦。</p>
<p>以下的内容，取自程序开发原理：</p>
<p>过程（接口）抽象是从自变量到结果的映射，可能会有一些对自变量的修改。自变量属于过程的定义域（domain），结果属于过程的值域（range）。只有当自变量从属于过程的定义域的子集时，这个过程才是有意义的。例如，只有当其自变量是正数时计算阶乘的过程才有意义。再例如，只有当元素出现在数组中时，查找（search）过程才返回元素的索引。</p>
<p>处理这种情况的方法之一是使用局部过程（partial procedures），例如，只有当 gcd 的自变量是正数时，才可以进行定义：</p>
<pre><code class="language-java">public static int gcd(int n, int d){
  // requires: n, d &gt; 0
  // effects: return the greatest common divisor of n and d
}
</code></pre>
<p>局部过程的调用者必须明确自变量属于定义域的子集，而实现者可以忽略这个子集之外的自变量。这样，在实现 gcd 的过程中，就可以忽略非正数自变量的情况了。</p>
<p>然而，一般来说，使用局部过程并不是什么好的解决方法，因为我们不能保证调用者一定不会传入 &lt; 0 的值。局部过程不能保证程序的鲁棒性。一个稳健的程序，即使发生错误，也应该继续合理的变现出错误。如果发生错误，程序无法像无错误时一样表现，则必须以一个明确定义的方式表现。</p>
<p>增强稳健性的方法是使用全过程（total procedures）：就是指为所有定义域内的输入都定义行为的过程。如果过程不能为其中某些输入执行其预期功能，则至少能够通知调用者。这样会引起调用者的注意，从而采取措施。</p>
<p>如果一个问题产生了，如何才能使调用者注意到它呢？一种可能，是使用特殊结果来传达这个信息。例如，如果计算阶乘过程的自变量不是正数，则会返回零：</p>
<pre><code class="language-java">public static int fact(int n)
  // effects: if n &gt; 0 return n! else return 0
</code></pre>
<p>这个解决方法其实并不大行，因为带有非法自变量的调用本身就是一个错误，如果用一个特殊的方法来处理这个情况就更好了。这样，使用这个接口的程序员就不太可能出错而忽略这个错误了。返回一个特殊值也可能给调用代码带来不便，返回了特殊值后，就必须再检查一下这个调用代码的结果，例如：</p>
<pre><code class="language-java">// 原来的代码
z = x + Num.fact(y);
// 优化后的代码
int r = Num.fact(y);
if(r &gt; 0) z = x + r; else ...
</code></pre>
<p>另外，如果返回类型的每个值都是过程的一个可能的结果，则这种返回一个特殊结果的解决方法就是不可能的，因为没有剩余值可以使用了。例如，向量 vector 的 get 方法返回向量的第 i 个元素的值，这个值可以是任何一个对象或者是 null。所以我们无法通过返回一个特殊对象或者返回 null 来传达有关越界的索引信息。</p>
<p>我们需要的是一种即时在返回类型的每个值都是合法结果时也能传达所有情况中有关不寻常信息的途径。而且，这个途径最好能够以某种方法区别哪些情况，这样用户就不会因为出错而忽略了它们。如果这个途径能使对这些情况的处理与其他正常的程序控制流分开进行（将业务代码和异常处理代码解耦），则是最佳的。</p>
<p>异常机制机制提供了我们所需要的，允许过程通过返回一个结果而正常终止或者异常终止！</p>
<h2 id="checked-exception-vs-runtime-exception"><a class="header" href="#checked-exception-vs-runtime-exception">checked exception vs runtime exception</a></h2>
<blockquote>
<p>对可恢复的情况使用受检异常，对编程错误使用运行时异常。—— Effective Java</p>
</blockquote>
<p>checked exception（受检异常） 继承自 Exception，unchecked exception（运行时异常，不可控异常） 继承自 RuntimeException。Exception 和 RuntimeException 都实现了 throwable 接口。</p>
<p>checked exception 必须被 try 或者抛出，unchecked exception 是隐藏的异常。</p>
<p>什么时候使用受检异常，什么时候使用运行时异常？如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。</p>
<pre><code class="language-java">try{
    String userInput = //read in user input
    Long id = Long.parseLong(userInput);
}catch(NumberFormatException e){
    id = 0; //recover the situation by setting the id to 0
}
</code></pre>
<p>用运行时异常来表明编程错误（调用接口的方式错误！）。大多数运行时异常都表示前提违例（precondition violation），就是指 API 的客户并没有遵守 API 规范建立的约定（你调用接口的方式错了，给你返回一个运行时异常，你重新调用）。例如，数组访问的预定指明了数组的下标值必须在 0 和数组长度 - 1之间。ArrayIndexOutOfBoundsException 表明违反了这个前提。</p>
<p>为什么 Web 服务返回的异常都使用 RuntimeException？因为 Web 服务的异常大多数都是接口调用方式不对，所以我们用 RuntimeException 来封装这些错误，并且直接冒泡返回，不需要层层 throw。</p>
<h2 id="什么时候使用异常"><a class="header" href="#什么时候使用异常">什么时候使用异常</a></h2>
<p>我们大多数时候使用的异常都是 RuntimeException。</p>
<p>异常应该用来去除大多数在 requires 中列出的约束条件（precondition）。requires 应该只为效率原因保留，或者在我们能确定调用该接口的时候一定能满足约束条件的时候，才保留 requires。</p>
<p>异常也应该用来消除在正常结果中的数字代码信息（异常就是异常，不能用特殊值来代替）。例如，如果元素不存在于数组中，search 就是一个异常，而不是返回一个特殊的数字。通过使用异常，我们能够清晰地区分正常的结果和异常的情况。</p>
<p>使用异常的规则：</p>
<ul>
<li>如果使用的环境是局部的，例如调用一个 private 方法，则不需要使用异常，因为能证实 requires 格式很容易得到满足，并且可以恰当地使用特殊结果。</li>
<li>但是，如果使用的环境是非局部的，例如公开的接口，则应该使用异常来代替特殊的结果。并且，应该使用异常来代替使用 requires 格式。（参考 Web 接口的异常码机制）</li>
</ul>
<h2 id="异常实战防御编程"><a class="header" href="#异常实战防御编程">异常实战：防御编程</a></h2>
<p>带有 requires 格式的过程的实现，如果可能，应该检查这个 requires 格式是否满足。如果没有满足，就抛出运行时异常 FailureException（requires 是契约，既然没有按照契约调用该接口，就是编程错误，就应该抛出运行时异常）。</p>
<p>接口的方法名不应该列出 FailureException，而且过程的规格中也不应该提到抛出它。因为这个异常描述的是不符合 precondition 的情况，调用者只有满足了这个 precondition 才能不抛出该异常。</p>
<p>更普遍的情况是，每当代码检查到一个应该满足的 precondition，但是这个 precondition 不满足时，就应该抛出运行时异常，表示没有准确地调用这个接口！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-虚拟机"><a class="header" href="#java-虚拟机">java 虚拟机</a></h1>
<h2 id="java-程序性能监测-visualvm"><a class="header" href="#java-程序性能监测-visualvm">Java 程序性能监测 visualvm</a></h2>
<pre><code class="language-shell"># run
cd bin
./visualvm
</code></pre>
<p>配置 Java 程序性能监控：</p>
<pre><code class="language-shell">java -Djava.rmi.server.hostname=198.87.103.211 \
-Dcom.sun.management.jmxremote=true \
-Dcom.sun.management.jmxremote.port=18006 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC xxx.jar
</code></pre>
<p>hostname 是 ip 地址，port 是 jmx 监控端口。</p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20220224200621658.png" alt="image-20220224200621658" /></p>
<h2 id="java-性能检测-jconsole"><a class="header" href="#java-性能检测-jconsole">Java 性能检测 jconsole</a></h2>
<p>jconsole 是 jre 自带的，直接输入 jconsole 就可以调起监控页面，很方便，感觉比 visualvm 好用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="junit"><a class="header" href="#junit">JUnit</a></h1>
<p>[TOC]</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<h3 id="junit5"><a class="header" href="#junit5">JUnit5</a></h3>
<p>https://junit.org/junit5/docs/current/user-guide/#running-tests-build-maven</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.7.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
    &lt;version&gt;5.7.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="springboot-配置"><a class="header" href="#springboot-配置">SpringBoot 配置</a></h3>
<h4 id="springboot-22-junit5"><a class="header" href="#springboot-22-junit5">SpringBoot 2.2+ JUnit5</a></h4>
<p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库。</p>
<p>JUnit5 的核心是 JUnit Jupiter。</p>
<p>JUnit5: https://junit.org/junit5/docs/current/user-guide/</p>
<p>需要引入的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>增加测试用例的 IDEA 快捷键：在类中 alt + insert</p>
<h4 id="兼容-junit4"><a class="header" href="#兼容-junit4">兼容 JUnit4</a></h4>
<p>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用 junit4 的功能 @Test）</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>@SpringBootTest + @RunWith(SpringTest.class)</p>
<h2 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h2>
<h3 id="重要性"><a class="header" href="#重要性">重要性</a></h3>
<ul>
<li>与 Maven 的配合，clean - test 会把所有的单元测试跑一遍</li>
<li>Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ul>
<li>在单元测试中，要使用 Assert 断言机制，不要使用 sout</li>
<li>一个业务逻辑开发完后，一定要写单元测试类。</li>
</ul>
<h2 id="junit5-注解"><a class="header" href="#junit5-注解">JUnit5 注解</a></h2>
<p>JUnit5 提供的一些注解：</p>
<table><thead><tr><th style="text-align: left">Annotation</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@Test</code></td><td style="text-align: left">Denotes that a method is a test method. Unlike JUnit 4’s <code>@Test</code> annotation, this annotation does not declare any attributes, since test extensions in JUnit Jupiter operate based on their own dedicated annotations. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@ParameterizedTest</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">parameterized test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@RepeatedTest</code></td><td style="text-align: left">Denotes that a method is a test template for a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests">repeated test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestFactory</code></td><td style="text-align: left">Denotes that a method is a test factory for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests">dynamic tests</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestTemplate</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-templates">template for test cases</a> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-test-templates">providers</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestMethodOrder</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order">test method execution order</a> for the annotated test class; similar to JUnit 4’s <code>@FixMethodOrder</code>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestInstance</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> for the annotated test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayName</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names">display name</a> for the test class or test method. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayNameGeneration</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-name-generator">display name generator</a> for the test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@Before</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@AfterEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@After</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@BeforeClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used). 注意，beforeall 修饰的必须是静态的方法</td></tr>
<tr><td style="text-align: left"><code>@AfterAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@AfterClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr>
<tr><td style="text-align: left"><code>@Nested</code></td><td style="text-align: left">Denotes that the annotated class is a non-static <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">nested test class</a>. <code>@BeforeAll</code> and <code>@AfterAll</code> methods cannot be used directly in a <code>@Nested</code> test class unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Tag</code></td><td style="text-align: left">Used to declare <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">tags for filtering tests</a>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are <em>inherited</em> at the class level but not at the method level.</td></tr>
<tr><td style="text-align: left"><code>@Disabled</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling">disable</a> a test class or test method; analogous to JUnit 4’s <code>@Ignore</code>. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Timeout</code></td><td style="text-align: left">Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@ExtendWith</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-declarative">register extensions declaratively</a>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@RegisterExtension</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic">register extensions programmatically</a> via fields. Such fields are <em>inherited</em> unless they are <em>shadowed</em>.</td></tr>
<tr><td style="text-align: left"><code>@TempDir</code></td><td style="text-align: left">Used to supply a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory">temporary directory</a> via field injection or parameter injection in a lifecycle method or test method; located in the <code>org.junit.jupiter.api.io</code> package.</td></tr>
</tbody></table>
<p>代码Demo：https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions</p>
<p>注意 @Test 标注，需要使用junit5版本的注解（Jupiter）。</p>
<h3 id="transactional-回滚"><a class="header" href="#transactional-回滚">@Transactional 回滚</a></h3>
<p>Demo:</p>
<pre><code class="language-java">@Test
// Transactional 回滚该方法
@Transactional
void update() {
    assertNotNull(userService.update());
}
</code></pre>
<h2 id="demo-2"><a class="header" href="#demo-2">Demo</a></h2>
<p>要引入这个静态包</p>
<pre><code class="language-java">import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person(&quot;Jane&quot;, &quot;Doe&quot;);

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));
        assertEquals(4, calculator.multiply(2, 2),
                &quot;The optional failure message is now the last parameter&quot;);
        assertTrue('a' &lt; 'b', () -&gt; &quot;Assertion messages can be lazily evaluated -- &quot;
                + &quot;to avoid constructing complex messages unnecessarily.&quot;);
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and all
        // failures will be reported together.
        assertAll(&quot;person&quot;,
            () -&gt; assertEquals(&quot;Jane&quot;, person.getFirstName()),
            () -&gt; assertEquals(&quot;Doe&quot;, person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll(&quot;properties&quot;,
            () -&gt; {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll(&quot;first name&quot;,
                    () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)),
                    () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;))
                );
            },
            () -&gt; {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll(&quot;last name&quot;,
                    () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)),
                    () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
        Exception exception = assertThrows(ArithmeticException.class, () -&gt;
            calculator.divide(1, 0));
        assertEquals(&quot;/ by zero&quot;, exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -&gt; {
            // Perform task that takes less than 2 minutes.
        });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -&gt; {
            return &quot;a result&quot;;
        });
        assertEquals(&quot;a result&quot;, actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals(&quot;Hello, World!&quot;, actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -&gt; {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -&gt; {
            // Simulate task that takes more than 10 ms.
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return &quot;Hello, World!&quot;;
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模板引擎"><a class="header" href="#模板引擎">模板引擎</a></h1>
<h2 id="btl-beetl-模板引擎"><a class="header" href="#btl-beetl-模板引擎">btl beetl 模板引擎</a></h2>
<p>官方文档：https://www.kancloud.cn/xiandafu/beetl3_guide/2138948</p>
<p>btl 内置方法：https://www.kancloud.cn/xiandafu/beetl3_guide/2138994</p>
<h3 id="mybatisplus-generator"><a class="header" href="#mybatisplus-generator">mybatisplus generator</a></h3>
<p><a href="https://www.cnblogs.com/bretgui/p/11125177.html">MybatisPlus代码生成器模板中的参数</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<p>[TOC]</p>
<h2 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h2>
<p>设计模式就是讲如何应对变化的。</p>
<p>SOLID</p>
<pre><code>Single Responsibility Principle
Open Closed Principle
Liskov Substitution Principle
Law of Demeter
Interface Segregation Principle
Dependence Inversion Principle
</code></pre>
<h2 id="里式替换原则"><a class="header" href="#里式替换原则">里式替换原则</a></h2>
<p>里式替换原则教我们如何实现子类。</p>
<p><a href="computer-science-notebook/note-for-java/"><img src="computer-science-notebook/note-for-java/assets/220px-Barbara_Liskov_MIT_computer_scientist_2010.jpg" alt="Portrait of Barbara Liskov" /></a> 麻省理工学院教授，04 年获得冯诺依曼奖，08 年获得图灵奖。</p>
<h3 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h3>
<p>Liskov Substitution Principle LSP 原则</p>
<p>把父类替换成子类，结果不变！</p>
<p>面向接口或父类编程：在类中调用其他类时，务必要使用其他类的父类或者接口，如果不能使用父类或接口，则说明类的设计已经违反了 LSP 原则。</p>
<p>玩具枪案例：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承。</p>
<p>LSP 可以正着用，但不能反着用。</p>
<p>对于覆盖（重写）来说，父类和子类的同名方法的输入参数是相同的，子类的方法的返回值范围应该小于父类；（肯定要小于父类的，因为客户端是用父类的引用指向子类的对象，如果子类返回的类型父类接不住，那不肯定出错！）</p>
<p>对于重载来说，则要求方法的输入参数类型或数量不相同，在里式替换原则要求下，子类的输入参数要宽于父类的输入参数，这样子类的这个重载方法才不会被调用。（入参范围变大，会产生危险，在调用的时候，就会寻找父类更小入参的方法，进而保证了父类的方法在每一个子类都能被优先执行）。</p>
<p>在采用里式替换原则时，要尽量避免子类的个性。</p>
<h3 id="demo-3"><a class="header" href="#demo-3">Demo</a></h3>
<p>A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code.</p>
<p>In mathematics, a <code>Square</code> is a <code>Rectangle</code>. Indeed it is a specialization of a rectangle. The &quot;is a&quot; makes you want to model this with inheritance. However if in code you made <code>Square</code> derive from <code>Rectangle</code>, then a <code>Square</code> should be usable anywhere you expect a <code>Rectangle</code>. This makes for some strange behavior.</p>
<p>Imagine you had <code>SetWidth</code> and <code>SetHeight</code> methods on your <code>Rectangle</code> base class; this seems perfectly logical. However if your <code>Rectangle</code> reference pointed to a <code>Square</code>, then <code>SetWidth</code> and <code>SetHeight</code> doesn't make sense because setting one would change the other to match it. In this case <code>Square</code> fails the Liskov Substitution Test with <code>Rectangle</code> and the abstraction of having <code>Square</code> inherit from <code>Rectangle</code> is a bad one.</p>
<p><a href="https://i.stack.imgur.com/ilxzO.jpg"><img src="computer-science-notebook/note-for-java/assets/ilxzO.jpg" alt="enter image description here" /></a></p>
<h2 id="依赖倒置原则"><a class="header" href="#依赖倒置原则">依赖倒置原则</a></h2>
<p>Dependence Inversion Principle DIP</p>
<h3 id="核心概念-1"><a class="header" href="#核心概念-1">核心概念</a></h3>
<p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。</p>
<p>六个字：面向接口编程！</p>
<p>接口就是契约，先定好契约，再实现具体的细节。</p>
<p>依赖正置：类间的依赖是实实在在的实现类之间的依赖，也就是面向实现编程，我要开奔驰车就依赖奔驰车，要使用笔记本电脑就直接依赖笔记本电脑。</p>
<p>依赖倒置：类间的依赖是接口之间的依赖，也就是面向接口编程。</p>
<h2 id="接口隔离原则"><a class="header" href="#接口隔离原则">接口隔离原则</a></h2>
<p>Interface-Segregation Principle</p>
<h3 id="核心概念-2"><a class="header" href="#核心概念-2">核心概念</a></h3>
<p>接口尽量细化，接口中的方法尽量少。</p>
<p>与单一职责不同。单一职责要求的是类与接口职责单一，注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少。例如一个接口的职责可能包含 10 个方法，这 10 个方法都放到一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束「不使用的方法不要访问」，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为其要求「尽量使用多个专门的接口」。</p>
<h2 id="迪米特法则"><a class="header" href="#迪米特法则">迪米特法则</a></h2>
<p>Law of Demeter</p>
<h3 id="核心概念-3"><a class="header" href="#核心概念-3">核心概念</a></h3>
<p>最少知识原则。一个类对自己需要耦合或调用的类知道得越少越好。</p>
<p>怎么做：解耦！</p>
<h2 id="开闭原则"><a class="header" href="#开闭原则">开闭原则</a></h2>
<p>Open Close Principe</p>
<h3 id="核心概念-4"><a class="header" href="#核心概念-4">核心概念</a></h3>
<p>对扩展开放，对修改关闭。</p>
<p>一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p>
<h2 id="创建型模式"><a class="header" href="#创建型模式">创建型模式</a></h2>
<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<h3 id="工厂方法"><a class="header" href="#工厂方法">工厂方法</a></h3>
<p>工厂模式用于定制对象。</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
<p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>
<p>传入不同的配置，获取不同的初始化对象。就跟工厂加工产品一样。</p>
<p>静态工厂方法（Static Factory Method）：</p>
<pre><code class="language-java">List&lt;String&gt; list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // 创建一个 collection

Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;) // 创建一个数组

Integer n = Integer.valueOf(100);

Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;) // 创建一个 stream
</code></pre>
<p>工厂方法：</p>
<pre><code class="language-java">public interface NumberFactory {
    
    static NumberFactory impl = new NumberFactoryImpl(); // 接口中也可以 new 对象
    
    // 创建方法:
    Number parse(String s);

    // 获取工厂实例:
    static NumberFactory getFactory() {
        return impl;
    }
    
}

public class NumberFactoryImpl implements NumberFactory {
    public Number parse(String s) {
        return new BigDecimal(s);
    }
}

NumberFactory factory = NumberFactory.getFactory();
Number result = factory.parse(&quot;123.456&quot;);
</code></pre>
<p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>
<p>工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p>
<p>实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。</p>
<p>调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。</p>
<h3 id="生成器"><a class="header" href="#生成器">生成器</a></h3>
<h2 id="装饰设计模式"><a class="header" href="#装饰设计模式">装饰设计模式</a></h2>
<p>装饰设计模式：对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。
装饰和继承都能实现一样的特点：进行功能的扩展增强，但是装饰比继承灵活，装饰的特点：装饰类和被装饰类都必须所属同一个接口或者父类。</p>
<p>Demo:</p>
<pre><code class="language-java">public class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person();
        // p.chifan();
        NewPerson p1 = new NewPerson(p);
        p1.chifan();
        NewPerson2 p2 = new NewPerson2();
        p2.chifan();
    }
}

class Person{
    void chifan(){
        System.out.println(&quot;吃饭&quot;);
    }
}

//这个类的出现是为了增强Person而出现的。
class NewPerson{
    private Person p ;
    NewPerson(Person p){
        this.p = p;
    }
    public void chifan(){
        System.out.println(&quot;开胃酒&quot;);
        p.chifan();
        System.out.println(&quot;甜点&quot;);
    }
}

class NewPerson2 extends Person{
    public void chifan(){
        System.out.println(&quot;开胃酒&quot;);
        super.chifan();
        System.out.println(&quot;甜点&quot;);
    }
}
</code></pre>
<h2 id="模板方法"><a class="header" href="#模板方法">模板方法</a></h2>
<p>https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762</p>
<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>
<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>
<h2 id="适配器模式"><a class="header" href="#适配器模式">适配器模式</a></h2>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>Adapter 模式可以将一个 A 接口转换为 B 接口，使得新的对象符合 B 接口规范。</p>
<p>编写 Adapter 实际上就是编写一个实现了 B 接口，并且内部持有A接口的类：</p>
<pre><code class="language-java">public BAdapter implements B {
    private A a;
    public BAdapter(A a) {
        this.a = a;
    }
    public void b() {
        a.a();
    }
}
</code></pre>
<p>在 Adapter 内部将 B 接口的调用“转换”为对A接口的调用。</p>
<h2 id="代理模式"><a class="header" href="#代理模式">代理模式</a></h2>
<p>https://www.bilibili.com/video/BV1M54y1X78p</p>
<p>在不修改原来对象代码的基础上，对原对象的功能进行修改或者增强。</p>
<p>代理就是跑腿，替身。</p>
<p>目标类：原来的对象</p>
<p>代理类：替身</p>
<p>既然是代理，那么行为必须是一样的！</p>
<h3 id="静态代理"><a class="header" href="#静态代理">静态代理</a></h3>
<p>代理类需要有和目标类一样的行为，怎么实现呢？</p>
<ul>
<li>基于接口：定义一个接口，代理类和目标类都实现自这个接口，这样两个类就有了同样的行为</li>
<li>基于继承：代理类继承自目标类</li>
</ul>
<p>静态代理的缺点：</p>
<p>一旦接口或者父类发生变动，则代理类的代码就得随之修改，代理类多的时候维护比较麻烦。所以在实际开发中，多使用动态代理。</p>
<h3 id="动态代理"><a class="header" href="#动态代理">动态代理</a></h3>
<p>动态代理，是在内存中生成代理对象的一种技术。也就是整个代理过程在内存中进行，不需要我们手写代理类的代码，也不会存在代理类编译的过程，而是直接在运行期，在 JVM 中凭空造出一个代理类对象供我们使用。</p>
<h3 id="动态代理-基于-jdk"><a class="header" href="#动态代理-基于-jdk">动态代理-基于 jdk</a></h3>
<p>基于接口</p>
<p>JDK 自带的动态代理技术，需要使用一个静态方法来创建代理对象。它要求被代理对象，也就是目标类，必须实现接口。生成的代理对象和原对象都实现相同的接口，是兄弟关系。</p>
<p>基于接口的动态代理，实际上是在内存中生成了一个对象，该对象实现了指定的目标类对象拥有的接口。所有代理类对象和目标类对象是兄弟关系。</p>
<p>兄弟关系：并列的关系，不能互相转换，包容性比较差。在后续会学习 spring 框架，如果配置 jdk 的动态代理方式，一定要用接口类型接收代理类。</p>
<h3 id="动态代理-基于-cglib"><a class="header" href="#动态代理-基于-cglib">动态代理-基于 cglib</a></h3>
<p>基于父类</p>
<p>第三方 cglib 动态代理技术，也是可以使用一个静态方法来创建一个代理对象。它不要求目标类实现接口，但是要求目标类不能是最终类，也就是不能被 final 修饰，否则无法继承。因为 cglib 是基于目标类生成该类的一个子类作为代理类，所以目标类必须可以被继承。</p>
<p>基于父类的动态代理，是在内存中生成了一个对象，该对象继承了原对象，所以代理对象实际上是目标类对象的儿子。</p>
<p>父子关系：父子关系，代理类对象是可以用父类的引用接收的。</p>
<h3 id="比较"><a class="header" href="#比较">比较</a></h3>
<ul>
<li>静态代理和动态代理，实际使用时，还是动态代理使用得比较多，原因就是静态代理需要自行手写代码，维护、修改非常频繁，会额外引入很多工作量。也不能很好地使用配置完成逻辑地指定，所以使用较少。</li>
<li>基于 jdk 和 基于 cglib 的动态代理：
<ul>
<li>在 Spring 中，默认情况下支持两种动态代理，如果目标类实现了接口，则自动选择 jdk 动态代理，如果目标类没有实现接口，则使用 cglib</li>
<li>我们在开发时，由于基于  jdk 的动态代理要求比较多，更不容易实现，所以很多人习惯于统一配置为使用 cglib 进行代理，也就是 cglib 更通用</li>
<li>如果使用 dubbo + zookeeper，底层进行代理时，最好配置定死使用 cglib 的方式进行代理，因为 dubbo 会使用基于包名的扫描方式进行类的处理，而 jdk 代理生成的包名类似于 <code>com.sun.proxy</code> 格式。我们实际需要代理类和目标类保持同样的包名，只有 cglib 能保持原包名不变生成代理类</li>
</ul>
</li>
</ul>
<h2 id="工厂模式"><a class="header" href="#工厂模式">工厂模式</a></h2>
<p>https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017</p>
<h2 id="策略设计模式"><a class="header" href="#策略设计模式">策略设计模式</a></h2>
<p>Strategy Pattern</p>
<h3 id="类图"><a class="header" href="#类图">类图</a></h3>
<img src="computer-science-notebook/note-for-java/assets/image-20220125153718245.png" alt="image-20220125153718245" style="zoom:50%;" />
<h3 id="核心概念-5"><a class="header" href="#核心概念-5">核心概念</a></h3>
<ul>
<li>
<p>Context 封装角色</p>
<p>起承上启下封装作用，屏蔽高层模块对策略的直接访问，封装可能存在的变化。注意，Context 中要提供一个和函数式接口中一样的方法，例如 <code>void operate()</code></p>
</li>
<li>
<p>IStrategy</p>
<p>抽象的策略，实际上是一个函数式接口</p>
</li>
<li>
<p>ConcreteStrategy</p>
<p>具体的策略，函数式接口的具体实现，可以是一个具体的类，也可以是匿名内部类，也可以直接就是一个 lambda 表达式</p>
</li>
</ul>
<h3 id="springboot-实战"><a class="header" href="#springboot-实战">SpringBoot 实战</a></h3>
<p>代码结构：</p>
<pre><code>├── strategy
│   ├── IQuantStrategy.java
│   ├── QuantContext.java
│   └── quant
│       ├── CriticalStrategy.java
│       └── RiseFallStrategy.java
</code></pre>
<p>在 SpringBoot 项目中，一个策略就是一个 Bean：</p>
<pre><code class="language-java">@Component
public class CriticalStrategy implements IQuantStrategy {

    @Resource
    private MailService mailService;

    @Override
    public boolean quant(IG507StockInfoWithMetaInfo ig507StockInfoWithMetaInfo) {
        return true;
    }
}
</code></pre>
<h3 id="优化"><a class="header" href="#优化">优化</a></h3>
<p><code>IStrategy</code> 实际上是一个函数式接口，可以使用 lambda 表达式来简化各个策略。</p>
<pre><code class="language-java">package strategy;

/**
 * @author wanshuo
 * @date 2022-01-25 16:14:34
 * 折扣策略
 */
public interface IDiscountStrategy {
    /***
     * 施加折扣
     * @param total 总价
     * @return 打折后的价格
     */
    float applyDiscount(float total);

    /***
     * java8 中接口内可以定义静态方法及其实现！
     * 5 折策略
     * @return 策略函数对象
     */
    static IDiscountStrategy halfDiscountStrategy(){
        return total -&gt; total * 0.5f;
    }

    /***
     * 打 8 折的策略
     * @return 策略函数对象
     */
    static IDiscountStrategy eightyDiscountStrategy(){
        return total -&gt; total * 0.8f;
    }
}

class IDiscountStrategyTest {
    @Test
    void strategy(){
        IDiscountStrategy halfDiscountStrategy = IDiscountStrategy.halfDiscountStrategy();
        System.out.println(halfDiscountStrategy.applyDiscount(50));
    }
}
</code></pre>
<h3 id="注意-1"><a class="header" href="#注意-1">注意</a></h3>
<p>策略设计模式的重点就是封装角色 Context，它不是代理类，虽然有着和函数式接口一样的方法，但是并没有实现函数式接口，如果实现了函数式接口，就是代理设计模式了。</p>
<h3 id="应用案例"><a class="header" href="#应用案例">应用案例</a></h3>
<ul>
<li>商场打折促销策略</li>
<li>告警策略</li>
</ul>
<h2 id="装饰设计模式-1"><a class="header" href="#装饰设计模式-1">装饰设计模式</a></h2>
<p>Decorator pattern</p>
<h3 id="类图-1"><a class="header" href="#类图-1">类图</a></h3>
<img src="computer-science-notebook/note-for-java/assets/image-20220126113450562.png" alt="image-20220126113450562" style="zoom:50%;" />
<h3 id="核心概念-6"><a class="header" href="#核心概念-6">核心概念</a></h3>
<p>装饰模式的核心，是装饰器（装饰类）。</p>
<p>装饰类继承自要装饰的接口，和要装饰的实体类，是兄弟关系。</p>
<p>Decorator 抽象类的目的很简单，就是让其子类来封装 SchoolReport 对象，重写 report 方法。</p>
<p>用继承也可以实现方法的装饰，但是继承太多会变得复杂，而且不容易维护。装饰模式相比生成子类更为灵活。</p>
<p>装饰设计模式是继承的一个替代方法，装饰类不管装饰多少层，返回的仍然是要装饰的对象，还是 is-a 的关系。</p>
<h3 id="demo-4"><a class="header" href="#demo-4">Demo</a></h3>
<pre><code class="language-java">public abstract class SchoolReport{
  // 成绩报告
  public abstract void report();
  // 签字
  public abstract void sign();
}
// 四年级的成绩报告
public class FouthGradeSchoolReport extends SchoolReport{
  public void report(){
    sout(&quot;语文：80 分&quot;);
  }
  public void sign(){
    sout(&quot;张三&quot;);
  }
}

// 下面开始装饰
public abstract class Decorator extends SchoolReport{

    private SchoolReport schoolReport;

    public Decorator(SchoolReport schoolReport){
        this.schoolReport = schoolReport;
    }

    @Override
    public void report() {
        this.schoolReport.report();
    }

    @Override
    public void sign() {
        this.schoolReport.sign();
    }
}

public class HighestScoreDecorator extends Decorator{

    public HighestScoreDecorator(SchoolReport schoolReport) {
        super(schoolReport);
    }

    private void myReport(){
        System.out.println(&quot;语文最高分：81&quot;);
    }

    /***
     * 想要装饰哪个方法，就重写那个方法
     */
    public void report(){
        this.myReport();
        super.report();
    }
}

public class SortOrderDecorator extends Decorator{

    public SortOrderDecorator(SchoolReport schoolReport) {
        super(schoolReport);
    }

    private void myReport(){
        System.out.println(&quot;我排名第 10 名&quot;);
    }

    /***
     * 想要装饰哪个方法，就重写那个方法
     */
    public void report(){
        this.myReport();
        super.report();
    }
}

public class Father {
    public static void main(String[] args) {
        SchoolReport schoolReport = new FouthGradeSchoolReport();
        schoolReport = new HighestScoreDecorator(schoolReport);
      	// 不管怎么装饰，返回的都是被装饰的对象
        schoolReport = new SortOrderDecorator(schoolReport);
        schoolReport.report();
    }
}

/**
我排名第 10 名
语文最高分：81
语文：80 分
*/
</code></pre>
<h2 id="参考文献-1"><a class="header" href="#参考文献-1">参考文献</a></h2>
<ul>
<li><a href="https://www.baeldung.com/java-liskov-substitution-principle">Liskov Substitution Principle in Java</a> </li>
<li><a href="https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle">What is an example of the Liskov Substitution Principle?</a></li>
<li><a href="https://www.baeldung.com/java-strategy-pattern">Strategy Design Pattern in Java 8</a></li>
<li><a href="https://ravthiru.medium.com/strategy-design-pattern-with-in-spring-boot-application-2ff5a7486cd8">Strategy Design Pattern with in Spring Boot application</a></li>
<li><a href="https://book.douban.com/subject/25843319/">设计模式之禅</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型详解"><a class="header" href="#泛型详解">泛型详解</a></h1>
<p>[TOC]</p>
<h2 id="泛型视频教程"><a class="header" href="#泛型视频教程">泛型视频教程</a></h2>
<p>泛型可以用来修饰类、接口、方法、参数、返回值</p>
<p><a href="https://www.bilibili.com/video/BV1xJ411n77R">JavaSE强化教程泛型，由点到面的讲解了整个泛型体系</a></p>
<h3 id="泛型类"><a class="header" href="#泛型类">泛型类</a></h3>
<p>泛型类在创建对象的时候，如果没有指定类型，则按照 Object 类型来操作。</p>
<p>泛型类不支持基本数据类型。</p>
<p><strong>同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型。</strong></p>
<p>泛型类的一个例子：抽奖。</p>
<p>从泛型类派生的子类：</p>
<ul>
<li>
<p>子类也是泛型类，则子类和父类的泛型类型一致</p>
<pre><code class="language-java">class ChindGeneric&lt;T&gt; extends Generic&lt;T&gt;
    
class ChindGeneric&lt;T,K,E&gt; extends Generic&lt;T&gt;    
</code></pre>
</li>
<li>
<p>子类不是泛型类，则父类要明确泛型的数据类型</p>
<pre><code class="language-java">class ChindGeneric extends Generic&lt;String&gt;
</code></pre>
</li>
</ul>
<h3 id="泛型接口"><a class="header" href="#泛型接口">泛型接口</a></h3>
<ul>
<li>实现类不是泛型类，接口要明确数据类型</li>
<li>实现类也是泛型类，实现类和接口的泛型类型要一致，要保证实现接口的泛型类泛型标志包含泛型接口的泛型标志</li>
</ul>
<h3 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h3>
<ul>
<li>泛型类，是在实例化类的时候，指定泛型的具体类型</li>
<li>泛型方法，是在调用方法的时候指明泛型的具体类型</li>
</ul>
<p>泛型方法使方法独立于类而产生变化。</p>
<p>只有声明了 <T> 的方法，才是泛型方法，泛型类中使用了泛型的成员方法并不是泛型方法。<T> 表示该方法将使用泛型类型 T，与泛型类的定义一样，T 可以随便写成任意标志，常见的如：T、E、K、V</p>
<pre><code class="language-java">// 这是泛型类中定义的成员方法，并不是泛型方法 
public T getProduct(){
     product = list.get(random.nextInt(list.size()));
     return product;
 }

// 定义一个泛型方法
public &lt;E&gt; E getProduct(ArrayList&lt;E&gt; list){
    product = list.get(random.nextInt(list.size()));
    return product;
}
// 调用泛型方法
ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();
strList.add(&quot;笔记本电脑&quot;);
strList.add(&quot;苹果手机&quot;);
ProductGetter&lt;Integer&gt; productGetter = new ProductGetter&lt;&gt;();
String product = productGetter.getProduct(strList);
</code></pre>
<p>泛型方法可以定义成静态，泛型类的成员方法不能定义为静态方法。</p>
<h4 id="静态泛型方法"><a class="header" href="#静态泛型方法">静态泛型方法</a></h4>
<pre><code class="language-java">public static &lt;T,E,K&gt; void printType(T t, E e, K k){
    sout(t + &quot;\t&quot; + t.getClass().getSimpleName);
    sout(e + &quot;\t&quot; + e.getClass().getSimpleName);
    sout(k + &quot;\t&quot; + k.getClass().getSimpleName);
}

ProductGetter.printType(100, &quot;java&quot;, true);

</code></pre>
<h4 id="泛型方法可变参数"><a class="header" href="#泛型方法可变参数">泛型方法可变参数</a></h4>
<pre><code class="language-java">public static &lt;E&gt; void print(E... e){
    for(E e1 : e){
        sout(e1); 
    }
}

ProductGetter.print(1, 2, 3, 4, 5);
ProductGetter.print(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
</code></pre>
<h3 id="类型通配符-"><a class="header" href="#类型通配符-">类型通配符 ?</a></h3>
<p>类型通配符一般是使用 &quot;?&quot; 代替具体的类型<strong>实参</strong>。</p>
<pre><code class="language-java">Box&lt;Number&gt; box1 = new Box&lt;&gt;();
box1.setFirst(100);
showBow(box1);

Box&lt;Integer&gt; box2 = new Box&lt;&gt;();
box2.setFirst(200);
showBox(box2);

public static void showBox(Box&lt;?&gt; box){
    Object first = box.getFirst();
    sout(first);
}
</code></pre>
<h4 id="上限-extends"><a class="header" href="#上限-extends">上限 extends</a></h4>
<p>类 / 接口 &lt;? extends 实参类型&gt;</p>
<pre><code class="language-java">ArrayList&lt;Animal&gt; animals = new ArrayList&lt;&gt;();
ArrayList&lt;Cat&gt; cats = new ArrayList&lt;&gt;();
ArrayList&lt;MiniCat&gt; miniCats = new ArrayList&lt;&gt;();
showAnimal(animals); // X
showAnimal(cats); // √
showAnimal(miniCats); // √

public static void showAnimal(ArrayList&lt;? extends Cat&gt; list){
    // list.add(new Cat()); // x
    // list.add(new MiniCat()); // x 因为传过来的是一个实参，我们并不知道 list 里面存储的到底是甚么类型的对象，如果传的是 ArrayList&lt;MiniCat&gt;，那么 list.add(new Cat()) 肯定不行，MiniCat 接不住 Cat，所以 extends 不允许 add
    for(int i=0; i&lt;list.size(); i++){
        Cat cat = list.get(i); // 拿上限 Cat 来接
        sout(cat);
    }
}
</code></pre>
<h4 id="下限-super"><a class="header" href="#下限-super">下限 super</a></h4>
<p>类 / 接口 &lt;? super 实参类型&gt;</p>
<p>要求该泛型的类型，只能是实参类型，或实参类型的父类类型</p>
<pre><code class="language-java">ArrayList&lt;Animal&gt; animals = new ArrayList&lt;&gt;();
ArrayList&lt;Cat&gt; cats = new ArrayList&lt;&gt;();
ArrayList&lt;MiniCat&gt; miniCats = new ArrayList&lt;&gt;();
showAnimal(animals); // √ 
showAnimal(cats); // √
showAnimal(miniCats); // x

public static void showAnimal(ArrayList&lt;? super Cat&gt; list){
    list.add(new Cat()); // √ 传过来的是 Cat 的父类集合，Cat 和 MiniCat 都能接住！所以 super 可以 add
    list.add(new MiniCat()); // √
    for(Object o : list){ // 拿上限 Object 来接
        sout(o)
    }
}
</code></pre>
<p>TreeSet 例子：</p>
<p>TreeSet 的 Comparator 构造函数为：</p>
<pre><code class="language-java">public TreeSet(Comparator&lt;? super E&gt; comparator) {
    this(new TreeMap&lt;&gt;(comparator));
}
</code></pre>
<pre><code class="language-java">TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator2()); // √ 根据 &lt;? super Cat&gt; 的规则，必须传 Cat 的父类比较器
TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator1()); // √ 
TreeSet&lt;Cat&gt; treeSet = new TreeSet&lt;&gt;(new Comparator3()); // × 
treeSet.add(new Cat(&quot;jerry&quot;, 20));
treeSet.add(new Cat(&quot;amy&quot;, 19));
treeSet.add(new Cat(&quot;frank&quot;, 22));



// Animal 类的比较器，继承自泛型接口，需要实现 compare 方法
class Comparator1 implements Comparator&lt;Animal&gt; {
    @Override
    public int compare(Animal o1, Animal o2){
        return o1.name.compare(o2.name);
    }
}
// Cat 类的比较器
class Comparator2 implements Comparator&lt;Cat&gt; {
    @Override
    public int compare(Cat o1, Cat o2){
        return o1.age - o2.age;
    }
}
// MiniCat 类的比较器
class Comparator3 implements Comparator&lt;MiniCat&gt; {
    @Override
    public int compare(MiniCat o1, MiniCat o2){
        return o1.level - o2.level;
    }
}
</code></pre>
<h3 id="类型擦除"><a class="header" href="#类型擦除">类型擦除</a></h3>
<p>泛型是 Java1.5 版本引入的概念，在这之前是没有泛型的，但是泛型代码能够很好地和之前版本的代码兼容。这是因为，泛型信息只存在于代码编译阶段，编译完后，类型就擦除了！在进入 JVM 之前，与泛型相关的信息会被擦除掉，我们称之为类型擦除。(JVM 里面根本没有泛型这玩意)</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();

sout(intList.getClass().getSimpleName()); // ArrayList
sout(strList.getClass().getSimpleName()); // ArrayList

sout(intList.getClass() == strList.getClass()); // true
</code></pre>
<h4 id="无限制类型擦除"><a class="header" href="#无限制类型擦除">无限制类型擦除</a></h4>
<img src="computer-science-notebook/note-for-java/assets/image-20210824195049556.png" alt="image-20210824195049556" style="zoom: 50%;" />
<pre><code class="language-java">Erasure&lt;Integer&gt; erasure = new Erasure&lt;&gt;();
// 利用反射获取 key 的类型
Class&lt;? extends Erasure&gt; clz = erasure.getClass();
Field[] declaredFields = clz.getDeclaredFields();
for(Field declaredField : declaredFields){
    sout(declaredField.getName() + &quot; : &quot; + declaredField.getType().getSimpleName());
}
// key:Object key 是 Object 类型
</code></pre>
<h4 id="有限制类型擦除"><a class="header" href="#有限制类型擦除">有限制类型擦除</a></h4>
<p>按照上限进行类型擦除</p>
<img src="computer-science-notebook/note-for-java/assets/image-20210824195550273.png" alt="image-20210824195550273" style="zoom: 50%;" />
<pre><code class="language-java">Erasure&lt;Integer&gt; erasure = new Erasure&lt;&gt;();
// 利用反射获取 key 的类型
Class&lt;? extends Erasure&gt; clz = erasure.getClass();
Field[] declaredFields = clz.getDeclaredFields();
for(Field declaredField : declaredFields){
    sout(declaredField.getName() + &quot; : &quot; + declaredField.getType().getSimpleName());
}
// key:Number key 是 Number 类型
</code></pre>
<h4 id="擦除方法中类型定义的参数"><a class="header" href="#擦除方法中类型定义的参数">擦除方法中类型定义的参数</a></h4>
<img src="computer-science-notebook/note-for-java/assets/image-20210824200028734.png" alt="image-20210824200028734" style="zoom: 50%;" />
<h4 id="桥接方法"><a class="header" href="#桥接方法">桥接方法</a></h4>
<img src="computer-science-notebook/note-for-java/assets/image-20210824200417465.png" alt="image-20210824200417465" style="zoom:50%;" />
<h3 id="泛型数组"><a class="header" href="#泛型数组">泛型数组</a></h3>
<p>可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象</p>
<pre><code class="language-java">ArrayList&lt;String&gt;[] listArr = new ArrayList&lt;String&gt;[5]; // x 只能声明引用，不能创建带泛型的数组对象
ArrayList[] arr = new ArrayList[5];
ArrayList&lt;String&gt;[] listArr; // √ 只能声明引用，然后赋值
listArr = arr; // √
ArrayList&lt;String&gt;[] listArr = new ArrayList[5]; // √ 
</code></pre>
<p>可以通过 <code>java.lang.reflect.Array 的 newInstance(Class&lt;T&gt;, int)</code> 创建 <code>T[]</code> 数组</p>
<pre><code class="language-java">public class Fruit&lt;T&gt;{
    private T[] array;
   
    public Fruit(Class&lt;T&gt; clz, int length){
        // 通过 Array.newInstance 创建泛型数组
        array = (T[])Array.newInstance(clz, length);
    }
}
</code></pre>
<h3 id="泛型和反射"><a class="header" href="#泛型和反射">泛型和反射</a></h3>
<p>下面介绍泛型对反射的支持。</p>
<p>反射常用的泛型类：</p>
<ul>
<li>Class<T></li>
<li>Constructor<T></li>
</ul>
<pre><code class="language-java">Person{
    private String name;
}

Class&lt;Person&gt; personClass = Person.class;
Constructor&lt;Person&gt; constructor = personClass.getConstructor();
Person person = constructor.newInstance();

// 对比
Class personClass = Person.class;
Constructor constructor = personClass.getConstructor();
Object o = constructor.newInstance();
</code></pre>
<h2 id="教程-1"><a class="header" href="#教程-1">教程</a></h2>
<ul>
<li><a href="https://www.oracle.com/cn/technical-resources/articles/java/juneau-generics.html">Oracle Generic Blog</a></li>
<li><a href="https://www.bilibili.com/video/BV1xJ411n77R">黑马程序员：JavaSE强化教程泛型，由点到面的讲解了整个泛型体系</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream"><a class="header" href="#stream">Stream</a></h1>
<p>[TOC]</p>
<h2 id="stream-调试"><a class="header" href="#stream-调试">stream 调试</a></h2>
<ol>
<li>使用 peek 打印中间步骤</li>
<li>IDEA 支持对 lambda 表达式下断点进行 debug，下次可以尝试一下！</li>
</ol>
<h2 id="stream-特点"><a class="header" href="#stream-特点">stream 特点</a></h2>
<h3 id="与-for-循环比较"><a class="header" href="#与-for-循环比较">与 for 循环比较</a></h3>
<p>for 循环采用外部迭代，流采用内部迭代。</p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208095104284.png" alt="image-20211208095104284" /></p>
<p>再举一个生活中实际的例子（引自《Java 8 实战》），比如您想让您两岁的孩子索菲亚把她的玩具都收到盒子里面去，你们之间可能会产生如下的对话：</p>
<ul>
<li>你：“索菲亚，我们把玩具收起来吧，地上还有玩具吗？”</li>
<li>索菲亚：“有，球。”</li>
<li>你：“好，把球放进盒子里面吧，还有吗？”</li>
<li>索菲亚：“有，那是我的娃娃。”</li>
<li>你：“好，把娃娃也放进去吧，还有吗？”</li>
<li>索菲亚：“有，有我的书。”</li>
<li>你：“好，把书也放进去，还有吗？”</li>
<li>索菲亚：“没有了。”</li>
<li>你：“好，我们收好啦。”</li>
</ul>
<p>这正是你每天都要对 Java 集合做的事情。你外部迭代了一个集合，显式地取出每个项目再加以处理，但是如果你只是跟索菲亚说：“把地上所有玩具都放进盒子里”，那么索菲亚就可以选择一手拿娃娃一手拿球，或是选择先拿离盒子最近的那个东西，再拿其他的东西。采用内部迭代，项目可以透明地并行处理，或者用优化的顺序进行处理，要是使用 Java 过去的外部迭代方法，这些优化都是很困难的。</p>
<h3 id="stream-优缺点"><a class="header" href="#stream-优缺点">stream 优缺点</a></h3>
<p>优点</p>
<ul>
<li>声明式编程，可读性好</li>
<li>简洁，优雅</li>
<li>减少代码行数</li>
</ul>
<p>缺点</p>
<ul>
<li>不方便 debug</li>
</ul>
<h3 id="只能遍历一次"><a class="header" href="#只能遍历一次">只能遍历一次</a></h3>
<p>和迭代器一样，流只能遍历一次。当流遍历完之后，我们就说这个流已经被消费掉了，你可以从原始数据那里重新获得一条新的流，但是却不允许消费已消费掉的流。例如下面代码就会抛出一个异常，说流已被消费掉了：</p>
<pre><code class="language-java">List&lt;String&gt; title = Arrays.asList(&quot;Wmyskxz&quot;, &quot;Is&quot;, &quot;Learning&quot;, &quot;Java8&quot;, &quot;In&quot;, &quot;Action&quot;);
Stream&lt;String&gt; s = title.stream();
s.forEach(System.out::println);
s.forEach(System.out::println);
// 运行上面程序会报以下错误
/*
Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279)
    at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)
    at Test1.main(Tester.java:17)
*/
</code></pre>
<h3 id="并行处理"><a class="header" href="#并行处理">并行处理</a></h3>
<p>Java 8 中不仅提供了方便的一些流操作（比如过滤、排序之类的），更重要的是对于并行处理有很好的支持，只需要加上 <code>.parallel()</code> 就行了！例如我们使用下面程序来说明一下多线程流操作的方便和快捷，并且与单线程做了一下对比：</p>
<pre><code class="language-java">COPYpublic class StreamParallelDemo {

    /** 总数 */
    private static int total = 100_000_000;

    public static void main(String[] args) {
        System.out.println(String.format(&quot;本计算机的核数：%d&quot;, Runtime.getRuntime().availableProcessors()));

        // 产生1000w个随机数(1 ~ 100)，组成列表
        Random random = new Random();
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(total);

        for (int i = 0; i &lt; total; i++) {
            list.add(random.nextInt(100));
        }

        long prevTime = getCurrentTime();
        list.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);
        System.out.println(String.format(&quot;单线程计算耗时：%d&quot;, getCurrentTime() - prevTime));

        prevTime = getCurrentTime();
        // 只需要加上 .parallel() 就行了
        list.stream().parallel().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);
        System.out.println(String.format(&quot;多线程计算耗时：%d&quot;, getCurrentTime() - prevTime));

    }

    private static long getCurrentTime() {
        return System.currentTimeMillis();
    }
}
</code></pre>
<p>以上程序分别使用了单线程流和多线程流计算了一千万个随机数的和，输出如下：</p>
<pre><code>本计算机的核数：8
655028378
单线程计算耗时：4159
655028378
多线程计算耗时：540
</code></pre>
<p>并行流的内部使用了默认的 ForkJoinPool 分支/合并框架，它的默认线程数量就是你的处理器数量，这个值是由 <code>Runtime.getRuntime().availableProcessors()</code> 得到的（当然我们也可以全局设置这个值）。我们也不再去过度的操心加锁线程安全等一系列问题。</p>
<h2 id="on-java"><a class="header" href="#on-java">on java</a></h2>
<p>在大多数情况下，将对象存储在集合中就是为了处理它们，因此你会发现你把编程的主要焦点从集合转移到了流上。
流的一个核心好处是，它使得程序更加短小并且更易理解。</p>
<p>流的知识可以分成三种：流的创建，流的中间操作，流的终端操作</p>
<h3 id="流支持"><a class="header" href="#流支持">流支持</a></h3>
<p>在接口中添加被 default（默认）修饰的方法。通过这种方案，设计者们可以将流式（stream）方法平滑地嵌入到现有类中</p>
<h3 id="创建流"><a class="header" href="#创建流">创建流</a></h3>
<h4 id="streamof"><a class="header" href="#streamof">Stream.of</a></h4>
<pre><code class="language-java">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) {
    return Arrays.stream(values); // 其实是调用了 Arrays.stream 静态泛型方法
}
</code></pre>
<pre><code class="language-java">Stream.of(&quot;It's &quot;, &quot;a &quot;, &quot;wonderful &quot;, &quot;day &quot;, &quot;for &quot;, &quot;pie!&quot;)
</code></pre>
<h4 id="arraysstream"><a class="header" href="#arraysstream">Arrays.stream</a></h4>
<p>将数组转换成流。</p>
<pre><code class="language-java">public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) {
    return stream(array, 0, array.length);
}
</code></pre>
<h4 id="collectionstream"><a class="header" href="#collectionstream">collection.stream</a></h4>
<pre><code class="language-java">list.stream();
m.entrySet().stream().map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())
</code></pre>
<h4 id="随机数流"><a class="header" href="#随机数流">随机数流</a></h4>
<pre><code class="language-java">Random rand = new Random(47); // 47 是种子
rand.ints().boxed().limit(4).forEach(System.out::println);
rand.longs()...;
rand.doubles()...;
rand.ints(10, 20)...; // 上限和下限
rand.ints(2)...; // 流的大小
rand.longs(3, 12, 22)...; // 流的大小和边界
</code></pre>
<h4 id="streamgenerate--supplier"><a class="header" href="#streamgenerate--supplier">Stream.generate + Supplier</a></h4>
<p>Stream.generate() 的用法，它可以把任意Supplier<T> 用于生成 T 类型的流。</p>
<pre><code class="language-java">Stream.generate(new RandomWords(&quot;Cheese.dat&quot;))
    .limit(10)
    .collect(Collectors.joining(&quot; &quot;)));

Stream.generate(() -&gt; &quot;duplicate&quot;)
    .limit(3)
    .forEach(System.out::println);
// duplicate  duplicate  duplicate
</code></pre>
<h4 id="intstreamrange"><a class="header" href="#intstreamrange">IntStream.range</a></h4>
<pre><code class="language-java">IntStream.range(0, 10).sum()
</code></pre>
<h4 id="streamiterate"><a class="header" href="#streamiterate">Stream.iterate</a></h4>
<p>Stream.iterate() 产生的流的第一个元素是种子（iterate 方法的第一个参数），然后将种子传递给方法（iterate 方法的第二个参数）。方法运行的结果被添加到流（作为流的下一个元素），并被存储起来，作为下次调用 iterate() 方法时的第一个参数，以此类推。</p>
<h4 id="patternsplitasstream"><a class="header" href="#patternsplitasstream">pattern.splitAsStream</a></h4>
<p>Java 8 在 java.util.regex.Pattern 中增加了一个新的方法 splitAsStream()。这个方法可以根据传入的公式将字符序列转化为流。</p>
<pre><code class="language-java">Pattern.compile(&quot;[ .,?]+&quot;).splitAsStream(str);
</code></pre>
<h3 id="中间操作"><a class="header" href="#中间操作">中间操作</a></h3>
<h4 id="peak"><a class="header" href="#peak">peak</a></h4>
<p>peek() 操作的目的是帮助调试。它允许你无修改地查看流中的元素。</p>
<pre><code class="language-java">Arrays.asList(1,2,3)
                .stream()
                .peek(System.out::println)
                .skip(1)
                .peek(System.out::println)
                .forEach(System.out::println);
</code></pre>
<h4 id="sort"><a class="header" href="#sort">sort</a></h4>
<pre><code class="language-java"> Arrays.asList(1,2,3,6,3,6,8,9,1,0,0)
                .stream()
                .skip(1)
                .sorted(Comparator.reverseOrder())
                .forEach(System.out::println);
</code></pre>
<p>sorted() 预设了一些默认的比较器。这里我们使用的是反转 “自然排序”。当然你也可以把 Lambda 函数作为参数传递给 sorted()。</p>
<pre><code class="language-java">Arrays.asList(1,2,3,6,3,6,8,9,1,0,0)
                .stream()
                .sorted((x, y) -&gt; x - y)
                .forEach(System.out::println);
</code></pre>
<h4 id="distinct"><a class="header" href="#distinct">distinct</a></h4>
<p>相比创建一个 Set 集合来消除重复，该方法的工作量要少得多。</p>
<pre><code class="language-java">Arrays.asList(1,2,3,6,3,6,8,9,1,0,0)
                .stream()
                .sorted((x, y) -&gt; x - y)
                .distinct()
                .forEach(System.out::println);
</code></pre>
<h4 id="filter"><a class="header" href="#filter">filter</a></h4>
<h4 id="map-1"><a class="header" href="#map-1">map</a></h4>
<ul>
<li>map(Function)：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li>
<li>mapToInt(ToIntFunction)：操作同上，但结果是 IntStream。</li>
<li>mapToLong(ToLongFunction)：操作同上，但结果是 LongStream。</li>
<li>mapToDouble(ToDoubleFunction)：操作同上，但结果是 DoubleStream。</li>
</ul>
<h4 id="flatmap"><a class="header" href="#flatmap">flatMap</a></h4>
<p>flatMap 用于将多个 collection 合并成一个 collection。flat: 降维，将二维降为一维，扁平化合并多个流为一个流。</p>
<p>demo:</p>
<pre><code class="language-java">List&lt;String&gt; collection1 = new ArrayList&lt;&gt;(Arrays.asList(&quot;str1&quot;, &quot;str2&quot;));
List&lt;String&gt; collection2 = new ArrayList&lt;&gt;(Arrays.asList(&quot;str3&quot;, &quot;str4&quot;));
List&lt;List&lt;String&gt;&gt; collectionList = Arrays.asList(collection1, collection2);
collectionList
    .stream()
    .flatMap(lst -&gt; lst.stream())
    .collect(Collectors.toList());
// 返回的 list 内容是 [str1, str2, str3, str4]
</code></pre>
<h3 id="终端操作"><a class="header" href="#终端操作">终端操作</a></h3>
<h4 id="数组-2"><a class="header" href="#数组-2">数组</a></h4>
<ul>
<li>toArray()：将流转换成适当类型的数组。</li>
<li>toArray(generator)：在特殊情况下，生成自定义类型的数组。</li>
</ul>
<pre><code class="language-java">int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
</code></pre>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<ul>
<li>forEach(Consumer) 常见如 System.out::println 作为 Consumer 函数。</li>
<li>forEachOrdered(Consumer)：保证 forEach 按照原始流顺序操作。</li>
</ul>
<h4 id="集合-1"><a class="header" href="#集合-1">集合</a></h4>
<ul>
<li>collect(Collector)：使用 Collector 收集流元素到结果集合中。</li>
<li>collect(Supplier, BiConsumer, BiConsumer)：同上，第一个参数 Supplier 创建了一个新的结果集合，第二个参数 BiConsumer 将下一个元素收集到结果集合中，第三个参数 BiConsumer 用于将两个结果集合合并起来。</li>
</ul>
<h4 id="组合"><a class="header" href="#组合">组合</a></h4>
<ul>
<li>reduce(BinaryOperator)：使用 BinaryOperator 来组合所有流中的元素。因为流可能为空，其返回值为 Optional。</li>
<li>reduce(identity, BinaryOperator)：功能同上，但是使用 identity 作为其组合的初始值。因此如果流为空， identity 就是结果。</li>
<li>reduce(identity, BiFunction, BinaryOperator)：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 map()和 reduce() 来更简单的表达它。</li>
</ul>
<h4 id="匹配"><a class="header" href="#匹配">匹配</a></h4>
<ul>
<li>allMatch(Predicate) ：如果流的每个元素提供给 Predicate 都返回 true ，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li>anyMatch(Predicate)：如果流的任意一个元素提供给 Predicate 返回 true ，结果返回为 true。在第一个 true 是停止执行计算。</li>
<li>noneMatch(Predicate)：如果流的每个元素提供给 Predicate 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li>
</ul>
<h4 id="查找"><a class="header" href="#查找">查找</a></h4>
<ul>
<li>findFirst()：返回第一个流元素的 Optional，如果流为空返回 Optional.empty。</li>
<li>findAny(：返回含有任意流元素的 Optional，如果流为空返回 Optional.empty。</li>
</ul>
<h4 id="统计"><a class="header" href="#统计">统计</a></h4>
<p>对象流统计</p>
<ul>
<li>count()：流中的元素个数。</li>
<li>max(Comparator)：根据所传入的 Comparator 所决定的 “最大” 元素。</li>
<li>min(Comparator)：根据所传入的 Comparator 所决定的 “最小” 元素。</li>
</ul>
<p>数字流统计</p>
<ul>
<li>average() ：求取流元素平均值。</li>
<li>max() 和 min()：数值流操作无需 Comparator。</li>
<li>sum()：对所有流元素进行求和。</li>
<li>summaryStatistics()：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</li>
</ul>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<p>为防止流中元素为空，引入 Optional 容器。</p>
<ul>
<li>findFirst() 返回一个包含第一个元素的 Optional 对象，如果流为空则返回 Optional.empty</li>
<li>findAny() 返回包含任意元素的 Optional 对象，如果流为空则返回 Optional.empty</li>
<li>max() 和 min() 返回一个包含最大值或者最小值的 Optional 对象，如果流为空，则返回 Optional.empty</li>
</ul>
<h4 id="创建-optional"><a class="header" href="#创建-optional">创建 Optional</a></h4>
<p>三个静态方法用于创建 Optional：</p>
<ul>
<li>empty()：生成一个空 Optional。</li>
<li>of(value)：将一个非空值包装到 Optional 里。</li>
<li>ofNullable(value)：针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中。</li>
</ul>
<h4 id="ispresent--get"><a class="header" href="#ispresent--get">isPresent()  get()</a></h4>
<h4 id="解包-optional"><a class="header" href="#解包-optional">解包 Optional</a></h4>
<ul>
<li>ifPresent(Consumer)：当值存在时调用 Consumer，否则什么也不做。</li>
<li>orElse(otherObject)：如果值存在则直接返回，否则生成 otherObject。</li>
<li>orElseGet(Supplier)：如果值存在则直接返回，否则使用 Supplier 函数生成一个可替代对象。</li>
<li>orElseThrow(Supplier)：如果值存在直接返回，否则使用 Supplier 函数生成一个异常。</li>
</ul>
<h2 id="-2"><a class="header" href="#-2">==========================================================</a></h2>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>Stream 是用函数式编程方式在集合类上进行复杂操作的工具。</p>
<p>Stream 方法分为惰性求值方法和及早求值方法：</p>
<ul>
<li>惰性求值：仍然返回 Stream 对象的就是惰性求值</li>
<li>及早求值：返回一个值或者为空</li>
</ul>
<p><strong>学好了流，就相当于在 Java 中使用 Pandas，很舒服！</strong></p>
<p><strong>Interface Hierarchy</strong></p>
<pre><code>java.lang.AutoCloseable
    java.util.stream.BaseStream&lt;T,S&gt;
        java.util.stream.DoubleStream
        java.util.stream.IntStream
        java.util.stream.LongStream
        java.util.stream.Stream&lt;T&gt;
</code></pre>
<h2 id="惰性求值方法"><a class="header" href="#惰性求值方法">惰性求值方法</a></h2>
<table><thead><tr><th>方法</th><th>功能</th><th>备注</th></tr></thead><tbody>
<tr><td>map</td><td>将一种类型的值转换成另外一种类型</td><td>Lambda 表达式必须是 Function 接口的一个实例</td></tr>
<tr><td>flatMap</td><td>用于处理元素是集合的集合</td><td>用于映射双层 for 循环</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<h3 id="flatmap-1"><a class="header" href="#flatmap-1">flatMap</a></h3>
<pre><code class="language-java">List&lt;Integer&gt; together = Stream.of(asList(1, 2), asList(3, 4))
    .flatMap(numbers -&gt; numbers.stream())
    .collect(toList());
assertEquals(asList(1, 2, 3, 4), together);
</code></pre>
<h2 id="及早求值方法"><a class="header" href="#及早求值方法">及早求值方法</a></h2>
<table><thead><tr><th>方法</th><th>功能</th><th>备注</th></tr></thead><tbody>
<tr><td>collect</td><td>转为 List / Map</td><td></td></tr>
<tr><td>toArray</td><td>转为 array</td><td></td></tr>
<tr><td>min / max</td><td></td><td></td></tr>
<tr><td>reduce</td><td>count/max/min 都是 reduce 操作</td><td></td></tr>
<tr><td>forEach</td><td></td><td>无返回值</td></tr>
</tbody></table>
<h3 id="collect"><a class="header" href="#collect">collect</a></h3>
<p>Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.</p>
<p><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code></p>
<pre><code>Params: collector – the Collector describing the reduction

Type parameters:
&lt;R&gt; – the type of the result
&lt;A&gt; – the intermediate accumulation type of the Collector

Returns: the result of the reduction

API Note:
	The following will accumulate strings into an ArrayList:
     List&lt;String&gt; asList = stringStream.collect(Collectors.toList());
 
	The following will classify Person objects by city:
     Map&lt;String, List&lt;Person&gt;&gt; peopleByCity 
     		= personStream.collect(Collectors.groupingBy(Person::getCity));
 
	The following will classify Person objects by state and city, cascading two Collectors together:
     Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity
         = personStream.collect(Collectors.groupingBy(Person::getState,
                                                      Collectors.groupingBy(Person::getCity)));

统计List中元素出现的次数
Map&lt;Integer, Long&gt; map = list.stream().collect(Collectors.groupingBy(p -&gt; p,Collectors.counting()));                                                       
</code></pre>
<p>传入一个 Collector 对象，Collector 对象封装了及早求值的规则。Collector 对象由 Collectors 工厂的静态方法生成。</p>
<p>Collectors 提供的静态方法（实际上 Collectors 中提供了各种函数写好的函数）：</p>
<pre><code>Collectors
Collectors
averagingDouble
averagingInt
averagingLong
boxSupplier
castingIdentity
collectingAndThen
computeFinalSum
counting
groupingBy
groupingBy
groupingBy
groupingByConcurrent
groupingByConcurrent
groupingByConcurrent
joining
joining
joining
mapMerger
mapping
maxBy
minBy
partitioningBy
partitioningBy
reducing
reducing
reducing
summarizingDouble
summarizingInt
summarizingLong
summingDouble
summingInt
summingLong
sumWithCompensation
throwingMerger
toCollection
toConcurrentMap
toConcurrentMap
toConcurrentMap
toList
toMap
toMap
toMap
toSet
CH_CONCURRENT_ID
CH_CONCURRENT_NOID
CH_ID
CH_NOID
CH_UNORDERED_ID
CollectorImpl
Partition
</code></pre>
<p>Demo:</p>
<pre><code class="language-java">Set&lt;String&gt; origins = album.getMusicians()
    .filter(artist -&gt; artist.getName().startsWith(&quot;The&quot;))
    .map(artist -&gt; artist.getNationality())
    .collect(Collectors.toSet());
</code></pre>
<pre><code class="language-java">// 找出成员最多的乐队
public Optional&lt;Artist&gt; biggestGroup(Stream&lt;Artist&gt; artists) {
    Function&lt;Artist,Long&gt; getCount = artist -&gt; artist.getMembers().count();
    return artists.collect(Collectors.maxBy(Comparator.comparing(getCount)));
}
</code></pre>
<p>toMap:</p>
<pre><code class="language-java">Map&lt;String, String&gt; nameToIdMap = conceptRepo.findSubConceptsByFid(fid)
                        .stream().collect(Collectors.toMap(Concept::getName, Concept::getId));
// toMap 第一个参数是 key，第二个参数是 value.

Map&lt;String, String&gt; fieldNameToAliasMap = Arrays.stream(fields)
                .filter(field -&gt; field.isAnnotationPresent(org.springframework.data.elasticsearch.annotations.Field.class))
                .filter(field -&gt; StringUtils.isNotEmpty(field.getAnnotation(org.springframework.data.elasticsearch.annotations.Field.class).name()))
                .collect(Collectors.toMap(
                        field -&gt; CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, field.getName()),
                        field -&gt; field.getAnnotation(org.springframework.data.elasticsearch.annotations.Field.class).name(),
                		(v1, v2) -&gt; v2 // 添加 key 重复的策略
                ));
</code></pre>
<h3 id="min--max"><a class="header" href="#min--max">min / max</a></h3>
<pre><code class="language-java">Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);
</code></pre>
<p>Demo：</p>
<pre><code class="language-java">List&lt;Track&gt; tracks = asList(new Track(&quot;Bakai&quot;, 524), 
                            new Track(&quot;Violets for Your Furs&quot;, 378),
                            new Track(&quot;Time Was&quot;, 451));
Track shortestTrack = tracks
    .stream()
    .min(Comparator.comparing(track -&gt; track.getLength()))
    .get();
assertEquals(tracks.get(1), shortestTrack);
</code></pre>
<h3 id="reduce"><a class="header" href="#reduce">reduce</a></h3>
<pre><code class="language-java">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);
</code></pre>
<p>等价于：</p>
<pre><code class="language-java">T result = identity;
for (T element : this stream)
    result = accumulator.apply(result, element)
return result;
</code></pre>
<p>Demo：</p>
<pre><code class="language-java">int count = Stream.of(1, 2, 3)
    .reduce(0, (acc, element) -&gt; acc + element);
assertEquals(6, count);
</code></pre>
<p>等价于：</p>
<pre><code class="language-java">BinaryOperator&lt;Integer&gt; accumulator = (acc, element) -&gt; acc + element;
int count = accumulator.apply(
    accumulator.apply(
        accumulator.apply(0, 1),
        2),
    3);
</code></pre>
<h2 id="intstream"><a class="header" href="#intstream">IntStream</a></h2>
<h3 id="range"><a class="header" href="#range">range</a></h3>
<p>range 是一个静态工厂方法，用于生成一个 IntStream。</p>
<p>代码重构：</p>
<pre><code class="language-java">for (int i = 0; i &lt; 4; i++) {
    System.out.println(i+&quot;...&quot;);
}
// 重构后：
IntStream.range(0,4).forEach(i -&gt; System.out.print(i +&quot;...&quot;));
</code></pre>
<p>Demo：</p>
<pre><code class="language-java">/**
    * 并行打印，看看结果
    * @param
    * @return
    */
public void parallelPrint(){
    IntStream.range(0, 10).parallel().forEach(i -&gt; {
        System.out.println(i);
    });
}
</code></pre>
<pre><code>并行打印的结果
6
5
1
0
2
3
9
7
8
4
</code></pre>
<h2 id="demo-5"><a class="header" href="#demo-5">Demo</a></h2>
<h3 id="函数式重构"><a class="header" href="#函数式重构">函数式重构</a></h3>
<p>原代码：</p>
<pre><code class="language-java">public Set&lt;String&gt; findLongTracks(List&lt;Album&gt; albums) {
    Set&lt;String&gt; trackNames = new HashSet&lt;&gt;();
    for(Album album : albums) {
        for (Track track : album.getTrackList()) {
            if (track.getLength() &gt; 60) {
                String name = track.getName();
                trackNames.add(name);
            }
        }
    } 
    return trackNames;
}
</code></pre>
<p>函数式重构：</p>
<pre><code class="language-java">public Set&lt;String&gt; findLongTracks(List&lt;Album&gt; albums) {
    Set&lt;String&gt; trackNames = new HashSet&lt;&gt;();
    albums.stream().forEach(album -&gt; {
        album.getTrackList.stream()
            .filter(track -&gt; track.getLength() &gt; 60)
            .map(track -&gt; track.getName())
            .forEach(name -&gt; trackNames.add(name));
    });
    return trackNames;
}
</code></pre>
<p>函数式重构 - 优化：</p>
<pre><code class="language-java">public Set&lt;String&gt; findLongTracks(List&lt;Album&gt; albums) {
    return albums.stream()
        .flatMap(album -&gt; album.getTrackList().stream())
        .filter(track -&gt; track.getLength() &gt; 60)
        .map(track -&gt; track.getName())
        .collect(Collectors.toSet());
}
</code></pre>
<h3 id="求交集差集"><a class="header" href="#求交集差集">求交集，差集</a></h3>
<pre><code class="language-java">List list=list1.stream().filter(t-&gt;list2.contains(t)).collect(Collectors.toList());

list=list1.stream().filter(t-&gt; !list2.contains(t)).collect(Collectors.toList());

list=list.stream().distinct().collect(Collectors.toList());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<p>[TOC]</p>
<h2 id="函数式编程-1"><a class="header" href="#函数式编程-1">函数式编程</a></h2>
<p>面向对象编程是对数据进行抽象， 而函数式编程是对行为进行抽象。</p>
<h2 id="on-java-函数式编程"><a class="header" href="#on-java-函数式编程">on java 函数式编程</a></h2>
<pre><code class="language-java">interface Strategy {
    String approach(String msg); // 函数签名，是传入一个 String，返回一个 String
}

Strategy[] strategies = {
    // 分别是函数式接口(匿名类)，lambda表达式，函数引用，三者等价
    new Strategy() { // [2]
        public String approach(String msg) {
            return msg.toUpperCase() + &quot;!&quot;;
        }
    },
    msg -&gt; msg.substring(0, 5), // [3] 确实是传入一个 String，返回一个 String，没毛病
    Unrelated::twice // [4]
};
</code></pre>
<p><strong>函数签名：参数类型和返回值类型。签名才是一个函数的特征，叫甚么不重要！lambda 表达式甚至不起函数名了，只有输入和输出。</strong></p>
<pre><code class="language-java">class Go {
    static void go() {
        System.out.println(&quot;Go::go()&quot;);
    }
}
public class RunnableMethodReference {
    public static void main(String[] args) {
        // 三者等价
        new Thread(new Runnable() {
            public void run() { // 函数签名：没有传参，没有返回值
                System.out.println(&quot;Anonymous&quot;);
            }
        }).start();
        new Thread(
            () -&gt; System.out.println(&quot;lambda&quot;)
        ).start();
        new Thread(Go::go).start();
    }
}
</code></pre>
<p>java8 允许我们将函数赋值给函数式接口</p>
<pre><code class="language-java">@FunctionalInterface
interface Functional {
    String goodbye(String arg);
}

public class FunctionalAnnotation {
    public String hehe(String arg) {
        return &quot;Goodbye, &quot; + arg;
    }
    public static void main(String[] args) {
        FunctionalAnnotation fa =
            new FunctionalAnnotation();
        Functional f = fa::hehe; // 将函数赋值给函数式接口
        Functional fl = a -&gt; &quot;Goodbye, &quot; + a; // 将函数赋值给函数式接口
    }
}
</code></pre>
<h3 id="lambda-表达式"><a class="header" href="#lambda-表达式">lambda 表达式</a></h3>
<p>lambda 表达式就是一个函数，Java8 引入了函数式编程，意在将函数提升为第一公民，函数也可以当作变量进行赋值。</p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208091948344.png" alt="image-20211208091948344" /></p>
<p>以上的过程，优雅的把「一块代码」赋给了一个变量。<strong>而「这块代码」，或者说「这个被赋给一个变量的函数」，就是一个 Lambda 表达式</strong>。</p>
<p>blockOfCode 的类型是什么呢？要用什么类型来接住 lambda 表达式呢？这就引出了函数式接口。Java8 规定，lambda 表达式的类型，是一个函数式接口。<strong>lambda 表达式本身是一个函数式接口的实现</strong>。</p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208092333873.png" alt="image-20211208092333873" /></p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208092339828.png" alt="image-20211208092339828" /></p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208092345615.png" alt="image-20211208092345615" /></p>
<p>lambda 表达式本身，是对一个函数式接口的实现：</p>
<p><img src="computer-science-notebook/note-for-java/assets/image-20211208092448575.png" alt="image-20211208092448575" /></p>
<h3 id="方法引用"><a class="header" href="#方法引用">方法引用</a></h3>
<p>类名或对象名::方法名</p>
<p>有以下四种形式的方法引用：</p>
<ul>
<li>引用静态方法: <code>ContainingClass::staticMethodName</code></li>
<li>引用某个对象的实例方法: <code>containingObject::instanceMethodName</code></li>
<li>引用某个类型的任意对象的实例方法: <code>ContainingType::methodName</code></li>
<li>引用构造方法: <code>ClassName::new</code></li>
</ul>
<p>Demo:</p>
<pre><code class="language-java">public class Person {

    String name;

    LocalDate birthday;

    public Person(String name, LocalDate birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public LocalDate getBirthday() {
        return birthday;
    }

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }

    @Override
    public String toString() {
        return this.name;
    }
}
</code></pre>
<pre><code class="language-java">public class MethodReferenceTest {

    @Test
    public static void main() {
        Person[] pArr = new Person[] {
            new Person(&quot;003&quot;, LocalDate.of(2016,9,1)),
            new Person(&quot;001&quot;, LocalDate.of(2016,2,1)),
            new Person(&quot;002&quot;, LocalDate.of(2016,3,1)),
            new Person(&quot;004&quot;, LocalDate.of(2016,12,1))
        };

        // 使用匿名类
        Arrays.sort(pArr, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person a, Person b) {
                return a.getBirthday().compareTo(b.getBirthday());
            }
        });

        //使用lambda表达式
        Arrays.sort(pArr, (Person a, Person b) -&gt; {
            return a.getBirthday().compareTo(b.getBirthday());
        });

        //使用方法引用，引用的是类的静态方法
        Arrays.sort(pArr, Person::compareByAge);
    }
}
</code></pre>
<h3 id="函数式接口"><a class="header" href="#函数式接口">函数式接口</a></h3>
<p><code>java.util.function</code> 包旨在创建一组完整的函数式接口，使得我们一般情况下不需再定义自己的接口。</p>
<p>函数式接口其实都大同小异，接口的名字才是关键，要做到看到接口的名字，就了解这个接口的作用。</p>
<p>函数式接口的命名规则：</p>
<ol>
<li>如果只处理对象而非基本类型，名称则为 Function， Consumer， Predicate 等。参数类型通过泛型添加。</li>
<li>如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction， IntPredicate 等，但返回基本类型的 Supplier 接口例外。</li>
<li>如果返回值为基本类型，则用 To 表示，如 ToLongFunction <T> 和 IntToLongFunction。</li>
<li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。</li>
<li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li>
<li>如果接收的两个参数类型不同，则名称中有一个 Bi。</li>
</ol>
<table><thead><tr><th>函数式接口</th><th>方法</th><th>返回值类型</th><th>备注</th></tr></thead><tbody>
<tr><td>Predicate<T></td><td>test(T)</td><td>boolean</td><td>断言</td></tr>
<tr><td>Consumer<T></td><td>accept(T)</td><td>void</td><td>只吃不吐</td></tr>
<tr><td>Function&lt;T, R&gt;</td><td>apply(T)</td><td>R</td><td>输入 T，输出 R</td></tr>
<tr><td>BinaryOperator<T></td><td>apply(T, T)</td><td>T</td><td>双飞</td></tr>
<tr><td>Supplier<T></td><td>get()</td><td>T</td><td>只吐不吃</td></tr>
</tbody></table>
<pre><code class="language-java">import java.util.function.*;

class In1 {}
class In2 {}

public class MethodConversion {
    static void accept(In1 i1, In2 i2) {
        System.out.println(&quot;accept()&quot;);
    }
    static void someOtherName(In1 i1, In2 i2) {
        System.out.println(&quot;someOtherName()&quot;);
    }
    public static void main(String[] args) {
        BiConsumer&lt;In1,In2&gt; bic;
        bic = MethodConversion::accept;
        bic.accept(new In1(), new In2());
        bic = MethodConversion::someOtherName; // 只要函数签名一致，就可以将函数赋值给函数式接口！
        // bic.someOtherName(new In1(), new In2()); // Nope
        bic.accept(new In1(), new In2());
    }
}
</code></pre>
<pre><code class="language-java">import java.util.*;
import java.util.function.*;

class AA {}
class BB {}
class CC {}

public class ClassFunctionals {
    static AA f1() { return new AA(); }
    static int f2(AA aa1, AA aa2) { return 1; }
    static void f3(AA aa) {}
    static void f4(AA aa, BB bb) {}
    static CC f5(AA aa) { return new CC(); }
    static CC f6(AA aa, BB bb) { return new CC(); }
    static boolean f7(AA aa) { return true; }
    static boolean f8(AA aa, BB bb) { return true; }
    static AA f9(AA aa) { return new AA(); }
    static AA f10(AA aa1, AA aa2) { return new AA(); }
    public static void main(String[] args) {
        Supplier&lt;AA&gt; s = ClassFunctionals::f1;
        s.get();
        Comparator&lt;AA&gt; c = ClassFunctionals::f2;
        c.compare(new AA(), new AA());
        Consumer&lt;AA&gt; cons = ClassFunctionals::f3;
        cons.accept(new AA());
        BiConsumer&lt;AA,BB&gt; bicons = ClassFunctionals::f4;
        bicons.accept(new AA(), new BB());
        Function&lt;AA,CC&gt; f = ClassFunctionals::f5;
        CC cc = f.apply(new AA());
        BiFunction&lt;AA,BB,CC&gt; bif = ClassFunctionals::f6;
        cc = bif.apply(new AA(), new BB());
        Predicate&lt;AA&gt; p = ClassFunctionals::f7;
        boolean result = p.test(new AA());
        BiPredicate&lt;AA,BB&gt; bip = ClassFunctionals::f8;
        result = bip.test(new AA(), new BB());
        UnaryOperator&lt;AA&gt; uo = ClassFunctionals::f9;
        AA aa = uo.apply(new AA());
        BinaryOperator&lt;AA&gt; bo = ClassFunctionals::f10;
        aa = bo.apply(new AA(), new AA());
    }
}
</code></pre>
<h3 id="高阶函数"><a class="header" href="#高阶函数">高阶函数</a></h3>
<pre><code class="language-java">default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
    Objects.requireNonNull(after);
    return (T t) -&gt; after.apply(apply(t)); // 注意，这里是，after.apply(this.apply(t))
}
</code></pre>
<h3 id="函数组合"><a class="header" href="#函数组合">函数组合</a></h3>
<p>函数组合（Function Composition）意为 “多个函数组合成新函数”。它通常是函数式编程的基本组成部分。</p>
<table><thead><tr><th>默认方法</th><th>作用</th><th></th></tr></thead><tbody>
<tr><td>function1.andThen(function2)</td><td>生成一个新函数，执行完 function1 再执行  function2</td><td></td></tr>
<tr><td>function1.compose(function2)</td><td>生成一个新函数，先执行 f2，再执行 f1</td><td></td></tr>
<tr><td>function1.and(function2)</td><td>生成一个新函数，<code>function1(x) &amp;&amp; function2(x)</code></td><td></td></tr>
<tr><td>function1.or(function2)</td><td>生成一个新函数，`function1(x)</td><td></td></tr>
<tr><td>function.negate()</td><td>生成一个新函数，<code>!function(x)</code></td><td></td></tr>
</tbody></table>
<pre><code class="language-java">import java.util.function.*;
public class FunctionComposition {
    static Function&lt;String, String&gt;
        f1 = s -&gt; {
        System.out.println(s);
        return s.replace('A', '_');
    },
    f2 = s -&gt; s.substring(3),
    f3 = s -&gt; s.toLowerCase(),
    f4 = f1.compose(f2).andThen(f3);
    public static void main(String[] args) {
        System.out.println(
            f4.apply(&quot;GO AFTER ALL AMBULANCES&quot;));
    }
}

//AFTER ALL AMBULANCES
//_fter _ll _mbul_nces
</code></pre>
<pre><code class="language-java">import java.util.function.*;
import java.util.stream.*;

public class PredicateComposition {
    static Predicate&lt;String&gt;
        p1 = s -&gt; s.contains(&quot;bar&quot;),
    p2 = s -&gt; s.length() &lt; 5,
    p3 = s -&gt; s.contains(&quot;foo&quot;),
    p4 = p1.negate().and(p2).or(p3);
    
    public static void main(String[] args) {
        Stream.of(&quot;bar&quot;, &quot;foobar&quot;, &quot;foobaz&quot;, &quot;fongopuckey&quot;)
            .filter(p4)
            .forEach(System.out::println);
    }
}
</code></pre>
<h2 id="一篇教程"><a class="header" href="#一篇教程">一篇教程</a></h2>
<p>https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/</p>
<h3 id="how-streams-work"><a class="header" href="#how-streams-work">How streams work</a></h3>
<p>A stream represents a sequence of elements and supports different kind of operations to perform computations upon those elements:</p>
<pre><code class="language-java">List&lt;String&gt; myList =
    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);

myList
    .stream()
    .filter(s -&gt; s.startsWith(&quot;c&quot;))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);

// C1
// C2
</code></pre>
<p>Stream operations are either intermediate or terminal. Intermediate operations return a stream so we can chain multiple intermediate operations without using semicolons. Terminal operations are either void or return a non-stream result. In the above example <code>filter</code>, <code>map</code> and <code>sorted</code> are intermediate operations whereas <code>forEach</code> is a terminal operation. For a full list of all available stream operations see the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream Javadoc</a>. Such a chain of stream operations as seen in the example above is also known as <em>operation pipeline</em>.</p>
<p>Most stream operations accept some kind of lambda expression parameter, a functional interface specifying the exact behavior of the operation. Most of those operations must be both <em>non-interfering</em> and <em>stateless</em>. What does that mean?</p>
<p>A function is <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">non-interfering</a> when it does not modify the underlying data source of the stream, e.g. in the above example no lambda expression does modify <code>myList</code> by adding or removing elements from the collection.</p>
<p>A function is <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Statelessness">stateless</a> when the execution of the operation is deterministic, e.g. in the above example no lambda expression depends on any mutable variables or states from the outer scope which might change during execution.</p>
<h3 id="different-kind-of-streams"><a class="header" href="#different-kind-of-streams">Different kind of streams</a></h3>
<p>如何生成 Stream？</p>
<p>Streams can be created from various data sources, especially collections. Lists and Sets support new methods <code>stream()</code> and <code>parallelStream()</code> to either create a sequential or a parallel stream. Parallel streams are capable of operating on multiple threads and will be covered in a later section of this tutorial. We focus on sequential streams for now:</p>
<pre><code class="language-java">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)
    .stream()
    .findFirst()
    .ifPresent(System.out::println);  // a1
</code></pre>
<p>Calling the method <code>stream()</code> on a list of objects returns a regular object stream. But we don't have to create collections in order to work with streams as we see in the next code sample:</p>
<pre><code class="language-java">Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)
    .findFirst()
    .ifPresent(System.out::println);  // a1
</code></pre>
<p>Just use <code>Stream.of()</code> to create a stream from a bunch of object references.</p>
<p>Besides regular object streams Java 8 ships with special kinds of streams for working with the primitive data types <code>int</code>, <code>long</code> and <code>double</code>. As you might have guessed it's <code>IntStream</code>, <code>LongStream</code> and <code>DoubleStream</code>.</p>
<p>IntStreams can replace the regular for-loop utilizing <code>IntStream.range()</code>:</p>
<pre><code class="language-java">IntStream.range(1, 4)
    .forEach(System.out::println);

// 1
// 2
// 3
</code></pre>
<p>All those primitive streams work just like regular object streams with the following differences: Primitive streams use specialized lambda expressions, e.g. <code>IntFunction</code> instead of <code>Function</code> or <code>IntPredicate</code> instead of <code>Predicate</code>. And primitive streams support the additional terminal aggregate operations <code>sum()</code> and <code>average()</code>:</p>
<pre><code class="language-java">Arrays.stream(new int[] {1, 2, 3})
    .map(n -&gt; 2 * n + 1)
    .average()
    .ifPresent(System.out::println);  // 5.0
</code></pre>
<p>Sometimes it's useful to transform a regular object stream to a primitive stream or vice versa. For that purpose object streams support the special mapping operations <code>mapToInt()</code>, <code>mapToLong()</code> and <code>mapToDouble</code>:</p>
<pre><code class="language-java">Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;)
    .map(s -&gt; s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println);  // 3
</code></pre>
<p>Primitive streams can be transformed to object streams via <code>mapToObj()</code>:</p>
<pre><code class="language-java">IntStream.range(1, 4)
    .mapToObj(i -&gt; &quot;a&quot; + i)
    .forEach(System.out::println);

// a1
// a2
// a3
</code></pre>
<p>Here's a combined example: the stream of doubles is first mapped to an int stream and than mapped to an object stream of strings:</p>
<pre><code class="language-java">Stream.of(1.0, 2.0, 3.0)
    .mapToInt(Double::intValue)
    .mapToObj(i -&gt; &quot;a&quot; + i)
    .forEach(System.out::println);

// a1
// a2
// a3
</code></pre>
<h3 id="processing-order"><a class="header" href="#processing-order">Processing Order</a></h3>
<p>Stream 为什么效率高，什么样的组合才是效率最高的？原则：先 filter 再 map！</p>
<p>Now that we've learned how to create and work with different kinds of streams, let's dive deeper into how stream operations are processed under the hood.</p>
<p>An important characteristic of intermediate operations is laziness. Look at this sample where a terminal operation is missing:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return true;
    });
</code></pre>
<p>When executing this code snippet, nothing is printed to the console. That is because intermediate operations will only be executed when a terminal operation is present.</p>
<p>Let's extend the above example by the terminal operation <code>forEach</code>:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return true;
    })
    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));
</code></pre>
<p>Executing this code snippet results in the desired output on the console:</p>
<pre><code class="language-java">filter:  d2
forEach: d2
filter:  a2
forEach: a2
filter:  b1
forEach: b1
filter:  b3
forEach: b3
filter:  c
forEach: c
</code></pre>
<p>The order of the result might be surprising. A naive approach would be to execute the operations horizontally one after another on all elements of the stream. But instead each element moves along the chain vertically. The first string &quot;d2&quot; passes <code>filter</code> then <code>forEach</code>, only then the second string &quot;a2&quot; is processed.</p>
<p>This behavior can reduce the actual number of operations performed on each element, as we see in the next example:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .map(s -&gt; {
        System.out.println(&quot;map: &quot; + s);
        return s.toUpperCase();
    })
    .anyMatch(s -&gt; {
        System.out.println(&quot;anyMatch: &quot; + s);
        return s.startsWith(&quot;A&quot;);
    });

// map:      d2
// anyMatch: D2
// map:      a2
// anyMatch: A2
</code></pre>
<p>The operation <code>anyMatch</code> returns <code>true</code> as soon as the predicate applies to the given input element. This is true for the second element passed &quot;A2&quot;. Due to the vertical execution of the stream chain, <code>map</code> has only to be executed twice in this case. So instead of mapping all elements of the stream, <code>map</code> will be called as few as possible.</p>
<p><strong>Why order matters？</strong></p>
<p>The next example consists of two intermediate operations <code>map</code> and <code>filter</code> and the terminal operation <code>forEach</code>. Let's once again inspect how those operations are being executed:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .map(s -&gt; {
        System.out.println(&quot;map: &quot; + s);
        return s.toUpperCase();
    })
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return s.startsWith(&quot;A&quot;);
    })
    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

// map:     d2
// filter:  D2
// map:     a2
// filter:  A2
// forEach: A2
// map:     b1
// filter:  B1
// map:     b3
// filter:  B3
// map:     c
// filter:  C
</code></pre>
<p>As you might have guessed both <code>map</code> and <code>filter</code> are called five times for every string in the underlying collection whereas <code>forEach</code> is only called once.</p>
<p>We can greatly reduce the actual number of executions if we change the order of the operations, moving <code>filter</code> to the beginning of the chain:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return s.startsWith(&quot;a&quot;);
    })
    .map(s -&gt; {
        System.out.println(&quot;map: &quot; + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

// filter:  d2
// filter:  a2
// map:     a2
// forEach: A2
// filter:  b1
// filter:  b3
// filter:  c
</code></pre>
<p>Now, <code>map</code> is only called once so the operation pipeline performs much faster for larger numbers of input elements. Keep that in mind when composing complex method chains.</p>
<p>Let's extend the above example by an additional operation, <code>sorted</code>:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .sorted((s1, s2) -&gt; {
        System.out.printf(&quot;sort: %s; %s\n&quot;, s1, s2);
        return s1.compareTo(s2);
    })
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return s.startsWith(&quot;a&quot;);
    })
    .map(s -&gt; {
        System.out.println(&quot;map: &quot; + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));
</code></pre>
<p>Sorting is a special kind of intermediate operation. It's a so called <em>stateful operation</em> since in order to sort a collection of elements you have to maintain state during ordering.</p>
<p>Executing this example results in the following console output:</p>
<pre><code>sort:    a2; d2
sort:    b1; a2
sort:    b1; d2
sort:    b1; a2
sort:    b3; b1
sort:    b3; d2
sort:    c; b3
sort:    c; d2
filter:  a2
map:     a2
forEach: A2
filter:  b1
filter:  b3
filter:  c
filter:  d2
</code></pre>
<p>First, the sort operation is executed on the entire input collection. In other words <code>sorted</code> is executed horizontally. So in this case <code>sorted</code> is called eight times for multiple combinations on every element in the input collection.</p>
<p>Once again we can optimize the performance by reordering the chain:</p>
<pre><code class="language-java">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
    .filter(s -&gt; {
        System.out.println(&quot;filter: &quot; + s);
        return s.startsWith(&quot;a&quot;);
    })
    .sorted((s1, s2) -&gt; {
        System.out.printf(&quot;sort: %s; %s\n&quot;, s1, s2);
        return s1.compareTo(s2);
    })
    .map(s -&gt; {
        System.out.println(&quot;map: &quot; + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

// filter:  d2
// filter:  a2
// filter:  b1
// filter:  b3
// filter:  c
// map:     a2
// forEach: A2
</code></pre>
<p>In this example <code>sorted</code> is never been called because <code>filter</code> reduces the input collection to just one element. So the performance is greatly increased for larger input collections.</p>
<h3 id="reusing-streams"><a class="header" href="#reusing-streams">Reusing Streams</a></h3>
<p>Stream 复用。</p>
<p>Java 8 streams cannot be reused. As soon as you call any terminal operation the stream is closed:</p>
<pre><code class="language-java">Stream&lt;String&gt; stream =
    Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
        .filter(s -&gt; s.startsWith(&quot;a&quot;));

stream.anyMatch(s -&gt; true);    // ok
stream.noneMatch(s -&gt; true);   // exception
</code></pre>
<p>Calling <code>noneMatch</code> after <code>anyMatch</code> on the same stream results in the following exception:</p>
<pre><code class="language-java">java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
    at com.winterbe.java8.Streams5.test7(Streams5.java:38)
    at com.winterbe.java8.Streams5.main(Streams5.java:28)
</code></pre>
<p>To overcome this limitation we have to to create a new stream chain for every terminal operation we want to execute, e.g. we could create a stream supplier to construct a new stream with all intermediate operations already set up:</p>
<pre><code class="language-java">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =
    () -&gt; Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)
            .filter(s -&gt; s.startsWith(&quot;a&quot;));

streamSupplier.get().anyMatch(s -&gt; true);   // ok
streamSupplier.get().noneMatch(s -&gt; true);  // ok
</code></pre>
<p>Each call to <code>get()</code> constructs a new stream on which we are save to call the desired terminal operation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-程序开发-抽象规格与面向对象设计"><a class="header" href="#java-程序开发-抽象规格与面向对象设计">Java 程序开发 抽象、规格与面向对象设计</a></h1>
<p>[TOC]</p>
<p>这本书教我们如何编程，将编程理论化，如果做架构设计。</p>
<h2 id="第一章-概述"><a class="header" href="#第一章-概述">第一章 概述</a></h2>
<ul>
<li>程序应该本着让人理解的原则来构建。（可读性）</li>
<li>分解（decomposition）和抽象（abstraction）是本书的两个核心概念</li>
</ul>
<h3 id="分解和抽象"><a class="header" href="#分解和抽象">分解和抽象</a></h3>
<p>当分解一个问题时，我们遵循一下的原则将其分解成几个可以再分的子问题：</p>
<ul>
<li>每个子问题在细节上处于相同的级别</li>
<li>每个子问题能够独立解决</li>
<li>每个子问题的解决方法综合起来能够解决原来的问题。</li>
</ul>
<p>通过改变问题所涉及的细节等级，抽象可以有效地处理分解的问题。当我们对一个问题进行抽象时，为了简化问题，需要忽略某些细节。例如，我们可能要将剧本的问题抽象为决定这个剧本中有几幕，或者是什么剧情，甚至抽象为每组对话的意思（但不是具体措辞）。完成这些事情以后，似乎最初的问题（即写出剧本中的所有对话）还是没有解决。但是，它已经大大简化了，甚至可以简化到在何处可以从一个要点转到另一个或几个要点。</p>
<h3 id="抽象"><a class="header" href="#抽象">抽象</a></h3>
<p>抽象主要是希望通过将相关的属性和其他不想关的属性分开，以简化分析过程。</p>
<p>抽象关注共有的特征。</p>
<p>两种抽象</p>
<ul>
<li>
<p>参数化抽象 abstraction by parameterization</p>
<p>用参数替换数据特征来进行抽象，这样能归纳出模块，使其可以用于更多的情况。</p>
</li>
<li>
<p>规格化抽象 abstraction by specification</p>
<p>将执行细节（即模块如何实现）抽象为用户所需求的行为（即模块做什么）。这是从具体实现中抽象出模块。</p>
</li>
</ul>
<p>在规格抽象中，我们关注的是用户所关心的行为，而不是实现行为的细节。规格抽象的关键优势在于，能让我们改变一种实现而不改变任何使用抽象描述的程序的含义（规格抽象就是接口）。例如，我们能够改变用来实现 isPrime 过程的算法，但是 isPrime 对外提供的功能是不变的。</p>
<p>每当要将一个过程与一个注释（这个注释提供了充分的信息，使其他人不用看过程主题就可以使用该过程）关联起来时，我们就会使用规格化抽象。写这种注释的一个好方法是用成对的断言（assertion）注释。一个过程中的 requires 断言（requires assertion）[或者说前置条件(precondition)] 是过程执行前指定一个假定成立的对象。在实践中，最常用到的断言是一组足以确保过程能正确操作的条件。（这也通常成为无实质断言，成立标志为 “TRUE”）。effects 断言（effects assertion）[或者叫后置条件(postcondition)] 是在满足前置条件的过程运行完毕后，指定一个假定成立的结果。</p>
<p>例如如下程序，因为已经提供了响应的规格，所以我们能够忽略过程主题，并且将过程调用 y = sqrt(x) 的意思理解为「过程调用时，如果参数大于 0，则在过程执行完毕后 y 就是 x 平方根的近似值」。</p>
<pre><code class="language-java">float sqrt(float coef){
  //requires: coef &gt; 0
  //effects: return a approximation to the square root of coef
  float ans = coef / 2.0;
  int i = 1;
  while(i &lt; 7){
    ans = ans - ((ans * ans - coef) / (2.0 * ans));
    i = i + 1;
  }
  return ans;
}
</code></pre>
<p>抽象的种类：</p>
<ul>
<li>过程抽象：对过程进行抽象（引入新的方法）</li>
<li>数据抽象：状态 + 行为（引入新的数据类型）</li>
<li>迭代抽象：能够迭代遍历在集合中的元素，而不需要显示如何获取元素的细节</li>
</ul>
<p>数据抽象是重点，是面向对象程序设计的基础。</p>
<h2 id="第二章-理解-java-中的对象"><a class="header" href="#第二章-理解-java-中的对象">第二章 理解 Java 中的对象</a></h2>
<p>对象中封装的成员变量，准确的来说，应该叫状态，而方法，是用来修改和获取状态的操作。</p>
<p>对于方法来说，异常也是一种返回结果！</p>
<p>方法的签名：入参和返回值（包括异常）。(函数真正叫什么其实不重要，参考 lambda 表达式。)</p>
<p>Java 是强类型语言，Java 编译器会检查代码，确保每个赋值和调用都是类型正确的。</p>
<p>int 和 float 可以损失精度赋值给 long 类型，但是不能反向提升精度。</p>
<h2 id="第三章-过程抽象"><a class="header" href="#第三章-过程抽象">第三章 过程抽象</a></h2>
<p>过程抽象组合了参数抽象和规格抽象，是输入到输出的映射。（过程就是接口）</p>
<h3 id="过程的规格"><a class="header" href="#过程的规格">过程的规格</a></h3>
<p>规格是抽象的唯一记录。</p>
<p>接口的定义。</p>
<p>一个接口的规格，除了接口名、输入和输出（异常）外，还可能有以下三点：</p>
<ul>
<li>requires: 使用该接口的前提条件（入参的条件），例如 binarySearch() 方法要求入参必须已经排好序</li>
<li>modifies: 描述了哪些入参（包含隐式输入）被修改了</li>
<li>effects: 程序运行的结果</li>
</ul>
<p>Arrays 中的 sort 和 search 方法是全局的(total)，因为其规格并不包含 requires 要求。而 binarySearch 是局部的（partial），只在参数数组已经排序的情况下才能工作。应该尽量避免规格中包含 requires 条件。</p>
<p>requires 是前置条件，前置条件是和调用方（客户端）的约定，如果可能，应该检查这个 requires 格式是否满足。</p>
<h3 id="过程的实现"><a class="header" href="#过程的实现">过程的实现</a></h3>
<p>接口的实现</p>
<p>过程的实现应产生由过程的规格所定义的行为。特别是，过程的实现必须只对出现在 modifies 格式中的那些输入进行修改；如果所有输入都满足 requires 格式，则必须得出与 effects 格式一致的结果。</p>
<p>例如用 Java 语言实现的线性查找方法 searchSorted()，当传入的参数数组为 null 的时候，实现 searchSorted 会返回 -1。这个行为与在规格中描述的行为是一致的。然而，更好的规格可能会对这个情况进行特殊处理，会指示必须抛出一个异常。</p>
<h3 id="设计过程抽象"><a class="header" href="#设计过程抽象">设计过程抽象</a></h3>
<p>过程（接口）可能包含有如下属性：</p>
<ul>
<li>未确定性：Arrays.search() 就是未确定的，数组中可能包含有多个要查找的元素，不同的算法实现会返回不同的值</li>
<li>一般性：如果一个规格能够处理比较大的一类输入，则这个规格就比另一个规格更有一般性</li>
</ul>
<p>过程（接口）的另一个重要属性是简单性。过程应该要有一个明确定义并且易于解释的名字，如果要想出这样一个名称很困难，则这个过程可能就有问题了。</p>
<p>如果检查显示 requires 格式没有满足，则过程可以产生一个错误提示消息。但更好的方法通常是抛出一个异常。</p>
<p>接口可以分成两类：局部的（partial）和全局的（total）。对外暴露的接口，最好是全局的（没有 requires 约束），私有方法可以用局部约束。</p>
<p>全局过程和局部过程：</p>
<ul>
<li>如果一个过程的行为对所有合法输入都是合适的，则这个过程就是全局的；否则，这个过程就是局部的。一个局部过程的规格总是包含一个 requires 格式。</li>
<li>局部过程比全局过程更不安全。因此，它们应该只在使用环境是有限时或者能带来重要好处时才能使用。</li>
<li>可能的时候，编程时应该检查 requires 格式中的约束条件。并且，如果这些约束条件不能满足就抛出一个异常。</li>
</ul>
<h2 id="第四章-异常"><a class="header" href="#第四章-异常">第四章 异常</a></h2>
<h3 id="exception-存在的意义-1"><a class="header" href="#exception-存在的意义-1">exception 存在的意义</a></h3>
<p>异常也是一种返回值！异常将业务代码和异常处理代码解耦。</p>
<p>以下的内容，取自程序开发原理：</p>
<p>过程（接口）抽象是从自变量到结果的映射，可能会有一些对自变量的修改。自变量属于过程的定义域（domain），结果属于过程的值域（range）。只有当自变量从属于过程的定义域的子集时，这个过程才是有意义的。例如，只有当其自变量是正数时计算阶乘的过程才有意义。再例如，只有当元素出现在数组中时，查找（search）过程才返回元素的索引。</p>
<p>处理这种情况的方法之一是使用局部过程（partial procedures），例如，只有当 gcd 的自变量是正数时，才可以进行定义：</p>
<pre><code class="language-java">public static int gcd(int n, int d){
  // requires: n, d &gt; 0
  // effects: return the greatest common divisor of n and d
}
</code></pre>
<p>局部过程的调用者必须明确自变量属于定义域的子集，而实现者可以忽略这个子集之外的自变量。这样，在实现 gcd 的过程中，就可以忽略非正数自变量的情况了。</p>
<p>然而，一般来说，使用局部过程并不是什么好的解决方法，因为我们不能保证调用者一定不会传入 &lt; 0 的值。局部过程不能保证程序的鲁棒性。一个稳健的程序，即使发生错误，也应该继续合理的变现出错误。如果发生错误，程序无法像无错误时一样表现，则必须以一个明确定义的方式表现。</p>
<p>增强稳健性的方法是使用全过程（total procedures）：就是指为所有定义域内的输入都定义行为的过程。如果过程不能为其中某些输入执行其预期功能，则至少能够通知调用者。这样会引起调用者的注意，从而采取措施。</p>
<p>如果一个问题产生了，如何才能使调用者注意到它呢？一种可能，是使用特殊结果来传达这个信息。例如，如果计算阶乘过程的自变量不是正数，则会返回零：</p>
<pre><code class="language-java">public static int fact(int n)
  // effects: if n &gt; 0 return n! else return 0
</code></pre>
<p>这个解决方法其实并不大行，因为带有非法自变量的调用本身就是一个错误，如果用一个特殊的方法来处理这个情况就更好了。这样，使用这个接口的程序员就不太可能出错而忽略这个错误了。返回一个特殊值也可能给调用代码带来不便，返回了特殊值后，就必须再检查一下这个调用代码的结果，例如：</p>
<pre><code class="language-java">// 原来的代码
z = x + Num.fact(y);
// 优化后的代码
int r = Num.fact(y);
if(r &gt; 0) z = x + r; else ...
</code></pre>
<p>另外，如果返回类型的每个值都是过程的一个可能的结果，则这种返回一个特殊结果的解决方法就是不可能的，因为没有剩余值可以使用了。例如，向量 vector 的 get 方法返回向量的第 i 个元素的值，这个值可以是任何一个对象或者是 null。所以我们无法通过返回一个特殊对象或者返回 null 来传达有关越界的索引信息。</p>
<p>我们需要的是一种即时在返回类型的每个值都是合法结果时也能传达所有情况中有关不寻常信息的途径。而且，这个途径最好能够以某种方法区别哪些情况，这样用户就不会因为出错而忽略了它们。如果这个途径能使对这些情况的处理与其他正常的程序控制流分开进行（将业务代码和异常处理代码解耦），则是最佳的。</p>
<p>异常机制机制提供了我们所需要的，允许过程通过返回一个结果而正常终止或者异常终止！</p>
<h3 id="checked-exception-vs-runtime-exception-1"><a class="header" href="#checked-exception-vs-runtime-exception-1">checked exception vs runtime exception</a></h3>
<blockquote>
<p>对可恢复的情况使用受检异常，对编程错误使用运行时异常。—— Effective Java</p>
</blockquote>
<p>checked exception（受检异常） 继承自 Exception，unchecked exception（运行时异常，不可控异常） 继承自 RuntimeException。Exception 和 RuntimeException 都实现了 throwable 接口。</p>
<p>checked exception 必须被 try 或者抛出，unchecked exception 是隐藏的异常。</p>
<p>什么时候使用受检异常，什么时候使用运行时异常？如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。</p>
<pre><code class="language-java">try{
    String userInput = //read in user input
    Long id = Long.parseLong(userInput);
}catch(NumberFormatException e){
    id = 0; //recover the situation by setting the id to 0
}
</code></pre>
<p>用运行时异常来表明编程错误（调用接口的方式错误！）。大多数运行时异常都表示前提违例（precondition violation），就是指 API 的客户并没有遵守 API 规范建立的约定（你调用接口的方式错了，给你返回一个运行时异常，你重新调用）。例如，数组访问的预定指明了数组的下标值必须在 0 和数组长度 - 1之间。ArrayIndexOutOfBoundsException 表明违反了这个前提。</p>
<p>为什么 Web 服务返回的异常都使用 RuntimeException？因为 Web 服务的异常大多数都是接口调用方式不对，所以我们用 RuntimeException 来封装这些错误，并且直接冒泡返回，不需要层层 throw。</p>
<h3 id="什么时候使用异常-1"><a class="header" href="#什么时候使用异常-1">什么时候使用异常</a></h3>
<p>我们大多数时候使用的异常都是 RuntimeException。</p>
<p>异常应该用来去除大多数在 requires 中列出的约束条件（precondition）。requires 应该只为效率原因保留，或者在我们能确定调用该接口的时候一定能满足约束条件的时候，才保留 requires。</p>
<p>异常也应该用来消除在正常结果中的数字代码信息（异常就是异常，不能用特殊值来代替）。例如，如果元素不存在于数组中，search 就是一个异常，而不是返回一个特殊的数字。通过使用异常，我们能够清晰地区分正常的结果和异常的情况。</p>
<p>使用异常的规则：</p>
<ul>
<li>如果使用的环境是局部的，例如调用一个 private 方法，则不需要使用异常，因为能证实 requires 格式很容易得到满足，并且可以恰当地使用特殊结果。</li>
<li>但是，如果使用的环境是非局部的，例如公开的接口，则应该使用异常来代替特殊的结果。并且，应该使用异常来代替使用 requires 格式。（参考 Web 接口的异常码机制）</li>
</ul>
<h3 id="异常实战防御编程-1"><a class="header" href="#异常实战防御编程-1">异常实战：防御编程</a></h3>
<p>带有 requires 格式的过程的实现，如果可能，应该检查这个 requires 格式是否满足。如果没有满足，就抛出运行时异常 FailureException（requires 是契约，既然没有按照契约调用该接口，就是编程错误，就应该抛出运行时异常）。</p>
<p>接口的方法名不应该列出 FailureException，而且过程的规格中也不应该提到抛出它。因为这个异常描述的是不符合 precondition 的情况，调用者只有满足了这个 precondition 才能不抛出该异常。</p>
<p>更普遍的情况是，每当代码检查到一个应该满足的 precondition，但是这个 precondition 不满足时，就应该抛出运行时异常，表示没有准确地调用这个接口！</p>
<h2 id="第五章-数据抽象"><a class="header" href="#第五章-数据抽象">第五章 数据抽象</a></h2>
<h3 id="类的定义"><a class="header" href="#类的定义">类的定义</a></h3>
<p>数据抽象的规格。</p>
<p>一个类型的意义，不应该由其任何一个实现给出，而是应该由规格定义其行为。由于类型的对象只通过调用操作使用，所以大多数规格都是用于解释这些操作做了什么。（类的定义）</p>
<p>成员方法分类：</p>
<ul>
<li>创建者（creator）：构造函数</li>
<li>生成者（producer）：这些操作将其类型的对象作为输入，并且生成一个新的同类型对象，既可能是构造函数，也可能是普通方法，例如 add 和 mul 就是 Poly 的生成者</li>
<li>改变者（mutator）：修改对象的状态，例如 List 的 add 方法，setter 方法</li>
<li>观察者（observer）：读取对象的状态，getter 方法</li>
</ul>
<p>immutable 对象：没有 modified（mutator） 的方法，成员变量不会被改动，例如定义一个多项式，定义一个 String</p>
<p>mutable 对象： 有 modified（mutator） 方法，会改动成员变量，例如 Set 和 List</p>
<h3 id="getter-和-setter"><a class="header" href="#getter-和-setter">getter 和 setter</a></h3>
<p>成员变量为何一定是 private 的？</p>
<p>为了支持抽象，将访问成员变量在方法和构造函数的实现范围内是很重要的。比如，这让你能够重新实现一个抽象类型而不影响任何使用这个类型的代码。成员变量对用户来说必须是不可见的，使用对象的代码只可以指向其方法。要防止成员变量被 client 看到，则需要声明它们为非公有。类只暴露方法，不暴露成员变量。</p>
<p><a href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors">Why use getters and setters/accessors?</a></p>
<p><a href="https://www.baeldung.com/java-why-getters-setters">Significance of Getters and Setters in Java</a></p>
<p>如果 Java 中没有 getter setter 的话：</p>
<ol>
<li>
<p>如果任何 client 都可以通过 <code>.</code> 直接修改对象的成员变量，那么某些类型便失去了 immutable 特性，例如 Poly 类型</p>
</li>
<li>
<p>we cannot provide any conditional logic to the change of the variable. Let's consider we have a class <em>Employee</em> with a field <em>retirementAge</em>:</p>
<pre><code class="language-java">public class Employee {
    public String name;
    public int retirementAge;

// Constructor, but no getter/setter
}
</code></pre>
<p>Note that, here we've set the fields as public to enable access from outside the class <em>Employee</em>. Now, we need to change the <em>retirementAge</em> of an employee:</p>
<pre><code class="language-java">public class RetirementAgeModifier {

    private Employee employee = new Employee(&quot;John&quot;, 58);

    private void modifyRetirementAge(){
        employee.retirementAge=18;
    }
}
</code></pre>
<p>Here, any client of the <em>Employee</em> class can easily do what they want with the <em>retirementAge</em> field. <strong>There's no way to validate the change.</strong></p>
</li>
<li>
<p>how could we achieve read-only or write-only access to the fields from outside the class?</p>
</li>
</ol>
<p>Java 中 getter 和 setter 的作用：</p>
<ol>
<li>It helps us achieve encapsulation which is used to hide the state of a structured data object inside a class, preventing unauthorized direct access to them</li>
<li>Achieve immutability by declaring the fields as private and using only getters</li>
<li>Getters and setters also allow additional functionalities like validation（例如校验退休年龄是否超过 60 岁）, error handling that could be added more easily in the future. Thus we can add conditional logic and provide behavior according to the needs</li>
<li>We can provide different access levels to the fields; for example, the get (read-access) may be public, while the set (write-access) could be protected</li>
<li>Control over setting the value of the property correctly</li>
<li>With getters and setters, we achieve one more key principle of OOP, i.e., abstraction, which is hiding implementation details so that no one can use the fields directly in other classes or modules</li>
</ol>
<p>David John Wheeler有一句名言：</p>
<p>“All problems in computer science can be solved by another level of indirection.”</p>
<p>getter、setter就是个很好的中间层。</p>
<p>直接摘录stackoverflow上一个不错的总结：</p>
<p><a href="http://stackoverflow.com/questions/1568091/why-use-getters-and-setters">oop - Why use getters and setters?</a></p>
<ol>
<li>这两个方法可以方便增加额外功能（比如验证）。</li>
<li>内部存储和外部表现不同。</li>
<li>可以保持外部接口不变的情况下，修改内部存储方式和逻辑。</li>
<li>任意管理变量的生命周期和内存存储方式。</li>
<li>提供一个debug接口。</li>
<li>能够和模拟对象、序列化乃至WPF库等融合。</li>
<li>允许继承者改变语义。</li>
<li>可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算）</li>
<li>getter和setter可以有不同的访问级别。</li>
</ol>
<p>在使用 getter 和 setter 时可能犯的错误：</p>
<ul>
<li>
<p>Assigning Object References Directly in the Setter Methods</p>
<p>When we assign object reference directly in the setter methods, both these references point to a single object in memory. So, changes made using any of the reference variables are actually made on the same object:</p>
<pre><code class="language-java">public void setEmployee(Employee employee) {
    this.employee = employee;
}
</code></pre>
<p>However, we can copy all the elements from one object to another object using a <a href="https://www.baeldung.com/java-deep-copy">deep copy</a>. Due to this, the state of <em>this</em> object becomes independent of the existing (passed) employee object:</p>
<pre><code class="language-java">public void setEmployee(Employee employee) {
    this.employee.setName(employee.getName());
    this.employee.setRetirementAge(employee.getRetirementAge());
}
</code></pre>
</li>
<li>
<p>Returning Object References Directly From the Getter Methods</p>
<p>Similarly, if the getter method returns the reference of the object directly, anyone can use this reference from the outside code to change the state of the object:</p>
<pre><code class="language-java">public Employee getEmployee() {
    return this.employee;
}
</code></pre>
<p>Let's use this <em>getEmployee()</em> method and change the <em>retirementAge:</em></p>
<pre><code class="language-java">private void modifyAge() {
    Employee employeeTwo = getEmployee();
    employeeTwo.setRetirementAge(65);
}
</code></pre>
<p>This leads to the unrecoverable loss of the original object.</p>
<p>So, instead of returning the reference from the getter method, we should return a copy of the object. One such way is as below:</p>
<pre><code class="language-java">public Employee getEmployee() {
    return new Employee(this.employee.getName(), this.employee.getRetirementAge());
}
</code></pre>
<p>However, we should also keep in mind that creating copies of objects within the getter or setter might not always be a best practice. For example, calling the above getter method in a loop could result in an expensive operation.</p>
<p>On the other hand, if we want that our collection should remain unmodifiable, it would make sense to return a copy of the collection from a getter. We then have to determine which approach suits best in a certain situation.</p>
</li>
</ul>
<h2 id="第六章-迭代抽象"><a class="header" href="#第六章-迭代抽象">第六章 迭代抽象</a></h2>
<h3 id="没有索引的对象怎么迭代"><a class="header" href="#没有索引的对象怎么迭代">没有索引的对象，怎么迭代？</a></h3>
<p>迭代背后的实现原理。如何实现一个数据抽象的迭代机制？</p>
<p>迭代的要求：一次只生成一项，递增地生成想要迭代的项。</p>
<pre><code class="language-java">for each result item i produced by iterator A:
		do perform some action on i
</code></pre>
<p>对于拥有索引的数据抽象，例如 ArrayList，可以没有迭代机制：</p>
<pre><code class="language-java">for(i=0; i&lt;list.size(); i++){
  do perform some action on list.get(i);
}
</code></pre>
<p>考虑如下的一个需求，对一个多项式对象的，迭代获取其每一项的系数，我们应该怎么办呢？</p>
<p>我们所需要的，是一种普遍的迭代机制，避免出现时间和空间问题。</p>
<h3 id="java-的迭代"><a class="header" href="#java-的迭代">Java 的迭代</a></h3>
<p>迭代器</p>
<pre><code class="language-java">public interface Iterator{
  public boolean hasNext();
  // EFFECTS: return true if there are more elements to yield, else return false
  
  public Object next() throws NoSuchElementException;
  // MODIFIES: this
  // EFFECTS: if there are more results to yield, returns the next result and modifies the state of this to record the yield. Otherwise, throws NoSuchElementException
}
</code></pre>
<p>迭代器和发生器：</p>
<ul>
<li>迭代器是一个返回发生器的过程。一个数据抽象，可以有一个或多个迭代器方法</li>
<li>发生器是生成用于迭代的元素的对象</li>
<li>迭代器的规格定义了发生器的行为</li>
</ul>
<p>注意：</p>
<ul>
<li>一个数据抽象可以有多个迭代器</li>
</ul>
<h3 id="实现迭代器"><a class="header" href="#实现迭代器">实现迭代器</a></h3>
<p>数据抽象中的迭代器抽象：</p>
<pre><code class="language-java">public class Poly{
  public Iterator terms()
    // EFFECTS: Returns a generator that will produce exponents
}
</code></pre>
<p>为了实现一个迭代器，需要在数据抽象中定义并实现一个内部类（发生器类）。迭代器的实现：</p>
<p><a href="computer-science-notebook/note-for-java/"><img src="computer-science-notebook/note-for-java/assets/image-20220315191911989.png" alt="image-20220315191911989" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-bin"><a class="header" href="#java-bin">java-bin</a></h1>
<p>[TOC]</p>
<p>java bin 目录下提供的二进制工具</p>
<h2 id="java-2"><a class="header" href="#java-2">java</a></h2>
<p>运行 class 文件。</p>
<pre><code class="language-shell"># 注意不要加 .class 后缀
java xxx
</code></pre>
<p>如果出现 <code>错误: 找不到或无法加载主类</code> 的情况，则大概率是包名的问题。Java 中一个类的唯一 ID，并不是类名，而是<code>包名 + 类名</code>。</p>
<h2 id="javac"><a class="header" href="#javac">javac</a></h2>
<p>编辑 java 代码</p>
<pre><code class="language-shell"># 编译 xxx.java 文件，生成
javac xxx.java

# 制定 class 文件的地址
javac -d classdir xxx.java
</code></pre>
<p>生成 class 文件</p>
<h2 id="javap"><a class="header" href="#javap">javap</a></h2>
<p>反编译 class 文件</p>
<pre><code class="language-shell"># -c 对代码进行反汇编
javap -c xxx
</code></pre>
<p>以下是一个 Java 代码编译后的反编译结果：</p>
<pre><code class="language-java">package thinkinjava.string;

public class Concatenation {
    public static void main(String[] args) {
        String mango = &quot;mango&quot;;
        String s = &quot;abc&quot; + mango + &quot;def&quot; + 47;
        System.out.println(s);
    }
}
</code></pre>
<p>反编译 class 文件：</p>
<pre><code># 一个反编译结果
public class thinkinjava.string.Concatenation {
  public thinkinjava.string.Concatenation();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String mango
       2: astore_1
       3: new           #3                  // class java/lang/StringBuilder
       6: dup
       7: invokespecial #4                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V
      10: ldc           #5                  // String abc
      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      15: aload_1
      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: ldc           #7                  // String def
      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: bipush        47
      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      32: astore_2
      33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;
      36: aload_2
      37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      40: return
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-开发工具"><a class="header" href="#java-开发工具">Java 开发工具</a></h1>
<p>[TOC]</p>
<h2 id="jdk"><a class="header" href="#jdk">JDK</a></h2>
<p>Open-JDK</p>
<p>版本：Java8 (Lambda 特性) ，可以使用最新版本</p>
<p>下载地址：<a href="https://adoptopenjdk.net/releases.html?variant=openjdk8&amp;jvmVariant=hotspot">Open-JDK</a></p>
<h2 id="apache-maven"><a class="header" href="#apache-maven">Apache Maven</a></h2>
<p><a href="https://maven.apache.org/download.cgi">[download]</a></p>
<p>Java 的包管理器，类似于 JS 的 npm，yarn，Python 的 pip</p>
<p>Maven 是免安装的，没有安装包，下载下来解压就能用</p>
<h2 id="postman"><a class="header" href="#postman">PostMan</a></h2>
<p>测试工具，可以保存设置。</p>
<h2 id="mock-数据"><a class="header" href="#mock-数据">Mock 数据</a></h2>
<p>伪造后端数据。</p>
<p>https://zhuanlan.zhihu.com/p/77199413</p>
<p>在实际的项目研发过程中，我们经常会遇到如下的尴尬场景：</p>
<p>前端开发依赖于后端接口数据，但是后台人员不足或者无法立即到位，前端迟迟不能开工，或者前端小伙子自己参照ui设计图，完成对应的静态页面（没有数据交互），待后台人员到位，再进行二次开发，协助完成接口对接。</p>
<p>可以用来 mock 数据的工具：rap2 http://rap2.taobao.org/</p>
<h2 id="技术栈-1"><a class="header" href="#技术栈-1">技术栈</a></h2>
<h3 id="front-end"><a class="header" href="#front-end">Front-End</a></h3>
<p><a href="https://ant.design/">AntDesign (based on React)</a></p>
<p>前端打包工具：webpack，相当于 C++ 中的 Makefile 工具</p>
<h3 id="back-end"><a class="header" href="#back-end">Back-End</a></h3>
<h4 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Microservices">[Wiki Microservices]</a> 微服务是一个软件架构形式。在这个架构中，复杂的应用程序是由多个小而独立的进程组成，每一个 进程通过独立于语言的接口进行相互交流。这些服务较小、高度解耦且专注于完成一个小任务，使得 用模块化方法建设系统更加容易。</p>
<p>容器化，将不同的服务相互隔离，采用统一的网关进行流量管理（类似百度的 BFE）：</p>
<ul>
<li>服务发现：注册 + 心跳</li>
<li>服务通信
<ul>
<li>同步调用：REST，RPC</li>
<li>异步调用：消息队列（Kafka，RocketMQ，ActiveMQ），Redis</li>
</ul>
</li>
<li>服务部署
<ul>
<li>WAR包形式基于tomcat部署</li>
<li>JAR包形式基于自带独立web容器部署（需占用独立端口）</li>
<li>Docker镜像方式部署，由 k8s 管理</li>
</ul>
</li>
<li>应用服务框架：Spring Boot</li>
<li>微服务框架：Spring cloud</li>
<li>负载均衡：haproxy</li>
<li>注册中心，配置中心：nacos，eureka</li>
<li>Web 服务器：tomcat</li>
<li>认证：Spring Security Oauth2</li>
</ul>
<h4 id="nacos"><a class="header" href="#nacos">Nacos</a></h4>
<p><a href="https://nacos.io/en-us/docs/what-is-nacos.html">Nacos</a> is committed to help you <strong>discover</strong>, <strong>configure</strong>, and <strong>manage</strong> your <strong>microservices</strong>. It provides a set of simple and useful features enabling you to realize dynamic service discovery, service configuration, service metadata and traffic management.</p>
<h3 id="microservices"><a class="header" href="#microservices">Microservices</a></h3>
<p><a href="https://www.zhihu.com/question/65502802/answer/802678798">[什么是微服务架构？- 老刘的回答]</a></p>
<p><a href="https://www.zhihu.com/question/65502802">[什么是微服务架构？]</a></p>
<h3 id="orm"><a class="header" href="#orm">ORM</a></h3>
<p>ORM（Object Relational Mapping）, ORM 举例：Django ORM，Java Mybatis puls</p>
<p>优点：替换 SQL 语句，提供获取数据的标准化，避免因为 SQL 查询导致的各种问题，例如 SQL 注入等问题</p>
<h3 id="rpc"><a class="header" href="#rpc">RPC</a></h3>
<p>gRPC（Google RPC） is a modern, open source <strong>remote procedure call</strong> (RPC) framework that can run anywhere. It enables client and server applications to communicate transparently, and makes it easier to build connected systems. </p>
<img align="left" src="computer-science-notebook/note-for-java/assets/image-20201106091824908.png" alt="image-20201106091824908" style="zoom:50%;" />
<p>RPC 通常是长链接，HTTP 是短连接。</p>
<p>HTTP 调用也是一种特殊的 RPC，HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>HTTP vs RPC</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。虽然国家一直在提倡使用普通话交流，但是这么多年过去了，你回一趟家乡探个亲什么的就会发现身边的人还是流行说方言。</p>
<p>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>一个完整的RPC框架底层往往是socket搭配序列化反序列化的工作。</p>
<p>作者：老钱
链接：https://www.zhihu.com/question/25536695/answer/417707733
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="负载均衡"><a class="header" href="#负载均衡">负载均衡</a></h3>
<p><strong>haproxy</strong></p>
<p><a href="http://www.haproxy.org/">[haproxy]</a> The Reliable, High Performance TCP/HTTP <strong>Load Balancer</strong>. </p>
<p>haproxy 的主要功能就是负载均衡。</p>
<p>HAProxy is a free, very fast and reliable solution offering <a href="http://en.wikipedia.org/wiki/High_availability">high availability</a>, <a href="http://en.wikipedia.org/wiki/Load_balancer">load balancing</a>, and proxying for TCP and HTTP-based applications. It is particularly suited for very high traffic web sites and powers quite a number of the world's most visited ones. Over the years it has become the de-facto standard opensource load balancer, is now shipped with most mainstream Linux distributions, and is often deployed by default in cloud platforms.</p>
<p><strong>nginx</strong></p>
<p>nginx 的主要功能是 web 服务器。兼职负载均衡和反向代理。</p>
<p><strong>keepalived</strong></p>
<p><a href="https://www.keepalived.org/">[keepalived]</a> 是一款路由软件。</p>
<p>反向代理</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="大数计算和存储"><a class="header" href="#大数计算和存储">大数计算和存储</a></h1>
<p>[TOC]</p>
<h2 id="需求"><a class="header" href="#需求">需求</a></h2>
<p>Java long 类型是 64 位，第一位是符号位，其存储的最大值是 <code>2^64 - 1</code>，转成二进制是  63 个 1</p>
<pre><code class="language-java">System.out.println(Long.toBinaryString(Long.MAX_VALUE));
// 111111111111111111111111111111111111111111111111111111111111111
</code></pre>
<p>现在我们需要存储的最大值是 64 个 1，所以考虑使用 Java 提供的 BigInteger。</p>
<p>有两个地方需要调研：</p>
<p>计算：BigInteger 是如何创建大数，如何计算大数的</p>
<p>存储：jpa 能否支持大数建模，主流数据库和国产数据库对于大数的支持</p>
<h2 id="计算"><a class="header" href="#计算">计算</a></h2>
<p>BigInteger 对象构造函数：</p>
<pre><code class="language-java">// Translates the decimal String representation of a BigInteger into a BigInteger.
BigInteger bigNum = new BigInteger(&quot;123456789&quot;);
</code></pre>
<p>加减乘除使用如下几个方法：add()，subtract()，mutiply()，divide()</p>
<h2 id="存储"><a class="header" href="#存储">存储</a></h2>
<p>经过测试  jpa 不能实现 BigInteger 的建模，jpa 自动将 BigInteger 转换成了整数部分为 19 位的整数，其支持的最大值还是 Java Long 的最大值。</p>
<table><thead><tr><th></th><th>BigInteger</th></tr></thead><tbody>
<tr><td>Oracle</td><td>NUMBER(19,2)</td></tr>
<tr><td>MySQL</td><td>decimal(19,2)</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<p>如果想让 jpa 将 BigInteger 转成更大的数，则需要 <code>@Column(columnDefinition=&quot;decimal(20,2)&quot;)</code> 但是这样就和具体的数据库强相关了，Oracle 则需要设置成 <code>@Column(columnDefinition=&quot;number(20,2)&quot;)</code></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="java-database"><a class="header" href="#java-database">Java Database</a></h1>
<p>[TOC]</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220330094704796.png" alt="image-20220330094704796" /></p>
<h2 id="jdbc"><a class="header" href="#jdbc">JDBC</a></h2>
<h3 id="jdbc-是什么"><a class="header" href="#jdbc-是什么">jdbc 是什么</a></h3>
<p>java database connector</p>
<p>JDBC 是 Java jdk 自带的标准库。</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐

│  ┌───────────────┐  │
   │   Java App    │
│  └───────────────┘  │
           │
│          ▼          │
   ┌───────────────┐
│  │JDBC Interface │&lt;─┼─── JDK
   └───────────────┘
│          │          │
           ▼
│  ┌───────────────┐  │
   │ MySQL Driver  │&lt;───── Oracle
│  └───────────────┘  │
           │
└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘
           ▼
   ┌───────────────┐
   │     MySQL     │
   └───────────────┘
</code></pre>
<p>jdbc jar 包和数据库通信也是采用的</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
   ┌───────────────┐
│  │   App.class   │  │
   └───────────────┘
│          │          │
           ▼
│  ┌───────────────┐  │
   │  java.sql.*   │
│  └───────────────┘  │
           │
│          ▼          │
   ┌───────────────┐     TCP    ┌───────────────┐
│  │ mysql-xxx.jar │──┼────────&gt;│     MySQL     │
   └───────────────┘            └───────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
          JVM
</code></pre>
<p>jdbc 是接口，是标准，就在 Java 的标准库 <code>java.sql</code> 里放着。</p>
<h3 id="maven-配置-1"><a class="header" href="#maven-配置-1">maven 配置</a></h3>
<p>JDBC 驱动就是各种数据库实现的 jar 包，只需要在 maven 中添加一个依赖即可。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意到这里添加依赖的<code>scope</code>是<code>runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把<code>runtime</code>改成<code>compile</code>，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code>com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code>compile</code>。</p>
<h3 id="jdbc-url"><a class="header" href="#jdbc-url">jdbc url</a></h3>
<table><thead><tr><th>db</th><th>url</th><th>demo</th></tr></thead><tbody>
<tr><td>mysql</td><td><code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2</code></td><td><code>jdbc:mysql://localhost:3306/learnjdbc?useSSL=false&amp;characterEncoding=utf8</code></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<h3 id="demo-6"><a class="header" href="#demo-6">Demo</a></h3>
<pre><code class="language-java">// JDBC连接的URL, 不同数据库有不同的格式:
String JDBC_URL = &quot;jdbc:mysql://localhost:3306/test&quot;;
String JDBC_USER = &quot;root&quot;;
String JDBC_PASSWORD = &quot;password&quot;;
try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (Statement stmt = conn.createStatement()) {
        try (ResultSet rs = stmt.executeQuery(&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;)) {
            while (rs.next()) {
                long id = rs.getLong(1); // 注意：索引从1开始
                long grade = rs.getLong(2);
                String name = rs.getString(3);
                int gender = rs.getInt(4);
            }
        }
    }
}
</code></pre>
<p>核心代码是<code>DriverManager</code>提供的静态方法<code>getConnection()</code>。<code>DriverManager</code>会自动扫描classpath，找到所有的JDBC驱动，然后根据我们传入的URL自动挑选一个合适的驱动。</p>
<p><code>Statment</code>和<code>ResultSet</code>都是需要关闭的资源，因此嵌套使用<code>try (resource)</code>确保及时关闭；</p>
<p>为了避免 SQL 注入，用 <code>PreparedStatement</code> 替代 <code>Statement</code>。<code>PreparedStatement</code>  用 <code>?</code> 作为占位符。</p>
<pre><code class="language-java">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;)) {
        ps.setObject(1, &quot;M&quot;); // 注意：索引从1开始 设置 gender 为 M
        ps.setObject(2, 3); // 设置 grade 为 3
        try (ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                long id = rs.getLong(&quot;id&quot;);
                long grade = rs.getLong(&quot;grade&quot;);
                String name = rs.getString(&quot;name&quot;);
                String gender = rs.getString(&quot;gender&quot;);
            }
        }
    }
}
</code></pre>
<h3 id="jdbc-增删改"><a class="header" href="#jdbc-增删改">jdbc 增删改</a></h3>
<pre><code class="language-java">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(
            &quot;INSERT INTO students (id, grade, name, gender) VALUES (?,?,?,?)&quot;)) {
        ps.setObject(1, 999); // 注意：索引从1开始
        ps.setObject(2, 1); // grade
        ps.setObject(3, &quot;Bob&quot;); // name
        ps.setObject(4, &quot;M&quot;); // gender
        int n = ps.executeUpdate(); // 1 注意是 executeUpdate，不是 executeQuery
    }
}
</code></pre>
<p>注意，<code>?</code> 只适用于 value，不适用于字段和表名，下面这个 sql 构造就是有问题的：</p>
<pre><code class="language-java">// error case
String sql = &quot;INSERT IGNORE INTO ? (\n&quot; +
                &quot;  ?, ?, ?, ? \n&quot; +
                &quot;) \n&quot; +
                &quot;VALUES \n&quot; +
                &quot;  (?, ?, ?, ?)\n&quot;;
</code></pre>
<h3 id="jdbc-连接池"><a class="header" href="#jdbc-连接池">jdbc 连接池</a></h3>
<h4 id="hikaricp"><a class="header" href="#hikaricp">Hikaricp</a></h4>
<p>HikariCP 是 Spring Boot 默认支持的数据库连接池。</p>
<p>JDBC连接池有一个标准的接口<code>javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。目前使用最广泛的是 HikariCP(黑卡瑞 cp)。我们以 HikariCP 为例，要使用JDBC连接池，先添加HikariCP的依赖如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
    &lt;version&gt;2.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>DataSource</code> 就是数据库连接池：</p>
<pre><code class="language-java">HikariConfig config = new HikariConfig();
config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
config.setUsername(&quot;root&quot;);
config.setPassword(&quot;password&quot;);
config.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;1000&quot;); // 连接超时：1秒
config.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60000&quot;); // 空闲超时：60秒
config.addDataSourceProperty(&quot;maximumPoolSize&quot;, &quot;10&quot;); // 最大连接数：10
DataSource ds = new HikariDataSource(config);
</code></pre>
<p>注意创建<code>DataSource</code>也是一个非常昂贵的操作，所以通常 <code>DataSource</code> 实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p>
<pre><code class="language-java">try (Connection conn = ds.getConnection()) { // 在此获取连接
    ...
} // 在此“关闭”连接
</code></pre>
<p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建<code>HikariDataSource</code>时传入的<code>HikariConfig</code>持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用<code>ds.getConnection()</code>，会迫使连接池内部先创建一个<code>Connection</code>，再返回给客户端使用。当我们调用<code>conn.close()</code>方法时（<code>在try(resource){...}</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p>
<p>因此，连接池内部维护了若干个<code>Connection</code>实例，如果调用<code>ds.getConnection()</code>，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对<code>Connection</code>调用<code>close()</code>，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p>
<p>在需要读写数据库的方法内部，按如下步骤访问数据库：</p>
<ul>
<li>从全局<code>DataSource</code>实例获取<code>Connection</code>实例；</li>
<li>通过<code>Connection</code>实例创建<code>PreparedStatement</code>实例；</li>
<li>执行SQL语句，如果是查询，则通过<code>ResultSet</code>读取结果集，如果是修改，则获得<code>int</code>结果。</li>
</ul>
<h4 id="druid"><a class="header" href="#druid">Druid</a></h4>
<p>阿里开源的数据库连接池。</p>
<h2 id="javaxpersistence"><a class="header" href="#javaxpersistence">javax.persistence</a></h2>
<p>Java Persistence is the API for the management for persistence and object/relational mapping.</p>
<p>用于持久化层和 ORM。提供了大量的注解和枚举类。</p>
<h2 id="jpa"><a class="header" href="#jpa">JPA</a></h2>
<p>Java Persistence API 是 Sun 官方提出的 Java 持久化规范。</p>
<p>注意，JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。</p>
<p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</p>
<p>JPA 更像 Django ORM，统一了 Java ORM 的规范。</p>
<p>reference</p>
<ul>
<li>https://www.liaoxuefeng.com/wiki/1252599548343744/1282383789686817</li>
<li>https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#jpa.repositories</li>
<li>Spring Boot系列(五)：spring data jpa的使用 - 极乐君的文章 - 知乎 https://zhuanlan.zhihu.com/p/25000309</li>
<li>https://www.baeldung.com/spring-data-save-saveall</li>
</ul>
<h2 id="hibernate"><a class="header" href="#hibernate">Hibernate</a></h2>
<h3 id="dialect"><a class="header" href="#dialect">dialect</a></h3>
<p>MySQL 是一种方言，Oracle 也是一种方言，MSSQL 也是一种方言，他们之间在遵循 SQL 规范的前提下，都有各自的扩展特性。</p>
<p>拿分页来说，MySQL 的分页是用关键字 <code>limit</code>， 而 Oracle 用的是 <code>ROWNUM</code>，MSSQL 可能又是另一种分页方式。</p>
<pre><code class="language-sql"># mysql
select * from t_user limit 10;
# oracle
select * from t_user t where ROWNUM &lt;10;
</code></pre>
<p>这对于 ORM 框架来说，为了在上层的ORM层做了无差别调用，比如分页，对使用者来说，不管你底层用的是MySQL还是Oracle，他们用的都是一样的接口，但是底层需要根据你使用的数据库方言不同而调用不同的DBAPI。用户只需要在初始化的时候指定用哪种方言就好，其它的事情ORM框架帮你完成了。</p>
<pre><code class="language-yaml">spring:
  jpa:
    database: oracle
    show-sql: true
    hibernate:
      naming:
        # 表名及字段全小写下划线分隔命名策略(默认),表名具备前缀res
        physical-strategy: CustomNamingStrategyConfig
    properties:
      hibernate:
        hbm2ddl:
          # 自动更新维护表结构
          auto: update
        dialect: MyOracle12cDialect
    open-in-view: false
  datasource:
    # ORACLE JDBC 配置
    url: jdbc:oracle:thin:@ip:1521:ora12a
    username: ttest
    password: ttest
    driver-class-name: oracle.jdbc.OracleDriver
</code></pre>
<h3 id="代理"><a class="header" href="#代理">代理</a></h3>
<p>使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。</p>
<p>而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。</p>
<p>那么，ORM框架是如何跟踪Java Bean的修改，以便在<code>update()</code>操作中更新必要的属性？</p>
<p>答案是使用<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：</p>
<pre><code>public class UserProxy extends User {
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }
}
</code></pre>
<p>这样，代理类可以跟踪到每个属性的变化。</p>
<p>针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：</p>
<pre><code>public class UserProxy extends User {
    Session _session;
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }

    /**
     * 获取User对象关联的Address对象:
     */
    public Address getAddress() {
        Query q = _session.createQuery(&quot;from Address where userId = :userId&quot;);
        q.setParameter(&quot;userId&quot;, this.getId());
        List&lt;Address&gt; list = query.list();
        return list.isEmpty() ? null : list(0);
    }
}
</code></pre>
<h2 id="jpa--hibernate--mybatis-比较"><a class="header" href="#jpa--hibernate--mybatis-比较">JPA / Hibernate / MyBatis 比较</a></h2>
<p>最常见的两种持久化层框架：<strong>JPA</strong>和<strong>MyBatis</strong></p>
<table><thead><tr><th style="text-align: left">JDBC</th><th style="text-align: left">Hibernate</th><th style="text-align: left">JPA</th><th><strong>MyBatis</strong></th><th>解释</th></tr></thead><tbody>
<tr><td style="text-align: left">DataSource</td><td style="text-align: left">SessionFactory</td><td style="text-align: left">EntityManagerFactory</td><td>SqlSessionFactory</td><td>数据库连接池</td></tr>
<tr><td style="text-align: left">Connection</td><td style="text-align: left">Session</td><td style="text-align: left">EntityManager</td><td>SqlSession</td><td>一个连接</td></tr>
</tbody></table>
<p>mybatis与spring data jpa的功能区别</p>
<ol>
<li>spring data jpa实现了jpa（java persistence api）功能，即可以实现pojo转换为关系型数据库记录的功能，通俗来讲就是可以不写任何的建表sql语句了。jpa是spring data jpa功能的一个子集。
而mybatis并没有 jpa 功能，建表语句还是要自己写的。</li>
<li>spring data jpa是<strong>全自动框架</strong>，不需要写任何sql。而mybatis是<strong>半自动框架</strong>，需要自己写sql，mybatis-plus为mybatis赋能，使其也可以基本上不需要写任何模板sql。
以上两点应该是二者功能上的最大的区别</li>
<li>debug模式下看生成的sql，mybatis下的sql可读性很好，而spring data jpa下的查询sql可读性并不好</li>
<li>……</li>
</ol>
<h2 id="nosql"><a class="header" href="#nosql">NoSQL</a></h2>
<h3 id="redis-1"><a class="header" href="#redis-1">Redis</a></h3>
<p>Redis 有两个 Java 客户端：Jedis 和 Lettuce</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpa-1"><a class="header" href="#jpa-1">JPA</a></h1>
<p>[TOC]</p>
<h2 id="reference-1"><a class="header" href="#reference-1">reference</a></h2>
<ul>
<li><a href="https://jakarta.ee/specifications/persistence/3.0/jakarta-persistence-spec-3.0.html">Jakarta Persistence 3.0 Specification Document</a> </li>
<li><a href="https://jakarta.ee/specifications/persistence/3.0/apidocs">Jakarta Persistence 3.0 Javadoc</a></li>
<li><a href="https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#preface">Spring Data JPA - Reference Documentation</a></li>
<li><a href="http://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf">Java Persistence API - Oracle Software Downloads</a></li>
<li><a href="https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl">Advanced Spring Data JPA - Specifications and Querydsl</a></li>
<li><a href="https://www.baeldung.com/hibernate-criteria-queries">JPA Criteria Queries</a></li>
<li><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjivm.html">Using the Criteria API and Metamodel API to Create Basic Typesafe Queries</a></li>
<li><a href="https://www.baeldung.com/jpa-join-column">@JoinColumn Annotation Explained</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282383789686817">廖雪峰 jpa 介绍</a></li>
</ul>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>Java Persistence API 是 Sun 官方提出的 Java 持久化规范。</p>
<p>JPA 和 Hibernate 的关系：JPA 是规范（类似于 JDBC），Hibernate 是 JPA 的实现</p>
<h2 id="annotations"><a class="header" href="#annotations">annotations</a></h2>
<table><thead><tr><th>Annotation</th><th>Desc</th><th></th></tr></thead><tbody>
<tr><td><code>@Entity</code></td><td>表示该类为实体类，将映射到指定的数据库表</td><td></td></tr>
<tr><td><code>@Table(name=&quot;table_name&quot;)</code></td><td>指定该类映射表的表名</td><td></td></tr>
<tr><td><code>@Id</code></td><td>映射主键</td><td></td></tr>
<tr><td><code>@GeneratedValue(strategy=&quot;&quot;)</code></td><td>主键生成策略</td><td></td></tr>
<tr><td><code>@Basic</code></td><td>字段的默认注解，如果没有，会自动添加</td><td></td></tr>
<tr><td><code>@Column</code></td><td>指定字段详细属性</td><td></td></tr>
<tr><td><code>@Transient</code></td><td>表示不作映射，可以作用于成员变量和方法</td><td>暂时的</td></tr>
<tr><td><code>@Temporal</code></td><td>指定时间格式</td><td>时间的</td></tr>
</tbody></table>
<h3 id="generatedvalue"><a class="header" href="#generatedvalue">@GeneratedValue</a></h3>
<p>几个 strategy：</p>
<ul>
<li>IDENTITY：ID 自增长，MySQL，Oracle 不支持</li>
<li>AUTO：啥也不填，JPA 自动选择合适的策略，默认选项</li>
<li>SEQUENCE：通过序列产生主键，MySQL 不支持</li>
<li>TABLE：通过表产生主键</li>
</ul>
<h3 id="basic"><a class="header" href="#basic">@Basic</a></h3>
<pre><code class="language-java">@Basic(fetch = FetchType.EAGER, optional = true)
private String email;
</code></pre>
<p>如果一个属性没有加任何注解，那么就会默认加上 basic 注解。</p>
<p>两个参数：</p>
<ul>
<li>fetch: 属性读取策略，EAGER vs LAZY ，饿汉式和懒汉式，默认是 EAGER</li>
<li>optional：属性是否允许为 null，默认式 null</li>
</ul>
<h3 id="column"><a class="header" href="#column">@Column</a></h3>
<p>几个参数：</p>
<ul>
<li>name: 指定列名</li>
<li>length：指定长度，只对字符串有效</li>
<li>nullable：是否允许为 null</li>
<li>unique：是否 unique</li>
<li>columnDefinition：表示该属性在数据库中的实际类型，JPA 无法判断 Date 要转成数据库的 Date，Time 还是 TIMESTAMP</li>
</ul>
<p>String 类型默认映射成 varchar，如果要映射成特定数据库的 BLOB 或 TEXT，则需要指定 columnDefinition。BigInteger 默认映射成长度为 19 的 decimal，如果想让 JPA 映射更大的数，则需要指定 <code>columnDefinition=&quot;decimal(20,2)&quot;</code></p>
<h3 id="temporal"><a class="header" href="#temporal">@Temporal</a></h3>
<pre><code>@Temporal(value=)
</code></pre>
<p>接受一个枚举类型，可选值有三个：</p>
<ul>
<li>DATE 年月日</li>
<li>TIME 年月日 时分秒</li>
<li>TIMESTAMP 兼容前两个</li>
</ul>
<h2 id="jpa-api"><a class="header" href="#jpa-api">jpa-api</a></h2>
<p>Java EE 已经归 Jakarta 组织维护，所以 jakarta 完全兼容 JavaEE，Jakarta Persistence API 就是 JPA。</p>
<h3 id="persistence"><a class="header" href="#persistence">Persistence</a></h3>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210529154255679.png" alt="image-20210529154255679" style="zoom:80%;" />
<p>Persistence 的主要作用就是用来创建 EntityManagerFactory 的。</p>
<pre><code class="language-java">String persistenceUnitName = &quot;default&quot;;
Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
properties.put(&quot;hibernate.format_sql&quot;, true);
EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnitName, properties);
</code></pre>
<h3 id="entitymanagerfactory"><a class="header" href="#entitymanagerfactory">EntityManagerFactory</a></h3>
<p>jpa 连接池，也是一个接口。主要作用还是创建数据库连接。</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210529155253942.png" alt="image-20210529155253942" style="zoom:80%;" />
<pre><code class="language-java">EntityManager entityManager = entityManagerFactory.createEntityManager();
// 重载的方法：map 用于提供 entityManager 的属性
EntityManager entityManager = entityManagerFactory.createEntityManager(map);
</code></pre>
<p><code>close()</code> 后，<code>isOpen()</code> 方法测试回返回 false，其他方法不能调用，否则回导致 IllegalStateException 异常。</p>
<h3 id="entitymanager"><a class="header" href="#entitymanager">EntityManager</a></h3>
<p>接口。</p>
<p><strong>临时对象</strong>：new 出来的无 id 的对象</p>
<p><strong>游离对象</strong>：new 出来的有 id 的对象</p>
<p><strong>懒加载</strong>：多次查询，对于不常用的级联数据不取出，等到要用的时候再取出。懒加载都设置了代理类。</p>
<p><strong>Eager加载</strong>：一次 join 查询获取所有值</p>
<p>增 persist 删 remove 查 find/getReference </p>
<h4 id="find--getreference--persist--remove--merge"><a class="header" href="#find--getreference--persist--remove--merge">find / getReference / persist / remove / merge</a></h4>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210530101236627.png" alt="image-20210530101236627" style="zoom:80%;" />
<pre><code class="language-java">package top.wansho.jpa;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import top.wansho.jpa.helloworld.Customer;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

import static org.junit.jupiter.api.Assertions.*;

public class EntityManagerTest {

    private EntityManagerFactory entityManagerFactory;
    private EntityManager entityManager;
    private EntityTransaction entityTransaction;

    @BeforeEach
    public void init(){
        entityManagerFactory = Persistence.createEntityManagerFactory(&quot;default&quot;);
        entityManager = entityManagerFactory.createEntityManager();
        entityTransaction = entityManager.getTransaction();
        // 开启事务
        entityTransaction.begin();
    }

    @AfterEach
    public void destroy(){
        // 提交事务
        entityTransaction.rollback();
        System.out.println(&quot;entityTransaction is active? &quot; + entityTransaction.isActive()); // true
//        entityTransaction.commit();
        System.out.println(&quot;entityTransaction is active? &quot; + entityTransaction.isActive()); // false
        entityManager.close();
        entityManagerFactory.close();
    }

    @Test
    public void testFind(){
        // 类似于 Hibernate 中的 get 方法，获取 id 为 1 的记录
        Customer customer = entityManager.find(Customer.class, 1);
        System.out.println(&quot;-------------------------&quot;);
        System.out.println(customer);
        // 先打印查询语句，再打印 --，饿汉式
    }

    @Test
    public void testGetReference(){
        // 类似于 Hibernate 中的 load 方法
        Customer customer = entityManager.getReference(Customer.class, 1); // 只获取引用
        System.out.println(customer.getClass().getName()); // top.wansho.jpa.helloworld.Customer$HibernateProxy$GLVOzPIc
        System.out.println(&quot;-------------------------&quot;);
        System.out.println(customer);
        // 先打印 --，再打印查询语句，懒加载，懒汉式，customer 是一个代理对象
    }

    @Test
    public void testPersist(){
        // 类似于 Hibernate 的 save 方法，使对象由临时状态变为持久化状态
        // 和 Hibernate 的 save 方法有些许不同，如果对象有 id，则不能执行 insert 操作，而会抛出异常
        Customer customer = new Customer();
        customer.setAge(13);
        customer.setEmail(&quot;wansho@163.com&quot;);
        customer.setLastName(&quot;www&quot;);
        entityManager.persist(customer);
        System.out.println(customer.getId()); // 有 id 了
    }

    @Test
    public void testRemove(){
        // 类似于 Hibernate 的 delete 对象，把对象对应的记录从数据库中移除
        // 注意：该方法只能移除持久化对象，而 hibernate 的 delete 方法实际上还可以移除游离对象
//        Customer customer = new Customer();
//        customer.setId(1); // 还是因为代理类的原因，不能删除游离对象
        Customer customer = entityManager.find(Customer.class, 1);
        entityManager.remove(customer);
    }

    @Test
    public void testMerge1(){
        // 1. 测试临时对象
        // 如果传入一个临时对象（没有 id），会创建一个新的对象，把临时对象的属性复制到新的对象中，然后对新的对象执行持久化操作
        // 所以新的对象会有 id，而临时对象没有 id
        Customer customer = new Customer();
        customer.setEmail(&quot;hehe@gmail.com&quot;);
        customer.setAge(18);
        customer.setLastName(&quot;ww&quot;);

        Customer customer2 = entityManager.merge(customer);
        System.out.println(customer.getId()); // null
        System.out.println(customer2.getId()); // 有 id
    }

    @Test
    public void testMerge2(){
        // 2. 测试游离对象
        // 2.1 在 EntityManager 缓存中没有该对象
        // 2.2 在数据库中也没有对应的记录
        // 2.3 JPA 会创建一个新的对象，然后把当前游离对象的属性复制到新创建的对象中
        // 2.4 对新创建的对象执行 insert 操作
        Customer customer = new Customer();
        customer.setEmail(&quot;hehe@gmail.com&quot;);
        customer.setAge(18);
        customer.setLastName(&quot;ww&quot;);
        customer.setId(20);

        Customer customer2 = entityManager.merge(customer);
        System.out.println(customer.getId());  // 20
        System.out.println(customer2.getId()); // 6，新对象 的 id 自增，和写入的 id 不一样
    }

    @Test
    public void testMerge3(){
        // 3. 测试游离对象
        // 3.1 在 EntityManager 缓存中没有该对象
        // 3.2 在数据库中有对应的记录
        // 3.3 JPA 会查询对应的记录，然后返回该记录对应的对象，然后再把游离对象的属性复制到查询到的对象中
        // 3.4 对查询到的对象进行 update
        Customer customer = new Customer();
        customer.setEmail(&quot;ww@gmail.com&quot;);
        customer.setAge(18);
        customer.setLastName(&quot;ww&quot;);
        customer.setId(6);

        Customer customer2 = entityManager.merge(customer);
        System.out.println(customer2 == customer); // false
        System.out.println(customer.getId());  // 6
        System.out.println(customer2.getId()); // 6，新对象 的 id 自增，和写入的 id 不一样
    }

    @Test
    public void testMerge4(){
        // 4. 测试游离对象
        // 4.1 在 EntityManager 缓存有该对象
        // 4.2 JPA 会把游离对象的属性直接复制给缓存中的对象
        // 4.3 对缓存中的对象执行 update
        Customer customer = new Customer();
        customer.setEmail(&quot;ww@gmail.com&quot;);
        customer.setAge(18);
        customer.setLastName(&quot;ww&quot;);
        customer.setId(6);

        Customer customer2 = entityManager.find(Customer.class, 6);
        entityManager.merge(customer);
        System.out.println(customer2 == customer);
    }

    @Test
    public void testFlush(){
        // 同 Hibernate 中 session 的 flush 方法，强制写入数据库
        Customer customer = entityManager.find(Customer.class, 1);
        customer.setLastName(&quot;dd&quot;);
        entityManager.flush();
    }

    @Test
    public void testRefresh(){
        // 从数据库中读最新的数据，强制刷新
        Customer customer = entityManager.find(Customer.class, 2); // select 1
        customer = entityManager.find(Customer.class, 2); // jpa 有一级缓存，这条语句没有去数据库中查询
        entityManager.refresh(customer); // select 2
        // 一共执行了两条查询语句
    }

}
</code></pre>
<h4 id="flush--setflushmode--getflushmode"><a class="header" href="#flush--setflushmode--getflushmode">flush / setFlushMode / getFlushMode</a></h4>
<p>强制将内存中的数据写入数据库，进行持久化。</p>
<h4 id="refresh"><a class="header" href="#refresh">refresh</a></h4>
<p>强制刷新。将数据库中的持久化对象的值同步到实体对象上，即更新实例的属性值。</p>
<h4 id="clear"><a class="header" href="#clear">clear</a></h4>
<p>Clear the persistence context, causing all managed entities to become detached.</p>
<p>清除持久上下文环境，断开所有关联的实体。</p>
<h4 id="isopen--gettransaction--close"><a class="header" href="#isopen--gettransaction--close">isOpen / getTransaction / close</a></h4>
<h4 id="createquery"><a class="header" href="#createquery">createQuery</a></h4>
<p>类似的接口都是用来做 jpql 查询的。</p>
<h3 id="entitytransaction"><a class="header" href="#entitytransaction">EntityTransaction</a></h3>
<pre><code class="language-java">@BeforeEach
    public void init(){
        entityManagerFactory = Persistence.createEntityManagerFactory(&quot;default&quot;);
        entityManager = entityManagerFactory.createEntityManager();
        entityTransaction = entityManager.getTransaction();
        // 开启事务
        entityTransaction.begin();
    }

    @AfterEach
    public void destroy(){
        
        entityTransaction.rollback();  // 回滚事务
//        entityTransaction.commit(); // 提交事务
        System.out.println(&quot;entityTransaction is active? &quot; + entityTransaction.isActive()); // false
        entityManager.close();
        entityManagerFactory.close();
    }
</code></pre>
<p>事务，要么提交，要么回滚，不能同时存在。提交或回滚后，事务就 isNotActive 了。</p>
<h2 id="springdata-repositories"><a class="header" href="#springdata-repositories">springdata-repositories</a></h2>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210531170125902.png" alt="image-20210531170125902" style="zoom:80%;" />
<p>The central interface in the Spring Data repository abstraction is <code>Repository</code>. It takes the domain class to manage as well as the ID type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extend this one. The <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html"><code>CrudRepository</code></a> interface provides sophisticated CRUD functionality for the entity class that is being managed.</p>
<h3 id="crudrepository"><a class="header" href="#crudrepository">CrudRepository</a></h3>
<pre><code class="language-java">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

  &lt;S extends T&gt; S save(S entity);      // Saves the given entity.

  Optional&lt;T&gt; findById(ID primaryKey); // 

  Iterable&lt;T&gt; findAll();               

  long count();                        

  void delete(T entity);               

  boolean existsById(ID primaryKey);   

  // … more functionality omitted.
}
</code></pre>
<h3 id="pagingandsortingrepository"><a class="header" href="#pagingandsortingrepository">PagingAndSortingRepository</a></h3>
<p>支持分页。</p>
<pre><code class="language-java">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
}

PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(PageRequest.of(1, 20));
</code></pre>
<h3 id="jparepository"><a class="header" href="#jparepository">JpaRepository</a></h3>
<p>继承自 PagingAndSortingRepository 接口，支持分页。</p>
<pre><code class="language-java">public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; {
    List&lt;T&gt; findAll();

    List&lt;T&gt; findAll(Sort var1);

    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1);

    &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);

    void flush();

    &lt;S extends T&gt; S saveAndFlush(S var1);

    void deleteInBatch(Iterable&lt;T&gt; var1);

    void deleteAllInBatch();

    T getOne(ID var1);

    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1);

    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);
}
</code></pre>
<h3 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h3>
<p>创建 Query Methods 的四个步骤：</p>
<ol>
<li>
<p>Declare an interface extending Repository or one of its subinterfaces and type it to the domain class and ID type that it should handle, as shown in the following example:</p>
<pre><code class="language-java">interface PersonRepository extends Repository&lt;Person, Long&gt; { … }
</code></pre>
</li>
<li>
<p>Declare query methods on the interface.</p>
<pre><code class="language-java">interface PersonRepository extends Repository&lt;Person, Long&gt; {
  List&lt;Person&gt; findByLastname(String lastname);
}
</code></pre>
</li>
<li>
<p>Set up Spring to create proxy instances for those interfaces, either with <a href="https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#repositories.create-instances.java-config">JavaConfig</a> or with <a href="https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#repositories.create-instances">XML configuration</a>.</p>
<pre><code class="language-java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories
class Config { … }
</code></pre>
</li>
<li>
<p>Inject the repository instance and use it, as shown in the following example:</p>
<pre><code class="language-java">class SomeClient {

  private final PersonRepository repository;

  SomeClient(PersonRepository repository) {
    this.repository = repository;
  }

  void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname(&quot;Matthews&quot;);
  }
}
</code></pre>
</li>
</ol>
<h3 id="defining-repository-interfaces"><a class="header" href="#defining-repository-interfaces">Defining Repository Interfaces</a></h3>
<p>如何定义 repository 接口</p>
<p>To define a repository interface, you first need to define a domain class-specific repository interface. The interface must extend <code>Repository</code> and be typed to the domain class and an ID type. If you want to expose CRUD methods for that domain type, extend <code>CrudRepository</code> instead of <code>Repository</code>.</p>
<h3 id="defining-query-methods"><a class="header" href="#defining-query-methods">Defining Query Methods</a></h3>
<p>有两种定义 Query Methods 的方法</p>
<p>The repository proxy has two ways to derive a store-specific query from the method name:</p>
<ul>
<li>By deriving the query from the method name directly. 采用函数名的方式</li>
<li>By using a manually defined query. 写 JPQL</li>
</ul>
<h4 id="query-的查找策略"><a class="header" href="#query-的查找策略">Query 的查找策略</a></h4>
<p>With XML configuration, you can configure the strategy at the namespace through the <code>query-lookup-strategy</code> attribute. For Java configuration, you can use the <code>queryLookupStrategy</code> attribute of the <code>Enable${store}Repositories</code> annotation. Some strategies may not be supported for particular datastores.</p>
<h4 id="query-demos"><a class="header" href="#query-demos">Query Demos</a></h4>
<pre><code class="language-java">interface PersonRepository extends Repository&lt;Person, Long&gt; {

    // 注意，此处的参数就是方法名用到的参数
    List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

    // Enables the distinct flag for the query
    List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
    List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

    // Enabling ignoring case for an individual property
    List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
    // Enabling ignoring case for all suitable properties
    List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

    // Enabling static ORDER BY for a query
    List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
    List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
    
    /***
    * Limiting the result size of a query with Top and First
    */
    User findFirstByOrderByLastnameAsc();

    User findTopByOrderByAgeDesc();

    Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);

    Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);

    List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);

    List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);
}
</code></pre>
<p>Parsing query method names is divided into subject and predicate. The first part (<code>find…By</code>, <code>exists…By</code>) defines the subject of the query, the second part forms the predicate. </p>
<p>The first <code>By</code> acts as a delimiter to indicate the start of the actual criteria predicate. At a very basic level, you can define conditions on entity properties and concatenate them with <code>And</code> and <code>Or</code>.</p>
<p>JPA 根据函数名构造 SQL 查询：</p>
<table><thead><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Sample</th><th style="text-align: left">JPQL snippet</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Distinct</code></td><td style="text-align: left"><code>findDistinctByLastnameAndFirstname</code></td><td style="text-align: left"><code>select distinct … where x.lastname = ?1 and x.firstname = ?2</code></td></tr>
<tr><td style="text-align: left"><code>And</code></td><td style="text-align: left"><code>findByLastnameAndFirstname</code></td><td style="text-align: left"><code>… where x.lastname = ?1 and x.firstname = ?2</code></td></tr>
<tr><td style="text-align: left"><code>Or</code></td><td style="text-align: left"><code>findByLastnameOrFirstname</code></td><td style="text-align: left"><code>… where x.lastname = ?1 or x.firstname = ?2</code></td></tr>
<tr><td style="text-align: left"><code>Is</code>, <code>Equals</code></td><td style="text-align: left"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td><td style="text-align: left"><code>… where x.firstname = ?1</code></td></tr>
<tr><td style="text-align: left"><code>Between</code></td><td style="text-align: left"><code>findByStartDateBetween</code></td><td style="text-align: left"><code>… where x.startDate between ?1 and ?2</code></td></tr>
<tr><td style="text-align: left"><code>LessThan</code></td><td style="text-align: left"><code>findByAgeLessThan</code></td><td style="text-align: left"><code>… where x.age &lt; ?1</code></td></tr>
<tr><td style="text-align: left"><code>LessThanEqual</code></td><td style="text-align: left"><code>findByAgeLessThanEqual</code></td><td style="text-align: left"><code>… where x.age &lt;= ?1</code></td></tr>
<tr><td style="text-align: left"><code>GreaterThan</code></td><td style="text-align: left"><code>findByAgeGreaterThan</code></td><td style="text-align: left"><code>… where x.age &gt; ?1</code></td></tr>
<tr><td style="text-align: left"><code>GreaterThanEqual</code></td><td style="text-align: left"><code>findByAgeGreaterThanEqual</code></td><td style="text-align: left"><code>… where x.age &gt;= ?1</code></td></tr>
<tr><td style="text-align: left"><code>After</code></td><td style="text-align: left"><code>findByStartDateAfter</code></td><td style="text-align: left"><code>… where x.startDate &gt; ?1</code></td></tr>
<tr><td style="text-align: left"><code>Before</code></td><td style="text-align: left"><code>findByStartDateBefore</code></td><td style="text-align: left"><code>… where x.startDate &lt; ?1</code></td></tr>
<tr><td style="text-align: left"><code>IsNull</code>, <code>Null</code></td><td style="text-align: left"><code>findByAge(Is)Null</code></td><td style="text-align: left"><code>… where x.age is null</code></td></tr>
<tr><td style="text-align: left"><code>IsNotNull</code>, <code>NotNull</code></td><td style="text-align: left"><code>findByAge(Is)NotNull</code></td><td style="text-align: left"><code>… where x.age not null</code></td></tr>
<tr><td style="text-align: left"><code>Like</code></td><td style="text-align: left"><code>findByFirstnameLike</code></td><td style="text-align: left"><code>… where x.firstname like ?1</code></td></tr>
<tr><td style="text-align: left"><code>NotLike</code></td><td style="text-align: left"><code>findByFirstnameNotLike</code></td><td style="text-align: left"><code>… where x.firstname not like ?1</code></td></tr>
<tr><td style="text-align: left"><code>StartingWith</code></td><td style="text-align: left"><code>findByFirstnameStartingWith</code></td><td style="text-align: left"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</td></tr>
<tr><td style="text-align: left"><code>EndingWith</code></td><td style="text-align: left"><code>findByFirstnameEndingWith</code></td><td style="text-align: left"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</td></tr>
<tr><td style="text-align: left"><code>Containing</code></td><td style="text-align: left"><code>findByFirstnameContaining</code></td><td style="text-align: left"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</td></tr>
<tr><td style="text-align: left"><code>OrderBy</code></td><td style="text-align: left"><code>findByAgeOrderByLastnameDesc</code></td><td style="text-align: left"><code>… where x.age = ?1 order by x.lastname desc</code></td></tr>
<tr><td style="text-align: left"><code>Not</code></td><td style="text-align: left"><code>findByLastnameNot</code></td><td style="text-align: left"><code>… where x.lastname &lt;&gt; ?1</code></td></tr>
<tr><td style="text-align: left"><code>In</code></td><td style="text-align: left"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td><td style="text-align: left"><code>… where x.age in ?1</code></td></tr>
<tr><td style="text-align: left"><code>NotIn</code></td><td style="text-align: left"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td><td style="text-align: left"><code>… where x.age not in ?1</code></td></tr>
<tr><td style="text-align: left"><code>True</code></td><td style="text-align: left"><code>findByActiveTrue()</code></td><td style="text-align: left"><code>… where x.active = true</code></td></tr>
<tr><td style="text-align: left"><code>False</code></td><td style="text-align: left"><code>findByActiveFalse()</code></td><td style="text-align: left"><code>… where x.active = false</code></td></tr>
<tr><td style="text-align: left"><code>IgnoreCase</code></td><td style="text-align: left"><code>findByFirstnameIgnoreCase</code></td><td style="text-align: left"><code>… where UPPER(x.firstname) = UPPER(?1)</code></td></tr>
</tbody></table>
<p><strong>根据属性的属性进行查找</strong></p>
<p>x.address.zipCode</p>
<pre><code class="language-java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
</code></pre>
<p><strong>list 作为参数</strong></p>
<pre><code class="language-java">@Query(&quot;select c from Concept c where c.id in ?1&quot;)
List&lt;Concept&gt; findByIds(List idList);
</code></pre>
<h4 id="pageable--page"><a class="header" href="#pageable--page">Pageable / Page</a></h4>
<p><strong>Demo</strong>:</p>
<pre><code class="language-java">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);
</code></pre>
<p><strong>Page</strong>:</p>
<p>Page 中封装了当前页的内容，和总页数。</p>
<pre><code class="language-java">public interface Page&lt;T&gt; extends Slice&lt;T&gt; {
    static &lt;T&gt; Page&lt;T&gt; empty() {
        return empty(Pageable.unpaged());
    }

    static &lt;T&gt; Page&lt;T&gt; empty(Pageable pageable) {
        return new PageImpl(Collections.emptyList(), pageable, 0L);
    }

    int getTotalPages();

    long getTotalElements();

    &lt;U&gt; Page&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; var1);
}
</code></pre>
<p><strong>Pageable</strong>:</p>
<p>Pageable 中封装了分页的规则，Pageable 的构建 <code>PageRequest.of</code></p>
<pre><code class="language-java">private Pageable getPageable(PageBean pageBean){
    // 默认根据 name 进行 desc 排序
    Sort sort = Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD);
    if(StringUtils.isNotBlank(pageBean.getSortField())) {
        if (StringUtils.isNotBlank(pageBean.getSortOrder()) &amp;&amp; pageBean.getSortOrder().equalsIgnoreCase(&quot;desc&quot;)) {
            sort = Sort.by(Sort.Direction.DESC, pageBean.getSortField());
        } else {
            sort = Sort.by(Sort.Direction.ASC, pageBean.getSortField());
        }
    }
    // 索引页从 0 开始，故需要 - 1
    int page = (int)pageBean.getCurrentPage() - 1;
    int size = (int)pageBean.getPageSize();
    return PageRequest.of(page, size, sort);
}
</code></pre>
<h4 id="sort-1"><a class="header" href="#sort-1">Sort</a></h4>
<p>Defining sort expressions:</p>
<pre><code class="language-java">Sort sort = Sort.by(&quot;firstname&quot;).ascending()
  .and(Sort.by(&quot;lastname&quot;).descending());
</code></pre>
<p>Defining sort expressions by using the type-safe API:</p>
<pre><code class="language-java">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);

Sort sort = person.by(Person::getFirstname).ascending()
    .and(person.by(Person::getLastname).descending());
</code></pre>
<h4 id="null-处理"><a class="header" href="#null-处理">null 处理</a></h4>
<p>As of Spring Data 2.0, repository CRUD methods that return an individual aggregate instance use Java 8’s <code>Optional</code> to indicate the potential absence of a value. </p>
<p>Repository methods returning collections, collection alternatives, wrappers, and streams are guaranteed never to return <code>null</code> but rather the corresponding empty representation. See “<a href="https://docs.spring.io/spring-data/jpa/docs/2.5.0/reference/html/#repository-query-return-types">Repository query return types</a>” for details.</p>
<p>三个常见的 null 注解：</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: Used on the package level to declare that the default behavior for parameters and return values is, respectively, neither to accept nor to produce <code>null</code> values.</li>
<li><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>: Used on a parameter or return value that must not be <code>null</code> (not needed on a parameter and return value where <code>@NonNullApi</code> applies).</li>
<li><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: Used on a parameter or return value that can be <code>null</code>.</li>
</ul>
<p><strong>Using different nullability constraints</strong> Demo：</p>
<pre><code class="language-java">package com.acme;                            // 1                           

import org.springframework.lang.Nullable;

interface UserRepository extends Repository&lt;User, Long&gt; {

  User getByEmailAddress(EmailAddress emailAddress);    // 2                 

  @Nullable
  User findByEmailAddress(@Nullable EmailAddress emailAdress); // 3         

  Optional&lt;User&gt; findOptionalByEmailAddress(EmailAddress emailAddress); // 4
}
</code></pre>
<ol>
<li>The repository resides in a package (or sub-package) for which we have defined non-null behavior</li>
<li>Throws an <code>EmptyResultDataAccessException</code> when the query does not produce a result. Throws an <code>IllegalArgumentException</code> when the <code>emailAddress</code> handed to the method is <code>null</code>.</li>
<li>Returns <code>null</code> when the query does not produce a result. Also accepts <code>null</code> as the value for <code>emailAddress</code>.</li>
<li>Returns <code>Optional.empty()</code> when the query does not produce a result. Throws an <code>IllegalArgumentException</code> when the <code>emailAddress</code> handed to the method is <code>null</code>.</li>
</ol>
<h4 id="streaming-query-results"><a class="header" href="#streaming-query-results">Streaming Query Results</a></h4>
<pre><code class="language-java">@Query(&quot;select u from User u&quot;)
Stream&lt;User&gt; findAllByCustomQueryAndStream();

Stream&lt;User&gt; readAllByFirstnameNotNull();

@Query(&quot;select u from User u&quot;)
Stream&lt;User&gt; streamAllPaged(Pageable pageable);
</code></pre>
<h3 id="creating-repository-instances"><a class="header" href="#creating-repository-instances">Creating Repository Instances</a></h3>
<p>创建 Repository 对象</p>
<ol>
<li>
<p>直接在 config 中批量注入</p>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(&quot;com.acme.repositories&quot;) // 指定 repostory 类的位置
class ApplicationConfiguration {

  @Bean
  EntityManagerFactory entityManagerFactory() {
    // …
  }
}
</code></pre>
</li>
<li>
<p>单独创建</p>
<pre><code class="language-java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);



</code></pre>
</li>
</ol>
<h2 id="jpa-repositories"><a class="header" href="#jpa-repositories">JPA Repositories</a></h2>
<p>This chapter points out the specialties for repository support for JPA.</p>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan(&quot;com.acme.domain&quot;);
    factory.setDataSource(dataSource());
    return factory;
  }

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    return txManager;
  }
}
</code></pre>
<h3 id="persist"><a class="header" href="#persist">persist</a></h3>
<p>Saving an entity can be performed with the <code>CrudRepository.save(…)</code> method. It <strong>persists</strong> or <strong>merges</strong> the given entity by using the underlying JPA <code>EntityManager</code>. If the entity has not yet been persisted, Spring Data JPA saves the entity with a call to the <code>entityManager.persist(…)</code> method. Otherwise, it calls the <code>entityManager.merge(…)</code> method.</p>
<h3 id="query-creation"><a class="header" href="#query-creation">Query creation</a></h3>
<h4 id="create-query"><a class="header" href="#create-query">create query</a></h4>
<ol>
<li>
<p>Query creation from method names</p>
<pre><code class="language-java">public interface UserRepository extends Repository&lt;User, Long&gt; {

  List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);
}
</code></pre>
</li>
<li>
<p>@Query</p>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(&quot;select u from User u where u.firstname like %?1&quot;)
  List&lt;User&gt; findByFirstnameEndsWith(String firstname);
}
</code></pre>
<p>2.1 native query</p>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)
  User findByEmailAddress(String emailAddress);
}
</code></pre>
</li>
</ol>
<p>Demo: declare native count queries for pagination at the query method by using <code>@Query</code></p>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = &quot;SELECT * FROM USERS WHERE LASTNAME = ?1&quot;,
    countQuery = &quot;SELECT count(*) FROM USERS WHERE LASTNAME = ?1&quot;,
    nativeQuery = true)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}
</code></pre>
<h4 id="sort-2"><a class="header" href="#sort-2">sort</a></h4>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(&quot;select u from User u where u.lastname like ?1%&quot;)
  List&lt;User&gt; findByAndSort(String lastname, Sort sort);

  @Query(&quot;select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%&quot;)
  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);
}

repo.findByAndSort(&quot;lannister&quot;, Sort.by(&quot;firstname&quot;));           //1     
repo.findByAndSort(&quot;stark&quot;, Sort.by(&quot;LENGTH(firstname)&quot;));          //2  
repo.findByAndSort(&quot;targaryen&quot;, JpaSort.unsafe(&quot;LENGTH(firstname)&quot;)); //3
repo.findByAsArrayAndSort(&quot;bolton&quot;, Sort.by(&quot;fn_len&quot;));      //4
</code></pre>
<ol>
<li>Valid <code>Sort</code> expression pointing to property in domain model.</li>
<li>Invalid <code>Sort</code> containing function call. Throws Exception.</li>
<li>Valid <code>Sort</code> containing explicitly <em>unsafe</em> <code>Order</code>.</li>
<li>Valid <code>Sort</code> expression pointing to aliased function.</li>
</ol>
<h4 id="using-named-parameters"><a class="header" href="#using-named-parameters">Using Named Parameters</a></h4>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;)
  User findByLastnameOrFirstname(@Param(&quot;lastname&quot;) String lastname,
                                 @Param(&quot;firstname&quot;) String firstname);
}
</code></pre>
<h4 id="specifications"><a class="header" href="#specifications">Specifications</a></h4>
<p>JPA 2 introduces a criteria API that you can use to build queries programmatically. By writing a <code>criteria</code>, you define the where clause of a query for a domain class. Taking another step back, these criteria can be regarded as a predicate over the entity that is described by the JPA criteria API constraints.</p>
<p>Spring Data JPA takes the concept of a specification from Eric Evans' book, “Domain Driven Design”, following the same semantics and providing an API to define such specifications with the JPA criteria API. To support specifications, you can extend your repository interface with the <code>JpaSpecificationExecutor</code> interface, as follows:</p>
<pre><code class="language-java">public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; {
 …
}
</code></pre>
<p>The additional interface has methods that let you run specifications in a variety of ways. For example, the <code>findAll</code> method returns all entities that match the specification, as shown in the following example:</p>
<pre><code class="language-java">List&lt;T&gt; findAll(Specification&lt;T&gt; spec);
</code></pre>
<p>The <code>Specification</code> interface is defined as follows:</p>
<pre><code class="language-java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}
</code></pre>
<h2 id="foreign-key"><a class="header" href="#foreign-key">foreign key</a></h2>
<p>代码：https://github.com/wansho/jpa</p>
<h3 id="onetoone"><a class="header" href="#onetoone">OneToOne</a></h3>
<h3 id="单向-manytoone"><a class="header" href="#单向-manytoone">单向 ManyToOne</a></h3>
<h3 id="单向-onetomany"><a class="header" href="#单向-onetomany">单向 OneToMany</a></h3>
<h3 id="双向-onetomany"><a class="header" href="#双向-onetomany">双向 OneToMany</a></h3>
<p>注意</p>
<ul>
<li>双向 OneToMany 和 双向 ManyToOne 是一样的</li>
<li>双向的列名外键的 name 要保持一致</li>
<li>如果在 1 的一端 <code>@OneToMany</code> 中使用了 <code>mapperBy</code> 属性，则 <code>@OneToMany</code> 端就不能再使用 <code>@JoinColumn</code> 属性</li>
</ul>
<h3 id="双向-manytomany"><a class="header" href="#双向-manytomany">双向 ManyToMany</a></h3>
<p>必须指定一个关系维护端（Owner Side 中间表），可以通过 <code>@ManyToMany</code> 注释中指定 <code>mappedBy</code> 属性来标识其为关系维护端。</p>
<h2 id="java-persistence-query-language"><a class="header" href="#java-persistence-query-language">Java Persistence Query Language</a></h2>
<h3 id="query-interface"><a class="header" href="#query-interface">Query Interface</a></h3>
<p>Interface used to control query execution.</p>
<p>Query 接口封装了执行数据库查询的相关方法。</p>
<p>获取 Query 对象的方法，是调用 EntityManager 的 createQuery，createNamedQuery，createNativeQuery 方法获取查询对象。</p>
<p>详细的 Query Language 语法和例子，参考 [Jakarta Persistence] 的第四章，Query Language。</p>
<pre><code>A select statement is a string which consists of the following clauses:
• a SELECT clause, which determines the type of the objects or values to be selected.
• a FROM clause, which provides declarations that designate the domain to which the expressions
specified in the other clauses of the query apply.
• an optional WHERE clause, which may be used to restrict the results that are returned by the
query.
• an optional GROUP BY clause, which allows query results to be aggregated in terms of groups.
• an optional HAVING clause, which allows filtering over aggregated groups.
• an optional ORDER BY clause, which may be used to order the results that are returned by the
query.
</code></pre>
<h2 id="criteria-api"><a class="header" href="#criteria-api">criteria-api</a></h2>
<p>The basic semantics of a Criteria query consists of a <code>SELECT</code> clause, a <code>FROM</code> clause, and an optional <code>WHERE</code> clause, similar to a JPQL query. Criteria queries set these clauses by using Java programming language objects, so the query can be created in a typesafe manner.</p>
<p>The Jakarta Persistence Criteria API is used to define queries through the construction of object-based query definition objects, rather than use of the string-based approach of the Jakarta Persistence query language. 动态查询机制。</p>
<p>只需要 root 和 criteriabuilder 两个就够了，root 用来构造属性，criteriabuilder 用来构造查询。</p>
<h3 id="maven"><a class="header" href="#maven">maven</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;   
    &lt;version&gt;5.3.2.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="criteriabuilder"><a class="header" href="#criteriabuilder">CriteriaBuilder</a></h3>
<p>查询的构造器，封装了很多查询条件，用于构造查询条件</p>
<p>The <code>javax.persistence.criteria.CriteriaBuilder</code> interface is used to construct</p>
<ul>
<li>Criteria queries</li>
<li>Selections</li>
<li>Expressions</li>
<li>Predicates</li>
<li>Ordering</li>
</ul>
<p>init CriteriaBuilder: </p>
<pre><code class="language-java">EntityManager em = ...;
CriteriaBuilder cb = em.getCriteriaBuilder();
</code></pre>
<h3 id="criteriaquery"><a class="header" href="#criteriaquery">CriteriaQuery</a></h3>
<p>顶层查询对象，自定义查询方式（了解，一般不用）</p>
<p>get CriteriaQuery:</p>
<pre><code class="language-java">CriteriaQuery&lt;Pet&gt; cq = cb.createQuery(Pet.class);
</code></pre>
<h3 id="root"><a class="header" href="#root">Root</a></h3>
<p>代表查询的根对象（查询的任何属性都可以从根对象中获取）</p>
<p>For a particular <code>CriteriaQuery</code> object, the root entity of the query, from which all navigation originates, is called the <strong>query root</strong>. It is similar to the <code>FROM</code> clause in a JPQL query.</p>
<p>Create the query root by calling the <code>from</code> method on the <code>CriteriaQuery</code> instance. The argument to the <code>from</code> method is either the entity class or an <code>EntityType&lt;T&gt;</code> instance for the entity.</p>
<p>The following code sets the query root to the <code>Pet</code> entity:</p>
<pre><code class="language-java">CriteriaQuery&lt;Pet&gt; cq = cb.createQuery(Pet.class);
Root&lt;Pet&gt; pet = cq.from(Pet.class);
</code></pre>
<p>The following code sets the query root to the <code>Pet</code> class by using an <code>EntityType&lt;T&gt;</code> instance:</p>
<pre><code class="language-java">EntityManager em = ...;
Metamodel m = em.getMetamodel();
EntityType&lt;Pet&gt; Pet_ = m.entity(Pet.class);
Root&lt;Pet&gt; pet = cq.from(Pet_);
</code></pre>
<h3 id="example-using-criteria"><a class="header" href="#example-using-criteria">example using criteria</a></h3>
<pre><code class="language-java">
public class Item implements Serializable {

    private Integer itemId;
    private String itemName;
    private String itemDescription;
    private Integer itemPrice;

   // standard setters and getters
}


Session session = HibernateUtil.getHibernateSession();
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item.class);
Root&lt;Item&gt; root = cr.from(Item.class);
cr.select(root);

Query&lt;Item&gt; query = session.createQuery(cr);
List&lt;Item&gt; results = query.getResultList();
</code></pre>
<h4 id="using-expressions"><a class="header" href="#using-expressions">Using Expressions</a></h4>
<p>To get items having a price of more than 1000:</p>
<pre><code class="language-java">cr.select(root).where(cb.gt(root.get(&quot;itemPrice&quot;), 1000));
</code></pre>
<p>Next, getting items having <em>itemPrice</em> less than 1000:</p>
<pre><code class="language-java">cr.select(root).where(cb.lt(root.get(&quot;itemPrice&quot;), 1000));
</code></pre>
<p>Items having <em>itemName</em> contain <em>Chair</em>:</p>
<pre><code class="language-java">cr.select(root).where(cb.like(root.get(&quot;itemName&quot;), &quot;%chair%&quot;));
</code></pre>
<p>Records having <em>itemPrice</em> in between 100 and 200:</p>
<pre><code class="language-java">cr.select(root).where(cb.between(root.get(&quot;itemPrice&quot;), 100, 200));
</code></pre>
<p>Items having <em>itemName</em> in <em>Skate Board, Paint</em> and <em>Glue</em>:</p>
<pre><code class="language-java">cr.select(root).where(root.get(&quot;itemName&quot;).in(&quot;Skate Board&quot;, &quot;Paint&quot;, &quot;Glue&quot;));
</code></pre>
<p>To check if the given property is null:</p>
<pre><code class="language-java">cr.select(root).where(cb.isNull(root.get(&quot;itemDescription&quot;)));
</code></pre>
<p>To check if the given property is not null:</p>
<pre><code class="language-java">cr.select(root).where(cb.isNotNull(root.get(&quot;itemDescription&quot;)));
</code></pre>
<p><strong>chain expressions</strong>:</p>
<pre><code class="language-java">Predicate[] predicates = new Predicate[2];
predicates[0] = cb.isNull(root.get(&quot;itemDescription&quot;));
predicates[1] = cb.like(root.get(&quot;itemName&quot;), &quot;chair%&quot;);
cr.select(root).where(predicates);
</code></pre>
<p>To add two expressions with logical operations:</p>
<pre><code class="language-java">Predicate greaterThanPrice = cb.gt(root.get(&quot;itemPrice&quot;), 1000);
Predicate chairItems = cb.like(root.get(&quot;itemName&quot;), &quot;Chair%&quot;);
</code></pre>
<p>Items with the above-defined conditions joined with <em>Logical OR</em>:</p>
<pre><code class="language-java">cr.select(root).where(cb.or(greaterThanPrice, chairItems));
</code></pre>
<p>To get items matching with the above-defined conditions joined with <em>Logical AND</em>:</p>
<pre><code class="language-java">cr.select(root).where(cb.and(greaterThanPrice, chairItems));
</code></pre>
<h4 id="sorting-1"><a class="header" href="#sorting-1">sorting</a></h4>
<pre><code class="language-java">cr.orderBy(
  cb.asc(root.get(&quot;itemName&quot;)), 
  cb.desc(root.get(&quot;itemPrice&quot;)));
</code></pre>
<h4 id="projections-aggregates-and-grouping-functions"><a class="header" href="#projections-aggregates-and-grouping-functions">projections, aggregates, and grouping functions</a></h4>
<p><strong>count</strong></p>
<pre><code class="language-java">CriteriaQuery&lt;Long&gt; cr = cb.createQuery(Long.class);
Root&lt;Item&gt; root = cr.from(Item.class);
cr.select(cb.count(root));
Query&lt;Long&gt; query = session.createQuery(cr);
List&lt;Long&gt; itemProjected = query.getResultList();
</code></pre>
<p><strong><em>Aggregate</em> function for Average</strong></p>
<pre><code class="language-java">CriteriaQuery&lt;Double&gt; cr = cb.createQuery(Double.class);
Root&lt;Item&gt; root = cr.from(Item.class);
cr.select(cb.avg(root.get(&quot;itemPrice&quot;)));
Query&lt;Double&gt; query = session.createQuery(cr);
List avgItemPriceList = query.getResultList();
</code></pre>
<p>Other useful aggregate methods that are available are <em>sum()</em>, <em>max()</em>, <em>min()</em> <strong>,</strong> <em>count()</em> etc.</p>
<h2 id="specifications-1"><a class="header" href="#specifications-1">Specifications</a></h2>
<p>Specification 是 Spring 框架的一部分，是 Spring 对 Criteria API （root，criteria）的封装</p>
<p>JPA 2 introduces a criteria API that you can use to build queries programmatically. By writing a <code>criteria</code>, you define the <strong>where clause</strong> of a query for a domain class. Taking another step back, these criteria can be regarded as a <strong>predicate</strong> over the entity that is described by the JPA criteria API constraints.</p>
<p>The <strong>power of specifications</strong> really shines when you combine them to create new <code>Specification</code> objects.</p>
<p><code>Specification</code> offers some “glue-code” default methods to chain and combine <code>Specification</code> instances. These methods let you extend your data access layer by creating new <code>Specification</code> implementations and combining them with already existing implementations.</p>
<p>Although this approach（直接按照规则写接口，不实现的方式） is really convenient (you don’t even have to write a single line of implementation code to get the queries executed) it has two drawbacks: first, the number of query methods might grow for larger applications because of - and that’s the second point - the queries define a fixed set of criterias. To avoid these two drawbacks, wouldn’t it be cool if you could come up with a set of atomic predicates that you could combine dynamically to build your query?</p>
<p>想要引入 Specifications 特性，必须继承 <code>JpaSpecificationExecutor</code> 接口。</p>
<p><strong>Specification</strong> 是一个函数式接口</p>
<pre><code class="language-java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}
</code></pre>
<p>Demo: Specifications for a Customer</p>
<pre><code class="language-java">public class CustomerSpecs {

  public static Specification&lt;Customer&gt; isLongTermCustomer() {
    return (root, query, builder) -&gt; {
      LocalDate date = LocalDate.now().minusYears(2);
      return builder.lessThan(root.get(Customer_.createdAt), date);
    };
  }

  public static Specification&lt;Customer&gt; hasSalesOfMoreThan(MonetaryAmount value) {
    return (root, query, builder) -&gt; {
      // build query here
    };
  }
}
</code></pre>
<pre><code class="language-java">// Using a simple Specification
List&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());

// Combined Specifications
MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
List&lt;Customer&gt; customers = customerRepository.findAll(
  isLongTermCustomer().or(hasSalesOfMoreThan(amount)));
</code></pre>
<p>Another Demo：</p>
<pre><code class="language-java">private Specification&lt;EntityGraph&gt; getSpecification(PageBean pageBean) {
        return (root, query, criteriaBuilder) -&gt; {
            List&lt;Predicate&gt; predicateList = new ArrayList&lt;&gt;();
            if(StringUtils.isNotEmpty(pageBean.getFilterValue())){
                predicateList.add(criteriaBuilder.equal(root.get(DEFAULT_FILTER_FIELD), pageBean.getFilterValue()));
            }
            return criteriaBuilder.and(predicateList.toArray(new Predicate[0]));
        };
    }
</code></pre>
<p>root 负责取成员变量，query 是 CriteriaQuery 类型，负责生成 root，criteriaBuilder 是 CriteriaBuilder 类型</p>
<h2 id="jpa-实现"><a class="header" href="#jpa-实现">jpa 实现</a></h2>
<h3 id="hibernate-1"><a class="header" href="#hibernate-1">Hibernate</a></h3>
<p>常见配置：</p>
<pre><code class="language-yml">jpa:
    database: mysql
    show-sql: true
    properties:
      hibernate:
        hbm2ddl:
          # 自动更新维护表结构
          auto: update
        dialect: org.hibernate.dialect.MySQL55Dialect
        format_sql: true # 对 sql 进行格式化
    open-in-view: false
</code></pre>
<h2 id="join-in-jpa"><a class="header" href="#join-in-jpa">join in jpa</a></h2>
<h2 id="questions-6"><a class="header" href="#questions-6">Questions</a></h2>
<ul>
<li>
<p>@LastModifiedDate 不起作用的解决方法</p>
<p>在实体中添加注解 @EntityListeners(AuditingEntityListener.class)监听实体变化</p>
<p>在自动更新时间戳字段增加 @LastModifiedDate</p>
<p>在Spring boot启动类增加注解 @EnableJpaAuditing启用JPA审计(自动填充默认值)</p>
</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mybatis"><a class="header" href="#mybatis">Mybatis</a></h1>
<p>[TOC]</p>
<h2 id="mybatis-hibernate-比较"><a class="header" href="#mybatis-hibernate-比较">mybatis hibernate 比较</a></h2>
<p>hibernate 是全自动框架，mybatis 是半自动轻量级框架。</p>
<p>全自动框架的缺点：黑箱操作，无法优化 sql 语句。</p>
<p>mybatis：sql 语句交给开发人员编写（将与数据库交互的命脉，交给开发人员，而不是全自动框架）。</p>
<h2 id="mybatis-编程注意事项"><a class="header" href="#mybatis-编程注意事项">mybatis 编程注意事项</a></h2>
<ul>
<li>selectBatchIds 会被映射成 where id in ()，所以传入的查询参数 list 不能为空，否则会报异常</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-bean"><a class="header" href="#java-bean">java bean</a></h1>
<p>[TOC]</p>
<p><a href="https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans">stackoverflow</a></p>
<h2 id="javabean"><a class="header" href="#javabean">JavaBean</a></h2>
<p>A JavaBean is a class that follows <a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">the JavaBeans conventions</a> as defined by Sun. Wikipedia has a pretty good summary of what <a href="http://en.wikipedia.org/wiki/JavaBean">JavaBeans</a> are:</p>
<blockquote>
<p>JavaBeans are reusable software components for Java that can be manipulated visually in a builder tool. Practically, they are classes written in the Java programming language conforming to a particular convention. They are used to encapsulate many objects into a single object (the bean), so that they can be passed around as a single bean object instead of as multiple individual objects. A JavaBean is a Java Object that is serializable, has a nullary constructor, and allows access to properties using getter and setter methods.</p>
<p>In order to function as a JavaBean class, an object class must obey certain conventions about method naming, construction, and behavior. These conventions make it possible to have tools that can use, reuse, replace, and connect JavaBeans.</p>
<p>The required conventions are:</p>
<ul>
<li>The class must have a public default constructor. This allows easy instantiation within editing and activation frameworks.</li>
<li>The class properties must be accessible using get, set, and other methods (so-called accessor methods and mutator methods), following a standard naming convention. This allows easy automated inspection and updating of bean state within frameworks, many of which include custom editors for various types of properties.</li>
<li>The class should be serializable. This allows applications and frameworks to reliably save, store, and restore the bean's state in a fashion that is independent of the VM and platform.</li>
</ul>
<p>Because these requirements are largely expressed as conventions rather than by implementing interfaces, some developers view JavaBeans as Plain Old Java Objects that follow specific naming conventions.</p>
</blockquote>
<p>JavaBean 必须有一个公开的无参构造方法，必须可以被序列化，必须有 get set 方法。可以实现接口，可以集成某一个类。</p>
<pre><code class="language-java">public class PersonBean implements java.io.Serializable {

    /** Properties **/
    private boolean deceased = false;

    private List list;

    /** Property &quot;name&quot;, readable/writable. */
    private String name = null;

    /** No-arg constructor (takes no arguments). */
    public PersonBean() {
    }

    public List getList() {
        return list;
    }
	
    public void setList(final List list) {
        this.list = list;
    }

    /**
     * Getter for property &quot;name&quot;.
     */
    public String getName() {
        return name;
    }

    /**
     * Setter for property &quot;name&quot;.
     *
     * @param value
     */
    public void setName(final String value) {
        this.name = value;
    }

    /**
     * Getter for property &quot;deceased&quot;
     * Different syntax for a boolean field (is v.s. get)
     */
    public boolean isDeceased() {
        return deceased;
    }

    /**
     * Setter for property &quot;deceased&quot;.
     * @param value
     */
    public void setDeceased(boolean value) {
        deceased = value;
    }
}
</code></pre>
<h2 id="pojo"><a class="header" href="#pojo">POJO</a></h2>
<p>A Plain Old Java Object or POJO is a term initially introduced to designate a simple lightweight Java object, not implementing any <code>javax.ejb</code> interface, as opposed to heavyweight EJB 2.x (especially Entity Beans, Stateless Session Beans are not that bad IMO). Today, the term is used for any simple object with no extra stuff. Again, Wikipedia does a good job at defining <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a>:</p>
<blockquote>
<p>POJO is an acronym for Plain Old Java Object. The name is used to emphasize that the object in question is an ordinary Java Object, not a special object, and in particular not an Enterprise JavaBean (especially before EJB 3). The term was coined by Martin Fowler, Rebecca Parsons and Josh MacKenzie in September 2000:</p>
<blockquote>
<p><em>&quot;We wondered why people were so against using regular objects in their systems and concluded that it was because simple objects lacked a fancy name. So we gave them one, and it's caught on very nicely.&quot;</em></p>
</blockquote>
<p>The term continues the pattern of older terms for technologies that do not use fancy new features, such as POTS (Plain Old Telephone Service) in telephony, and PODS (Plain Old Data Structures) that are defined in C++ but use only C language features, and POD (Plain Old Documentation) in Perl.</p>
<p>The term has most likely gained widespread acceptance because of the need for a common and easily understood term that contrasts with complicated object frameworks. A JavaBean is a POJO that is serializable, has a no-argument constructor, and allows access to properties using getter and setter methods. An Enterprise JavaBean is not a single class but an entire component model (again, EJB 3 reduces the complexity of Enterprise JavaBeans).</p>
<p>As designs using POJOs have become more commonly-used, systems have arisen that give POJOs some of the functionality used in frameworks and more choice about which areas of functionality are actually needed. Hibernate and Spring are examples.</p>
</blockquote>
<p>一个轻量的 Java object，没有构造方法，不能继承，也不能实现任何接口，也不能加任何注解。要有 get set 方法。</p>
<pre><code class="language-java">public class MyBean {

    private String someProperty;

    public String getSomeProperty() {
         return someProperty;
    }

    public void setSomeProperty(String someProperty) {
        this.someProperty = someProperty;
    }
}
</code></pre>
<h2 id="dto"><a class="header" href="#dto">DTO</a></h2>
<p>In the field of programming a <strong>data transfer object</strong> (<strong>DTO</strong>[<a href="https://en.wikipedia.org/wiki/Data_transfer_object#cite_note-msdn-1">1]</a>[<a href="https://en.wikipedia.org/wiki/Data_transfer_object#cite_note-fowler-2">2]</a>) is an object that carries data between processes. The motivation for its use is that communication between processes is usually done resorting to remote interfaces (e.g., web services), where each call is an expensive operation.[<a href="https://en.wikipedia.org/wiki/Data_transfer_object#cite_note-fowler-2">2]</a> Because the majority of the cost of each call is related to the round-trip time between the client and the server, one way of reducing the number of calls is to use an object (the DTO) that aggregates the data that would have been transferred by the several calls, but that is served by one call only.[<a href="https://en.wikipedia.org/wiki/Data_transfer_object#cite_note-fowler-2">2]</a></p>
<p>The difference between data transfer objects and <a href="https://en.wikipedia.org/wiki/Business_object">business objects</a> or <a href="https://en.wikipedia.org/wiki/Data_access_object">data access objects</a> is that a DTO does not have any behavior except for storage, retrieval, serialization and deserialization of its own data (<a href="https://en.wikipedia.org/wiki/Mutator_method">mutators</a>, <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">accessors</a>, <a href="https://en.wikipedia.org/wiki/Parsing">parsers</a> and <a href="https://en.wikipedia.org/wiki/Serialization">serializers</a>). In other words, DTOs are simple objects that should not contain any business logic but may contain serialization and deserialization mechanisms for transferring data over the wire.</p>
<p><strong>DTO -</strong> Data transfer objects are just data containers which are used to transport data between layers and tiers.</p>
<ul>
<li>It mainly contains attributes. You can even use public attributes without getters and setters.</li>
<li>Data transfer objects do not contain any business logic.</li>
</ul>
<blockquote>
<p><strong>Analogy:</strong>
Simple Registration form with attributes username, password and email id.</p>
<ul>
<li>When this form is submitted in RegistrationServlet file you will get all the attributes from view layer to business layer where you pass the attributes to java beans and then to the DAO or the persistence layer.</li>
<li>DTO's helps in transporting the attributes from view layer to business layer and finally to the persistence layer.</li>
</ul>
</blockquote>
<p>DTO was mainly used to get data transported across the network efficiently, it may be even from JVM to another JVM.</p>
<p>DTOs are often <code>java.io.Serializable</code> - in order to transfer data across JVM.</p>
<p>DTO 用于在不同层、客户端服务端之间交换数据。DTO 对数据进行封装，这些就较少了调用次数。</p>
<p>DTO 只用来封装数据，不包含业务方法，只有 get，set 方法，序列化和反序列化方法。</p>
<p>DTO 主要用于服务端返回数据给客户端。</p>
<h2 id="qo"><a class="header" href="#qo">Qo</a></h2>
<p>Query Object，和 DTO 类似，同样用来封装数据。区别在于，Qo 主要用于封装客户端对后端的查询参数（比 DTO 多了 <code>@NotEmpty</code> 和 <code>@NotNull</code>）：</p>
<pre><code class="language-java">@Data
public class PermissionCheckQo {

    @ApiModelProperty(name=&quot;权限所在服务ID&quot;)
    @NotEmpty(message = &quot;服务ID不能为空&quot;)
    @NotNull(message = &quot;服务ID不能缺少&quot;)
    private String serviceId;

    @ApiModelProperty(name=&quot;权限表达式&quot;)
    @NotEmpty(message = &quot;权限表达式不能为空&quot;)
    @NotNull(message = &quot;权限表达式不能缺少&quot;)
    private String permission;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-1"><a class="header" href="#maven-1">Maven</a></h1>
<p>[TOC]</p>
<h2 id="参考文档"><a class="header" href="#参考文档">参考文档</a></h2>
<ul>
<li><a href="https://maven.apache.org/pom.html">maven 官方文档</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309301196980257">廖雪峰教程</a></li>
<li><a href="https://www.bilibili.com/video/BV1TW411g7hP">尚硅谷 maven 教程</a></li>
</ul>
<h2 id="经验总结-1"><a class="header" href="#经验总结-1">经验总结</a></h2>
<h3 id="scope-范围"><a class="header" href="#scope-范围">scope 范围</a></h3>
<ul>
<li>
<p>默认的 scope 是 compile，如果设置了 compile，那么该库的所有类，都会引入到当前的项目中。</p>
</li>
<li>
<p>对于所有的 maven 依赖包，都要<strong>显式</strong>地指定其依赖范围</p>
<p>例如 MySQL 的 jdbc 驱动 jar 包，如果没有配置其依赖范围，那么其代码就会被引入当前 IDE 中，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code>com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code>compile</code></p>
</li>
</ul>
<h3 id="把-jar-包导入-maven-仓库并引用"><a class="header" href="#把-jar-包导入-maven-仓库并引用">把 jar 包导入 maven 仓库并引用</a></h3>
<p>把 jar 包导入本地 maven 库：</p>
<pre><code class="language-shell">mvn install:install-file -DgroupId=com.jxdinfo -DartifactId=lcdp_push_sdk -Dversion=2.0.3 -Dpackaging=jar -Dfile=jar包地址

mvn install:install-file -DgroupId=org.elasticsearch.plugin -DartifactId=x-pack-sql-jdbc -Dversion=7.6.2 -Dpackaging=jar -Dfile=x-pack-sql-jdbc-7.6.2.jar
</code></pre>
<p>然后在 POM 文件中引用该 sdk：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.jxdinfo&lt;/groupId&gt;
    &lt;artifactId&gt;lcdp_push_sdk&lt;/artifactId&gt;
    &lt;version&gt;2.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="dependency-分析插件"><a class="header" href="#dependency-分析插件">dependency 分析插件</a></h3>
<p>IDEA Maven Helper</p>
<p>可以对依赖进行树形分析，并且可以直接搜索。</p>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>Maven是一个 Java 项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是 Java 项目不可缺少的工具。它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<p><strong>自动化构建工具历史</strong>：</p>
<p>Make -&gt; Ant -&gt; Maven -&gt; Gradle</p>
<h2 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h2>
<h3 id="构建是什么"><a class="header" href="#构建是什么">构建是什么</a></h3>
<p>构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为原材料，去生产出一个可以运行的项目的过程。</p>
<p><strong>编译结果和 web 工程的区别</strong>：</p>
<p>开发过程中,所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准的</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210609185021160.png" alt="image-20210609185021160" /></p>
<h3 id="构建中的各个环节"><a class="header" href="#构建中的各个环节">构建中的各个环节</a></h3>
<p><strong>清理</strong>：将以前编译得到的旧的 class 字节码文件删除,为下一次编译做准备</p>
<p><strong>编译</strong>：将 Java 源程序编程成 class 字节码文件</p>
<p><strong>测试</strong>：自动测试！自动调用 JUnit 程序进行测试。</p>
<p><strong>报告</strong>：测试程序执行的结果。</p>
<p><strong>打包</strong>：动态 Web 工程打 war 包，Java 工程打 jar 包。</p>
<p><strong>安装</strong>：Maven 特定的概念一将打包得到的文件复制到 &quot;仓库”中的指定位置</p>
<h4 id="部署"><a class="header" href="#部署">部署</a></h4>
<p>将动态 Web 工程生成的 war 包复制到 Servlet 容器的指定目录下,使其可以运行</p>
<h2 id="maven-的安装"><a class="header" href="#maven-的安装">Maven 的安装</a></h2>
<p>maven 依赖 JDK，而且是根据 JAVA_HOME 的环境变量找 JDK 的，所以 JAVA_HOME 就起到了配置 JDK 环境变量的作用。</p>
<h2 id="mvn-cmds"><a class="header" href="#mvn-cmds">mvn cmds</a></h2>
<p>运行Maven命令时一定要进入 pom.xml 文件所在的目录！</p>
<p>**Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。**而插件本身并不包含在Maven的核心程序中。当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。本地仓库的默认位置: <code>C:\USERS\USERNAME\.m2\repository</code>。Maven 核心程序如果在本地仓库中找不到需要的插件，那么它会到中央仓库下载。</p>
<h3 id="demos-3"><a class="header" href="#demos-3">demos</a></h3>
<pre><code class="language-shell"># Maven先执行 clean 生命周期并运行到 clean 这个 phase，然后执行 default 生命周期并运行到 package 这个 phase
mvn clean package

# 清理所有生成的class和jar
mvn clean 

# 先清理，再执行到compile；
mvn clean compile

# 先清理，再执行到package
mvn clean package

# 查看版本
mvn -v

</code></pre>
<h3 id="clean"><a class="header" href="#clean">clean</a></h3>
<h3 id="compile"><a class="header" href="#compile">compile</a></h3>
<p>编译主程序，还会执行测试。</p>
<h3 id="test-compile"><a class="header" href="#test-compile">test-compile</a></h3>
<p>编译测试程序</p>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p>执行测试</p>
<h3 id="package"><a class="header" href="#package">package</a></h3>
<p>打包。打包的时候会触发测试。</p>
<p>跳过测试的 pom 配置：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;skipTests&gt;true&lt;/skipTests&gt;
&lt;/properties&gt;
</code></pre>
<h3 id="install-1"><a class="header" href="#install-1">install</a></h3>
<p>安装</p>
<h3 id="deploy"><a class="header" href="#deploy">deploy</a></h3>
<p>部署</p>
<h2 id="maven-核心概念"><a class="header" href="#maven-核心概念">Maven 核心概念</a></h2>
<h3 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h3>
<p>一个标准的 Java Maven 项目（这是 maven 的标准！）：</p>
<pre><code>a-maven-project
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   ├── top.wansho.demo
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
</code></pre>
<p>约定 &gt; 配置 &gt; 编码，能配置，就不要编码。</p>
<h3 id="pom-文件"><a class="header" href="#pom-文件">POM 文件</a></h3>
<p>A Project Object Model（项目对象模型） or POM is the fundamental unit of work in Maven. It is an XML file that contains information about the project and configuration details used by Maven to build the project. It contains default values for most projects. </p>
<p>项目对象模型：将项目中的对象，封装成对象，然后作为一个模型来研究。</p>
<h3 id="坐标"><a class="header" href="#坐标">坐标</a></h3>
<p>一个 dependency 由 groupId、artifactId 和 version 三个参数唯一决定。artifact(工艺品)</p>
<p>Demo:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven 工程的坐标与仓库中路径的对应关系：</p>
<pre><code class="language-xml">&lt;groupId&gt; org.springframework &lt;/groupId&gt;
&lt;artifactId&gt; spring-core &lt;/artifactId&gt;
&lt;version&gt;4.0.0.RELEASE &lt;/version&gt;
</code></pre>
<pre><code>org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar
</code></pre>
<h3 id="依赖"><a class="header" href="#依赖">依赖</a></h3>
<p>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。对于我们自己开发的 Maven 工程,使用 mvn install 命令安装后就可以进入仓库。</p>
<p>Maven定义了几种依赖关系 ，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p>
<p>默认的 scope 就是 compile。</p>
<p>注意，不同的 scope 依赖关系，会有不同的导入策略，例如 h2 数据库，如果是想用 h2 作为内存数据库，则导包策略如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.h2database&lt;/groupId&gt;
  &lt;artifactId&gt;h2&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;version&gt;1.4.193&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>如果是想用 h2 的 server 模式，则导包策略如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.h2database&lt;/groupId&gt;
  &lt;artifactId&gt;h2&lt;/artifactId&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
  &lt;version&gt;1.4.193&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>不同的导入策略，导入的类也有所不同，Runtime 模式就不会导入 <code>org.h2.tools.Server</code> 类。</p>
<table><thead><tr><th style="text-align: left">scope</th><th style="text-align: left">说明</th><th style="text-align: left">示例</th><th>是否需要打包进程序</th></tr></thead><tbody>
<tr><td style="text-align: left">compile</td><td style="text-align: left">编译时需要用到该jar包</td><td style="text-align: left">commons-logging</td><td>需要</td></tr>
<tr><td style="text-align: left">test</td><td style="text-align: left">编译Test时需要用到该jar包</td><td style="text-align: left">junit</td><td>不需要</td></tr>
<tr><td style="text-align: left">runtime</td><td style="text-align: left">编译时不需要，但运行时需要用到</td><td style="text-align: left">mysql</td><td>需要</td></tr>
<tr><td style="text-align: left">provided</td><td style="text-align: left">编译时需要用到，但运行时由 JDK 或某个服务器提供</td><td style="text-align: left">servlet-api tomcat</td><td>不需要</td></tr>
</tbody></table>
<h4 id="compile-类型"><a class="header" href="#compile-类型">compile 类型</a></h4>
<ul>
<li>对<strong>主程序</strong>是否有效：有效</li>
<li>对测试程序是否有效：<strong>有效</strong></li>
<li>是否参与打包：参与</li>
<li>是否参与部署：参与</li>
<li>典型例子：spring-core</li>
</ul>
<h4 id="test-类型"><a class="header" href="#test-类型">test 类型</a></h4>
<ul>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
<li>典型例子：junit</li>
</ul>
<h4 id="provided-类型"><a class="header" href="#provided-类型">provided 类型</a></h4>
<ul>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与（由 servlet 容器提供）</li>
<li>典型例子：servlet-api.jar</li>
</ul>
<h4 id="runtime-类型"><a class="header" href="#runtime-类型">runtime 类型</a></h4>
<ul>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：？</li>
<li>是否参与打包：参与</li>
<li>是否参与部署：参与</li>
<li>典型例子：jdbc jar 包</li>
</ul>
<h3 id="依赖高级"><a class="header" href="#依赖高级">依赖【高级】</a></h3>
<h4 id="依赖的传递性"><a class="header" href="#依赖的传递性">依赖的传递性</a></h4>
<p>A -&gt; B，C -&gt; A 则 C -&gt; B。</p>
<p>底层的依赖包，在底层依赖引入就好。</p>
<p>好处：可以传递的依赖不必在每个模块工程中都重复声明，在”最下面”的工程中依赖一次即可。</p>
<p>注意：<strong>非 compile 范围的依赖不能传递（也就是说 test 和 provided 类型依赖是传递不了的）。所以在各个工程模块中，如果有需要就得重复声明依赖。</strong></p>
<h4 id="依赖的排除"><a class="header" href="#依赖的排除">依赖的排除</a></h4>
<p>排除传递过来的依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt; org.springframework &lt;/groupId&gt;
    &lt;artifactId&gt; spring-core &lt;/artifactId&gt;
    &lt;version&gt;4.0.0.RELEASE &lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意：依赖的排除也有传递性。</p>
<h4 id="依赖的原则"><a class="header" href="#依赖的原则">依赖的原则</a></h4>
<p>解决 jar 包冲突问题。</p>
<p>两个原则：</p>
<ul>
<li>最短路径优先原则（就近原则）</li>
<li>路径相同时，先声明者优先</li>
</ul>
<h4 id="统一管理依赖的版本"><a class="header" href="#统一管理依赖的版本">统一管理依赖的版本</a></h4>
<p>一个实际的需求：需要对 spring 各个jar包的依赖版本进行管理，从 4.0.0 升级到 4.1.1，手动逐一修改不靠谱。</p>
<p>建议配置方式：</p>
<ol>
<li>使用 properties 标签内使用自定义标签统一声明版本号</li>
<li>在需要统一版本的位置,使用<code>${自定义标签名}</code>引用声明的版本号</li>
</ol>
<p>Demo:</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;cvzhanshi.spring.version&gt;4.0.0.RELEASE&lt;/cvzhanshi.spring.version&gt;
&lt;/properties&gt;

&lt;version&gt;${cvzhanshi.spring.versio}&lt;/version&gt;
</code></pre>
<p>注意：properties 中还可以定义其他变量。凡是需要统一声明后再引用的场合都可以使用。例如：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;cvzhanshi.spring.version&gt;4.0.0.RELEASE&lt;/cvzhanshi.spring.version&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;
</code></pre>
<h3 id="仓库"><a class="header" href="#仓库">仓库</a></h3>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210609202112181.png" alt="image-20210609202112181" style="zoom: 67%;" />
<ul>
<li>
<p>本地仓库：</p>
</li>
<li>
<p>远程仓库</p>
<ul>
<li>私服：搭建在局域网，Nexus 是 Maven 私服的一个实现。私服没有的包，私服会从中央仓库拉过来。</li>
<li>中央仓库：架设在 Internet 上,为全世界所有 Maven 工程服务，负载沉重</li>
<li>中央仓库镜像：为了分担中央仓库的流量，提升用户访问速度</li>
</ul>
</li>
</ul>
<ul>
<li>仓库中保存的内容：Maven 工程
<ul>
<li>Maven 自身所需的插件</li>
<li>第三方框架或工具的 jar 包（第一方：jdk，第二方：我们）</li>
<li>自己开发的 Maven 工程</li>
</ul>
</li>
</ul>
<h3 id="生命周期--插件--目标"><a class="header" href="#生命周期--插件--目标">生命周期 / 插件 / 目标</a></h3>
<p><strong>maven 有三套相互独立的生命周期</strong></p>
<ul>
<li>
<p>Clean Lifecycle 在构建前进行清理</p>
<p>clean 包含有以下三个阶段</p>
<pre><code>pre-clean
clean （注意这个clean不是lifecycle而是phase）
post-clean
</code></pre>
</li>
<li>
<p>Default Lifecycle 构建的核心部分，编译、测试、打包、安装、部署</p>
<p>default 包含有以下阶段：</p>
<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>
</li>
<li>
<p>Site Lifecycle 生成项目报告，站点，发布站点</p>
</li>
</ul>
<p>每一个周期都有很多阶段。</p>
<p><strong>注意</strong></p>
<ul>
<li>各个构建环节执行的顺序: 不能打乱顺序，必须按照既定的正确顺序来执行</li>
<li>Maven 的核心程序中定义了抽象的生命周期，<strong>生命周期中各个阶段的具体任务是由插件来完成的</strong></li>
<li><strong>不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的阶段开始执行</strong></li>
</ul>
<p><strong>插件和目标</strong></p>
<ul>
<li>生命周期的各个阶段仅仅定义了要执行的任务是什么</li>
<li>各个阶段和插件的目标是对应的</li>
<li>相似的目标由特定的插件来完成</li>
<li>可以将目标看作调用插件功能的命令</li>
</ul>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210609210810287.png" alt="image-20210609210810287" /></p>
<p><strong>Demo</strong></p>
<ul>
<li>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止</li>
<li>运行<code>mvn clean package</code>，Maven先执行<code>clean</code>生命周期并运行到<code>clean</code>这个phase，然后执行<code>default</code>生命周期并运行到<code>package</code>这个phase</li>
</ul>
<h3 id="继承-2"><a class="header" href="#继承-2">继承</a></h3>
<p>问题描述：</p>
<pre><code>Hello 依赖的 junit: 4.0
HelloFriend 依赖的 junit: 5.0
MakeFriend 依赖的 junit: 4.9

由于 test 范围的依赖没有传递性，所以必然分散在各个模块中，很容易造成版本不一致。
</code></pre>
<p>需求：统一管理各个模块工程中对 junit 依赖的版本</p>
<p>解决思路：将 junit 依赖统一提取到“父”工程中，在子工程中声明 junit 依赖时不指定版本，以父工程中统一设定的为准，也便于修改。</p>
<p>步骤：</p>
<ol>
<li>
<p>创建一个Maven工程作为<strong>父工程</strong>。注意：打包的方式为 pom</p>
<pre><code class="language-xml">&lt;groupId&gt;com.cvzhanshi.maven&lt;/groupId&gt;
&lt;artifactId&gt;Parent&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
</li>
<li>
<p>在子工程中声明对父工程的引用</p>
<pre><code class="language-xml">&lt;!-- 子工程中声明父工程 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;com.cvzhanshi.maven&lt;/groupId&gt;
    &lt;artifactId&gt;Parent&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;!-- 以当前文件为基准的父工程 pom.xml 文件的相对路径 --&gt;
    &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
</li>
<li>
<p>将子工程的坐标中与父工程坐标中重复的内容删除</p>
</li>
<li>
<p>在父工程中统一管理 junit 的依赖（注意，在父类的 dependencyManagement 中定义的 dependency，不会被继承到子 module 中 <a href="https://stackoverflow.com/questions/2619598/differences-between-dependencymanagement-and-dependencies-in-maven">参考链接</a>）</p>
<pre><code class="language-xml">&lt;!-- 配置依赖的管理 --&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.9&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
</li>
<li>
<p>在子工程中删除 junit 依赖的版本号部分</p>
</li>
</ol>
<p>注意：配置继承后，执行安装命令时要先安装父工程</p>
<h3 id="聚合--模块化"><a class="header" href="#聚合--模块化">聚合 / 模块化</a></h3>
<p>作用：一键安装各个模块工程</p>
<p>配置方式：在一个 ”总的聚合工程“ 中配置各个参与聚合的模块</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;build&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;name&gt;build&lt;/name&gt;

    &lt;modules&gt;
        &lt;module&gt;parent&lt;/module&gt;
        &lt;module&gt;module-a&lt;/module&gt;
        &lt;module&gt;module-b&lt;/module&gt;
        &lt;module&gt;module-c&lt;/module&gt;
    &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p>在聚合工程的pom.xml上点右键-&gt;run as-&gt;maven install（eclipse中）</p>
<p><strong>注意，要先在聚合工程上 clean -&gt; install，然后再在子模块上 install。</strong></p>
<h2 id="idea--maven"><a class="header" href="#idea--maven">IDEA + Maven</a></h2>
<p>IDEA 搜索依赖并添加：</p>
<p>在 pom 文件中，<code>alt + insert</code>，generate，选择 <code>Dependency</code>，然后就可以搜索以来了，例如搜索 mysql 的依赖。添加到 pom 文件后，<code>ctrl + shift + O</code> 就可以加载该依赖。</p>
<p>版本仲裁：</p>
<p>SpringBoot 中对常见的依赖进行了版本的配置(哪个版本最合适，默认版本)，我们在导入一些常见依赖的时候，不需要再填写版本了：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="插件-plugins"><a class="header" href="#插件-plugins">插件 plugins</a></h2>
<p>Maven 自带了很多插件：</p>
<table><thead><tr><th style="text-align: left">插件名称</th><th style="text-align: left">对应执行的phase</th></tr></thead><tbody>
<tr><td style="text-align: left">clean</td><td style="text-align: left">clean</td></tr>
<tr><td style="text-align: left">compiler</td><td style="text-align: left">compile</td></tr>
<tr><td style="text-align: left">surefire</td><td style="text-align: left">test</td></tr>
<tr><td style="text-align: left">jar</td><td style="text-align: left">package</td></tr>
</tbody></table>
<p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p>
<p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用<code>maven-shade-plugin</code>可以创建一个可执行的jar，要使用这个插件，需要在<code>pom.xml</code>中声明它：</p>
<pre><code class="language-xml">&lt;project&gt;
    ...
	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.1&lt;/version&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;phase&gt;package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;shade&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
                            ...
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>下面列举了一些常用的插件：</p>
<ul>
<li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li>
<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>
<li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li>
</ul>
<h2 id="模块化-demo"><a class="header" href="#模块化-demo">模块化 Demo</a></h2>
<p>一个大项目拆成三个 module</p>
<pre><code class="language-ascii">mutiple-project
├── module-a
│   ├── pom.xml
│   └── src
├── module-b
│   ├── pom.xml
│   └── src
└── module-c
    ├── pom.xml
    └── src
</code></pre>
<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。例如，模块A的<code>pom.xml</code>：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-a&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-a&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>模块B的<code>pom.xml</code>：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-b&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-b&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>可以看出来，模块A和模块B的<code>pom.xml</code>高度相似，因此，我们可以提取出共同部分作为<code>parent</code>：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;name&gt;parent&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>注意到parent的<code>&lt;packaging&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何Java代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>
<pre><code class="language-ascii">multiple-project
├── pom.xml
├── parent
│   └── pom.xml
├── module-a
│   ├── pom.xml
│   └── src
├── module-b
│   ├── pom.xml
│   └── src
└── module-c
    ├── pom.xml
    └── src
</code></pre>
<p>这样模块A就可以简化为：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;parent&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;module-a&lt;/artifactId&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;module-a&lt;/name&gt;
&lt;/project&gt;
</code></pre>
<p>模块B、模块C都可以直接从<code>parent</code>继承，大幅简化了<code>pom.xml</code>的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<pre><code class="language-xml">    ...
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
            &lt;artifactId&gt;module-b&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译（新建一个工程用来聚合也行）：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;build&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;name&gt;build&lt;/name&gt;

    &lt;modules&gt;
        &lt;module&gt;parent&lt;/module&gt;
        &lt;module&gt;module-a&lt;/module&gt;
        &lt;module&gt;module-b&lt;/module&gt;
        &lt;module&gt;module-c&lt;/module&gt;
    &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p>这样，在根目录执行<code>mvn clean package</code>时，Maven根据根目录的<code>pom.xml</code>找到包括<code>parent</code>在内的共4个<code>&lt;module&gt;</code>，一次性全部编译。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>[TOC]</p>
<h2 id="lombok"><a class="header" href="#lombok">Lombok</a></h2>
<h3 id="java-项目配置"><a class="header" href="#java-项目配置">Java 项目配置</a></h3>
<p>对于普通的 Java8 项目，一个 lombok 依赖是不够的，还需要其他依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="junit5-1"><a class="header" href="#junit5-1">JUnit5</a></h2>
<p>测试框架。</p>
<h3 id="java-项目配置-1"><a class="header" href="#java-项目配置-1">Java 项目配置</a></h3>
<p>https://junit.org/junit5/docs/current/user-guide/#dependency-metadata</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.7.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
    &lt;version&gt;5.7.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="oval"><a class="header" href="#oval">OVal</a></h2>
<p>校验框架。</p>
<p><a href="https://sebthom.github.io/oval/USERGUIDE.html">OVal</a> - the object validation framework for Java.</p>
<p><a href="https://javadoc.io/doc/net.sf.oval/oval/latest/index.html">OVal Doc</a>  <a href="https://blog.csdn.net/neweastsun/article/details/49154337/">汉化版参考文档</a></p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;net.sf.oval&lt;/groupId&gt;
  &lt;artifactId&gt;oval&lt;/artifactId&gt;
  &lt;version&gt;[VERSION_GOES_HERE]&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>用正则表达式来检验内容 Demo:</p>
<pre><code class="language-java">public class EntityGraphDto {

    @ApiModelProperty(name=&quot;画面ID&quot;, required = true)
    private String id;

    ...

    @MatchPattern(
            // 正则表达式：[a-zA-Z0-9\|\*\.\[\]\{\}\(\)\\,/:-]+
            pattern = {&quot;[a-zA-Z0-9\\|\\*\\.\\[\\]\\{\\}\\(\\)\\\\,/:-]+&quot;},
            message = &quot;权限表达式格式有问题，不能包含中文和下划线，可以包含以下字符：| * . [] {} () \\ , / : -&quot;)
    @ApiModelProperty(name=&quot;画面权限表达式&quot;, required = true)
    private String expression;

    @ApiModelProperty(name=&quot;画面所属应用&quot;)
    private String app;
		
    ...

}
</code></pre>
<h2 id="apache-commons-beanutils"><a class="header" href="#apache-commons-beanutils">Apache Commons BeanUtils</a></h2>
<p>Bean 工具类</p>
<pre><code class="language-yaml">&lt;dependency&gt;
    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;
    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;
    &lt;version&gt;1.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">BeanUtils.populate(userInfoDto, result.getData());
// b 拷贝到 a，浅拷贝
BeanUtils.copyProperties(a, b);
</code></pre>
<p>拷贝性能比较差，</p>
<h2 id="springframework-beanutils"><a class="header" href="#springframework-beanutils">springframework BeanUtils</a></h2>
<p>优先使用 Spring 提供的 BeanUtils</p>
<pre><code class="language-java">// a 拷贝到 b，比较符合直觉，把 a 复制到 b, from, to
BeanUtils.copyProperties(a, b);
</code></pre>
<h2 id="java-bean-序列化反序列化"><a class="header" href="#java-bean-序列化反序列化">java bean 序列化，反序列化</a></h2>
<p>fastjson jackson gson</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务架构课"><a class="header" href="#微服务架构课">微服务架构课</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architect"><a class="header" href="#architect">Architect</a></h1>
<p>[TOC]</p>
<h2 id="名词解释"><a class="header" href="#名词解释">名词解释</a></h2>
<table><thead><tr><th>名词</th><th>解释</th><th>备注</th></tr></thead><tbody>
<tr><td>jar</td><td>Java ARchive</td><td></td></tr>
<tr><td>war</td><td>Java Web Application ARchive</td><td></td></tr>
<tr><td>jsp</td><td>Java Server Pages，html + <code>&lt;% ... %&gt;</code>，jsp 最终会被转换成 Servlet</td><td></td></tr>
<tr><td>Java Servlet</td><td>能处理HTTP请求，发送HTTP响应的小程序</td><td></td></tr>
<tr><td>Tomcat</td><td>JSP 程序运行容器</td><td>Servlet容器</td></tr>
<tr><td>POM</td><td>Project Object Model</td><td>胖母</td></tr>
<tr><td>Maven</td><td>项目配置</td><td>中文译名：专家，读作 妹文</td></tr>
<tr><td>Gradle</td><td>功能和 Maven 类似</td><td></td></tr>
<tr><td>CRUD</td><td>create retrieve update delete</td><td></td></tr>
<tr><td>self-contained application</td><td>把环境依赖一起打包到程序中的应用，例如 electron 应用</td><td></td></tr>
<tr><td>JDBC</td><td>Java Database Connectivity is an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">application programming interface</a> (API) for Java</td><td></td></tr>
<tr><td>JavaBean</td><td>若干<code>private</code>实例字段； 通过<code>public</code>方法来读写实例字段。</td><td>就是对一个对象的封装</td></tr>
<tr><td>component</td><td>组件</td><td></td></tr>
<tr><td>DAO</td><td>Data Access Object</td><td></td></tr>
<tr><td>ORM</td><td>Object-Relational Mapping</td><td><a href="https://hibernate.org/">Hibernate</a> 就是一个 ORM 框架</td></tr>
<tr><td>JPA</td><td>Java Persistence API</td><td>JPA 也是一个 Java 的 ORM 框架</td></tr>
<tr><td>MyBatis</td><td></td><td>半自动化ORM框架</td></tr>
<tr><td>POJO</td><td>Plain Old Java Object</td><td></td></tr>
<tr><td>YAML</td><td>Yet Anohter Markup Language</td><td>yaml 中单引号会转义，双引号不会转义，单引号会将 <code>\n</code> 作为字符串输出，双引号会将 <code>\n</code> 作为换行输出</td></tr>
</tbody></table>
<h2 id="数据库相关"><a class="header" href="#数据库相关">数据库相关</a></h2>
<h3 id="业务相关"><a class="header" href="#业务相关">业务相关</a></h3>
<ul>
<li>不要用外键</li>
<li>任何表都需要设置 ID 主键</li>
<li>所有业务相关的数据，不能直接删除，因为后面不知道啥时候还会用到，可以设置一个删除标志位</li>
<li>不要使用 uuid 作为主键，uuid 作为主键的时候，在进行数据插入的时候，对于磁盘 IO 的压力是非常大的</li>
</ul>
<h3 id="mysql-服务器硬件选型"><a class="header" href="#mysql-服务器硬件选型">MySQL 服务器硬件选型</a></h3>
<ul>
<li>MySQL 不支持多核同时运算一条 sql</li>
<li>CPU 选择原则
<ul>
<li>对于高并发的场景，CPU 的核心数比频率更重要</li>
<li>对于计算密集型场景，CPU 频率比核心数更重要</li>
</ul>
</li>
<li>内存选择原则
<ul>
<li>InnoDB 引擎会将索引和数据缓存到内存中，速度很快，理想的选择是服务器内存大于数据总量</li>
</ul>
</li>
<li>硬盘选择原则
<ul>
<li>优先用 SSD 固态硬盘</li>
</ul>
</li>
</ul>
<h3 id="列数据库"><a class="header" href="#列数据库">列数据库</a></h3>
<p>应用场景：批量处理、超大规模即时查询（适用于高查询场景，不适合高增删改场景）</p>
<p>列式存储数据库：HBase, Cassandra(卡三桌)</p>
<p>对于传统的行数据库来说，数据是按照行进行<strong>分散存储</strong>的，在读取数据的时候，磁盘要去寻找匹配的行，从而产生多次 IO，而列数据库的数据是<strong>连续存储</strong>的，IO 消耗很小。</p>
<table><thead><tr><th>行数据库存储</th><th>列数据库存储</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20210923195912024.png" alt="image-20210923195912024" /></td><td><img src="computer-science-notebook/note-for-java-web/assets/image-20210923195831697.png" alt="image-20210923195831697" /></td></tr>
</tbody></table>
<p>Cassandra 官方宣称其速度比 MySQL 快 100 倍。</p>
<p><strong>列数据库速度快的原因</strong>：</p>
<ul>
<li>
<p>不读取无效数据</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210923200225125.png" alt="image-20210923200225125" style="zoom:50%;" />
</li>
<li>
<p>数据压缩比大</p>
<p>数据相关性大，连续存储的数据，类型都是一样的，可以采用一些算法进行压缩</p>
</li>
</ul>
<p><strong>列式数据库遗留问题</strong></p>
<ul>
<li>如何高效新增 —&gt; 多个列族，并发写磁盘</li>
<li>如何高效更新 —&gt; Cansandra 添加一个新版本号的数据</li>
<li>如何高效删除 —&gt; 添加删除标记 keyType=Delete（逻辑删除）</li>
</ul>
<h3 id="模糊查询"><a class="header" href="#模糊查询">模糊查询</a></h3>
<p>MySQL5.7 开始提供 Ngram 全文检索</p>
<p>传统的 like 在进行检索的时候，索引可能会失效，导致全表检索</p>
<pre><code class="language-sql">create index idx_title on article(title)
# 可能用到索引,看索引选择性
select * from article where title like ‘Java%’
# 一定不会用到索引
select * from article where title like ‘%Java’
select * from article where title like ‘%Java%’
</code></pre>
<p>替代方法：将数据同步到 Elasticsearch 进行复杂的模糊查询。但是这个方法也会带来更高的成本：</p>
<p>数据一致性如何保证？ElasticSearch高可用架构采用哪种方案？谁来负责维护 ElasticSearch？</p>
<p>MySQL 给出了折中的方法，从 MySQL 5.7.6 开始，MySQL 内置了 ngram 全文解析器，允许对短文本进行全文检索查询，以替代 like 关键字，对于复杂业务场景的全文检索查询，还是要用 ES</p>
<p>在 MySQL 5.7.6 之前，全文索引只支持英文全文索引，不支持中文全文索引，需要利用分词器把中文段落预处理拆分成单词，然后存入数据库。从 <strong>MySQL 5.7.6</strong> 开始，MySQL内置了 ngram 全文解析器，用来<strong>支持中文</strong>、日文、韩文分词。本文使用的MySQL 版本是 <strong>5.7.24</strong>，<strong>InnoDB</strong>数据库引擎。</p>
<h3 id="uuid"><a class="header" href="#uuid">UUID</a></h3>
<p>接口规则：</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211005105623986.png" alt="image-20211005105623986" style="zoom:50%;" />
<p>UUID 接口有五种实现算法，最常用的是基于随机数的 uuid 生成算法：</p>
<ul>
<li>完全随机生成，会存在极小概率重复的情况</li>
<li>与外部环境无关，不涉及环境信息</li>
<li>生成内容无序无规律</li>
<li>目前的主流做法</li>
</ul>
<p>Java 的支持：</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211005110126284.png" alt="image-20211005110126284" style="zoom: 50%;" />
<p>UUID 产生主键的问题：不支持趋势递增，影响索引效率</p>
<p>B+ 数是一颗有序树，如果主键随机，则需要在插入数据的时候，频繁重构索引树，带来严重的效率问题</p>
<p>优化方法，有序的数字主键生成策略：</p>
<ul>
<li>美团 Leaf</li>
<li>推特 Snowflake</li>
</ul>
<h3 id="缓存一致性"><a class="header" href="#缓存一致性">缓存一致性</a></h3>
<p>如何保证缓存中的数据，和数据库中的数据，是一致的？</p>
<p>不要更新缓存，不要更新缓存，不要更新缓存！因为更新了缓存，可能导致和数据库中的数据不一致！</p>
<p>正确的做法：更新数据库，然后删除缓存重新加载！</p>
<h2 id="时区问题"><a class="header" href="#时区问题">时区问题</a></h2>
<ul>
<li>
<p>UTC 世界时间</p>
<p>世界时间比格林威治时间准，使用原子钟。</p>
<p>UTC+8就是国际时加八小时,是东八区时间,是北京时间。</p>
</li>
<li>
<p>GMT 格林威治时间</p>
</li>
</ul>
<p>时间解释：<code>2018-01-31T14:32:19Z</code></p>
<p>T代表后面跟着是时间，Z代表0时区（相差北京时间8小时）</p>
<p>2021-09-27T10:45:15.343Z 表示世界时间，其中 343 是毫秒 1s = 1000ms</p>
<h2 id="分布式相关"><a class="header" href="#分布式相关">分布式相关</a></h2>
<h3 id="raft-选举算法"><a class="header" href="#raft-选举算法">raft 选举算法</a></h3>
<p>分布式集群中，通常是有一个主节点的，确定主节点的算法，通常是 raft 算法。</p>
<p>目前流行的组件：Consul，Nacos，Rocket MQ 底层都采用了 Raft 算法来确认集群的主节点。</p>
<p>作用：在分布式集群架构下进行主节点的确认。</p>
<h3 id="cap-定理"><a class="header" href="#cap-定理">cap 定理</a></h3>
<p>https://www.ruanyifeng.com/blog/2018/07/cap.html</p>
<p>分布式系统的三个指标：CAP 定理。</p>
<ul>
<li>
<p>C Consistency 一致性</p>
<p>Every read receives the most recent write or an error. </p>
<p>每个分区的数据都是一致的。</p>
</li>
<li>
<p>A Availability 可用性</p>
<p>Every request receives a (non-error) response, without the guarantee that it contains the most recent write. </p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>
</li>
<li>
<p>P Partition tolerance 分区容错性</p>
<p>The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes. </p>
<p>指当网络出现分区的情况（即系统中的一部分节点无法和其他节点进行通信）分离的系统也能够正常运行。</p>
</li>
</ul>
<p>CAP 三个指标不可能同时满足。</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211101201609822.png" alt="image-20211101201609822" style="zoom:50%;" />
<p>Consistency 和 Availability 的矛盾：</p>
<p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<p>在什么场合，AP 高于 CP？</p>
<p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。（很多场合，不求一致性，但求高可用，别宕机）</p>
<p>一个场景，订单创建成功后，发短信告诉用户：</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211101203121795.png" alt="image-20211101203121795" style="zoom: 67%;" />
<p>CP 的应用场景：并发小，数据一致性要求高，例如订单，银行转账，表现为订单创建后需要等待短信发送成功，用户体验差</p>
<p>AP 的应用场景：表现为订单创建后，立即返回短信发送成功，无需等待短信是否发送成功，保证用户体验。但是 AP 有很大的问题，例如爆了一件神话装备，但是服务器宕机了，缓存没有写入磁盘，导致装备丢失。</p>
<h3 id="base-最终一致性"><a class="header" href="#base-最终一致性">BASE 最终一致性</a></h3>
<p>AP 缺乏数据一致性的解决方案：BASE，是对 CAP 的补充，让短信尽可能地发送成功</p>
<ul>
<li>
<p><strong>Basically available</strong>: reading and writing operations are available as much as possible (using all nodes of a database cluster), but may not be consistent (the write may not persist after conflicts are reconciled, the read may not get the latest write)</p>
<p>基本可用，就是基本实现用户的基本价值和诉求，创建订单后立即返回，就是基本可用的体现</p>
</li>
<li>
<p><strong>Soft-state</strong>: without consistency guarantees, after some amount of time, we only have some probability of knowing the state, since it may not yet have converged</p>
<p>软状态，表示业务操作没有最终完成前的中间状态，订单创建后，短信记录未成功发送前就属于软状态，CP 没有软状态。</p>
</li>
<li>
<p><strong>Eventually consistent</strong>: If we execute some writes and then the system functions long enough, we can know the state of the data; any further reads of that data item will return the same value</p>
<p>最终一致性，表示通过技术手段，<strong>过一段时间后</strong>，让数据保持一致性。最终一致性只是对 AP 打补丁，不能 100% 实现 Consistency。</p>
</li>
</ul>
<p>最终一致性的方案：</p>
<ul>
<li>
<p>重试</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211101203842618.png" alt="image-20211101203842618" style="zoom: 33%;" />
</li>
<li>
<p>数据校对程序</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211101204033346.png" alt="image-20211101204033346" style="zoom:33%;" />
</li>
<li>
<p>人工介入</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211101204144216.png" alt="image-20211101204144216" style="zoom:33%;" />
</li>
</ul>
<h2 id="微服务架构设计经验"><a class="header" href="#微服务架构设计经验">微服务架构设计经验</a></h2>
<p>https://www.bilibili.com/video/BV1jf4y1c7TZ</p>
<p>软件开发没有银弹！</p>
<p>在著名软件著作《人月神话》中提到，软件世界没有“银弹”，这句话当然适用于架构领域，随这从单体架构过度到微服务架构，因为将原有系统打散，给系统增加了许多不稳定因素。</p>
<h3 id="微服务的坑"><a class="header" href="#微服务的坑">微服务的坑</a></h3>
<p><strong>服务调用失败问题</strong></p>
<p>以往单体应用是在单机中进行进程内通信，通信稳定性相当好。但是打散为分布式系统后，变为进程间通信，往往这个过程还伴随着跨设备的网络访问，架构师在设计时必须考虑上下游系统因为网络因素无法通信的情况，要假设网络是不可靠的，并设计微服务在网络异常时也能进行符合预期的异常处理。以支付模块为例，用户支付成功后系统自动调用短信服务向用户手机发送“订单支付成功”的消息，此时架构师就必须假设短信服务在服务或者网络不可用时不会影响到订单业务的正常执行。 </p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20211007221514225.png" alt="image-20211007221514225" style="zoom:80%;" />
<p><strong>性能问题</strong></p>
<p>相比传统单体架构进程内通信，跨进程、跨网络的微服务通信在网络传输与消息序列化带来的延迟是不可被忽略的，尤其是在五个以上微服务间消息调用时，因为网络延迟对于实时系统的影响是是很大的。 </p>
<p><strong>运维成本问题</strong></p>
<p>运维成本会直线上升，早期单体应用因为结构简单，规模也较小，发版时通常面对几台服务器部署几个Jar/War文件就可以了。同时，应用的交付周期也是以周甚至月为单位，此时硬件设备成本与运维人员技术要求都比较低，采用手动部署即可满足要求。而对于微服务架构而言，每一个服务都是可独立运行、独立部署、独立维护的业务单元，再加上互联网时代用户需求的不断变化以及市场的不稳定因素，运维人员每天面对成百上千台服务器发布几十次已是家常便饭，传统手动部署显然已经无法满足互联网的快速变化。</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20211007221435855.png" alt="image-20211007221435855" style="zoom:80%;" />
<p><strong>组织架构调整问题</strong></p>
<p>微服务不但是一种架构风格，同样也是一种软件组织模型，以往软件公司会按照职能划分，如：研发、测试、运维部门进行独立管理考核，而在微服务的实施过程中，以业务模块进行划分团队，每一个团队是内聚的，要求可以独立完成从调研到发版的全流程，尽量减少对外界的依赖。如何将传统的职能团队调整为按业务划分组织架构，同样是对管理者的巨大挑战，要知道人的思想比架构更难改变。</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211007221559011.png" alt="image-20211007221559011" style="zoom:67%;" />
<p><strong>集成测试问题</strong></p>
<p>服务间的集成测试变得举步维艰，传统单体架构集成测试是将不同的模块按业务流程进行组合，在进程内验证每一种可能性下其模块间协作是否符合预期即可。但对于微服务而言，系统被拆解为很多独立运行的单元，服务件采用接口进行网络通信。要获取准确的测试结果，必须搭建完整的微服务环境，光这一项工作就有很大的工作量。同时，因为是跨网络通信，网络延迟、超时、带宽、数据量等因素都将影响最终结果，测试结果易产生偏差。</p>
<h3 id="微服务最佳实践"><a class="header" href="#微服务最佳实践">微服务最佳实践</a></h3>
<p><strong>微服务的划分原则</strong></p>
<ul>
<li>
<p>单一职责原则</p>
<p>每一个微服务只做好一件事，体现出“高内聚、低耦合”，尽量减少对外界环境的依赖。比如，在公司创业之初，完全可将订单与仓储服务进行合并。因为订单与仓储在业务与数据紧密相关，如果强行拆分会导致出现跨进程通信带来的数据一致性难题。随着业务的发展，仓储的业务职责扩展，派生出许多与订单无紧密联系的功能，到时再将其剥离形成独立的“仓储服务”也不晚。</p>
</li>
<li>
<p>服务依赖原则</p>
<p>避免服务间的循环引用，在设计时就要对服务进行分级，例如区分核心服务与非核心服务。例如订单服务与短信服务，显然短信服务是非核心服务，服务间调用要遵循“核心服务”到“非核心服务”，不允许出现反向调用。同时，对于核心服务要做好保护，避免非核心服务出现问题影响核心服务的正常运行。</p>
</li>
<li>
<p>Two Pizza原则</p>
<p>就是说让团队保持在两个比萨能让队员吃饱的小规模的概念。团队要小到让每个成员都能做出显著的贡献，并且相互依赖，有共同目标，以及统一的成功标准。一个微服务团队应涵盖从需求到发布运维的完整生命周期，使团队内部便可以解决大部分任务，从人数上4~6人是比较理想的规模。</p>
</li>
</ul>
<p>服务的拆与合是伴随着公司业务的演进而变化的，一切以解决问题为准。</p>
<p>**微服务确保独立的数据存储  **</p>
<p>数据是任何系统最重要的资产。以往单体应用通常会选择MySQL这种关系型数据库作为数据的统一存储，这样做的好处是涉及多表操作
时，利用数据库自带的事务机制便可最大程度保证数据完整性。但这样做却存在诸多问题，以下图为例，不同的微服务对数据存储的需求也是不同的，订单服务需要MySQL数据保存订单与订单明细；新闻服务需要Elasticsearch提供全文检索支持；朋友圈需要图数据库表达现实世界人际关系；文件存储服务则需要分布式文件系统。如果将所有数据都揉在MySQL中使用会变得十分蹩脚，好的做法是为每一个微服务提供符合自身业务特性的数据库。</p>
<p>在微服务架构下，因为数据库绝不允许其他团队访问，关联查询只能变为API调用形式，程序实现层面比单库复杂不少。</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20211007222552958.png" alt="image-20211007222552958" style="zoom:67%;" />
<p>**服务间通信优先采用聚合器模式  **</p>
<p>在微服务间通信时存在两种消息传递模式“链式模式”与“聚合器模式”。下图是所示，按业务流程请求在各个服务间流转，最终
处理完成返回客户端。</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20211007222654433.png" alt="image-20211007222654433" style="zoom:80%;" />
<p>因为请求是按业务流程传递，很容易能被开发人员理解，因此链式模式称为了最常用的服务间通信模式。但链式模式采用串联模式，调用整个成功率等于服务调用成功率的乘积，假设每个服务可靠性为90%，一个业务代码在4个服务执行后的最终成功率只有<code>90%*90%*90%*90%≈66%</code>，有将近一半的请求会处理失败，这是无法接受的。此外，链式模式因默认采用同步方式传输，在服务处理完成前请求会一直处于阻塞状态，当调用链较长时，系统整体性能会严重下滑。</p>
<p>聚合器模式则是通过服务作为入口，组装其他服务的调用，因为“订单流程服务”是将其他服务进行聚合操作，所以称其为聚合器模式。以“订单流程服务”为例，将“订单”、“支付”、“库存”服务进行聚合，一个服务实现从下单、支付、减库存的完整流程。</p>
<h3 id="适合上马微服务的场景"><a class="header" href="#适合上马微服务的场景">适合上马微服务的场景</a></h3>
<ul>
<li>
<p>新规划的大型业务系统</p>
<p>这肯定是最适合引入微服务架构的情况了， 微服务强调&quot;高内聚，低耦合&quot;，每一个团队负责一个服务，这就意味着从根上和传统的整体性应用有本质不同。从规划阶段采用微服务架构是再好不过的。</p>
</li>
<li>
<p>敏捷的小团队系统</p>
<p>在公司在大型项目微服务实践前，往往这类边缘化的小项目会起到&quot;试验田&quot;的作用， 引入快速迭代、持续交付等开发模式，积累适合本公司特点的微服务实践经验，在将这些经验扩大到其他大型项目中。</p>
</li>
<li>
<p>历史的大型留存业务系统</p>
<p>之前多年我一直在金融软件领域工作，在银行内部许多系统已经使用超过10年时间，长百上千个模块错综复杂维护愈发苦难，无论架构、框架乃至技术人员都需要更新迭代，但都不可能一次大动手术，这是微服务的&quot;微&quot;就体现出来，重构时可以将某一个部分剥离为微服务独立运行，确保无误后再继续剥离出下一个服务，通过抽丝剥茧一般的剥离，逐步将原有大系统剥离为若干子服务，虽然过程十分痛苦，但这是必须做的事情。</p>
</li>
</ul>
<h2 id="真实案例"><a class="header" href="#真实案例">真实案例</a></h2>
<h3 id="push---pull---数据订阅"><a class="header" href="#push---pull---数据订阅">push -&gt; pull -&gt; 数据订阅</a></h3>
<table><thead><tr><th>架构图</th><th>特点</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20211003082959640.png" alt="image-20211003082959640" /></td><td>子系统共用一个账户系统，并且每个子系统都有一个本地库</td></tr>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20211003083200936.png" alt="image-20211003083200936" /></td><td>账户系统修改用户名后，要根据每个子系统提供的接口，推送给每一个子系统。账户系统和子系统耦合非常严重，每增加一个子系统，账户系统都要修改一次代码</td></tr>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20211003083445956.png" alt="image-20211003083445956" /></td><td>改成子系统从账户系统定时 pull 的模式，降低耦合，但是仍然存在账户系统修改接口的风险</td></tr>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20211003083532775.png" alt="image-20211003083532775" /></td><td>将可变因素同步接口进行解耦，引入消息队列，直接订阅数据，不对接口产生依赖</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restful-api"><a class="header" href="#restful-api">restful-api</a></h1>
<p>[TOC]</p>
<h2 id="definition-1"><a class="header" href="#definition-1">definition</a></h2>
<p><strong>Representational state transfer</strong> (<strong>REST</strong>) is a <a href="https://en.wikipedia.org/wiki/Software_architecture">software architectural style</a> which uses a subset of <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>.[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a> It is commonly used to create <a href="https://en.wikipedia.org/wiki/Interactivity">interactive</a> applications that use <a href="https://en.wikipedia.org/wiki/Web_service">Web services</a>. A Web service that follows these guidelines is called <em>RESTful</em>. Such a Web service must provide its <a href="https://en.wikipedia.org/wiki/Web_resource_framework">Web resources</a> in a textual representation and allow them to be read and modified with a <a href="https://en.wikipedia.org/wiki/Stateless_protocol">stateless protocol</a> and a predefined set of operations. </p>
<p>REST 是一套用于构建 Web Service 的规范。</p>
<h2 id="restful-vs-mvc"><a class="header" href="#restful-vs-mvc">restful vs mvc</a></h2>
<p>MVC 和 RESTful web 的关键不同点：</p>
<p>A key difference between a traditional MVC controller and the RESTful web service controller shown earlier is the way that the HTTP response body is created. Rather than relying on a view technology to perform server-side rendering of the greeting data to HTML, this RESTful web service controller populates and returns a <code>Greeting</code> object. The object data will be written directly to the HTTP response as JSON.</p>
<p>以前网页是前后端融合在一块的（我之前写的 Senti-weibo 网页，就是前后端融合在一块的，类似 JSP），Restful 标准是实现前后端分离的标准，一个后端服务就可以服务 Web、app 等多个前端平台。</p>
<h2 id="通俗解释"><a class="header" href="#通俗解释">通俗解释</a></h2>
<p>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p>
<p>url 使用名词来指定资源，使用 HTTP 动词来描述动作。</p>
<pre><code>server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：http://api.qc.com/v1/newsfeed: 获取某人的新鲜; 
http://api.qc.com/v1/friends: 获取某人的好友列表;
http://api.qc.com/v1/profile: 获取某人的详细信息;

用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：
GET    用来获取资源
POST  用来新建资源（也可以用于更新资源）
PUT    用来更新资源
DELETE  用来删除资源

比如：
DELETE http://api.qc.com/v1/friends: 删除某人的好友 （在http parameter指定好友id）
POST http://api.qc.com/v1/friends: 添加好友
UPDATE http://api.qc.com/v1/profile: 更新个人资料
</code></pre>
<p>Demos</p>
<pre><code>GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
</code></pre>
<h2 id="reference-2"><a class="header" href="#reference-2">reference</a></h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring"><a class="header" href="#spring">Spring</a></h1>
<p>[TOC]</p>
<p>该笔记记录 Spring 的底层知识。</p>
<h2 id="学习教程"><a class="header" href="#学习教程">学习教程</a></h2>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309301178105890">廖雪峰 Java 教程</a></li>
</ul>
<h2 id="aspect-oriented-programming"><a class="header" href="#aspect-oriented-programming">Aspect Oriented Programming</a></h2>
<h3 id="动态代理-1"><a class="header" href="#动态代理-1">动态代理</a></h3>
<p>aop 的核心机制是动态代理，有两种动态代理机制：</p>
<ul>
<li>JDK：基于接口（兄弟关系）</li>
<li>cglib：基于父类（父子关系）</li>
</ul>
<h3 id="几个概念"><a class="header" href="#几个概念">几个概念</a></h3>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210902090011382.png" alt="image-20210902090011382" /></p>
<p>AOP 有 Python 装饰器的味道。</p>
<p>Aspect Oriented Programming 面向切面编程。AOP 是一种和 OOP 不同的新的编程范式。OOP 把系统看作多个对象的交互，AOP 把系统分解为不同的关注点，或者称之为切面（Aspect）。</p>
<p>切面实际上是代理设计模式。</p>
<h2 id="注解"><a class="header" href="#注解">注解</a></h2>
<table><thead><tr><th>Annotation</th><th>作用对象</th><th>解释</th><th>备注</th></tr></thead><tbody>
<tr><td>@Component</td><td>类</td><td>表示该类为一个组件</td><td>定义了一个 Bean，单例</td></tr>
<tr><td>@Autowired</td><td>字段和方法</td><td>将指定类型的 Bean 注入到字段或者方法上</td><td>required = false 如果找不到对应的 Bean，就忽略，防止报错。通常用于字段</td></tr>
<tr><td>@Resource</td><td>字段</td><td>@Resource默认按照byName方式进行bean匹配 @Resource(name = &quot;tiger&quot;)</td><td></td></tr>
<tr><td>@Service</td><td>类</td><td>声明该类是一个bean，这点很重要，因为该类是一个bean，其他的类才可以使用@Autowired将该类作为一个成员变量自动注入</td><td></td></tr>
<tr><td>@Configuration</td><td>类</td><td>告诉 Spring 这个类是一个配置类，等同于配置文件。配置类通常用于装配组件</td><td></td></tr>
<tr><td>@ComponentScan</td><td>类</td><td>告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配</td><td></td></tr>
<tr><td>@Order</td><td>类</td><td>Component 注入 list 时指定 Bean 的顺序</td><td>从 @Order(1) 开始</td></tr>
<tr><td>@Bean</td><td>方法</td><td>Bean 不在我们的包中，就在@Configuration 类中编写一个 Java 方法创建并返回它，并且给该方法标记一个 @Bean 注解。给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</td><td>单例。</td></tr>
<tr><td>@Qualifier</td><td>方法</td><td><code>@Qualifier(&quot;utc8&quot;)</code> 给 Bean 起名字，破解单例</td><td></td></tr>
<tr><td>@Primary</td><td>方法</td><td>表示默认注入的 Bean</td><td>主从数据库，配置默认数据库</td></tr>
<tr><td>@Scope</td><td>类</td><td>@Scope(ConfigurableBeanFactory.<br />SCOPE_PROTOTYPE) 表示多例，每次调用返回一个新的实例</td><td></td></tr>
<tr><td>@PostConstruct</td><td>方法</td><td>标记 <code>init()</code> 方法，表示 Bean 初始化时执行的动作</td><td></td></tr>
<tr><td>@PreDestroy</td><td>方法</td><td>标记 <code>shutdown()</code> 方法，表示 Bean 被销毁时执行的动作</td><td></td></tr>
<tr><td>@Value</td><td>字段</td><td>加载配置文件中的属性进行注入</td><td><code>@Value(&quot;classpath:/logo.txt&quot;)</code> 注入 Resource</td></tr>
<tr><td>@PropertySource</td><td>类</td><td>配置自动读取配置文件 @PropertySource(&quot;application.yml&quot;) 表示从 application.yml 中读取配置</td><td><code>@Value(&quot;${app.zone:Z}&quot;)</code> 提取 app.zone 的 value，默认为 Z</td></tr>
<tr><td>@Profile</td><td>方法</td><td>用来表示不同的环境，不同的环境创建不同的 Bean。@Profile(&quot;!test&quot;) 非 test 环境</td><td></td></tr>
<tr><td>@Conditional</td><td>类/方法</td><td>根据<code>@Conditional</code>决定是否创建并注入某个Bean到 IoC 中</td><td></td></tr>
<tr><td>@Aspect</td><td>类</td><td>声明该类为切面类</td><td></td></tr>
<tr><td>拦截器</td><td></td><td></td><td></td></tr>
<tr><td>@Before</td><td>方法</td><td>在……之前执行该切面</td><td></td></tr>
<tr><td>@After</td><td>方法</td><td></td><td></td></tr>
<tr><td>@Around</td><td>方法</td><td>在……前后执行该切面</td><td></td></tr>
<tr><td>@AfterReturning</td><td>方法</td><td>和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</td><td></td></tr>
<tr><td>@AfterThrowing</td><td>方法</td><td>和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</td><td></td></tr>
<tr><td>@EnableAspectJAutoProxy</td><td>类</td><td>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中</td><td></td></tr>
<tr><td>@EnableTransactionManagement</td><td>类</td><td>启用声明式事务</td><td></td></tr>
<tr><td>@Transactional</td><td>类/方法</td><td>表示类中所有  public 方法都支持事务 / 表示该方法支持事务</td><td></td></tr>
<tr><td>@Entity</td><td>类</td><td>如果一个JavaBean被用于映射，我们就标记一个<code>@Entity</code></td><td></td></tr>
<tr><td>@Table</td><td>类</td><td><code>@Table(name=&quot;users&quot;)</code> 指定映射的表名</td><td></td></tr>
<tr><td>@Column</td><td>方法</td><td>属性到数据库列的映射</td><td></td></tr>
<tr><td>@Id</td><td>方法</td><td>表示主键</td><td></td></tr>
<tr><td>@GeneratedValue</td><td>方法</td><td>表示自增</td><td></td></tr>
<tr><td>@MappedSuperclass</td><td>类</td><td>表示用于继承</td><td></td></tr>
<tr><td>@Transient</td><td>方法</td><td>表示方法返回一个“虚拟”的属性</td><td></td></tr>
<tr><td>@PrePersist</td><td>方法</td><td>在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法</td><td></td></tr>
<tr><td>@Select</td><td>方法</td><td>表示 sql 语句</td><td></td></tr>
<tr><td>@Param()</td><td>参数</td><td></td><td></td></tr>
<tr><td>@MapperScan</td><td>类</td><td>让MyBatis自动扫描指定包的所有Mapper并创建实现类</td><td></td></tr>
<tr><td>@EnableWebMvc</td><td>类</td><td>启用 Spring MVC</td><td></td></tr>
<tr><td>@Entity</td><td>类</td><td>用来注解该类是一个实体类用来进行和数据库中的表建立关联关系，首次启动项目的时候，默认会在数据中生成一个同实体类相同名字的表（table），也可以通过注解中的 name 属性来修改表（table）名称， 如@Entity(name=“user”) , 这样数据库中表的名称则是 user 。该注解十分重要，如果没有该注解首次启动项目的时候你会发现数据库没有生成对应的表。</td><td></td></tr>
<tr><td>@Table</td><td>类</td><td>该注解可以用来修改表的名字，该注解完全可以忽略掉不用，@Entity 注解已具备该注解的功能。</td><td></td></tr>
<tr><td>@Import</td><td>类</td><td>给容器中注入一个组件</td><td></td></tr>
<tr><td>@ImportResource</td><td>类</td><td>从 xml 文件中导入 bean 配置</td><td></td></tr>
<tr><td>@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)</td><td></td><td>入参是字符串时间，接收类型是 date 类型，则自动转换成 date 类型（入参格式化）</td><td></td></tr>
<tr><td>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</td><td></td><td>出参格式化 与 DateTimeFormat 相反，将 date 类型转为字符串</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-security-1"><a class="header" href="#spring-security-1">spring-security</a></h1>
<p>https://www.bilibili.com/video/BV1mm4y1X7Hc</p>
<p>本质上是一个过滤器链。</p>
<h2 id="认证授权整个流程"><a class="header" href="#认证授权整个流程">认证授权整个流程</a></h2>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220526134339123.png" alt="image-20220526134339123" /></p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220526134353028.png" alt="image-20220526134353028" /></p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>: 负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p>**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p>**FilterSecurityInterceptor：**负责权限校验的过滤器。</p>
<h2 id="认证"><a class="header" href="#认证">认证</a></h2>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220526133129215.png" alt="image-20220526133129215" /></p>
<p>登录</p>
<p>​	①自定义登录接口</p>
<p>​				调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>
<p>​				把用户信息存入redis中</p>
<p>​	②自定义UserDetailsService </p>
<p>​				在这个实现类中去查询数据库</p>
<p>校验：</p>
<p>​	①定义Jwt认证过滤器</p>
<p>​				获取token</p>
<p>​				解析token获取其中的userid</p>
<p>​				从redis中获取用户信息</p>
<p>​				存入SecurityContextHolder（后面的过滤器会获取 SecurityContextHolder 中认证的用户信息，如果能获取到，并且是认证的状态，则放行）</p>
<h2 id="授权"><a class="header" href="#授权">授权</a></h2>
<p>在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>所以我们在项目中只需要把当前登录用户的权限信息也存入 Authentication。</p>
<p>然后设置我们的资源所需要的权限即可。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220527135446218.png" alt="image-20220527135446218" /></p>
<h2 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h2>
<p>我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>
<p>在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>
<p>如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>
<p>如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>
<p>所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p>
<h2 id="跨域-2"><a class="header" href="#跨域-2">跨域</a></h2>
<p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springboot"><a class="header" href="#springboot">SpringBoot</a></h1>
<p>[TOC]</p>
<h2 id="springboot-开发经验"><a class="header" href="#springboot-开发经验">SpringBoot 开发经验</a></h2>
<ul>
<li>
<p><strong>Controller层是不允许直接操作数据库</strong></p>
<p>Controller 层是负责调用 Service 的。一般的，一个Controller对应一个Service，一个Service对应一个Dao，一个Dao对应一个数据库表，当然根据项目或业务复杂程度，一个Controller可以调用多个Service，而一个Service也可以调用多个Dao，但是Controller层不允许互调</p>
</li>
<li>
<p>Tomcat10 不再支持 javax，转为支持 jakarta</p>
</li>
</ul>
<h3 id="resource-autowired-区别"><a class="header" href="#resource-autowired-区别">@Resource @Autowired 区别</a></h3>
<ol>
<li>@Autowired 与 @Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。</li>
<li>@Autowired 默认按类型装配（这个注解属于 spring），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</li>
<li>@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 <code>@Resource(name=&quot;PasswordEncoder&quot;) </code> 此为按照名称进行装配</li>
</ol>
<h2 id="springboot-aop"><a class="header" href="#springboot-aop">SpringBoot AOP</a></h2>
<p>springboot aop 具体实现：https://blog.csdn.net/qq_33257527/article/details/82561635</p>
<h2 id="springboot-项目代码结构"><a class="header" href="#springboot-项目代码结构">SpringBoot 项目代码结构</a></h2>
<pre><code>entity: entity 对应数据库中的表的映射
model
	dto: Data Transfer Object 数据传输对象， Service 向外传输的对象，命名规则 XxxDTO
	qo: 数据查询对象，controller 层接收上层的查询请求时的参数，命名规则 XxxQo
task: 存放定时任务，命名规则：XxxSchedule
</code></pre>
<h2 id="springboot-scheduling"><a class="header" href="#springboot-scheduling">SpringBoot Scheduling</a></h2>
<p>https://juejin.cn/post/6844904047237955592</p>
<p>https://spring.io/guides/gs/scheduling-tasks/</p>
<p>Cron expression must consist of 6 fields！没有年！！！</p>
<p><code> [秒] [分] [时] [日] [月] [周]</code></p>
<table><thead><tr><th>域</th><th>是否必填</th><th>值以及范围</th><th>通配符</th></tr></thead><tbody>
<tr><td>秒</td><td>是</td><td>0-59</td><td>, - * /</td></tr>
<tr><td>分</td><td>是</td><td>0-59</td><td>, - * /</td></tr>
<tr><td>时</td><td>是</td><td>0-23</td><td>, - * /</td></tr>
<tr><td>日</td><td>是</td><td>1-31</td><td>, - * ? / L W</td></tr>
<tr><td>月</td><td>是</td><td>1-12 或 JAN-DEC</td><td>, - * /</td></tr>
<tr><td>周</td><td>是</td><td>1-7 或 SUN-SAT</td><td>, - * ? / L #</td></tr>
</tbody></table>
<p>通配符：</p>
<pre><code>,  这里指的是在两个以上的时间点中都执行，如果我们在 “分” 这个域中定义为 8,12,35 ，则表示分别在第8分，第12分 第35分执行该定时任务。
-  这个比较好理解就是指定在某个域的连续范围，如果我们在 “时” 这个域中定义 1-6，则表示在1到6点之间每小时都触发一次，用 , 表示 1,2,3,4,5,6
*  表示所有值，可解读为 “每”。 如果在“日”这个域中设置 *,表示每一天都会触发。
?  表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的8号触发一个操作，但不关心是周几，我们可以这么设置 0 0 0 8 * ?
/  在某个域上周期性触发，该符号将其所在域中的表达式分为两个部分，其中第一部分是起始值，除了秒以外都会降低一个单位，比如 在 “秒” 上定义 5/10 表示从 第 5 秒开始 每 10 秒执行一次，而在 “分” 上则表示从 第 5 秒开始 每 10 分钟执行一次。
L  表示英文中的LAST 的意思，只能在 “日”和“周”中使用。在“日”中设置，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在“周”上表示周六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在“周”上设置”7L”这样的格式,则表示“本月最后一个周六”
W  表示离指定日期的最近那个工作日(周一至周五)触发，只能在 “日” 中使用且只能用在具体的数字之后。若在“日”上置”15W”，表示离每月15号最近的那个工作日触发。假如15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果是 “1W” 就只能往本月的下一个最近的工作日推不能跨月往上一个月推。
#  表示每月的第几个周几，只能作用于 “周” 上。例如 ”2#3” 表示在每月的第三个周二。
</code></pre>
<p>创建 <code>scheduledtask</code> 包，然后在该包下新建定时任务。</p>
<p>java 的 crontab 可以精确到秒。</p>
<pre><code class="language-java">@Component // 必须要加该注解，表示这是一个组件，这样 IoC 容器才会自动生成该对象
@EnableScheduling
public class SyncSchedule {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);

    @Scheduled(cron = &quot;*/3 * * * * *&quot;) // 每 3 秒执行一次
    public void schedulingDemo(){
        System.out.println(&quot;The time is now {}&quot;, dateFormat.format(new Date()));
    }
}
</code></pre>
<p>在分布式环境中，还要为 Schedule 配置分布式锁：</p>
<pre><code class="language-java">@Component
@EnableScheduling
@Slf4j
@PropertySource(&quot;application.yml&quot;)
public class SyncSchedule {

    public SyncSchedule(@Value(&quot;${cron}&quot;)String cron) throws NoSuchMethodException, NoSuchFieldException, IllegalAccessException {
        // 动态修改定时器注解的定时任务
        Method method = SyncSchedule.class.getDeclaredMethod(&quot;schedulingDemo&quot;);
        if ( method != null ) {
            Scheduled scheduledAnnotation = method.getAnnotation(Scheduled.class);
            InvocationHandler handler = Proxy.getInvocationHandler(scheduledAnnotation);
            Field hField = handler.getClass().getDeclaredField(&quot;memberValues&quot;);
            hField.setAccessible(true);
            Map memberValues = (Map) hField.get(handler);
            memberValues.put(&quot;cron&quot;, cron);
        }
    }

    /**
    * 定时程序，触发频率可以在 application.yml 中修改
    * @param
    * @return
    */
    @Scheduled(cron = &quot;*/3 * * * * *&quot;)
    @SchedulerLock(name = &quot;res_schedulingDemo&quot;, lockAtMostFor = &quot;10m&quot;, lockAtLeastFor = &quot;10m&quot;)
    public void schedulingDemo(){
        log.info(&quot;schedulingDemo run...&quot;);
    }
}
</code></pre>
<p>其中 <code>name</code> 必须要取，<code>lockAtMostFor</code> 表示加锁时间不能超过 10m，超过 10m 就释放锁，<code>lockAtLeastFor</code> 表示加锁至少 10m。</p>
<p>By setting <code>lockAtMostFor</code> we make sure that the lock is released even if the node dies and by setting <code>lockAtLeastFor</code> we make sure it's not executed more than once in fifteen minutes. Please note that <strong><code>lockAtMostFor</code> is just a safety net in case that the node executing the task dies, so set it to a time that is significantly larger than maximum estimated execution time.</strong> If the task takes longer than <code>lockAtMostFor</code>, it may be executed again and the results will be unpredictable (more processes will hold the lock).</p>
<p>Reference：</p>
<ul>
<li>https://note.youdao.com/ynoteshare1/index.html?id=fe2f77731cd2b9196f1184a093989488&amp;type=note</li>
<li>https://github.com/lukas-krecan/ShedLock#jdbctemplate</li>
</ul>
<h2 id="springboot-boostrap"><a class="header" href="#springboot-boostrap">SpringBoot Boostrap</a></h2>
<p>bootstrap.yml 比 application.yml 先加载，具有更高的优先级，并且不会被覆盖。</p>
<p>bootstrap.yml 用来程序引导时执行，应用于更加早期配置信息读取。可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。一旦bootStrap.yml 被加载，则内容不会被覆盖。</p>
<p>application.yml 可以用来定义应用级别的， 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。</p>
<p>bootstrap 主要用于配置 SpringCloud 微服务。</p>
<h2 id="springboot-yml-配置文件"><a class="header" href="#springboot-yml-配置文件">SpringBoot yml 配置文件</a></h2>
<p>yml 文件中的配置，如果是数字的配置，可以用 int 或者 float 来接。以下的配置，都是有效的：</p>
<pre><code class="language-yaml">boost:
  boost1: 1.1f
  boost2: 2.2f
  crontab: 0 */10 * * * *
</code></pre>
<h2 id="springboot-全局异常处理"><a class="header" href="#springboot-全局异常处理">SpringBoot 全局异常处理</a></h2>
<p>SpringBoot中有一个<code>ControllerAdvice</code>的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用<code>ExceptionHandler</code> 注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。</p>
<p>https://www.cnblogs.com/xuwujing/p/10933082.html</p>
<h2 id="springboot-profile-多开发环境"><a class="header" href="#springboot-profile-多开发环境">SpringBoot Profile 多开发环境</a></h2>
<p>环境切换</p>
<p>profile 还可以用作条件装配</p>
<p>配合 snakeyml 可以实现   <code>active: @profile.env@</code> 动态配置</p>
<p>每一次切换配置文件，都要 reload 一下 maven，否则会报下面这个错误：</p>
<pre><code>found character '@' that cannot start any token. (Do not use @ for indentation)
 in 'reader', line 6, column 13:
        active: @profile.env@
</code></pre>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210630081937810.png" alt="image-20210630081937810" style="zoom:80%;" />
<pre><code class="language-xml">&lt;profiles&gt;
    &lt;!-- 开发/测试环境，默认激活 --&gt;
    &lt;profile&gt;
        &lt;id&gt;test&lt;/id&gt; &lt;!-- 此处的 test 对应上图中的 test --&gt;
        &lt;properties&gt; &lt;!-- 定义该 profile 持有的三个变量 --&gt;
            &lt;application.exclude&gt;-pro&lt;/application.exclude&gt;
            &lt;bootstrap.exclude&gt;pro&lt;/bootstrap.exclude&gt;
            &lt;profile.env&gt;test&lt;/profile.env&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;

    &lt;!-- 生产环境 --&gt;
    &lt;profile&gt;
        &lt;id&gt;pro&lt;/id&gt;
        &lt;properties&gt;
            &lt;!-- 支持通配符，这里表示在选中 pro 进行打包的时候，排除掉所有以 application-开头的配置，也就是排除掉了所有的 application yml 文件 --&gt;
            &lt;application.exclude&gt;-*&lt;/application.exclude&gt;
            &lt;bootstrap.exclude&gt;test&lt;/bootstrap.exclude&gt;
            &lt;profile.env&gt;pro&lt;/profile.env&gt;
        &lt;/properties&gt;
        &lt;activation&gt;
            &lt;!--默认启用的是pro环境配置 --&gt;
            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
        &lt;/activation&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;

&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt; &lt;!-- 在打包的时候，IDE 会看我们勾选了哪一个环境，加入勾选了 test 环境，那么下面这两个 exclude 就把  application-pro.yml 和 bootstrap-pro.yml 屏蔽掉，这两个变量指向的是 test 环境配置的变量 --&gt;
                &lt;exclude&gt;application${application.exclude}.yml&lt;/exclude&gt; 
                &lt;exclude&gt;bootstrap-${bootstrap.exclude}.yml&lt;/exclude&gt;
            &lt;/excludes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><strong>注意</strong>：如果切换 profile 后，不生效的话，要把 target 目录下的内容 clean 掉！</p>
<h2 id="springboot-程序版本控制"><a class="header" href="#springboot-程序版本控制">SpringBoot 程序版本控制</a></h2>
<p>想要实现 jar 包程序的版本控制，可以在程序打包的时候，将 git commit 信息打到 jar 包中，然后通过 swagger 暴露出来。</p>
<p>这是一个公共的功能，可以抽取成公共组件！</p>
<h2 id="spel-spring-表达式"><a class="header" href="#spel-spring-表达式">SpEL Spring 表达式</a></h2>
<p>Spring Expression Language</p>
<h2 id="springboot-controller-http-请求分类"><a class="header" href="#springboot-controller-http-请求分类">SpringBoot Controller HTTP 请求分类</a></h2>
<h3 id="get"><a class="header" href="#get">Get</a></h3>
<pre><code class="language-java">@GetMapping(&quot;/entity2groups/{groupId}/access&quot;)
@ApiOperation(value = &quot;获取分组关联的实体ID集合&quot;)
public Result&lt;List&lt;String&gt;&gt; getEntitiesByGroup(@PathVariable(&quot;groupId&quot;) String groupId){
    List&lt;String&gt; entityIdList = entityToGroupService.findAllEntityByGroup(groupId);
    return Result.buildSuccess(entityIdList, &quot;获取分组关联的实体集合&quot;);
}

// required: 可以传参，也可以不传
@GetMapping(&quot;/get_id&quot;)
@ApiOperation(value = &quot;测试 get_id&quot;)
public String findIdByName(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;test_name&quot;, required = false) String name){
    return entityItemService.findIdByName(name);
}
</code></pre>
<h3 id="post"><a class="header" href="#post">Post</a></h3>
<pre><code class="language-java">@PostMapping(&quot;/import&quot;)
@ApiOperation(value = &quot;全量导入路由&quot;, notes = &quot;全量导入，导入前路由库会清空&quot;)
public Result&lt;Boolean&gt; updateIndexRoute(@RequestBody List&lt;RouteDTO&gt; routeList) throws IOException, ClassNotFoundException {
    routeService.updateIndexRoute(routeList);
    return Result.buildSuccess();
}


// 注意这里配置了两个注解，@NotNull 和 @PathVariable，说明多个注解可以同时使用
// @NotNull 注解也有奇效，可以直接对传参进行控制
@PostMapping(&quot;/{tableName}/import&quot;)
@ApiOperation(value = &quot;全量配置一张表的路由&quot;, notes = &quot;全量导入，导入前该表的旧路由会被全部删除&quot;)
public Result&lt;Boolean&gt; updateIndexRouteByTableName(@PathVariable(&quot;tableName&quot;) @NotNull String tableName,
                                                   @RequestBody List&lt;RouteDTO&gt; routeList) throws IOException, ClassNotFoundException {
    routeService.updateIndexRouteByTableName(tableName, routeList);
    return Result.buildSuccess();
}
</code></pre>
<h2 id="springboot-开发常用库"><a class="header" href="#springboot-开发常用库">SpringBoot 开发常用库</a></h2>
<h3 id="swagger"><a class="header" href="#swagger">Swagger</a></h3>
<p>Swagger是一款RESTFUL接口的文档在线自动生成 + 功能测试功能软件。</p>
<p>配置：</p>
<p>在 <code>config/</code> 文件夹下，增加 swagger 的配置，文件名可以任意指定，通常设置为 <code>Swagger2Config</code></p>
<p>使用 Swagger Annotations</p>
<pre><code class="language-java">@GetMapping(&quot;&quot;)
@ApiOperation(value = &quot;测试数据库同步&quot;) // 注解接口名称
public long getNameByID(@ApiParam(&quot;查询的 ID&quot;) int id){ // 注解参数
    return 1;
}
</code></pre>
<pre><code class="language-java">public class AuthorityInfoReq {
    @ApiModelProperty(name=&quot;服务ID&quot;, required = true)
    @NotNull(message = &quot;服务ID不能缺少&quot;)
    @NotEmpty(message = &quot;服务ID不能为空&quot;)
    private String serviceId;

    @ApiModelProperty(&quot;动作&quot;)
    private String operation;

    @ApiModelProperty(name=&quot;资源列表&quot;, required = true)
    @NotNull(message = &quot;资源列表不能缺少&quot;)
    private List&lt;ObjectResourceDto&gt; resource;
}
</code></pre>
<p><strong>测试</strong></p>
<pre><code>http://localhost:port/service-name/doc.html
</code></pre>
<h3 id="easypoi"><a class="header" href="#easypoi">easypoi</a></h3>
<p>Office 文档处理，生成 word, excel 文档</p>
<h3 id="spring-boot-maven-plugin"><a class="header" href="#spring-boot-maven-plugin">spring-boot-maven-plugin</a></h3>
<p>用于简化部署！</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
</code></pre>
<p>用于创建一个可执行的 jar 包。fat jar。clean —&gt; package</p>
<pre><code>java -jar xxx.jar
</code></pre>
<p>注意，如果我们只是做依赖包，那么就不需要留着 main 方法，删除 main 文件后，会报错找不到主类，这个时候就需要删除这个组件了。</p>
<h3 id="lombok-1"><a class="header" href="#lombok-1">lombok</a></h3>
<p>lang bao k</p>
<p>lombok的主要作用是通过一些注解，消除样板式代码。简化 JavaBean 开发。在编译的时候生成 Java 代码。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Demo:</p>
<pre><code class="language-java">@ToString // 生成 toString 方法
@Data // 生成 Mountain 的 getter setter 
@AllArgsConstructor // 生成有参构造器
@NoArgsConstructor // 无参构造器
@EqualsAndHashCode // 用这些参数生成 hashcode
public class Mountain{
    private String name;
    private double longitude;
    private String country;
}
</code></pre>
<pre><code class="language-java">@Slf4j
// 等价于
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
</code></pre>
<p>注意：需要在 IDEA 中安装 lombok 插件。setting - plugins </p>
<h3 id="resttemplate"><a class="header" href="#resttemplate">RestTemplate</a></h3>
<p>发起 http 请求的库。</p>
<p>get 请求的两种请求方式：</p>
<pre><code class="language-java">@Resource
private RestTemplate restTemplate;
	
// getForEntity 是 Spring 对 HTTP请求响应 的封装
entity = httpClientTemplate.getForEntity(casUrl, String.class);
entity.getStatusCodeValue();
entity.getBody();

// getForObject函数实际上是对getForEntity函数的进一步封装，是对消息体的进一步封装
IG507StockInfo responseStockInfo = restTemplate.getForObject(ig507Url, IG507StockInfo.class);
</code></pre>
<p>注意，RestTemplate 需要自己 new 出来，springboot 并没有帮我们自动注入</p>
<pre><code class="language-java">@Configuration
public class Config {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder){
        return builder.build();
    }
}
</code></pre>
<h3 id="fastjson-jackson"><a class="header" href="#fastjson-jackson">fastjson jackson</a></h3>
<p>序列化和反序列化工具。</p>
<p>SpringBoot 自带的是 jackson，如果要切换成 fastjson，则需要单独配置。</p>
<p>jackson 有一个巨坑，就是无法反序列化第二个字母大写的字段，举例：</p>
<p>将下面的 json 反序列化成 bean 的时</p>
<pre><code class="language-json">{
  &quot;eMail&quot;: &quot;wanshojs@gmail.com&quot;
}
</code></pre>
<p>得到的 eMail 字段是 null。需要强制指定来进行反序列化：</p>
<pre><code class="language-java">@Data
public class User {

    private String name;

    @JsonProperty(&quot;eMail&quot;)
    private String eMail;
  
  	/***
     * 前端传过来的是 more-info，解析对应到 moreInfo 字段
     */
    @JsonProperty(&quot;more-info&quot;)
    private String moreInfo;

}
</code></pre>
<p>fastjson 不存在上述问题。</p>
<p>fastjson 中和 @JsonProperty 功能类似的注解是：<code>@JSONField(name=&quot;eMail&quot;)</code>。</p>
<p>https://stackoverflow.com/questions/30205006/why-does-jackson-2-not-recognize-the-first-capital-letter-if-the-leading-camel-c</p>
<h2 id="springboot-项目测试"><a class="header" href="#springboot-项目测试">SpringBoot 项目测试</a></h2>
<h3 id="单元测试-1"><a class="header" href="#单元测试-1">单元测试</a></h3>
<h4 id="重要性-1"><a class="header" href="#重要性-1">重要性</a></h4>
<ul>
<li>与 Maven 的配合，clean - test 会把所有的单元测试跑一遍</li>
<li>Junit 类具有 Spring 的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
<h4 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h4>
<ul>
<li>在单元测试中，要使用 Assert 断言机制，不要使用 sout</li>
<li>一个业务逻辑开发完后，一定要写单元测试类。</li>
</ul>
<h3 id="springboot-22-junit5-1"><a class="header" href="#springboot-22-junit5-1">SpringBoot 2.2+ JUnit5</a></h3>
<p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库。</p>
<p>JUnit5 的核心是 JUnit Jupiter。</p>
<p>JUnit5: https://junit.org/junit5/docs/current/user-guide/</p>
<p>需要引入的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>增加测试用例的 IDEA 快捷键：在类中 alt + insert</p>
<h3 id="兼容-junit4-1"><a class="header" href="#兼容-junit4-1">兼容 JUnit4</a></h3>
<p>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用 junit4 的功能 @Test）</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>@SpringBootTest + @RunWith(SpringTest.class)</p>
<h3 id="junit5-注解-1"><a class="header" href="#junit5-注解-1">JUnit5 注解</a></h3>
<p>JUnit5 提供的一些注解：</p>
<table><thead><tr><th style="text-align: left">Annotation</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@Test</code></td><td style="text-align: left">Denotes that a method is a test method. Unlike JUnit 4’s <code>@Test</code> annotation, this annotation does not declare any attributes, since test extensions in JUnit Jupiter operate based on their own dedicated annotations. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@ParameterizedTest</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">parameterized test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@RepeatedTest</code></td><td style="text-align: left">Denotes that a method is a test template for a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests">repeated test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestFactory</code></td><td style="text-align: left">Denotes that a method is a test factory for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests">dynamic tests</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestTemplate</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-templates">template for test cases</a> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-test-templates">providers</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestMethodOrder</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order">test method execution order</a> for the annotated test class; similar to JUnit 4’s <code>@FixMethodOrder</code>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestInstance</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> for the annotated test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayName</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names">display name</a> for the test class or test method. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayNameGeneration</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-name-generator">display name generator</a> for the test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@Before</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@AfterEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@After</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@BeforeClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr>
<tr><td style="text-align: left"><code>@AfterAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@AfterClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr>
<tr><td style="text-align: left"><code>@Nested</code></td><td style="text-align: left">Denotes that the annotated class is a non-static <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">nested test class</a>. <code>@BeforeAll</code> and <code>@AfterAll</code> methods cannot be used directly in a <code>@Nested</code> test class unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Tag</code></td><td style="text-align: left">Used to declare <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">tags for filtering tests</a>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are <em>inherited</em> at the class level but not at the method level.</td></tr>
<tr><td style="text-align: left"><code>@Disabled</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling">disable</a> a test class or test method; analogous to JUnit 4’s <code>@Ignore</code>. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Timeout</code></td><td style="text-align: left">Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@ExtendWith</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-declarative">register extensions declaratively</a>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@RegisterExtension</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic">register extensions programmatically</a> via fields. Such fields are <em>inherited</em> unless they are <em>shadowed</em>.</td></tr>
<tr><td style="text-align: left"><code>@TempDir</code></td><td style="text-align: left">Used to supply a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory">temporary directory</a> via field injection or parameter injection in a lifecycle method or test method; located in the <code>org.junit.jupiter.api.io</code> package.</td></tr>
</tbody></table>
<p>代码Demo：https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions</p>
<p>注意 @Test 标注，需要使用junit5版本的注解（Jupiter）。</p>
<h3 id="测试经验总结"><a class="header" href="#测试经验总结">测试经验总结</a></h3>
<h4 id="transactional-回滚-1"><a class="header" href="#transactional-回滚-1">@Transactional 回滚</a></h4>
<p>想要数据库回到测试之前的情况，使用 <code>@Transactional</code> 进行回滚</p>
<pre><code class="language-java">@Test
// Transactional 回滚该方法
@Transactional
void update() {
    assertNotNull(userService.update());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务"><a class="header" href="#微服务">微服务</a></h1>
<p>[TOC]</p>
<h2 id="甚么是微服务"><a class="header" href="#甚么是微服务">甚么是微服务</a></h2>
<p>微服务是一种经过良好架构设计的分布式架构方案。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210826154834131.png" alt="image-20210826154834131" /></p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210826155201843.png" alt="image-20210826155201843" /></p>
<p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210826161312535.png" alt="image-20210826161312535" style="zoom:80%;" />
<img src="computer-science-notebook/note-for-java-web/assets/image-20210826161412062.png" alt="image-20210826161412062" style="zoom:80%;" />
<h2 id="服务拆分"><a class="header" href="#服务拆分">服务拆分</a></h2>
<p>微服务拆分的几个原则：</p>
<ul>
<li>业务解耦：不同微服务，不要重复开发相同业务</li>
<li>数据库解耦：微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ul>
<h2 id="微服务远程调用"><a class="header" href="#微服务远程调用">微服务远程调用</a></h2>
<p>使用 RestTemplate 向其他服务发起 HTTP 请求。</p>
<p>远程调用的问题：</p>
<ul>
<li>服务消费者该如何获取服务提供者的地址信息？</li>
<li>如果有多个服务提供者，消费者该如何选择？</li>
<li>消费者如何得知服务提供者的健康状态？</li>
</ul>
<h2 id="eureka-注册中心"><a class="header" href="#eureka-注册中心">Eureka 注册中心</a></h2>
<p>1.搭建EurekaServer</p>
<ul>
<li>
<p>引入eureka-server依赖</p>
</li>
<li>
<p>添加 @EnableEurekaServer 注解</p>
</li>
<li>
<p>在 application.yml 中配置 eureka 地址</p>
</li>
</ul>
<p>2.服务注册</p>
<ul>
<li>
<p>引入 eureka-client 依赖</p>
</li>
<li>
<p>在 application.yml 中配置 eureka 地址</p>
</li>
</ul>
<p>3.服务发现</p>
<ul>
<li>
<p>给RestTemplate添加@LoadBalanced注解</p>
</li>
<li>
<p>用服务提供者的服务名称远程调用</p>
</li>
</ul>
<h3 id="作用"><a class="header" href="#作用">作用</a></h3>
<p>Eureka 的作用：</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210826164713881.png" alt="image-20210826164713881" style="zoom:80%;" />
<h3 id="搭建-eureka-server"><a class="header" href="#搭建-eureka-server">搭建 Eureka Server</a></h3>
<p>Eureka Server 不是一个独立的软件，依赖于一个独立的微服务，以服务的形式呈现。</p>
<ol>
<li>引入 eureka-server 依赖</li>
<li>添加 @EnableEurekaServer 注解</li>
<li>在 application.yml 中配置 eureka 地址</li>
</ol>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>给 eureka-server 服务编写一个启动类，一定要添加一个 @EnableEurekaServer 注解，开启 eureka 的注册中心功能：</p>
<pre><code class="language-java">package cn.itcast.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
</code></pre>
<p>编写一个 application.yml 文件，内容如下：</p>
<pre><code class="language-yaml">server:
  port: 10086
spring:
  application:
    name: eureka-server
eureka:
  client:
    service-url: 
      defaultZone: http://127.0.0.1:10086/eureka # 将自己也注册到 Eureka Server
</code></pre>
<h3 id="注册到-eureka"><a class="header" href="#注册到-eureka">注册到 Eureka</a></h3>
<p>下面，我们将 user-service 注册到 eureka-server 中去。</p>
<p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p>
<pre><code class="language-yaml">spring:
  application:
    name: userservice
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
</code></pre>
<h3 id="服务拉取"><a class="header" href="#服务拉取">服务拉取</a></h3>
<p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡。</p>
<ol>
<li>
<p>修改 OrderService 的代码，修改访问的 url 路径，用服务名代替ip、端口</p>
<pre><code class="language-java">String url = &quot;http://userservice/user/&quot; + order.getUserId();
</code></pre>
</li>
<li>
<p>在 order-service 项目的启动类 OrderApplication 中的 RestTemplate 添加<strong>负载均衡</strong>注解</p>
<pre><code class="language-java">@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}
</code></pre>
</li>
</ol>
<h3 id="ribbon-负载均衡"><a class="header" href="#ribbon-负载均衡">Ribbon 负载均衡</a></h3>
<p>Ribbon 负载均衡是 SpringCloud 的一个组件，spring-cloud-starter-netflix-eureka-client 会自动引入 ribbon。</p>
<p>负载均衡的流程：</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210826191057969.png" alt="image-20210826191057969" style="zoom:80%;" />
<p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>
<p>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p>
<pre><code class="language-java">@Bean
public IRule randomRule(){
    return new RandomRule();
}
</code></pre>
</li>
<li>
<p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>
<pre><code class="language-java">userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 
</code></pre>
</li>
</ol>
<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<pre><code class="language-yaml">ribbon:
  eager-load:
    enabled: true # 开启饥饿加载 
    clients: 
      - userservice # 指定对userservice这个服务饥饿加载
</code></pre>
<h2 id="nacos-注册中心"><a class="header" href="#nacos-注册中心">Nacos 注册中心</a></h2>
<p>nacos 有别于 eureka，nacos 有一个客户端（其实也是一个 jar 包）。Nacos 也使用 ribbon 做服务拉取和负载均衡。</p>
<p>Nacos 比 Eureka 多了一个配置管理，可以远程管理各个微服务的 yml 文件。</p>
<p>nacos 已经升级到 nacos2 版本，性能提了 3 倍，加入了 gRPC 协议（nacos1.x 采用 restful 的方式）。</p>
<h3 id="nacos-api-注册"><a class="header" href="#nacos-api-注册">Nacos API 注册</a></h3>
<p>用于其他服务主动向 nacos 发送心跳。</p>
<p>https://nacos.io/zh-cn/docs/open-api.html</p>
<h3 id="服务注册"><a class="header" href="#服务注册">服务注册</a></h3>
<p>在 cloud-demo 父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入 SpringCloudAlibaba 的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在user-service和order-service中的pom文件中引入 nacos-discovery 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      server-addr: localhost:8848
</code></pre>
<h3 id="服务分级存储模型"><a class="header" href="#服务分级存储模型">服务分级存储模型</a></h3>
<p>将一个服务的多个实例，部署到多个机房。Nacos 引入了这个机房（地域）的概念。</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210826201700533.png" alt="image-20210826201700533" style="zoom:80%;" />
<p>服务调用尽可能选择本地集群的服务，跨集群调用延迟较高。本地集群不可访问时，再去访问其它集群。</p>
<p>配置集群(cluster)，修改 user-service 的 application.yml 文件，添加集群配置：</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ # 集群名称
</code></pre>
<p>还需要配置以下 Ribbon 的负载均衡规则。修改 order-service 的application.yml文件，修改负载均衡规则：</p>
<pre><code class="language-yaml">orderservice:
  ribbon:
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 
</code></pre>
<p>NacosRule 负载均衡策略：</p>
<ul>
<li>
<p>优先选择同集群服务实例列表</p>
</li>
<li>
<p>本地集群找不到提供者，才去其它集群寻找，并且会报警告</p>
</li>
<li>
<p>确定了可用实例列表后，再采用随机负载均衡挑选实例</p>
</li>
</ul>
<p><strong>注意</strong>：Ribbon 默认的负载均衡 Rule 是轮询，而 NacosRule 是随机的负载均衡方式。</p>
<h3 id="权重配置"><a class="header" href="#权重配置">权重配置</a></h3>
<p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况 NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重。</p>
<p>Nacos 控制台可以设置实例的权重值，0~1之间。同集群内的多个实例，权重越高被访问的频率越高，权重设置为0则完全不会被访问。</p>
<p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问。</p>
<p>权重配置，可以用于服务的平滑(用户无感知)升级，先把一个服务的权重设置为 0，然后设置升级服务，再把权重设置为 0.1，进行小流量测试。</p>
<h3 id="环境隔离-namespace"><a class="header" href="#环境隔离-namespace">环境隔离 namespace</a></h3>
<p>Nacos 提供了 namespace 来实现环境隔离功能。</p>
<ul>
<li>nacos 中可以有多个 namespace</li>
<li>namespace 下可以有 group、service等</li>
<li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li>
</ul>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210714000101516.png" alt="image-20210714000101516" style="zoom: 33%;" />
<p>默认情况下，所有service、data、group 都在同一个 namespace，名为 public。我们可以增加 dev, pro, test 等命名空间。</p>
<p>给微服务配置 namespace：</p>
<p>例如，修改 order-service 的 application.yml 文件：</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ
        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID
</code></pre>
<h3 id="nacos-与-eureka-区别"><a class="header" href="#nacos-与-eureka-区别">nacos 与 eureka 区别</a></h3>
<p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210826205832777.png" alt="image-20210826205832777" style="zoom: 67%;" />
<ul>
<li>
<p>Nacos 与 eureka 的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>
<p>Nacos 与 Eureka 的区别</p>
<ul>
<li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式（默认情况下所有的实例都是临时实例），非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</li>
</ul>
</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      discovery:
        ephemeral: false # 设置为非临时实例
</code></pre>
<h2 id="nacos-配置管理"><a class="header" href="#nacos-配置管理">Nacos 配置管理</a></h2>
<h3 id="统一配置管理"><a class="header" href="#统一配置管理">统一配置管理</a></h3>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210830085330590.png" alt="image-20210830085330590" style="zoom:80%;" />
<ol>
<li>
<p>引入 nacos-config 依赖</p>
<p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p>
<pre><code class="language-xml">&lt;!--nacos配置管理依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>添加 bootstrap.yaml</p>
<p>然后，在user-service中添加一个bootstrap.yaml 文件，内容如下：</p>
<pre><code class="language-yaml">spring:
  application:
    name: userservice # 服务名称
  profiles:
    active: dev #开发环境，这里是dev 
  cloud:
    nacos:
      server-addr: localhost:8848 # Nacos地址
      config:
        file-extension: yaml # 文件后缀名
</code></pre>
<p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p>
<p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714170845901.png" alt="image-20210714170845901" /></p>
</li>
<li>
<p>读取nacos配置</p>
<p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714170337448.png" alt="image-20210714170337448" /></p>
</li>
</ol>
<h3 id="配置热更新"><a class="header" href="#配置热更新">配置热更新</a></h3>
<p>Spring 不会自动进行热更新，有两种方式可以配置热更新：</p>
<ol>
<li>
<p><code>@RefreshScope</code></p>
<p>在 @Value 注入的变量所在类上添加注解 </p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714171036335.png" alt="image-20210714171036335" /></p>
</li>
<li>
<p><code>@ConfigurationProperties</code></p>
<p>使用 @ConfigurationProperties 注解代替 @Value 注解。</p>
<p>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：</p>
<pre><code class="language-java">package cn.itcast.user.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@Data
@ConfigurationProperties(prefix = &quot;pattern&quot;)
public class PatternProperties {
    private String dateformat;
}
</code></pre>
<p>在 UserController 中使用这个类代替 @Value：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714171316124.png" alt="image-20210714171316124" /></p>
</li>
</ol>
<h3 id="配置共享"><a class="header" href="#配置共享">配置共享</a></h3>
<p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p>
<ul>
<li>
<p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p>
</li>
<li>
<p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p>
</li>
</ul>
<p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p>
<p>当 nacos、服务本地同时出现相同属性时，优先级有高低之分：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714174623557.png" alt="image-20210714174623557" /></p>
<h2 id="http-客户端-feign"><a class="header" href="#http-客户端-feign">HTTP 客户端 Feign</a></h2>
<h3 id="feign-替代-resttemplate"><a class="header" href="#feign-替代-resttemplate">Feign 替代 RestTemplate</a></h3>
<p>RestTemplate 的缺点：</p>
<ul>
<li>
<p>代码可读性差，编程体验不统一</p>
</li>
<li>
<p>参数复杂URL难以维护</p>
</li>
</ul>
<p>Feign 是一个<strong>声明式</strong>的 http 客户端，官方地址：https://github.com/OpenFeign/feign</p>
<p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。Feign 还继承了 Ribbon，自带负载均衡。</p>
<p>Fegin的使用步骤如下：</p>
<ol>
<li>
<p>引入依赖</p>
<p>我们在order-service服务的pom文件中引入feign的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>添加注解</p>
<p>在 order-service 的启动类添加注解开启Feign的功能：</p>
<p><img src="computer-science-notebook/note-for-java-web/../../../../%E9%BB%91%E9%A9%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%A0%88/%E5%AE%9E%E7%94%A8%E7%AF%87/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/assets/image-20210714175102524.png" alt="image-20210714175102524" /></p>
</li>
<li>
<p>编写Feign的客户端</p>
<p>在 order-service（消费者，访问生产者 userservice） 的 client 文件夹下，新建一个接口，内容如下：</p>
<pre><code class="language-java">package cn.itcast.order.client;

import cn.itcast.order.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(&quot;userservice&quot;)
public interface UserClient {
    @GetMapping(&quot;/user/{id}&quot;)
    User findById(@PathVariable(&quot;id&quot;) Long id);
}
</code></pre>
<p>这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</p>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li>请求路径：/user/{id}</li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<p>这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>
</li>
</ol>
<h3 id="自定义配置"><a class="header" href="#自定义配置">自定义配置</a></h3>
<p>Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：</p>
<table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr>
<tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr>
<tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr>
<tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr>
<tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr>
</tbody></table>
<p>一般我们需要配置的就是日志级别。</p>
<h3 id="feign性能优化"><a class="header" href="#feign性能优化">Feign性能优化</a></h3>
<p>Feign的优化：</p>
<ol>
<li>
<p>日志级别尽量用 basic</p>
</li>
<li>
<p>使用 HttpClient 或 OKHttp 代替 URLConnection</p>
<p>2.1 引入 feign-httpClient 依赖</p>
<p>2.2 配置文件开启 httpClient 功能，设置连接池参数</p>
</li>
</ol>
<h3 id="feign-实战"><a class="header" href="#feign-实战">Feign 实战</a></h3>
<p>将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>
<p>也就是将所有消费者端写的 feign client，抽取到一个模块中，防止每个消费者模块都写一遍，增加维护成本。</p>
<p>例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714214041796.png" alt="image-20210714214041796" /></p>
<h2 id="统一网关-gateway"><a class="header" href="#统一网关-gateway">统一网关 Gateway</a></h2>
<h3 id="网关的作用"><a class="header" href="#网关的作用">网关的作用</a></h3>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20210830111825328.png" alt="image-20210830111825328" style="zoom: 50%;" />
<ul>
<li>身份认证和权限校验</li>
<li>服务路由、负载均衡</li>
<li>请求限流</li>
</ul>
<h3 id="gateway-快速入门"><a class="header" href="#gateway-快速入门">gateway 快速入门</a></h3>
<p>gateway 网关以一个独立的服务而存在。</p>
<p>网关搭建步骤：</p>
<ol>
<li>
<p>创建项目，引入nacos服务发现和gateway依赖</p>
</li>
<li>
<p>配置application.yml，包括服务基本信息、nacos地址、路由</p>
</li>
</ol>
<p>路由配置包括：</p>
<ol>
<li>
<p>路由id：路由的唯一标示</p>
</li>
<li>
<p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p>
</li>
<li>
<p>路由断言（predicates）：判断路由的规则，</p>
</li>
<li>
<p>路由过滤器（filters）：对请求或响应做处理</p>
</li>
</ol>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210830182353541.png" alt="image-20210830182353541" style="zoom:67%;" />
<p>步骤：</p>
<ol>
<li>
<p>创建 gateway 服务，引入依赖</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714210919458.png" alt="image-20210714210919458" /></p>
<p>引入依赖：</p>
<pre><code class="language-xml">&lt;!--网关--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--nacos服务发现依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>编写启动类</p>
<pre><code class="language-java">package cn.itcast.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(GatewayApplication.class, args);
	}
}
</code></pre>
</li>
<li>
<p>编写基础配置和路由规则</p>
<p>创建application.yml文件，内容如下：</p>
<pre><code class="language-yaml">server:
  port: 10010 # 网关端口
spring:
  application:
    name: gateway # 服务名称
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
    gateway:
      routes: # 网关路由配置
        - id: user-service # 路由id，自定义，只要唯一即可
          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址
          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称
          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
</code></pre>
<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>
</li>
</ol>
<h3 id="断言工厂"><a class="header" href="#断言工厂">断言工厂</a></h3>
<p>predicates：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody>
<tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr>
<tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr>
<tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr>
<tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr>
<tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr>
<tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr>
<tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr>
<tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr>
<tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr>
<tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr>
<tr><td>Weight</td><td>权重处理</td><td></td></tr>
</tbody></table>
<h3 id="过滤器工厂"><a class="header" href="#过滤器工厂">过滤器工厂</a></h3>
<p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的<strong>请求</strong>和微服务返回的<strong>响应</strong>做处理。</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20210830202353641.png" alt="image-20210830202353641" style="zoom:67%;" />
<p>Spring提供了31种不同的路由过滤器工厂。例如：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody>
<tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr>
<tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr>
<tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr>
<tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr>
<tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr>
<tr><td>...</td><td></td></tr>
</tbody></table>
<ol>
<li>
<p>请求头过滤器</p>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p>
<p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
      - id: user-service 
        uri: lb://userservice 
        predicates: 
        - Path=/user/** 
        filters: # 过滤器
        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
</code></pre>
<p>当前过滤器写在userservice路由下，因此仅仅对访问 userservice 的请求有效。</p>
</li>
<li>
<p>默认过滤器</p>
<p>如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
      - id: user-service 
        uri: lb://userservice 
        predicates: 
        - Path=/user/**
      default-filters: # 默认过滤项
      - AddRequestHeader=Truth, Itcast is freaking awesome! 
</code></pre>
<p>总结</p>
<p>过滤器的作用是什么？</p>
<p>① 对路由的请求或响应做加工处理，比如添加请求头</p>
<p>② 配置在路由下的过滤器只对当前路由的请求生效</p>
<p>defaultFilters 的作用是什么？</p>
<p>① 对所有路由都生效的过滤器</p>
</li>
</ol>
<h3 id="全局过滤器"><a class="header" href="#全局过滤器">全局过滤器</a></h3>
<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现。</p>
<p>定义方式是实现 GlobalFilter 接口。</p>
<pre><code class="language-java">public interface GlobalFilter {
    /**
     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
     *
     * @param exchange 请求上下文，里面可以获取Request、Response等信息
     * @param chain 用来把请求委托给下一个过滤器 
     * @return {@code Mono&lt;Void&gt;} 返回标示当前过滤器业务结束
     */
    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);
}
</code></pre>
<p>在 filter 中编写自定义逻辑，可以实现下列功能：</p>
<ul>
<li>登录状态判断</li>
<li>权限校验</li>
<li>请求限流等</li>
</ul>
<p>自定义全局过滤器，需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p>
<ul>
<li>
<p>参数中是否有authorization，</p>
</li>
<li>
<p>authorization参数值是否为admin</p>
</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<p>实现：</p>
<p>在gateway中定义一个过滤器：</p>
<pre><code class="language-java">package cn.itcast.gateway.filters;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Order(-1) // 过滤器的执行顺序
@Component
public class AuthorizeFilter implements GlobalFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1.获取请求参数
        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();
        // 2.获取authorization参数
        String auth = params.getFirst(&quot;authorization&quot;);
        // 3.校验
        if (&quot;admin&quot;.equals(auth)) {
            // 放行
            return chain.filter(exchange);
        }
        // 4.拦截
        // 4.1.禁止访问，设置状态码
        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
        // 4.2.结束处理
        return exchange.getResponse().setComplete();
    }
}
</code></pre>
<p>自定义过滤器，一定要有顺序。</p>
<h3 id="过滤器执行顺序"><a class="header" href="#过滤器执行顺序">过滤器执行顺序</a></h3>
<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p>
<p>请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20210714214228409.png" alt="image-20210714214228409" /></p>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的 order 值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter 通过实现 Ordered 接口，或者添加 @Order 注解来指定 order 值，由我们自己指定</li>
<li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li>
</ul>
<h3 id="网关跨域问题"><a class="header" href="#网关跨域问题">网关跨域问题</a></h3>
<p>跨域只需要在网关处处理就 ok 了。</p>
<p>在 gateway 服务的 application.yml 文件中，添加下面的配置：</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      # 。。。
      globalcors: # 全局的跨域处理
        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题
        corsConfigurations:
          '[/**]':
            allowedOrigins: # 允许哪些网站的跨域请求 
              - &quot;http://localhost:8090&quot;
            allowedMethods: # 允许的跨域ajax的请求方式
              - &quot;GET&quot;
              - &quot;POST&quot;
              - &quot;DELETE&quot;
              - &quot;PUT&quot;
              - &quot;OPTIONS&quot;
            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息
            allowCredentials: true # 是否允许携带cookie
            maxAge: 360000 # 这次跨域检测的有效期
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactive"><a class="header" href="#reactive">Reactive</a></h1>
<p>[TOC]</p>
<h2 id="vertx"><a class="header" href="#vertx">Vert.x</a></h2>
<p>Reactive applications on the JVM.</p>
<p>Vert.x 是一个 web 框架，是响应式的 web 框架，类似 Node.js。运行在 Java 虚拟机上，支持 7 种语言的开发。</p>
<h2 id="spring-webflux"><a class="header" href="#spring-webflux">Spring Webflux</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缓存"><a class="header" href="#缓存">缓存</a></h1>
<p>[TOC]</p>
<h2 id="缓存组件"><a class="header" href="#缓存组件">缓存组件</a></h2>
<h3 id="caffeine"><a class="header" href="#caffeine">caffeine</a></h3>
<p><a href="https://www.cnblogs.com/rickiyang/p/11074158.html">Caffine Cache</a> </p>
<h3 id="ehcache"><a class="header" href="#ehcache">ehcache</a></h3>
<p><a href="https://blog.csdn.net/w405722907/article/details/80517345">SpringBoot+SpringDataJPA使用Ehcache缓存</a> 测试可用</p>
<p><a href="https://zhuanlan.zhihu.com/p/328919856">教程</a></p>
<h2 id="spring-cache"><a class="header" href="#spring-cache">Spring Cache</a></h2>
<p>Spring Cache 对 Cache 进行了统一化，类似于 Spring Data。</p>
<p><a href="https://juejin.cn/post/6844903966615011335">Spring Cache 使用</a> | <a href="https://www.cnblogs.com/coding-one/p/12401630.html">@Cacheable 使用详解</a> | </p>
<h3 id="cachemanager"><a class="header" href="#cachemanager">CacheManager</a></h3>
<p>在 Spring 3.1 中引入了多 Cache 的支持，在 spring-context 包中定义了<code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 两个接口来统一不同的缓存技术。Cache 接口包含缓存的常用操作：增加、删除、读取等。CacheManager 是 Spring 各种缓存的抽象接口。</p>
<p>Spring 支持的常用 CacheManager 如下：</p>
<table><thead><tr><th>CacheManager</th><th>描述</th></tr></thead><tbody>
<tr><td>SimpleCacheManager</td><td>使用简单的 Collection 来存储缓存</td></tr>
<tr><td>ConcurrentMapCacheManager</td><td>使用 java.util.ConcurrentHashMap 来实现缓存</td></tr>
<tr><td>NoOpCacheManager</td><td>仅测试用，不会实际存储缓存</td></tr>
<tr><td>EhCacheCacheManger</td><td>使用EhCache作为缓存技术。EhCache 是一个纯 Java 的进程内缓存框架，特点快速、精干，是 Hibernate 中默认的 CacheProvider，也是 Java 领域应用最为广泛的缓存</td></tr>
<tr><td>JCacheCacheManager</td><td>支持JCache（JSR-107）标准的实现作为缓存技术</td></tr>
<tr><td>CaffeineCacheManager</td><td>使用 Caffeine 作为缓存技术。用于取代 Guava 缓存技术。</td></tr>
<tr><td>RedisCacheManager</td><td>使用Redis作为缓存技术</td></tr>
<tr><td>HazelcastCacheManager</td><td>使用Hazelcast作为缓存技术</td></tr>
<tr><td>CompositeCacheManager</td><td>用于组合 CacheManager，可以从多个 CacheManager 中轮询得到相应的缓存</td></tr>
</tbody></table>
<h3 id="注解-1"><a class="header" href="#注解-1">注解</a></h3>
<p>Spring Cache 提供了 @Cacheable 、@CachePut 、@CacheEvict 、@Caching 等注解，在方法上使用。通过注解 Cache 可以实现类似事务一样、缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码。 核心思想：当我们调用一个方法时会把该方法的参数和返回结果最为一个键值对存放在缓存中，等下次利用同样的参数来调用该方法时将不会再执行，而是直接从缓存中获取结果进行返回。</p>
<ul>
<li>
<p>@EnableCaching</p>
<p>开启缓存功能，一般放在启动类上。</p>
</li>
<li>
<p>@CacheConfig</p>
<p>当我们需要缓存的地方越来越多，你可以使用@CacheConfig(cacheNames = {&quot;cacheName&quot;})注解在 class 之上来统一指定value的值，这时可省略value，如果你在你的方法依旧写上了value，那么依然以方法的value值为准。</p>
</li>
<li>
<p>@Cacheable （查）</p>
<p>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。<strong>一般用在查询方法上</strong>。 查看源码，属性值如下：</p>
<table><thead><tr><th>属性/方法名</th><th>解释</th></tr></thead><tbody>
<tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr>
<tr><td>cacheNames</td><td>与 value 差不多，二选一即可，用于关联多块缓存</td></tr>
<tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的 key</td></tr>
<tr><td>keyGenerator</td><td>key的生成器。key/keyGenerator 二选一使用</td></tr>
<tr><td>cacheManager</td><td>指定缓存管理器</td></tr>
<tr><td>cacheResolver</td><td>指定获取解析器</td></tr>
<tr><td>condition</td><td>条件符合则缓存</td></tr>
<tr><td>unless</td><td>条件符合则不缓存</td></tr>
<tr><td>sync</td><td>是否使用异步模式，默认为 false</td></tr>
</tbody></table>
<p>@Cacheable 支持同一个方法关联多个缓存。这种情况下，当执行方法之前，这些关联的每一个缓存都会被检查，而且只要至少其中一个缓存命中了，那么这个缓存中的值就会被返回。</p>
<p>一个缓存名对应一个被注解的方法，但是一个方法可能传入不同的参数，那么结果也就会不同，这应该如何区分呢？这就需要用到 key 。在 spring 中，key 的生成有两种方式：显式指定和使用 keyGenerator 自动生成。</p>
</li>
<li>
<p>@CachePut （增）</p>
<p>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。通常用于新增的方法上。</p>
</li>
<li>
<p>@CacheEvict （删）</p>
<p>每次调用被该注解标注的方法，都会执行，并且删除指定的缓存。通常用于删除的方法上。</p>
<table><thead><tr><th>属性/方法名</th><th>解释</th></tr></thead><tbody>
<tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr>
<tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr>
<tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr>
<tr><td>keyGenerator</td><td>key的生成器。key/keyGenerator二选一使用</td></tr>
<tr><td>cacheManager</td><td>指定缓存管理器</td></tr>
<tr><td>cacheResolver</td><td>指定获取解析器</td></tr>
<tr><td>condition</td><td>条件符合则缓存</td></tr>
<tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存</td></tr>
<tr><td>beforeInvocation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存</td></tr>
</tbody></table>
</li>
</ul>
<h3 id="实战"><a class="header" href="#实战">实战</a></h3>
<p>spring cache + caffeine</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
  &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
  &lt;version&gt;2.8.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-yaml">spring:
	cache:
    multi:
      # 是否存储空值，默认true，防止缓存穿透
      cacheNullValues: true
      # 是否动态根据cacheName创建Cache的实现，默认true
      dynamic: true
      # 是否通过缓存rest接口组件清空其他服务缓存,如果为true，必需要引入缓存rest接口组件
      allow-sync: true
      caffeine:
        # 过期策略-访问后过期
        # 访问后过期时间，单位毫秒，默认不配置
        # 设置为&lt;=0时，不生效
        # expireAfterAccess: 30000
        # 过期策略-写入后过期(优先使用该策略)
        # 写入后过期时间，单位毫秒，默认为30000
        # 写入后过期时间和访问后过期时间同时存在时，以写入后过期时间为准
        # 设置为&lt;=0时，不生效
        # 数据写入缓存后，10 分钟失效
        expireAfterWrite: 600000
        # 初始化大小，默认为100
        initialCapacity: 3000
        # 最大缓存对象个数，超过此数量时之前放入的缓存将失效，默认为500
        maximumSize: 30000
</code></pre>
<h2 id="缓存中间件"><a class="header" href="#缓存中间件">缓存中间件</a></h2>
<h3 id="redis-2"><a class="header" href="#redis-2">Redis</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webapi-的设计与实现"><a class="header" href="#webapi-的设计与实现">WebAPI 的设计与实现</a></h1>
<p>[TOC]</p>
<h2 id="读书感悟"><a class="header" href="#读书感悟">读书感悟</a></h2>
<p>书写的很好，api 设计查漏补缺了，后面就是在实战中多。</p>
<p>日本人写书，有一个特点，就是啰啰嗦嗦，事无巨细。但是有的地方总给我一种，抓不住重点，无法把握全局和精髓的感觉。例如在 2.6 节讲 OAuth 的时候，用在线服务 A 和 B 举例，我的睁大眼睛，屏住呼吸才能理解作者想要表达的意思。同样的知识点，阮一峰就讲得很简洁明了 <a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a>，我感觉日本人虽然严谨，但是有点严谨过头了。</p>
<p>聊到日本人，突然想起来王德峰老师评价日本文化。日本人缺乏幽默感，是因为其地理位置险恶，像一条虫蜷缩于太平洋地震带上，没办法退一步海阔天空，所以做事小心谨慎，没办法豁达。</p>
<h2 id="第一章-什么是-web-api"><a class="header" href="#第一章-什么是-web-api">第一章 什么是 web api</a></h2>
<ul>
<li>
<p>web api 与服务器返回的 html 的区别</p>
<p>api 不是通过输入或点击链接来访问的，而是由程序进行调用的。HTML 是让人读的，api 是让机器读的。</p>
</li>
<li>
<p>Web API 是计算机领域的 UGC（User Generated Content）</p>
</li>
<li>
<p>公开什么 api</p>
<p>所有的在线服务，都可以公开 api，api 可以作为一个程序员的名片</p>
</li>
<li>
<p>公开 api 是否有风险</p>
<p>即使不公开 api，真想要获取数据的话，用爬虫爬取 html 也可以获取</p>
</li>
<li>
<p>api 设计的重要性</p>
<ul>
<li>api 一经设计，就很少再更改，所以首次设计很重要</li>
<li>api 是程序员的名片</li>
<li>设计良好的 api 可读性好，易于使用，易于传播</li>
</ul>
</li>
<li>
<p>api 的一种分类</p>
<ul>
<li>LSUD：Large Set of Unknown Developers 面向大量的开发者，例如 Twitter 的 api</li>
<li>SSKD：Small Set of Known Developers 面向少量已知开发者，例如公司内部的 api。设计 SSDK API 时，一个屏幕的内容使用一次 API 调用，一次保存使用一次 API 调用</li>
</ul>
</li>
<li>
<p>api 的设计不必严格遵循 rest，尽信书不如无书</p>
</li>
</ul>
<h2 id="第二章-url-设计与请求的形式"><a class="header" href="#第二章-url-设计与请求的形式">第二章 url 设计与请求的形式</a></h2>
<ul>
<li>
<p>通过封装 sql 来设计 api 的思路是不可取的，这样不仅没法描述抽象的功能，还可能暴露服务端存储的数据结构</p>
</li>
<li>
<p>Good URI</p>
<ul>
<li>
<p>短小便于输入</p>
</li>
<li>
<p>可读性好</p>
</li>
<li>
<p>没有大小写混用</p>
<p>HTTP 协议规定，模式和主机名必须小写，后面的地址是区分大小写的</p>
</li>
<li>
<p>修改方便</p>
<pre><code>✔️ http://api.example.com/v1/items/12345
✔️ http://api.example.com/v1/items/12346
</code></pre>
</li>
<li>
<p>不会暴露服务端架构</p>
</li>
<li>
<p>规则统一</p>
<pre><code>// 获取 id 为 100 的好友的信息
http://api.example.com/friends/100

// 给 100 的朋友发送消息
http://api.example.com/friends/100/message
</code></pre>
</li>
</ul>
</li>
<li>
<p>HTTP methods</p>
<ul>
<li>
<p>GET</p>
<p>get 方法有时候也会修改资源，例如在 get 数据的时候，将已读修改成未读，修改最后访问时间等信息</p>
</li>
<li>
<p>POST</p>
<p>POST 用于新建资源</p>
</li>
<li>
<p>PUT</p>
<p>PUT 通常只用于更新数据</p>
</li>
<li>
<p>DELETE</p>
</li>
<li>
<p>PATCH</p>
</li>
<li>
<p>HEAD</p>
</li>
</ul>
</li>
</ul>
<p>​		<img src="computer-science-notebook/note-for-java-web/assets/image-20220117092243651.png" alt="image-20220117092243651" style="zoom:50%;" /></p>
<ul>
<li>
<p><strong>将资源描述成 url，并用 HTTP 方法表示对其进行的操作</strong>，URL 中只包含名词，不包含动词和形容词！</p>
</li>
<li>
<p>当需要使用多个单词描述一个资源的时候，使用连接符</p>
<pre><code>http://api.example.com/v1/users/12345/profile-image
</code></pre>
</li>
<li>
<p>使用请求参数 ？还是路径</p>
<p>看这个参数是否指代资源，例如下面的 access-token，并不指代资源，所以应该放在请求参数中</p>
<pre><code>✔️ http://api.example.com/v1/users?access-token=xxx
❌ http://api.example.com/v1/users/access-token/xxx
</code></pre>
</li>
<li>
<p>获取当前用户自身的数据</p>
<pre><code>http://api.example.com/v1/users/me
</code></pre>
</li>
<li>
<p>API 设计级别</p>
<ul>
<li>REST LEVEL0 使用 HTTP</li>
<li>REST LEVEL1 引入资源的概念</li>
<li>REST LEVEL2 引入 HTTP 动词</li>
<li>REST LEVEL3 引入 HATEOAS 概念</li>
</ul>
</li>
</ul>
<h2 id="第三章-响应数据的设计"><a class="header" href="#第三章-响应数据的设计">第三章 响应数据的设计</a></h2>
<ul>
<li>
<p>指定响应数据的格式</p>
<ul>
<li>
<p>使用请求参数指定</p>
<pre><code>http://api.example.com/v1/users?format=json
</code></pre>
</li>
<li>
<p>使用 url 扩展名指定</p>
<pre><code>http://api.example.com/v1/users.json
</code></pre>
</li>
<li>
<p>在请求的首部中指定</p>
<pre><code>GET /v1/users
Host: api.example.com
Accept: application/json
</code></pre>
</li>
</ul>
</li>
<li>
<p>响应数据的设计原则</p>
<ul>
<li>允许适当的冗余，进而减少 API 的请求次数</li>
<li>响应数据的状态码语义，应该与响应数据契合</li>
<li>响应数据应该尽可能的扁平化，不要封装太多的层次结构</li>
</ul>
</li>
<li>
<p>响应数据中的时间，通常用 unix 时间戳来表示，单位是秒</p>
</li>
<li>
<p>出错信息的表示</p>
<ul>
<li>响应码要与出错信息契合！</li>
<li>具体的出错信息，要在响应体中给出，包括更详细的错误码和错误描述</li>
</ul>
</li>
</ul>
<h2 id="第四章-最大程度地利用-http-协议规范"><a class="header" href="#第四章-最大程度地利用-http-协议规范">第四章 最大程度地利用 HTTP 协议规范</a></h2>
<ul>
<li>
<p>5 开头的响应码表示服务端出错，4 开头的响应码表示客户端请求出错</p>
</li>
<li>
<p>3 打头的响应码表示资源的地址变了，服务端返回一个新的地址</p>
</li>
<li>
<p>重要的响应码</p>
<ul>
<li>401：Unauthorized 认证错误</li>
<li>403：Forbidden 无权访问</li>
<li>404：not found 资源未找到</li>
<li>405：Method not Allowd 资源存在，但是请求的方法不对</li>
<li>406：Not Acceptable 服务端不支持客户端请求的数据格式</li>
<li>503：服务器在维护</li>
</ul>
</li>
<li>
<p>HTTP 缓存</p>
<p>为了降低访问服务端的次数，客户端将数据缓存起来，再次需要时，就从缓存中读取</p>
<p>适合缓存的数据：生成后就不会变动的数据，例如历史的天气数据</p>
<p>HTTP 缓存模型</p>
<ul>
<li>
<p>过期模型</p>
<p>预先决定响应数据的保存期限，到达期限后就再次访问服务器</p>
<p>在头信息中，加入</p>
<pre><code>// 3600 秒后过期
Cache-Control: max-age=3600
</code></pre>
<p>或者加入：</p>
<pre><code>Expire: Fri, 01 Jan 2015 00:00:00 GMT
</code></pre>
<p>Cache-Control 的优先级更高</p>
</li>
<li>
<p>验证模型</p>
<p>采用询问服务器的方式，来判断缓存是否有效</p>
</li>
</ul>
<p>如果不想使用缓存，则配置如下：</p>
<pre><code>Cache-Control: no-cache
</code></pre>
</li>
<li>
<p>指定媒体类型</p>
<p>格式：顶层类型名称 / 子类型名称</p>
<p>指定响应体的类型：</p>
<pre><code>Content-Type: application/json
</code></pre>
<p>优先使用 <code>application/xml</code>，而不是 <code>text/xml</code></p>
<p>请求的类型：</p>
<p>表示请求体的内容是 <code>application/json</code>，Accept 表示客户端能够接收的数据类型。</p>
<pre><code>Content-Type: application/json
Accept: application/json
</code></pre>
<p>Accept 可以枚举多种类型，还可以配置优先级：</p>
<pre><code>Accept: application/json, application/xml;q=0.9
</code></pre>
</li>
<li>
<p>跨域访问相关</p>
<p>客户端发起跨域请求时，会在头信息中携带一个 Origin</p>
<p>当客户端通过跨域在头信息中加入 Cookie 或者 Authentication 认证信息时，服务器端认证通过后，需要在头信息中携带有：</p>
<pre><code>Access-Control-Allow-Credentials: true
</code></pre>
<p>如果不携带的话，浏览器会直接拒绝来自服务器的响应请求。</p>
</li>
</ul>
<p>常见的 MIME 媒体类型</p>
<table><thead><tr><th>媒体类型</th><th>数据格式</th></tr></thead><tbody>
<tr><td>text/plain</td><td>纯文本</td></tr>
<tr><td>text/html</td><td>html 文件</td></tr>
<tr><td>application/xml</td><td>xml 文件</td></tr>
<tr><td>text/css</td><td>css 文件</td></tr>
<tr><td>application/javascript</td><td>javascript</td></tr>
<tr><td>application/json</td><td>json 文件</td></tr>
<tr><td>application/rss+xml</td><td>RSS 域</td></tr>
<tr><td>application/octet-stream</td><td>二进制数据</td></tr>
<tr><td>application/zip</td><td>zip 文件</td></tr>
<tr><td>image/jpeg</td><td>jpeg 图像</td></tr>
<tr><td>image/png</td><td>png 图像</td></tr>
<tr><td>image/svg+xml</td><td>svg 图像</td></tr>
<tr><td>multipart/form-data</td><td>多个数据组成的 web 表单数据</td></tr>
<tr><td>video/mp4</td><td>mp4 动画文件</td></tr>
<tr><td>application/vnd.ms-excel</td><td>excel 文件</td></tr>
</tbody></table>
<h2 id="第五章-开发方便更改设计的-web-api"><a class="header" href="#第五章-开发方便更改设计的-web-api">第五章 开发方便更改设计的 web api</a></h2>
<ul>
<li>
<p>在 url 中嵌入版本号</p>
<pre><code>http://api.example.com/v1/items/12345
</code></pre>
</li>
<li>
<p>新的 api 发布后，旧的仍然使用</p>
<img align="left" src="computer-science-notebook/note-for-java-web/assets/image-20220117155502175.png" alt="image-20220117155502175" style="zoom:50%;" />
</li>
</ul>
<h2 id="第六章-开发牢固的-web-api"><a class="header" href="#第六章-开发牢固的-web-api">第六章 开发牢固的 web api</a></h2>
<p>后面统一学习安全相关的知识。</p>
<h2 id="web-api-确认清单"><a class="header" href="#web-api-确认清单">web api 确认清单</a></h2>
<ul>
<li>URL 是否短小且容易输入</li>
<li>URL 是否能让人一眼看懂</li>
<li>URL 是否只有小写字母</li>
<li>URL 中是否只有名次，是否存在形容词和动词</li>
<li>URL 是否指代某资源</li>
<li>URL 是否容易修改</li>
<li>URL 是否会泄露服务端架构</li>
<li>URL 规则是否统一</li>
<li>有没有使用合适的 HTTP 方法</li>
<li>URL 中的单词使用是否统一</li>
<li>URL 中不要加空格和需要编码的字符</li>
<li>URL 中多个单词之间要用 <code>-</code> 连接</li>
<li>响应数据的格式是否指定</li>
<li>响应数据是不是过度封装</li>
<li>响应数据的结构有没有做到扁平化</li>
<li>有没有返回合适的响应码</li>
<li>出错时是否返回详细的错误信息</li>
<li>服务器在维护时是否返回 503</li>
<li>需不需要缓存</li>
<li>需不需要进行版本控制</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rbac"><a class="header" href="#rbac">RBAC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket"><a class="header" href="#socket">Socket</a></h1>
<p>[TOC]</p>
<h2 id="all-about-sockets"><a class="header" href="#all-about-sockets">All about sockets</a></h2>
<h3 id="what-is-a-socket"><a class="header" href="#what-is-a-socket">what is a socket</a></h3>
<p>通常的，一个服务端程序会运行在一台电脑上，并且拥有一个 socket，该 socket 会绑定到一个端口。服务端程序就一直等着，监听 socket，等着客户端来连接。</p>
<p>在客户端，客户端知道服务端的 ip 地址和绑定的端口号。如果想要发起连接的话，客户端会绑定客户端所在电脑的一个端口号，然后向服务端发起连接。客户端绑定的端口号通常由系统分配。</p>
<img src="computer-science-notebook/note-for-java-web/assets/image-20220124192541502.png" alt="image-20220124192541502" style="zoom:50%;" />
<p>如果一切顺利的话，服务端会接受来自客户端的连接。一旦连接成功，服务端就会获取到一个绑定到本地端口的新 socket，该 socket 的另一端连到了客户端的端口。之所以创建了</p>
<h3 id="reading-from-and-writting-to-a-socket"><a class="header" href="#reading-from-and-writting-to-a-socket">reading from and writting to a socket</a></h3>
<h3 id="writting-the-server-side-of-a-socket"><a class="header" href="#writting-the-server-side-of-a-socket">writting the server side of a socket</a></h3>
<h2 id="jdk-1"><a class="header" href="#jdk-1">JDK</a></h2>
<h3 id="socket-1"><a class="header" href="#socket-1">Socket</a></h3>
<p>This class implements client sockets (also called just &quot;sockets&quot;). A socket is an endpoint for communication between two machines.
The actual work of the socket is performed by an instance of the SocketImpl class. An application, by changing the socket factory that creates the socket implementation, can configure itself to create sockets appropriate to the local firewall.</p>
<h3 id="serversocket"><a class="header" href="#serversocket">ServerSocket</a></h3>
<p>This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester.
The actual work of the server socket is performed by an instance of the SocketImpl class. An application can change the socket factory that creates the socket implementation to configure itself to create sockets appropriate to the local firewall.</p>
<h3 id="socketimpl"><a class="header" href="#socketimpl">SocketImpl</a></h3>
<p>The abstract class SocketImpl is a common superclass of all classes that actually implement sockets. It is used to create both client and server sockets.
A &quot;plain&quot; socket implements these methods exactly as described, without attempting to go through a firewall or proxy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webservice"><a class="header" href="#webservice">WebService</a></h1>
<p>[TOC]</p>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>WebService 是对 HTTP 协议的二次封装，可以理解为 HTTP + XML</p>
<h2 id="wsdl-文件"><a class="header" href="#wsdl-文件">wsdl 文件</a></h2>
<p>wsdl 文件是服务端提供的 webservice 接口说明书（xml 格式）</p>
<p>根据 wsdl 文件，可以生成 Java 文件，也可以直接发起 http 请求，请求体是 xml</p>
<h2 id="参考文献-2"><a class="header" href="#参考文献-2">参考文献</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/383326629">webService、soap、wsdl入门</a></li>
<li><a href="http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?op=getWeatherbyCityName">WeatherWebService</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tomcat-servlet"><a class="header" href="#tomcat-servlet">tomcat servlet</a></h1>
<p>[TOC]</p>
<h2 id="servlet"><a class="header" href="#servlet">servlet</a></h2>
<h3 id="servlet-是什么"><a class="header" href="#servlet-是什么">servlet 是什么</a></h3>
<p>servlet 对 http 请求和响应进行封装，得到 HttpServletRequest 和 HttpServletResponse 两个对象。</p>
<p>Servlet 就是一个能处理 HTTP 请求，发送 HTTP 响应的小程序。</p>
<p>下面的这个 servlet 就是对请求路径为 <code>/</code> 的 get 请求进行响应，然后返回 hello world。</p>
<pre><code class="language-java">// WebServlet注解表示这是一个Servlet，并映射到地址/:
@WebServlet(urlPatterns = &quot;/&quot;)
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        // 设置响应类型:
        resp.setContentType(&quot;text/html&quot;);
        // 获取输出流:
        PrintWriter pw = resp.getWriter();
        // 写入响应:
        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);
        // 最后不要忘记flush强制输出:
        pw.flush();
    }
}
</code></pre>
<p>一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解说明自己能处理的路径。</p>
<pre><code class="language-java">@WebServlet(urlPatterns = &quot;/hello&quot;)
public class HelloServlet extends HttpServlet {
    ...
}

@WebServlet(urlPatterns = &quot;/signin&quot;)
public class SignInServlet extends HttpServlet {
    ...
}

@WebServlet(urlPatterns = &quot;/&quot;)
public class IndexServlet extends HttpServlet {
    ...
}
</code></pre>
<p>如果 client 发送的是 GET 请求，则在 servlet 中覆写 <code>doGet</code> 请求，如果 client 发送的是 POST 请求，则在 servlet 中覆写 <code>doPost</code> 请求。一个Servlet如果映射到<code>/hello</code>，那么所有请求方法都会由这个Servlet处理，至于能不能返回200成功响应，要看有没有覆写对应的请求方法。</p>
<h3 id="dispatcher"><a class="header" href="#dispatcher">Dispatcher</a></h3>
<p>dispatcher 根据路径分发</p>
<p>浏览器发出的 HTTP 请求总是由 Web Server 先接收，然后，根据 Servlet 配置的映射，不同的路径转发到不同的Servlet：</p>
<pre><code class="language-ascii">               ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐

               │            /hello    ┌───────────────┐│
                          ┌──────────&gt;│ HelloServlet  │
               │          │           └───────────────┘│
┌───────┐    ┌──────────┐ │ /signin   ┌───────────────┐
│Browser│───&gt;│Dispatcher│─┼──────────&gt;│ SignInServlet ││
└───────┘    └──────────┘ │           └───────────────┘
               │          │ /         ┌───────────────┐│
                          └──────────&gt;│ IndexServlet  │
               │                      └───────────────┘│
                              Web Server
               └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
</code></pre>
<h3 id="httpservletrequest"><a class="header" href="#httpservletrequest">HttpServletRequest</a></h3>
<p><code>HttpServletRequest</code> 封装了一个HTTP请求，它实际上是从 <code>ServletRequest</code> 继承而来。</p>
<p>我们通过 <code>HttpServletRequest</code> 提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有：</p>
<ul>
<li>getMethod()：返回请求方法，例如，<code>&quot;GET&quot;</code>，<code>&quot;POST&quot;</code>；</li>
<li>getRequestURI()：返回请求路径，但不包括请求参数，例如，<code>&quot;/hello&quot;</code>；</li>
<li>getQueryString()：返回请求参数，例如，<code>&quot;name=Bob&amp;a=1&amp;b=2&quot;</code>；</li>
<li>getParameter(name)：返回请求参数，GET 请求从 URL 读取参数，POST 请求从 Body 中读取参数；</li>
<li>getContentType()：获取请求 Body 的类型，例如，<code>&quot;application/x-www-form-urlencoded&quot;</code>；</li>
<li>getContextPath()：获取当前Webapp挂载的路径，对于 ROOT 来说，总是返回空字符串<code>&quot;&quot;</code>；</li>
<li>getCookies()：返回请求携带的所有 Cookie；</li>
<li>getHeader(name)：获取指定的 Header，对 Header 名称不区分大小写；</li>
<li>getHeaderNames()：返回所有 Header 名称；</li>
<li>getInputStream()：如果该请求带有 HTTP Body，该方法将打开一个输入流用于读取Body；</li>
<li>getReader()：和 getInputStream() 类似，但打开的是 Reader；</li>
<li>getRemoteAddr()：返回客户端的IP地址；</li>
<li>getScheme()：返回协议类型，例如，<code>&quot;http&quot;</code>，<code>&quot;https&quot;</code>；</li>
</ul>
<p>此外，<code>HttpServletRequest</code> 还有两个方法：<code>setAttribute()</code> 和 <code>getAttribute()</code>，可以给当前 <code>HttpServletRequest</code> 对象附加多个Key-Value，相当于把 <code>HttpServletRequest</code> 当作一个 <code>Map&lt;String, Object&gt;</code> 使用。</p>
<h3 id="httpservletresponse"><a class="header" href="#httpservletresponse">HttpServletResponse</a></h3>
<p><code>HttpServletResponse</code> 封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作 <code>HttpServletResponse</code>对象时，必须先调用设置 Header 的方法，最后调用发送 Body 的方法。</p>
<p>常用的设置Header的方法有：</p>
<ul>
<li>setStatus(sc)：设置响应代码，默认是 <code>200</code>；</li>
<li>setContentType(type)：设置Body的类型，例如，<code>&quot;text/html&quot;</code>；</li>
<li>setCharacterEncoding(charset)：设置字符编码，例如，<code>&quot;UTF-8&quot;</code>；</li>
<li>setHeader(name, value)：设置一个Header的值；</li>
<li>addCookie(cookie)：给响应添加一个Cookie；</li>
<li>addHeader(name, value)：给响应添加一个Header，因为HTTP协议允许有多个相同的Header；</li>
</ul>
<p>写入响应时，需要通过 <code>getOutputStream()</code> 获取写入流，或者通过 <code>getWriter()</code>  获取字符流，二者只能获取其中一个。</p>
<p>写入响应前，无需设置<code>setContentLength()</code>，因为底层服务器会根据写入的字节数自动设置，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用 Chunked 编码让浏览器能识别数据结束符而不需要设置 Content-Length 头。</p>
<p>但是，写入完毕后调用 <code>flush()</code> 却是必须的，因为大部分Web服务器都基于 HTTP/1.1 协议，会复用 TCP 连接。如果没有调用 <code>flush()</code>，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用 <code>close()</code>，原因同样是因为会复用TCP连接，如果关闭写入流，将关闭 TCP 连接，使得 Web 服务器无法复用此 TCP 连接。</p>
<h3 id="重定向"><a class="header" href="#重定向">重定向</a></h3>
<p>我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，如果收到的路径为<code>/hi</code>，希望能重定向到<code>/hello</code>，可以再编写一个<code>RedirectServlet</code>：</p>
<pre><code>@WebServlet(urlPatterns = &quot;/hi&quot;)
public class RedirectServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 构造重定向的路径:
        String name = req.getParameter(&quot;name&quot;);
        String redirectToUrl = &quot;/hello&quot; + (name == null ? &quot;&quot; : &quot;?name=&quot; + name);
        // 发送重定向响应:
        resp.sendRedirect(redirectToUrl);
    }
}
</code></pre>
<p>如果浏览器发送<code>GET /hi</code>请求，<code>RedirectServlet</code>将处理此请求。由于<code>RedirectServlet</code>在内部又发送了重定向响应，因此，浏览器会收到如下响应：</p>
<pre><code>HTTP/1.1 302 Found
Location: /hello
</code></pre>
<p>当浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向：</p>
<pre><code class="language-ascii">┌───────┐   GET /hi     ┌───────────────┐
│Browser│ ────────────&gt; │RedirectServlet│
│       │ &lt;──────────── │               │
└───────┘   302         └───────────────┘


┌───────┐  GET /hello   ┌───────────────┐
│Browser│ ────────────&gt; │ HelloServlet  │
│       │ &lt;──────────── │               │
└───────┘   200 &lt;html&gt;  └───────────────┘
</code></pre>
<p>重定向有两种：一种是 302 响应，称为临时重定向，一种是 301 响应，称为永久重定向。两者的区别是，如果服务器发送 301 永久重定向响应，浏览器会缓存<code>/hi</code>到 <code>/hello</code> 这个重定向的关联，下次请求 <code>/hi</code> 的时候，浏览器就直接发送 <code>/hello</code> 请求了。</p>
<p>重定向有什么作用？重定向的目的是当 Web 应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p>
<h3 id="多线程模型"><a class="header" href="#多线程模型">多线程模型</a></h3>
<p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个 Servlet 的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题：</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    private Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 注意读写map字段是多线程并发的:
        this.map.put(key, value);
    }
}
</code></pre>
<p>对于每个请求，Web服务器会创建唯一的 <code>HttpServletRequest</code>  和 <code>HttpServletResponse</code> 实例，因此，<code>HttpServletRequest</code> 和<code>HttpServletResponse</code> 实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。</p>
<h2 id="cookie-session"><a class="header" href="#cookie-session">cookie session</a></h2>
<p>在 Web 应用程序中，我们经常要跟踪用户身份。当一个用户登录成功后，如果他继续访问其他页面，Web 程序如何才能识别出该用户身份？</p>
<p>因为HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一 ID，并以 Cookie 的形式发送到浏览器，浏览器在后续访问时总是附带此 Cookie，这样，服务器就可以识别用户身份。</p>
<p>我们把这种基于唯一 ID 识别用户身份的机制称为 Session。每个用户第一次访问服务器后，会自动获得一个 Session ID。如果用户在一段时间内没有访问服务器，那么 Session 会自动失效，下次即使带着上次分配的 Session ID 访问，服务器也认为这是一个新用户，会分配新的 Session ID。</p>
<p>JavaEE 的 Servlet 机制内建了对 Session 的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个 <code>HttpSession</code> 对象，以便后续访问其他页面的时候，能直接从 <code>HttpSession</code> 取出用户名。</p>
<p>Servlet 提供的 <code>HttpSession</code> 本质上就是通过一个名为 <code>JSESSIONID</code> 的 Cookie 来跟踪用户会话的。</p>
<p>Cookie 本质上是用来记录客户端的信息，可以记录用户的 id，也可以记录用于的语言和地区。Cookie 是由服务端创建好，返回给客户端存储的，用来标记客户的信息。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220318133947112.png" alt="image-20220318133947112" /></p>
<p>https://www.liaoxuefeng.com/wiki/1252599548343744/1328768897515553</p>
<h2 id="jsp"><a class="header" href="#jsp">jsp</a></h2>
<p>java servlet page</p>
<p>jsp 是一个模板。jsp 方便了动态 html 页面的生成，不再需要频繁地 PrintWriter 了。</p>
<pre><code class="language-jsp">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello World - JSP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%-- JSP Comment --%&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;p&gt;
    &lt;%
         out.println(&quot;Your IP address is &quot;);
    %&gt;
    &lt;span style=&quot;color:red&quot;&gt;
        &lt;%= request.getRemoteAddr() %&gt;
    &lt;/span&gt;
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>整个 JSP 的内容实际上是一个 HTML，但是稍有不同：</p>
<ul>
<li>包含在 <code>&lt;%-- </code>和 <code>--%&gt;</code> 之间的是 JSP 的注释，它们会被完全忽略；</li>
<li>包含在 <code>&lt;%</code> 和 <code>%&gt;</code> 之间的是 Java 代码，可以编写任意Java代码；</li>
<li>如果使用 <code>&lt;%= xxx %&gt;</code> 则可以快捷输出一个变量的值。</li>
</ul>
<p>JSP页面内置了几个变量：</p>
<ul>
<li>out：表示HttpServletResponse的PrintWriter；</li>
<li>session：表示当前HttpSession对象；</li>
<li>request：表示HttpServletRequest对象。</li>
</ul>
<p>这几个变量可以直接使用。</p>
<p>访问 JSP 页面时，直接指定完整路径。例如，<code>http://localhost:8080/hello.jsp</code>，浏览器显示如下</p>
<h2 id="mvc-开发"><a class="header" href="#mvc-开发">MVC 开发</a></h2>
<p>从上面两节，我们可以看到：</p>
<ul>
<li>Servlet 适合编写 Java 代码，实现各种复杂的业务逻辑，但不适合输出复杂的 HTML；</li>
<li>JSP 适合编写 HTML，并在其中插入动态内容，但不适合编写复杂的 Java 代码。</li>
</ul>
<p>能否将两者结合起来，发挥各自的优点，避免各自的缺点？</p>
<p>答案是肯定的。我们来看一个具体的例子。</p>
<p>假设我们已经编写了几个 JavaBean：</p>
<pre><code class="language-java">public class User {
    public long id;
    public String name;
    public School school;
}

public class School {
    public String name;
    public String address;
}
</code></pre>
<p>在 <code>UserServlet</code> 中，我们可以从数据库读取 <code>User</code> 、 <code>School</code> 等信息，然后，把读取到的 JavaBean 先放到 HttpServletRequest 中，再通过 <code>forward()</code> 传给 <code>user.jsp</code> 处理：</p>
<pre><code class="language-java">@WebServlet(urlPatterns = &quot;/user&quot;)
public class UserServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 假装从数据库读取:
        School school = new School(&quot;No.1 Middle School&quot;, &quot;101 South Street&quot;);
        User user = new User(123, &quot;Bob&quot;, school);
        // 放入Request中:
        req.setAttribute(&quot;user&quot;, user);
        // forward给user.jsp:
        req.getRequestDispatcher(&quot;/WEB-INF/user.jsp&quot;).forward(req, resp);
    }
}
</code></pre>
<p>在 <code>user.jsp</code> 中，我们只负责展示相关 JavaBean 的信息，不需要编写访问数据库等复杂逻辑：</p>
<pre><code class="language-jsp">&lt;%@ page import=&quot;com.itranswarp.learnjava.bean.*&quot;%&gt;
&lt;%
    User user = (User) request.getAttribute(&quot;user&quot;);
%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello World - JSP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt;
    &lt;p&gt;School Name:
    &lt;span style=&quot;color:red&quot;&gt;
        &lt;%= user.school.name %&gt;
    &lt;/span&gt;
    &lt;/p&gt;
    &lt;p&gt;School Address:
    &lt;span style=&quot;color:red&quot;&gt;
        &lt;%= user.school.address %&gt;
    &lt;/span&gt;
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>请注意几点：</p>
<ul>
<li>需要展示的 <code>User</code> 被放入 <code>HttpServletRequest</code> 中以便传递给JSP，因为一个请求对应一个 <code>HttpServletRequest</code> ，我们也无需清理它，处理完该请求后 <code>HttpServletRequest</code> 实例将被丢弃；</li>
<li>把 <code>user.jsp</code> 放到 <code>/WEB-INF/</code> 目录下，是因为 <code>WEB-INF</code> 是一个特殊目录，Web Server 会阻止浏览器对 <code>WEB-INF</code> 目录下任何资源的访问，这样就防止用户通过 <code>/user.jsp</code> 路径直接访问到 JSP 页面；</li>
<li>JSP 页面首先从 <code>request </code>变量获取 <code>User</code> 实例，然后在页面中直接输出，此处未考虑 HTML 的转义问题，有潜在安全风险。</li>
</ul>
<p>我们在浏览器访问 <code>http://localhost:8080/user</code>，请求首先由 <code>UserServlet</code> 处理，然后交给 <code>user.jsp</code> 渲染：</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/l.jpeg" alt="mvc" /></p>
<p>我们把 <code>UserServlet</code> 看作业务逻辑处理，把 <code>User</code> 看作模型，把 <code>user.jsp</code> 看作渲染，这种设计模式通常被称为 MVC：Model-View-Controller，即 <code>UserServlet</code> 作为控制器（Controller），<code>User</code> 作为模型（Model），<code>user.jsp</code>作为视图（View），整个MVC架构如下：</p>
<pre><code class="language-ascii">                   ┌───────────────────────┐
             ┌────&gt;│Controller: UserServlet│
             │     └───────────────────────┘
             │                 │
┌───────┐    │           ┌─────┴─────┐
│Browser│────┘           │Model: User│
│       │&lt;───┐           └─────┬─────┘
└───────┘    │                 │
             │                 ▼
             │     ┌───────────────────────┐
             └─────│    View: user.jsp     │
                   └───────────────────────┘
</code></pre>
<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p>
<h2 id="filter-过滤器"><a class="header" href="#filter-过滤器">Filter 过滤器</a></h2>
<p>在 HTTP 请求到达 Servlet 之前，可以被多个 Filter 预处理，类似打印日志、登录检查等逻辑，完全可以放到 Filter 中。</p>
<p>下面这个 filter 就是设置输入和输出的编码格式，其对 <code>/users/*</code> 请求起作用：</p>
<pre><code class="language-java">@WebFilter(&quot;/user/*&quot;)
public class AuthFilter implements Filter {
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        System.out.println(&quot;AuthFilter: check authentication&quot;);
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        if (req.getSession().getAttribute(&quot;user&quot;) == null) {
            // 未登录，自动跳转到登录页:
            System.out.println(&quot;AuthFilter: not signin!&quot;);
            resp.sendRedirect(&quot;/signin&quot;);
        } else {
            // 已登录，继续处理:
            chain.doFilter(request, response);
        }
    }
}
</code></pre>
<p>Filter 可以有针对性地拦截或者放行 HTTP 请求。如果Filter要使请求继续被处理，就一定要调用chain.doFilter()！</p>
<p>Filter是一种对HTTP请求进行预处理的组件，它可以构成一个处理链，使得公共处理代码能集中到一起；</p>
<p>Filter适用于日志、登录检查、全局设置等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编解码-2"><a class="header" href="#编解码-2">编解码</a></h1>
<p>[TOC]</p>
<h2 id="为什么要编解码"><a class="header" href="#为什么要编解码">为什么要编解码</a></h2>
<p>在进行网络传输和存储的时候，要节省带宽和空间。</p>
<h2 id="java-encode-decode"><a class="header" href="#java-encode-decode">Java encode decode</a></h2>
<p>编码：字符串 ——&gt; 字节数组</p>
<p>解码：字节数组 ——&gt; 字符串</p>
<pre><code class="language-java">package com.wansho.hellojava;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

public class EncodeDemo {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        /*
         * 字符串 --&gt; 字节数组：编码。
         * 字节数组 --&gt; 字符串：解码。
         *
         * 你好： GBK: -60 -29 -70 -61
         *
         * 你好: utf-8: -28 -67 -96 -27 -91 -67
         *
         *
         * 如果你编错了，解不出来。
         * 如果编对了，解错了，有可能有救。
         */
        String str = &quot;谢谢&quot;;
        byte[] buf = str.getBytes(&quot;gbk&quot;); // 编码
        String s1 = new String(buf,&quot;UTF-8&quot;); // 解码，解错了
        System.out.println(&quot;s1=&quot;+s1); // лл
        byte[] buf2 = s1.getBytes(&quot;UTF-8&quot;);//获取源字节.
        printBytes(buf2); // -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -17 -65 -67 -17 -65 -67 -17 -65 -67 -17 -65 -67
        // -48 -69 -48 -69
        String s2 = new String(buf2,&quot;GBK&quot;); // 解码，解对了
        System.out.println(&quot;s2=&quot;+s2);
        // encodeDemo(str);
    }
    /**
     * @param str
     * @throws UnsupportedEncodingException
     */
    public static void encodeDemo(String str)
            throws UnsupportedEncodingException {
        //编码；
        byte[] buf = str.getBytes(&quot;UTF-8&quot;);
        // printBytes(buf);
        //解码：
        String s1 = new String(buf,&quot;UTF-8&quot;);
        System.out.println(&quot;s1=&quot;+s1);
    }
    private static void printBytes(byte[] buf) {
        for(byte b : buf){
            System.out.print(b +&quot; &quot;);
        }
    }
}
</code></pre>
<h2 id="web-服务器收到乱码"><a class="header" href="#web-服务器收到乱码">web 服务器收到乱码</a></h2>
<p>前后端数据交互的方式有两种：</p>
<ul>
<li>
<p>form 表单提交</p>
<p>form 表单可以通过 enctype 属性设置编码类型，默认值为 application/x-www-form-urlencoded，字符集通常是 utf8</p>
</li>
<li>
<p>ajax 提交</p>
<p>ajax 表单可以通过 content-type 设置编码类型，默认值也是 application/x-www-form-urlencoded，字符集通常是 utf8</p>
</li>
</ul>
<p>服务器对于接收到的 application/x-www-form-urlencoded 类型数据进行字符集为 ISO-8859-1 的 URLDecoding 处理，经过处理得到的字符串，内码为 ISO-8859-1。</p>
<p>问题来了，客户端的编码，都是 utf8 字符集，而服务端却要用 ISO-8859-1 字符集解码，所以解码得到的字符串肯定是乱码！</p>
<p>纠正的操作：</p>
<pre><code class="language-java">// utf8 网络传输编码 ——&gt; 服务端 ISO-8859-1 解码（字符集用错了，应该用 utf8） ——&gt; 服务端 ISO-8859-1 编码 ——&gt; 服务端 utf8 解码
// 整个编解码过程由后面两个反编译得到
// 服务器对于接收到的 application/x-www-form-urlencoded 类型数据进行字符集为 ISO-8859-1 的 URLDecoding 处理
String note = new String(note.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);
log.info(&quot;新建的笔记：&quot; + note);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netty"><a class="header" href="#netty">Netty</a></h1>
<p>[TOC]</p>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p>Netty 是一个网络通信库！</p>
<p>Netty提供异步的、<a href="https://baike.baidu.com/item/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/9597519">事件驱动</a>的网络应用程序框架和工具，用以快速开发高性能、高可靠性的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/99096">网络服务器</a>和客户端程序。</p>
<p>Netty 主要针对在 TCP 协议下，面向 Client 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。</p>
<p>Netty 本质上是一个 NIO（New IO）框架，适用于服务器通信相关的多种应用场景。</p>
<p>要彻底理解 Netty，要先学习 NIO。</p>
<p>Netty 的核心贡献者，是一位韩国人。</p>
<p><img src="computer-science-notebook/note-for-java-web/image/netty/1658751361592.png" alt="1658751361592" /></p>
<h3 id="异步"><a class="header" href="#异步">异步</a></h3>
<table><thead><tr><th>同步(向服务器发起请求后，等待响应)</th><th>异步(向服务器发起请求后，就干其他事情，响应后就执行回调)</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/note-for-java-web/assets/image-20220725191001914.png" alt="image-20220725191001914" /></td><td><img src="computer-science-notebook/note-for-java-web/assets/image-20220725191243728.png" alt="image-20220725191243728" /></td></tr>
</tbody></table>
<h3 id="事件驱动"><a class="header" href="#事件驱动">事件驱动</a></h3>
<p>类似于浏览器的点击事件。</p>
<p>服务端也是基于事件进行响应的，例如客户端的连接事件，断开事件。</p>
<h3 id="应用场景-1"><a class="header" href="#应用场景-1">应用场景</a></h3>
<ul>
<li>分布式系统中，各个节点之间的需要远程服务调用，高性能的 RPC 框架必不可少。Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。
例如：阿里的 RPC 框架 Dubbo 默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
<li>游戏行业，Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈。</li>
</ul>
<h3 id="dubbo-和-netty-的关系"><a class="header" href="#dubbo-和-netty-的关系">Dubbo 和 Netty 的关系</a></h3>
<p>Dubbo 是一款 RPC 框架，其底层默认使用 Netty 作为基础通信组件。</p>
<h3 id="学习资料-3"><a class="header" href="#学习资料-3">学习资料</a></h3>
<ul>
<li>Netty in Action</li>
<li>Netty 权威指南</li>
</ul>
<h2 id="java-网络-io-模型"><a class="header" href="#java-网络-io-模型">Java 网络 IO 模型</a></h2>
<h3 id="bio"><a class="header" href="#bio">BIO</a></h3>
<p>Blocking IO 同步且阻塞（传统阻塞型）</p>
<p>服务器实现模式为一个连接一个线程，即客户端有连接时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销（可以通过线程池机制改善）。</p>
<p>使用场景：连接请求较少，架构固定，多服务器资源要求很高 ，JDK1.4 以前的唯一选择，但是程序简单容易理解。</p>
<p>相关类和接口在 java.io 中。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220726203557035.png" alt="image-20220726203557035" /></p>
<h3 id="nio"><a class="header" href="#nio">NIO</a></h3>
<p>No Blocking IO 同步非阻塞（多路复用）。</p>
<p>服务器实现模式为一个线程处理多个请求（连接）。即客户端发送的请求都会注册到多路复用器上，多路复用器轮询到连接有 IO 请求就进行处理。</p>
<p>理论依据：客户端连接到服务端后，并不是一直都在读写数据，这样就没有充分利用线程这个资源，造成浪费。</p>
<p>使用场景：连接请求多并且连接比较短的架构，例如聊天服务器，弹幕系统，服务器间通讯。编程较复杂，JDK1.4 开始支持。</p>
<p><img src="computer-science-notebook/note-for-java-web/assets/image-20220726203933765.png" alt="image-20220726203933765" /></p>
<p>NIO 三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector(选择器)</p>
<p>NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果注册到这个线程的所有请求都没有推数据过来，那么这个线程就去干其他事情，反正不会阻塞。非阻塞写也是如此，一个线程请求写入一些数据到某个通道，不需要等到数据完全写入，这个线程就可以去干其他事情了。</p>
<p>通俗地理解，NIO 是可以做到用一个线程来处理多个请求的。假设有 10000 个请求过来，可以分配 50 到 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个线程。</p>
<p>Selector, Channel 和 Buffer 的关系图（简单版）：</p>
<ol>
<li>每个 Channel 都对应一个 Buffer</li>
<li>Selector 只对应一个线程，一个线程对应多个 Channel（连接）</li>
<li>程序切换到哪个 channel 是由事件决定的，Event 就是一个重要的概念</li>
<li>Selector 会根据不同的 event 在各个通道上切换</li>
<li>Buffer 就是一个内存块，底层是有一个数组</li>
<li>数据的读取写入是通过 Buffer，BIO 要么是输入流，要么是输出流，不能双向，但是 NIO 的 Buffer 是可以读也可以写，需要 flip 方法切换</li>
<li>Channel 是双向的，Linux 底层的通道也是双向的</li>
</ol>
<h3 id="aionio2"><a class="header" href="#aionio2">AIO(NIO2)</a></h3>
<p>异步非阻塞。</p>
<p>使用场景：连接数目多且长链接比较多。比如文件服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>
<h2 id="nio-1"><a class="header" href="#nio-1">NIO</a></h2>
<h3 id="buffer"><a class="header" href="#buffer">Buffer</a></h3>
<p>缓冲区：本质上是一个可以读写数据的内存块，可以理解成一个容器对象，该容器提供了一组方法，可以更轻松地使用内存块。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p>
<p>每一种缓冲区都带有的四个属性：</p>
<ul>
<li>Capacity：缓冲区的容量</li>
<li>Limit：缓冲区当前的终点，不能对缓冲区超过极限的位置进行读写操作。极限是可以修改的</li>
<li>Position：索引，下一个要被读或者写的元素的索引</li>
<li>Mark：标记</li>
</ul>
<p>mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>缓冲区常见方法：</p>
<pre><code class="language-java">position(int newPosition); // 设置此缓冲区的位置

clear(); // 清除这个缓冲区，所有标记恢复初试状态，但是数据并没有真正擦除

flip(); // 反转缓冲区

hasRemaining(); // 告知在 position 和 limit 之前是否还有元素
</code></pre>
<p>ByteBuffer 特有的方法：</p>
<pre><code class="language-java">get(); // 从当前 position 上 get，然后 position 自动+1
get(position); // 从绝对位置 get
put(byte b); // 从当前位置添加，put 后 position 自动+1
put(int position, byte b); // 从绝对位置 put
allocate(int capacity); // 设置缓冲区的初试容量
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs"><a class="header" href="#nodejs">nodeJS</a></h1>
<p>[TOC]</p>
<h2 id="配置国内镜像"><a class="header" href="#配置国内镜像">配置国内镜像</a></h2>
<p><a href="https://blog.csdn.net/qq_27022241/article/details/107251657">教程</a></p>
<pre><code>npm config set registry &quot;http://registry.npm.taobao.org/&quot;
npm config set ELECTRON_MIRROR &quot;https://npm.taobao.org/mirrors/electron/&quot;
</code></pre>
<p>换回官方镜像：</p>
<pre><code>npm config set registry &quot;https://registry.npmjs.org/&quot;

# 检查是否配置成功
npm config get ELECTRON_MIRROR
npm config get registry
</code></pre>
<p><code>npm config delete ELECTRON_MIRROR</code></p>
<h2 id="代理-1"><a class="header" href="#代理-1">代理</a></h2>
<p>配置代理</p>
<pre><code class="language-shell">npm config set proxy http://127.0.0.1:7890
npm config set https-proxy=https://127.0.0.1:7890
</code></pre>
<p>取消代理</p>
<pre><code class="language-shell">npm config delete proxy
npm config delete https-proxy
</code></pre>
<h2 id="npm-install"><a class="header" href="#npm-install">npm install</a></h2>
<p><code>npm install</code> 默认将 <code>package.json</code> 的配置的环境依赖下载到当前目录下的 <code>node_modules</code> 中，如果想要复用这些环境依赖，可以直接加参数：<code>-g --global</code>。</p>
<p><code>npm install -g</code></p>
<h2 id="npm-pack"><a class="header" href="#npm-pack">npm pack</a></h2>
<pre><code>npm run pack
# 或者
npm run dist
</code></pre>
<h2 id="electron-项目打包"><a class="header" href="#electron-项目打包">electron 项目打包</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/266005043">[electron-builder 打包失败]</a></p>
<p><strong><code>npm run dist</code> 打包失败 - 网络问题</strong></p>
<p>网络问题，不能把 GitHub 上面的资源拉下来，需要手动切换淘宝镜像：</p>
<pre><code class="language-shell">npm config set electron_mirror=https://npm.taobao.org/mirrors/electron/
npm config set electron-builder-binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/
</code></pre>
<p><strong><code>npm run dist</code> 打包失败 - cannot move downloaded into final location (another process downloaded faster?)</strong></p>
<p>关闭火绒！！！</p>
<h2 id="nvm-nodejs-版本管理"><a class="header" href="#nvm-nodejs-版本管理">nvm nodejs 版本管理</a></h2>
<pre><code class="language-shell"># 配置默认的版本
nvm alias default v14.15.5

# 安装指定版本的 nodejs
nvm install v14.15.5

# 切换到指定的版本
nvm use v14.15.5

# 查看当前安装的版本
nvm ls
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yarn"><a class="header" href="#yarn">Yarn</a></h1>
<p>[TOC]</p>
<h2 id="introduction-9"><a class="header" href="#introduction-9">Introduction</a></h2>
<p>yarn 之余 JavaScript，等价于 maven 之于 Java。yarn 和 react 都是 Facebook 推出的工具。</p>
<p>Yarn is a package manager that doubles down as project manager. Whether you work on one-shot projects or large monorepos, as a hobbyist or an enterprise user, we've got you covered.</p>
<p>install yarn: <code>npm install --global yarn</code></p>
<h2 id="cli"><a class="header" href="#cli">cli</a></h2>
<h3 id="yarn---version"><a class="header" href="#yarn---version">yarn --version</a></h3>
<h3 id="yarn-start"><a class="header" href="#yarn-start">yarn start</a></h3>
<p>start the development server</p>
<h3 id="yarn-build"><a class="header" href="#yarn-build">yarn build</a></h3>
<p>bundle the app into static files for production</p>
<h3 id="yarn-test"><a class="header" href="#yarn-test">yarn test</a></h3>
<p>start the test runner</p>
<h3 id="yarn-eject"><a class="header" href="#yarn-eject">yarn eject</a></h3>
<p>暴露所有的 webpack 配置文件(不可逆)。</p>
<p>remove this tool and copies build dependencies, configuration files and scripts into the app directory.</p>
<h2 id="repos"><a class="header" href="#repos">repos</a></h2>
<h3 id="uuid-1"><a class="header" href="#uuid-1">uuid</a></h3>
<p><code>npm install uuid</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repos-1"><a class="header" href="#repos-1">repos</a></h1>
<h2 id="uuid-2"><a class="header" href="#uuid-2">uuid</a></h2>
<p>生成一个唯一 id</p>
<p><code>npm i uuid</code></p>
<h2 id="nanoid"><a class="header" href="#nanoid">nanoid</a></h2>
<p>轻量的 uuid</p>
<p><code>yarn add nanoid</code></p>
<h2 id="prop-types"><a class="header" href="#prop-types">prop-types</a></h2>
<p>对 props 内容类型进行限制</p>
<p><code>yarn add prop-types</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react"><a class="header" href="#react">React</a></h1>
<p>[TOC]</p>
<p><strong>React</strong> is a JavaScript library for building user interfaces. Learn what React is all about on <a href="https://reactjs.org/">our homepage</a> or <a href="https://reactjs.org/tutorial/tutorial.html">in the tutorial</a>.</p>
<h2 id="react-特点"><a class="header" href="#react-特点">react 特点</a></h2>
<ul>
<li>组件化</li>
<li>用 jsx 写虚拟 DOM</li>
<li>diff 算法，增量渲染</li>
<li>React Native 移动端开发</li>
</ul>
<h2 id="cheatsheet-备忘"><a class="header" href="#cheatsheet-备忘">cheatsheet 备忘</a></h2>
<ul>
<li>jsx 是创建虚拟 DOM 的语法糖</li>
<li>虚拟 DOM 实际上是一个对象</li>
</ul>
<h2 id="vscode-snippet"><a class="header" href="#vscode-snippet">vscode snippet</a></h2>
<table><thead><tr><th>缩写</th><th>功能</th><th>备注</th></tr></thead><tbody>
<tr><td>rcc</td><td>生成类组件代码</td><td>react class component</td></tr>
<tr><td>!</td><td>生成 html 代码</td><td></td></tr>
<tr><td>rfc</td><td>生成函数组件代码</td><td>react function component</td></tr>
<tr><td>dev#root</td><td>生成一个 id 为 root 的 div</td><td></td></tr>
</tbody></table>
<h2 id="react-基本库"><a class="header" href="#react-基本库">react 基本库</a></h2>
<ol>
<li>react.js：React 核心库，引入后，全局就有了一个 React 变量。</li>
<li>react-dom.js：提供操作 DOM 的 react 扩展库，引入后，全局就有了一个 ReactDOM 变量。</li>
<li>babel.min.js：将 JSX 语法代码转为 JS 代码（另外一个功能 ES6 -&gt; ES5）。</li>
</ol>
<h2 id="react-项目代码结构"><a class="header" href="#react-项目代码结构">react 项目代码结构</a></h2>
<pre><code>public/
	index.html
src/
	components/
		Footer/
			index.css
			index.jsx
		Header/
			index.css
			index.jsx
	containers/ // 容器组件
		Header/  // Header 的容器组件
			index.jsx
	redux/
		actions/
			header.js // 为 Header 封装的 action
			count.js
		reducers/
			header.js // 为 Header 服务的 reducer
		constant.js // 配置常量
		store.js // redux 管理员
	App.css 
	App.jsx // 所有组件的外壳组件 
	index.js	// 入口文件
</code></pre>
<h2 id="react-打包发布"><a class="header" href="#react-打包发布">react 打包发布</a></h2>
<p>注意，要在 package.json 中配置 <code>&quot;homepage&quot;: &quot;.&quot;</code>，这样才能以相对路径进行打包。</p>
<h2 id="react--antd-开发流程"><a class="header" href="#react--antd-开发流程">react + antd 开发流程</a></h2>
<p>用脚手架创建 app</p>
<pre><code>create-react-app hello-react
</code></pre>
<p>启动 app</p>
<pre><code>npm start
</code></pre>
<p>安装 antd</p>
<h2 id="react-基础"><a class="header" href="#react-基础">react 基础</a></h2>
<h3 id="hello-react"><a class="header" href="#hello-react">hello react</a></h3>
<pre><code class="language-react">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;/&gt;
        &lt;title&gt;hello-react&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!--  引入 react 核心库，核心库一定要先引入，全局有了一个 React 变量 --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
        &lt;!--    引入 react-dom，用于支持 react 操作 dom，全局有了一个 ReactDOM 变量 --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
        &lt;!--        引入 babel，用于将 jsx 转为 js --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
        &lt;!-- 准备一个容器--&gt;
        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/babel&quot;&gt; /* 此处一定要写 babel */
            // 1. 用 jsx 语法创建虚拟 dom，然后将 DOM 赋值给一个变量 （虚拟 DOM 实际上是一个变量！）
            const VDOM = &lt;h1&gt;hello, react&lt;/h1&gt; /* 此处一定不要加单引号，因为不是字符串 */
            // 2. 渲染虚拟 dom 到容器种
            ReactDOM.render(VDOM, document.getElementById('test'))
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="创建虚拟-dom-的两种方式"><a class="header" href="#创建虚拟-dom-的两种方式">创建虚拟 DOM 的两种方式</a></h3>
<p>jsx: javascript xml</p>
<p>jsx 用于创建虚拟 DOM，jsx 是为了避免用 js 创建虚拟 DOM 而产生的语法糖。</p>
<p>可以使用 JavaScript 面向对象的方法，创建虚拟 DOM，也可以直接写 jsx 创建虚拟 DOM。</p>
<p>用 JavaScript 创建虚拟 DOM。</p>
<pre><code class="language-react">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;/&gt;
        &lt;title&gt;hello-react&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/babel&quot;&gt;
			// 用 JavaScript 创建虚拟 DOM
            const VDOM = React.createElement('h1', {id: 'title'}, React.createElement('span', {}, 'hello react'))
            // 2. 渲染虚拟 dom 到页面
            ReactDOM.render(VDOM, document.getElementById('test'))
        &lt;/script&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>用 jsx 语法创建虚拟 DOM</p>
<pre><code class="language-react">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;/&gt;
        &lt;title&gt;hello-react&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

        &lt;!-- 准备一个容器--&gt;
        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;text/babel&quot;&gt; /* 此处一定要写 babel */
            // 1. 用 jsx 语法创建虚拟 dom
            const VDOM = (
            &lt;h1 id=&quot;title&quot;&gt;
                &lt;span&gt;hello, react&lt;/span&gt;
            &lt;/h1&gt;
            ) /* 此处一定不要加单引号，因为不是字符串 */
            // 2. 渲染虚拟 dom 到页面
            ReactDOM.render(VDOM, document.getElementById('test'))

            console.log('虚拟dom: ', VDOM)
            console.log('真实dom: ', document.getElementById('test'))
            console.log(typeof VDOM)
            console.log(typeof document.getElementById('test'))
            /*
            * 1. 虚拟 DOM 本质上是一个 object 对象
            * 2. 虚拟 dom 比较轻，真实 dom 比较重，因为虚拟 dom 是 react 内部用，不需要太多属性
            * 3. 虚拟 dom 最终会被 react 转化为真实 dom，呈现在页面上
            * */
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="jsx-语法"><a class="header" href="#jsx-语法">jsx 语法</a></h3>
<p>jsx 语法</p>
<pre><code>1. 定义虚拟DOM时，不要写引号。
2. 标签中混入JS表达式时要用{}。
3. 样式的类名指定不要用class，要用className。
4. 内联样式，要用style=\{\{key:value\}\}的形式去写，外层{}表示 js 表达式，内层{}表示 json。
5. 只有一个根标签
6. 标签必须闭合
7. 标签首字母
(1).若小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该标签对应的同名元素，则报错。
(2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。
8. 其他重写规则：
	onclick -&gt; onClick
</code></pre>
<p>js 语句和 js 表达式，{ } 中只能写 js 表达式</p>
<pre><code>一定注意区分：【js语句(代码)】与【js表达式】
1.表达式：一个表达式会产生返回值，可以放在任何一个需要值的地方
    下面这些都是表达式：
    (1). a
    (2). a+b
    (3). demo(1)
    (4). arr.map() 
    (5). function test () {}
2.语句(代码)：
    下面这些都是语句(代码)：
    (1).if(){}
    (2).for(){}
    (3).switch(){case:xxxx}
</code></pre>
<p>demo:</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Person extends React.Component{
        // 限定类型
        static propTypes = {
            name: PropTypes.string.isRequired,
            age: PropTypes.number,
            sex: PropTypes.string
        }
        // 设置默认值
        static defaultProps = {
            age: 18,
            sex: &quot;男&quot;
        }
        render(){
            const {name, age, sex} = this.props
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：{name}&lt;/li&gt;
                    &lt;li&gt;年龄：{age + 1}&lt;/li&gt;
                    &lt;li&gt;性别：{sex}&lt;/li&gt;
                &lt;/ul&gt;
            )
        }
    }
    let data = {name: 'wansho'}
    ReactDOM.render(&lt;Person {...data}/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>以上的 <code>{name}</code> 的用法，类似于前后端一体时候的模板语言。</p>
<h3 id="react-函数式组件"><a class="header" href="#react-函数式组件">react 函数式组件</a></h3>
<p>函数式组件相当于给 VDOM 进行组件化封装</p>
<pre><code class="language-react">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;/&gt;
        &lt;title&gt;hello-react&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;text/babel&quot;&gt; /* 此处一定要写 babel */
            // 1. 创建函数式组件，函数式组件相当于给 VDOM 进行组件化封装
            function MyComponent(){
                return &lt;h2&gt; 这是一个函数式组件！ &lt;/h2&gt;
            }
            // 2. 渲染虚拟 dom 到页面
            ReactDOM.render(&lt;MyComponent/&gt;, document.getElementById('test'))
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="react-类式组件"><a class="header" href="#react-类式组件">react 类式组件</a></h3>
<pre><code class="language-react">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;/&gt;
	&lt;title&gt;2_类式组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

	&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

	&lt;script type=&quot;text/babel&quot;&gt;
		//1.创建类式组件
		class MyComponent extends React.Component {
			render(){
				//render是放在哪里的？—— MyComponent的原型对象上，供实例使用。
				//render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。
				console.log('render中的this:',this);
				return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById('test'))
		/* 
			执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？
            1.React解析组件标签，找到了MyComponent组件。
            2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。
            3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。
		*/
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="类组件三大核心属性state"><a class="header" href="#类组件三大核心属性state">类组件三大核心属性：state</a></h3>
<pre><code class="language-react">this.state; // 存储组件的数据（状态）
this.props; // 存储传给组件的数据
this.refs; // 存储组件内定义的标签的 id
</code></pre>
<p>在构造函数中初始化 state</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    // 1.创建类式组件
    class Weather extends React.Component {
        constructor(props) {
            super(props)
            this.state = { isHot: true, wind: '微风'}
            this.changeWeather = this.changeWeather.bind(this)
        }
        render() {
            // destructure-assignment
            const {isHot, wind} = this.state
            return &lt;h2 onClick={this.changeWeather}&gt;今天天气情况：{isHot ? '炎热' : '凉快'}, {wind}&lt;/h2&gt;
        }
        changeWeather() {
            const isHot = this.state.isHot
            // 状态不能直接更改，要借助 React 的 api 进行更改
            this.setState({isHot: !isHot})
            console.log(this.state.isHot)
        }
    }
    // 2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById('test'))
&lt;/script&gt;
</code></pre>
<p>直接创建类的成员变量 state</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    // 1.创建类式组件
    class Weather extends React.Component {
        // 初始化状态
        // 给 weather 添加一个属性：state
        state = {isHot: true, wind: '微风'}

        render() {
            // destructure-assignment
            const { isHot, wind} = this.state
            return &lt;h2 onClick={this.changeWeather}&gt;今天天气情况：{isHot ? '炎热' : '凉快'}, {wind}&lt;/h2&gt;
        }

        // 自定义方法: 要用赋值语句的形式 + 箭头函数
        // 给 weather 添加一个属性 changeWeather
        // 箭头函数内没有 this，找外部的 this 作为内部的 this 使用，也就是类的对象
        changeWeather = () =&gt;{
            console.log(this)
            const isHot = this.state.isHot
            // 状态不能直接更改，要借助 React 的 api 进行更改，改完状态后，会调用 render 重新渲染
            this.setState({isHot: !isHot})
            console.log(this.state.isHot)
        }
    }
    // 2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById('test'))
&lt;/script&gt;
</code></pre>
<h3 id="类组件三大核心属性props"><a class="header" href="#类组件三大核心属性props">类组件三大核心属性：props</a></h3>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Person extends React.Component{
        // 限定类型
        static propTypes = {
            name: PropTypes.string.isRequired,
            age: PropTypes.number,
            sex: PropTypes.string
        }
        // 设置默认值
        static defaultProps = {
            age: 18,
            sex: &quot;男&quot;
        }
        render(){
            const {name, age, sex} = this.props
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：{name}&lt;/li&gt;
                    &lt;li&gt;年龄：{age + 1}&lt;/li&gt;
                    &lt;li&gt;性别：{sex}&lt;/li&gt;
                &lt;/ul&gt;
            )
        }
    }
    let data = {name: 'wansho'}
    ReactDOM.render(&lt;Person {...data}/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<h3 id="类组件三大核心属性refs"><a class="header" href="#类组件三大核心属性refs">类组件三大核心属性：refs</a></h3>
<p>组件内的标签可以定义 ref 属性来标识自己。</p>
<ol>
<li>字符串形式的 ref</li>
</ol>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;

    class Demo extends React.Component{
        showData1 = () =&gt; {
            console.log(this.refs)
            // 从 ref 中获取标签
            const {input1} = this.refs
            alert(input1.value)
        }
        showData2 = () =&gt; {
            const {input2} = this.refs
            alert(input2.value)
        }
        render(){
            return (
                &lt;div&gt;
                    { /* ref 传入一个字符串 */ }
                    &lt;input ref=&quot;input1&quot; placeholder=&quot;输入内容，点击按钮弹窗显示&quot;/&gt;
                    &lt;button onClick={this.showData1}&gt; 点我提示左侧的数据&lt;/button&gt;
                    &lt;input ref=&quot;input2&quot; onBlur={this.showData2}/&gt;
                &lt;/div&gt;
            )
        }
    }

    ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&quot;test&quot;))

&lt;/script&gt;
</code></pre>
<ol start="2">
<li>回调形式的 ref</li>
</ol>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component{
        showData1 = () =&gt; {
            alert(this.input1.value)
        }
        showData2 = () =&gt; {
            alert(this.input2.value)
        }
        render(){
            return (
                &lt;div&gt;
                    { /* ref 内传入一个回调函数，函数的输入是 currentNode，将其与实例进行绑定，这里在 Demo 实例上，加了 input1 成员变量和 input2 成员变量*/ }
                    &lt;input ref={(currentNode) =&gt; this.input1 = currentNode} placeholder=&quot;输入内容，点击按钮弹窗显示&quot;/&gt;
                    &lt;button onClick={this.showData1}&gt; 点我提示左侧的数据 &lt;/button&gt;
                    &lt;input ref={(currentNode) =&gt; this.input2 = currentNode} onBlur={this.showData2}/&gt;
                &lt;/div&gt;
            )
        }
    }
    ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<ol start="3">
<li>createRef 创建 ref 容器</li>
</ol>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component{
        /*
            React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，该容器是“专人专用”的
        */
        myRef1 = React.createRef();
        myRef2 = React.createRef();
        showData1 = () =&gt; {
            alert(this.myRef1.current.value)
        }
        showData2 = () =&gt; {
            alert(this.myRef2.current.value)
        }
        render(){
            return (
                &lt;div&gt;
                    &lt;input ref={this.myRef1} placeholder=&quot;输入内容，点击按钮弹窗显示&quot;/&gt;
                    &lt;button onClick={this.showData1}&gt; 点我提示左侧的数据&lt;/button&gt;
                    &lt;input ref={this.myRef2} onBlur={this.showData2}/&gt;
                &lt;/div&gt;
            )
        }
    }
    ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>事件处理 event:</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Demo extends React.Component{
        myRef1 = React.createRef();
        showData1 = () =&gt; {
            alert(this.myRef1.current.value)
        }
        /***
         1. 通过 onXxx 属性指定事件处理函数(注意大小写)
            1) React 使用的是自定义(合成)事件, 而不是使用的原生 DOM 事件  —————— 为了更好的兼容性
            2) React 中的事件是通过事件委托方式处理的(委托给组件最外层的元素)  ————————为了的高效
         2. 通过 event.target 得到发生事件的 DOM 元素对象 ———————不要过度使用ref
        */
        
        // 传入一个事件
        showData2 = (event) =&gt; {
            alert(event.target.value)
        }
        render(){
            return (
                &lt;div&gt;
                    &lt;input ref={this.myRef1} placeholder=&quot;输入内容，点击按钮弹窗显示&quot;/&gt;
                    &lt;button onClick={this.showData1}&gt; 点我提示左侧的数据&lt;/button&gt;
                    { /* 这个 input 不需要设置 ref，可以直接给这个 input 绑定事件处理  */ }
                    &lt;input onBlur={this.showData2} placeholder=&quot;输入内容，失去焦点后弹窗显示&quot;/&gt;
                &lt;/div&gt;
            )
        }
    }
    ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>非受控组件：</p>
<p>非受控组件，页面内所有输入类的 DOM，现用现取，就是非受控组件。</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Forum extends React.Component {
        username = React.createRef()
        password = React.createRef()
        submitForum = (event) =&gt; {
            event.preventDefault() // 阻止表单提交
            console.log(this.refs)
            console.log(this.username.current.value)
            console.log(this.password.current.value)
            // 发起 ajax 请求
        }
        render(){
            return (
                &lt;form onSubmit={this.submitForum}&gt;
                    username: &lt;input ref={this.username} name=&quot;username&quot;/&gt;
                    password: &lt;input ref={this.password} name=&quot;password&quot;/&gt;
                    &lt;button&gt;提交&lt;/button&gt;
                &lt;/form&gt;
            )
        }
    }
    ReactDOM.render(&lt;Forum/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>受控组件：</p>
<p>页面内所有输入类的 DOM，随着输入，会把内容维护到状态中。等到需要用的时候，就从状态中取出来。受控组件用得比较多。</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Forum extends React.Component {
        //初始化状态
        state = {
            username: '',
            password: ''
        }
        // 保存用户名到 state 中
        saveUsername = (event) =&gt; {
            this.setState({username: event.target.value})
        }
        // 保存密码到 state 中
        savePassword = (event) =&gt; {
            this.setState({password: event.target.value})
        }
        // 提交表单时，从 state 读出信息提交
        submitForum = () =&gt; {
            const {username, password} = this.state
            alert(`username: ${username}, password: ${password}`)
        }
        render(){
            return (
                &lt;form onSubmit={this.submitForum}&gt;
                    { /* onChange 绑定一个回调函数，onXxx 都是传入一个函数进行绑定 */ }
                    username: &lt;input onChange={this.saveUsername} name=&quot;username&quot;/&gt;
                    password: &lt;input onChange={this.savePassword} name=&quot;password&quot;/&gt;
                    &lt;button&gt;提交&lt;/button&gt;
                &lt;/form&gt;
            )
        }
    }
    ReactDOM.render(&lt;Forum/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>函数的柯里化：</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Forum extends React.Component {
        //初始化状态
        state = {
            username: '',
            password: ''
        }
        // 提交表单时，从 state 读出信息提交
        submitForum = () =&gt; {
            const {username, password} = this.state
            alert(`username: ${username}, password: ${password}`)
        }
        /*
        高阶函数：如果一个函数符合下面 2 个规范中的任何一个，那该函数就是高阶函数。
            1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。
            2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。
            常见的高阶函数有：Promise、setTimeout、arr.map()等等

        函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。
            function sum(a){
                return(b)=&gt;{
                    return (c)=&gt;{
                        return a+b+c
                    }
                }
            }
        */
        saveFormData = (data) =&gt; {
            // 返回的这个函数，才是 onChange 的回调函数
            // console.log(data)
            return (event) =&gt; {
                // console.log(data, event.target.value)
                this.setState({[data]: event.target.value})
            }
        }
        render() {
            return (
                &lt;form onSubmit={this.submitForum}&gt;
                    { /* onChange 必须绑定一个回调函数，这个函数返回一个函数 */}
                    username: &lt;input onChange={this.saveFormData('username')} name=&quot;username&quot;/&gt;
                    password: &lt;input onChange={this.saveFormData('password')} name=&quot;password&quot;/&gt;
                    &lt;button&gt;提交&lt;/button&gt;
                &lt;/form&gt;
            )
        }
    }
    ReactDOM.render(&lt;Forum/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<p>不使用柯里化的方式：</p>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Forum extends React.Component {
        //初始化状态
        state = {
            username: '',
            password: ''
        }
        // 提交表单时，从 state 读出信息提交
        submitForum = () =&gt; {
            const {username, password} = this.state
            alert(`username: ${username}, password: ${password}`)
        }
        saveFormData = (data, event) =&gt; {
            this.setState({[data]: event.target.value})
        }
        render() {
            return (
                &lt;form onSubmit={this.submitForum}&gt;
                    { /* onChange 必须绑定一个回调函数，这里传入一个匿名函数 */}
                    username: &lt;input onChange={(event) =&gt; {this.saveFormData('username', event)}} name=&quot;username&quot;/&gt;
                    password: &lt;input onChange={(event) =&gt; {this.saveFormData('password', event)}} name=&quot;password&quot;/&gt;
                    &lt;button&gt;提交&lt;/button&gt;
                &lt;/form&gt;
            )
        }
    }
    ReactDOM.render(&lt;Forum/&gt;, document.getElementById(&quot;test&quot;))
&lt;/script&gt;
</code></pre>
<h3 id="组件的生命周期"><a class="header" href="#组件的生命周期">组件的生命周期</a></h3>
<p>初始化阶段，由 ReactDOM.render()触发，初次渲染</p>
<ul>
<li>
<p>constructor()</p>
</li>
<li>
<p>getDerivedStateFromProps</p>
</li>
<li>
<p>render()</p>
</li>
<li>
<p>componentDidMount()</p>
<p>加载完后进行初始化，例如开启定时器发送网络请求，订阅消息</p>
</li>
</ul>
<p>更新阶段，由组件内部 this.setSate()或父组件重新 render 触发</p>
<ol>
<li>
<p>getDerivedStateFromProps()</p>
</li>
<li>
<p>shouldComponentUpdate()</p>
</li>
<li>
<p>render()</p>
</li>
<li>
<p>getSnapshotBeforeUpdate()</p>
</li>
<li>
<p>componentDidUpdate()</p>
</li>
</ol>
<p>卸载组件，由 ReactDOM.unmountComponentAtNode() 触发</p>
<ul>
<li>componentWillUnmount()</li>
</ul>
<p>重要的钩子：</p>
<ol>
<li>render： 初始化渲染或更新渲染调用</li>
<li>componentDidMount： 开启监听, 发送 ajax 请求</li>
<li>componentWillUnmount： 做一些收尾工作, 如: 清理定时器</li>
</ol>
<h3 id="diffing-算法"><a class="header" href="#diffing-算法">diffing 算法</a></h3>
<p>新虚拟 DOM 会和旧虚拟 DOM 进行比较，然后增量渲染。</p>
<img align="left" src="computer-science-notebook/front-end/assets/image-20211207091205684.png" alt="image-20211207091205684" style="zoom: 50%;" />
<p>Diffing 算法对比的最小粒度，是标签，而且是嵌套逐层对比。</p>
<pre><code>/*
经典面试题:
1) react/vue中的key有什么作用？（key的内部原理是什么？）
2) 为什么遍历列表时，key最好不要用index?

1. 虚拟DOM中key的作用：
    1) 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。

    2) 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,
    随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：

        a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
        (1) 若虚拟DOM中内容没变, 直接使用之前的真实DOM
        (2) 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM

        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key
        根据数据创建新的真实DOM，随后渲染到到页面

2. 用index作为key可能会引发的问题：
    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
    会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。

    2. 如果结构中还包含输入类的DOM：
    会产生错误DOM更新 ==&gt; 界面有问题。

    3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，
    仅用于渲染列表用于展示，使用index作为key是没有问题的。

3. 开发中如何选择key?:
    1. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
    2. 如果确定只是简单的展示数据，用index也是可以的。
    
*/
</code></pre>
<pre><code class="language-react">&lt;script type=&quot;text/babel&quot;&gt;
    class Person extends React.Component {
        state = {data: [{id: 1, name: 'wansho', age: 26}, {id: 2, name: 'ceshi', age: 20}]}
        addXiaoWang = ()=&gt;{
            let {data} = this.state
            let xiaowang = {id: 3, name: '小王', age: 29 }
            this.setState({data: [xiaowang, ...data]})
        }
        render(){
            return (
                &lt;div&gt;
                    &lt;h2&gt;展示人员信息&lt;/h2&gt;
                    &lt;button onClick={this.addXiaoWang}&gt;添加一个小王&lt;/button&gt;
                    {this.state.data.map((person) =&gt; {
                        return &lt;li key={person.id}&gt;id: {person.id}, name: {person.name}, age: {person.age} &lt;input text='input'/&gt;&lt;/li&gt;
                    })}
                &lt;/div&gt;
            )
        }
    }
    ReactDOM.render(&lt;Person/&gt;, document.getElementById('test'))
&lt;/script&gt;
</code></pre>
<p>使用 index 索引值作为 key，和使用 id 唯一标志作为 key</p>
<pre><code>/* 
	慢动作回放----使用index索引值作为key

			初始数据：
					{id:1,name:'小张',age:18},
					{id:2,name:'小李',age:19},
			初始的虚拟DOM：
					&lt;li key=0&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=1&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;

			更新后的数据：
					{id:3,name:'小王',age:20},
					{id:1,name:'小张',age:18},
					{id:2,name:'小李',age:19},
			更新数据后的虚拟DOM：
					&lt;li key=0&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
			新的虚拟 DOM 和旧的虚拟 DOM，一对比，发现都得更新，根本没有复用
	-----------------------------------------------------------------

	慢动作回放----使用id唯一标识作为key

			初始数据：
					{id:1,name:'小张',age:18},
					{id:2,name:'小李',age:19},
			初始的虚拟DOM：
					&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;

			更新后的数据：
					{id:3,name:'小王',age:20},
					{id:1,name:'小张',age:18},
					{id:2,name:'小李',age:19},
			更新数据后的虚拟DOM：
					&lt;li key=3&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
					&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;

*/
</code></pre>
<h2 id="redux"><a class="header" href="#redux">redux</a></h2>
<p>将多个组件中的共享数据，交给 redux 管理。</p>
<p>redux 是独立第三方库，不是集成到 react 中的，和 Facebook 没关系。</p>
<img align="left" src="computer-science-notebook/front-end/assets/image-20211207150355387.png" alt="image-20211207150355387" style="zoom:40%;" />
<h3 id="action"><a class="header" href="#action">action</a></h3>
<p>action 是一个对象，封装了动作的类型和动作的数据。</p>
<ul>
<li>type: 标识属性, 值为字符串, 唯一, 必要属性</li>
<li>data: 数据属性, 值类型任意, 可选属性 </li>
</ul>
<p>Demo: <code>{ type: 'ADD_STUDENT',data:{name: 'tom',age:18} }  </code></p>
<p>action 分成两类：</p>
<ul>
<li>同步 action：action 值是一个 object 对象</li>
<li>异步 action：action 值是一个函数</li>
</ul>
<p>其实函数也是对象，函数在 JavaScript 中是一等公民。实际创建一个异步 action 函数，就是自定义了一个 reducer，store 不需要手下人去干活了，直接运行这个新建的函数。</p>
<h3 id="reducer"><a class="header" href="#reducer">reducer</a></h3>
<p>map / reduce，reducer 是一个打工仔，是一个计算单元</p>
<p>用于对 redux 中存储的状态进行加工处理</p>
<ol>
<li>用于初始化状态、 加工状态。</li>
<li>加工时，根据旧的 state 和 action，产生新的 state 的纯函数。</li>
</ol>
<h3 id="store"><a class="header" href="#store">store</a></h3>
<p>store 是一个调度者，管理者，将 state、 action、 reducer 联系在一起的对象</p>
<pre><code class="language-javascript">// 创建 store 对象
import {createStore} from 'redux'
import reducer from './reducers'
const store = createStore(reducer)

// store 的 api
getState() // 得到 state
dispatch(action) // 分发 action, 触发 reducer 调用, 产生新的 state
subscribe(listener) // 注册监听, 当产生了新的 state 时, 自动调用
</code></pre>
<h3 id="redux-install"><a class="header" href="#redux-install">redux install</a></h3>
<p>redux 不是默认集成到 react 中的，需要手动安装。</p>
<pre><code class="language-shell">npm install redux
yarn add redux
</code></pre>
<h3 id="redux-精简版"><a class="header" href="#redux-精简版">redux 精简版</a></h3>
<pre><code>	(1) 去除 Count 组件自身的状态
	(2) src下建立:
    	-redux
            -store.js
            -count_reducer.js

	(3) store.js：
        1) 引入 redux 中的 createStore 函数，创建一个 store
        2) createStore 调用时要传入一个为其服务的 reducer
        3) 记得暴露 store 对象

	(4) count_reducer.js：
        1) reducer 的本质是一个函数，接收：preState, action，返回加工后的状态
        2) reducer 有两个作用：初始化状态，加工状态
        3) reducer 被第一次调用时，是 store 自动触发的，
            传递的 preState 是 undefined,
            传递的 action 是:{type:'@@REDUX/INIT_a.2.b.4}

	(5) 在 index.js 中监测 store 中状态的改变，一旦发生改变重新渲染&lt;App/&gt;
    	备注：redux 只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。
</code></pre>
<h3 id="redux-完整版"><a class="header" href="#redux-完整版">redux 完整版</a></h3>
<pre><code>新增文件：
	1. count_action.js 专门用于创建 action 对象
	2. constant.js 放置容易写错的 type 值
</code></pre>
<h3 id="redux-thunk"><a class="header" href="#redux-thunk">redux-thunk</a></h3>
<p>如果想要 redux 的 store 能接收并执行函数，则需要一个中间件 redux-thunk</p>
<pre><code class="language-shell">npm install redux-thunk
</code></pre>
<pre><code>(1) 明确：延迟的动作不想交给组件自身，想交给 action
(2) 何时需要异步 action：想要对状态进行操作，但是具体的数据靠异步任务返回。
(3) 具体编码：
    1) yarn add redux-thunk，并配置在 store 中
    2) 创建 action 的函数不再返回一般对象，而是一个函数，该函数中写异步任务。
    3) 异步任务有结果后，分发一个同步的 action 去真正操作数据
(4) 备注：异步 action 不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步 action
</code></pre>
<h2 id="react-redux"><a class="header" href="#react-redux">react-redux</a></h2>
<p>react-redux 是 react 官方出的库，相当于 react + redux。</p>
<img align="left" src="computer-science-notebook/front-end/assets/image-20211207201359698.png" alt="image-20211207201359698" style="zoom:50%;" />
<h3 id="install-2"><a class="header" href="#install-2">install</a></h3>
<pre><code class="language-shell">npm install redux
npm install react-redux
</code></pre>
<h3 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h3>
<pre><code>(1) 明确两个概念：
    1) UI组件: 不能使用任何 redux 的 api，只负责页面的呈现、交互等。
    2) 容器组件：负责和 redux 通信，将结果交给 UI 组件。
(2) 如何创建一个容器组件————靠 react-redux 的 connect 函数
    connect(mapStateToProps,mapDispatchToProps)(UI 组件)
        -mapStateToProps: 映射状态，是一个函数，返回值是一个对象
        -mapDispatchToProps: 映射操作状态的方法，是一个函数，返回值是一个对象
    容器组件会自动监测 redux 中状态的概念，不需要 subscribe 进行监测了
(3) 备注1：容器组件中的 store 是靠 props 传进去的，而不是在容器组件中直接引入
(4) 备注2：mapDispatchToProps，也可以是一个对象
</code></pre>
<h3 id="优化-1"><a class="header" href="#优化-1">优化</a></h3>
<pre><code>(1) 容器组件和 UI组件 整合一个文件
(2) 无需自己给容器组件传递 store，给 &lt;App/&gt; 包裹一个 &lt;Provider store={store}&gt; 即可。
(3) 使用了 react-redux 后也不用再自己检测 redux 中状态的改变了，容器组件可以自动完成这个工作。
(4) mapDispatchToProps 也可以简单的写成一个对象
(5) 一个组件要和 redux “打交道”要经过哪几步？
    (1) 定义好 UI组件 ---不暴露
    (2) 引入 connect 生成一个容器组件，并暴露，写法如下：
        connect(
            state =&gt; ({key:value}), // 映射状态
            {key:xxxxxAction} // 映射操作状态的方法
        )(UI组件)
    (3) 在 UI组件 中通过 this.props.xxxxxxx 读取和操作状态
</code></pre>
<h2 id="react-相关技术"><a class="header" href="#react-相关技术">react 相关技术</a></h2>
<h3 id="webpack"><a class="header" href="#webpack">webpack</a></h3>
<p>Webpack 是一个开源的前端打包工具。Webpack 提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。</p>
<p>Webpack可以从终端、或是更改webpack.config.js 来设置各项功能。 要使用Webpack 前须先安装Node.js。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chrome-extension"><a class="header" href="#chrome-extension">Chrome-Extension</a></h1>
<p>[TOC]</p>
<h2 id="tutorial-1"><a class="header" href="#tutorial-1">Tutorial</a></h2>
<ul>
<li>官方Tutorial: https://developer.chrome.com/extensions</li>
<li>How to debug: https://developer.chrome.com/tut_debugging</li>
<li>API: https://developer.chrome.com/apps/api_index</li>
<li><a href="http://open.chrome.360.cn/">360翻译的中文文档</a></li>
<li><a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html">中文 Blog 教程</a></li>
</ul>
<h2 id="chrome-extension-introduction"><a class="header" href="#chrome-extension-introduction">Chrome Extension Introduction</a></h2>
<p>Chrome extension 是由 HTML, CSS, JavaScript 开发的在浏览器上运行的轻量级 Web 程序, 本质上是一个 web page, 其可以使用浏览器提供的 API.</p>
<p>一个 Chrome 扩展应该是一把锋利的小刀，就像 Linux 系统的一个命令一样，只完成一件或一类任务。</p>
<h3 id="扩展工作方式"><a class="header" href="#扩展工作方式">扩展工作方式</a></h3>
<ol>
<li>
<p>和网页交互</p>
<p>Extension 可以使用 content-scripts 和网页进行读写交互</p>
</li>
<li>
<p>和服务器交互</p>
<p>可以使用 cross-origin XMLHttpRequests 和服务器进行交互</p>
</li>
</ol>
<h3 id="api-种类"><a class="header" href="#api-种类">API 种类</a></h3>
<p>有两类可用的 API</p>
<h4 id="browser-api"><a class="header" href="#browser-api">Browser API</a></h4>
<p>浏览器本身自带的 API</p>
<h4 id="extension-specific-api"><a class="header" href="#extension-specific-api">Extension Specific API</a></h4>
<p>Chrome 为扩展定制的API</p>
<h4 id="asynchronous-vs-synchronous-methods"><a class="header" href="#asynchronous-vs-synchronous-methods">Asynchronous vs. synchronous methods</a></h4>
<p>大多数的 Chrome API 都是异步的。如果 Extension 想要获取一个异步方法的结果，其可以往方法中传入一个回调方法（callback function），callback function 可能要执行很久。异步方法往往不需要加入返回值，因为异步方法会马上执行并返回一个返回值，但是这个返回值往往是空的，因为 callback function 还没有执行，真正想要获取异步方法的返回值，应该在 callback 中获取。</p>
<p>一个标准的异步方法：</p>
<pre><code class="language-javascript">// Signature for an asynchronous method
chrome.tabs.query(object queryInfo , function callback )
</code></pre>
<p>异步方法往往没有返回值，返回值的处理放在了 callback 方法中</p>
<p>同步方法通常是有返回值的。</p>
<h2 id="代码-architecture"><a class="header" href="#代码-architecture">代码 Architecture</a></h2>
<pre><code>-- app
   -- Manifest
   -- Background Script # extension's event handler 事件处理
   -- UI Elements # Chrome Extension 的 UI 包括 html 和 js事件处理
   -- Content Script # 和前端页面进行交互
   -- Options Page
</code></pre>
<p><img src="http://assets.processon.com/chart_image/5c98d6b5e4b0f88919bbbfd0.png" alt="框架" /></p>
<h3 id="background-script"><a class="header" href="#background-script">Background Script</a></h3>
<ul>
<li>background.js 是整个应用的事件处理器，里面包含了对浏览器事件的监听器</li>
<li>Background Script 相当于整个 app 的基类，貌似除了 content-script 不能调用其中的方法外，其他所有的 js  脚本都继承自该基类（个人理解）</li>
</ul>
<h3 id="ui-elements"><a class="header" href="#ui-elements">UI Elements</a></h3>
<h4 id="ui-分类"><a class="header" href="#ui-分类">UI 分类</a></h4>
<ul>
<li>
<p>browser actions</p>
<p>如果 extension 和绝大多数的页面都有关，则选用 browser actions</p>
</li>
<li>
<p>page actions</p>
<p>如果 extension 仅和少数页面相关，则选用 page actions</p>
</li>
<li>
<p>context menus</p>
</li>
<li>
<p>Other UI</p>
</li>
</ul>
<h4 id="popup-设计"><a class="header" href="#popup-设计">popup 设计</a></h4>
<p><a href="https://developer.chrome.com/extensions/user_interface">官方文档</a> <a href="https://developer.chrome.com/extensions/samples">官方Demos</a></p>
<p>如何设计 popup.html ？看官网 Demo ！</p>
<p>注意：</p>
<ul>
<li>popup.html 中不能加入 JavaScript 代码，HTML 和 Javascript 必须分离开。</li>
<li>popup.js 中的 console.log 需要对 popup 页面右击点击查看才能看到。</li>
<li>popup.html 中的超链接 <code>&lt;a&gt;</code> 不会生效，不知为何。 </li>
</ul>
<h3 id="content-scripts"><a class="header" href="#content-scripts">Content Scripts</a></h3>
<p>By using the standard <a href="http://www.w3.org/TR/DOM-Level-2-HTML/">Document Object Model</a> (DOM), they are able to read details of the web pages the browser visits, make changes to them and pass information to their parent extension.</p>
<p>Extension 使用 content script 和前端网页进行读写交互（也只有content script 可以和前端页面进行交互），content script 利用 DOM 和网页进行交互，可以对前端进行改动。Content-Script 在页面加载的时候会自动执行。Content-Script 是一个相对隔离的脚本，只与前端页面进行交互。</p>
<ul>
<li>Content script 可以利用 <a href="https://developer.chrome.com/extensions/messaging">Messaging</a> 和 background.js / popup.js 进行交互。</li>
<li>Content Script 已经在 manifest 中设置了 在页面加载完成后执行.</li>
<li>Content Script 只限于 DOM 操作，做 html，css，js 的相关操作，不能完成与服务器交互的操作，事实上，Google 对 Content Script 的限制非常严格，因为 Content-Script 可以轻而易举的获取到用户的隐私</li>
<li>Content Script 中的 log 会打印在其操作的页面上，也就是 Web page 上，F12</li>
</ul>
<h4 id="contentscript-前端注入-html-代码"><a class="header" href="#contentscript-前端注入-html-代码">ContentScript 前端注入 HTML 代码</a></h4>
<p><a href="https://developer.chrome.com/extensions/examples/api/eventPage/basic/content.js">demo</a></p>
<p>添加 DOM 的三种方式。</p>
<pre><code class="language-JavaScript">function appendText()
{
    var txt1=&quot;&lt;p&gt;文本。&lt;/p&gt;&quot;;              // 使用 HTML 标签创建文本
    var txt2=$(&quot;&lt;p&gt;&lt;/p&gt;&quot;).text(&quot;文本。&quot;);  // 使用 jQuery 创建文本
    var txt3=document.createElement(&quot;p&quot;);
    txt3.innerHTML=&quot;文本。&quot;;               // 使用 DOM 创建文本 text with DOM
    $(&quot;body&quot;).append(txt1,txt2,txt3);        // 追加新元素
}
</code></pre>
<h3 id="option-page"><a class="header" href="#option-page">Option page</a></h3>
<p>option page 可以对 extension 进行个性化定制。</p>
<h2 id="其他功能"><a class="header" href="#其他功能">其他功能</a></h2>
<h3 id="communication-between-pages-通信功能"><a class="header" href="#communication-between-pages-通信功能">Communication between pages 通信功能</a></h3>
<p>Different components in an extension often need to communicate with each other. Different HTML pages can find each other by using the <a href="https://developer.chrome.com/extensions/extension"><code>chrome.extension</code></a> methods, such as <code>getViews()</code> and <code>getBackgroundPage()</code>. Once a page has a reference to other extension pages the first one can invoke functions on the other pages and manipulate their DOMs. Additionally, all components of the extension can access values stored using the <a href="https://developer.chrome.com/extensions/storage">storage</a> API and communicate through <a href="https://developer.chrome.com/extensions/messaging">message passing</a>.</p>
<p>所有的组件，都可以获取存储到本地的数据，也可以互相通信。</p>
<h4 id="sendmessage-方法"><a class="header" href="#sendmessage-方法">sendMessage 方法</a></h4>
<p><a href="https://developer.chrome.com/apps/runtime#method-sendMessage">官方文档</a></p>
<p>sendMessage 方法用于 extension 中不同的模块进行通信，当我们发送了一条消息时，所有的模块的runtime.onMessage 都会响应。但是，runtime.sendMessage 不能发送 message 到 content-script，要想和 content-script 进行通信，就要使用 <a href="https://developer.chrome.com/extensions/tabs#method-sendMessage">tabs.sendMessage</a> 发消息，content-script 才能收到。tabs.sendMessage 是专门设计用来和指定的 content-script 进行通信的。</p>
<p>注意，对于 tabs.sendMessage 方法，如果我们打开了 DevTools，那么返回的 tabs 数组将为空 <a href="https://stackoverflow.com/questions/29681477/background-script-messaging-with-javascript">StackOverflow</a></p>
<pre><code class="language-JavaScript">chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
	chrome.tabs.sendMessage(tabs[0].id, {command: &quot;start_rendering&quot;});
   }
);
</code></pre>
<h3 id="数据存储--storage"><a class="header" href="#数据存储--storage">数据存储  storage</a></h3>
<p><a href="https://developer.chrome.com/storage">storage tutorial</a></p>
<h4 id="本地少量数据存储-sync"><a class="header" href="#本地少量数据存储-sync">本地少量数据存储 sync</a></h4>
<pre><code class="language-JavaScript">chrome.storage.sync.set({color: '#3aa757'}, function() {
	console.log(&quot;The color is green.&quot;);
});
</code></pre>
<h4 id="本地大量数据存储-local"><a class="header" href="#本地大量数据存储-local">本地大量数据存储 local</a></h4>
<pre><code class="language-JavaScript">chrome.storage.local.set({color: '#3aa757'}, function() {
	console.log(&quot;The color is green.&quot;);
});
</code></pre>
<h4 id="两种存储方式的异同点"><a class="header" href="#两种存储方式的异同点">两种存储方式的异同点</a></h4>
<ul>
<li>
<p>本地存储的对象不仅限于 string 类型，也可以存储字典</p>
</li>
<li>
<p><code>sync</code> 存储的数据有大小限制，最大为 8k，<code>local</code> 能存储的比较大，为 5M</p>
</li>
<li>
<p><code>sync</code> 方式存储的数据，会存储到用户的云上，并且会在所有的 Chrome 客户端进行同步，而 <code>local</code> 方式只局限于本地的存储</p>
</li>
</ul>
<h3 id="权限控制-1"><a class="header" href="#权限控制-1">权限控制</a></h3>
<p>大多数 API，包括 存储 / 外域访问 / 前端代码注入，都需要在 manifest 中注册，用于权限管理。</p>
<p>当我们发现程序怎么调试都有问题的时候，往往是我们忽略了权限的配置。</p>
<h3 id="开发注意事项"><a class="header" href="#开发注意事项">开发注意事项</a></h3>
<ul>
<li>Background scripts 和 其他重要的 components 必须在 manifest 中注册</li>
<li>要实现外域（外网）访问，需要在 permission 中加入要访问的 域名，用通配符</li>
</ul>
<h2 id="chrome-extension-国际化"><a class="header" href="#chrome-extension-国际化">Chrome Extension 国际化</a></h2>
<p><a href="https://developer.chrome.com/webstore/i18n">Tutorial</a></p>
<p><a href="https://developer.chrome.com/extensions/i18n">Doc</a></p>
<h2 id="bootstrap-material-design--chrome-extension"><a class="header" href="#bootstrap-material-design--chrome-extension">bootstrap-material-design + Chrome Extension</a></h2>
<p>注意，在导入 bootstrap 的过程中，js 应该按照以下的顺序导入（不能乱序）：</p>
<pre><code class="language-html">&lt;script src=&quot;static/js/jquery-2.0.3.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;static/js/popper.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;static/js/bootstrap-material-design.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>另外，由于 Chrome Extension 规定了 html 代码中不能有动态执行的 js 代码，所以我们需要在 popup.js 加入以下的代码，使得 bootstrap 起作用：</p>
<pre><code class="language-JavaScript">$(document).ready(function() { $('body').bootstrapMaterialDesign(); });
</code></pre>
<h2 id="chrome-插件收藏"><a class="header" href="#chrome-插件收藏">Chrome 插件收藏</a></h2>
<ul>
<li><a href="https://github.com/nsfw-filter/nsfw-filter">NSFW</a> 过滤 Not Safe for Work 的图片</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ajax"><a class="header" href="#ajax">ajax</a></h1>
<p>[TOC]</p>
<h2 id="introduction-10"><a class="header" href="#introduction-10">introduction</a></h2>
<p>Asynchronous JavaScript and XML.</p>
<p><strong>Ajax 是一套技术，可以实现不用刷新页面就可以更新网页数据的功能，XMLHttpRequest（XHR）是 Ajax 的核心。</strong></p>
<p>ajax 诞生于 2005 年，标志着 web2.0 时代的到来。AJAX 不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>代替以进一步减少数据量。而客户端与服务器也并不需要异步。</p>
<p>使用结合了这些技术的 AJAX 模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。</p>
<h2 id="ajax-and-jquery"><a class="header" href="#ajax-and-jquery">ajax and jquery</a></h2>
<p>jquery 是一个 JavaScript 工具包，集成了 ajax 功能。</p>
<h2 id="ajax-implements"><a class="header" href="#ajax-implements">ajax implements</a></h2>
<ul>
<li>jQuery 很重，而且主要功能不是发送 Ajax 请求，是操作 DOM</li>
<li>axios 轻量级，建议使用
<ul>
<li>封装 XmlHttpRequest 对象的 ajax</li>
<li>promise 风格</li>
<li>可以用在浏览器端和 node 服务器端</li>
</ul>
</li>
</ul>
<h2 id="ajax-详解"><a class="header" href="#ajax-详解">ajax 详解</a></h2>
<h3 id="xmlhttprequest"><a class="header" href="#xmlhttprequest">XMLHttpRequest</a></h3>
<p><strong>XMLHttpRequest</strong> (<strong>XHR</strong>) is an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> in the form of an <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object</a> whose <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">methods</a> transfer data between a <a href="https://en.wikipedia.org/wiki/Web_browser">web browser</a> and a <a href="https://en.wikipedia.org/wiki/Web_server">web server</a>. The object is provided by the browser's <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> environment. </p>
<p>XHR 是一个对象，其中封装了浏览器和服务器进行数据交互的 api，由浏览器的 JavaScript 运行环境提供。</p>
<h3 id="跨域问题"><a class="header" href="#跨域问题">跨域问题</a></h3>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">阮一峰：浏览器同源政策及其规避方法</a> </p>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。可以通过架设服务器代理来避免这个问题。</p>
<h2 id="axios-教程"><a class="header" href="#axios-教程">axios 教程</a></h2>
<h3 id="installation"><a class="header" href="#installation">installation</a></h3>
<pre><code class="language-shell">yarn add axios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jquery"><a class="header" href="#jquery">jQuery</a></h1>
<p><strong>jQuery 是一个 JavaScript 库。</strong></p>
<p><strong>jQuery 极大地简化了 JavaScript 编程。</strong></p>
<p><strong>jQuery 很容易学习。</strong></p>
<p>[TOC]</p>
<h2 id="how-to-learn"><a class="header" href="#how-to-learn">How to Learn</a></h2>
<p>现用现学：https://www.w3school.com.cn/jquery/index.asp</p>
<h2 id="jquery-与油猴脚本"><a class="header" href="#jquery-与油猴脚本">jQuery 与油猴脚本</a></h2>
<p>一个网页本身，会嵌入很多 JavaScript 脚本。我们可以利用油猴，植入自己的 JavaScript 代码，直接对原脚本中的函数进行调用。自己植入的代码，和网页源代码，是处于同一个环境下的，可以相互调用。</p>
<p>Demo：</p>
<pre><code class="language-javascript">// myPlayer 是网页源码中的播放器对象，我们可以植入脚本，直接对 myPlayer 对象进行操作，从而对播放状态进行控制

function detectPlaybackStatus() {
    const date = new Date();
    console.info(date.toLocaleString() + ' 检测播放状态...')
    if (myPlayer.getState() == 'playing') {
        console.log(&quot;播放中...啥也不操作了&quot;);
    } else if (myPlayer.getState() == 'paused') { //暂停
        console.log(&quot;暂停啦！！！&quot;);
        myPlayer.play(); 
        console.log(&quot;开始播放~&quot;);
    } else if (myPlayer.getState() == 'complete') {
        console.log($('#lblTitle').text() + &quot;播放完成！！！&quot;);
        //返回上一级
        GoBack();
    }
}
</code></pre>
<h2 id="jquery-选择器"><a class="header" href="#jquery-选择器">jQuery 选择器</a></h2>
<p>选择器条件组合：</p>
<ul>
<li>https://www.cnblogs.com/fanbi/p/7705235.html</li>
</ul>
<table><thead><tr><th style="text-align: left">选择器</th><th style="text-align: left">实例</th><th style="text-align: left">选取</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_all.asp">*</a></td><td style="text-align: left">$(&quot;*&quot;)</td><td style="text-align: left">所有元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_id.asp">#<em>id</em></a></td><td style="text-align: left">$(&quot;#lastname&quot;)</td><td style="text-align: left">id=&quot;lastname&quot; 的元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_class.asp">.<em>class</em></a></td><td style="text-align: left">$(&quot;.intro&quot;)</td><td style="text-align: left">所有 class=&quot;intro&quot; 的元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_element.asp"><em>element</em></a></td><td style="text-align: left">$(&quot;p&quot;)</td><td style="text-align: left">所有 <p> 元素</td></tr>
<tr><td style="text-align: left">.<em>class</em>.<em>class</em></td><td style="text-align: left">$(&quot;.intro.demo&quot;)</td><td style="text-align: left">所有 class=&quot;intro&quot; 且 class=&quot;demo&quot; 的元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_first.asp">:first</a></td><td style="text-align: left">$(&quot;p:first&quot;)</td><td style="text-align: left">第一个 <p> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_last.asp">:last</a></td><td style="text-align: left">$(&quot;p:last&quot;)</td><td style="text-align: left">最后一个 <p> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_even.asp">:even</a></td><td style="text-align: left">$(&quot;tr:even&quot;)</td><td style="text-align: left">所有偶数 <tr> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_odd.asp">:odd</a></td><td style="text-align: left">$(&quot;tr:odd&quot;)</td><td style="text-align: left">所有奇数 <tr> 元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_eq.asp">:eq(<em>index</em>)</a></td><td style="text-align: left">$(&quot;ul li:eq(3)&quot;)</td><td style="text-align: left">列表中的第四个元素（index 从 0 开始）</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_gt.asp">:gt(<em>no</em>)</a></td><td style="text-align: left">$(&quot;ul li:gt(3)&quot;)</td><td style="text-align: left">列出 index 大于 3 的元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_lt.asp">:lt(<em>no</em>)</a></td><td style="text-align: left">$(&quot;ul li:lt(3)&quot;)</td><td style="text-align: left">列出 index 小于 3 的元素</td></tr>
<tr><td style="text-align: left">:not(<em>selector</em>)</td><td style="text-align: left">$(&quot;input:not(:empty)&quot;)</td><td style="text-align: left">所有不为空的 input 元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_header.asp">:header</a></td><td style="text-align: left">$(&quot;:header&quot;)</td><td style="text-align: left">所有标题元素 <h1> - <h6></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_animated.asp">:animated</a></td><td style="text-align: left"></td><td style="text-align: left">所有动画元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_contains.asp">:contains(<em>text</em>)</a></td><td style="text-align: left">$(&quot;:contains('W3School')&quot;)</td><td style="text-align: left">包含指定字符串的所有元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_empty.asp">:empty</a></td><td style="text-align: left">$(&quot;:empty&quot;)</td><td style="text-align: left">无子（元素）节点的所有元素</td></tr>
<tr><td style="text-align: left">:hidden</td><td style="text-align: left">$(&quot;p:hidden&quot;)</td><td style="text-align: left">所有隐藏的 <p> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_visible.asp">:visible</a></td><td style="text-align: left">$(&quot;table:visible&quot;)</td><td style="text-align: left">所有可见的表格</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">s1,s2,s3</td><td style="text-align: left">$(&quot;th,td,.intro&quot;)</td><td style="text-align: left">所有带有匹配选择的元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/jquery/selector_attribute.asp"><em>attribute</em>]</a></td><td style="text-align: left">$(&quot;[href]&quot;)</td><td style="text-align: left">所有带有 href 属性的元素</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/jquery/selector_attribute_equal_value.asp"><em>attribute</em>=<em>value</em>]</a></td><td style="text-align: left">$(&quot;[href='#']&quot;)</td><td style="text-align: left">所有 href 属性的值等于 &quot;#&quot; 的元素</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/jquery/selector_attribute_notequal_value.asp"><em>attribute</em>!=<em>value</em>]</a></td><td style="text-align: left">$(&quot;[href!='#']&quot;)</td><td style="text-align: left">所有 href 属性的值不等于 &quot;#&quot; 的元素</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/jquery/selector_attribute_end_value.asp"><em>attribute</em>$=<em>value</em>]</a></td><td style="text-align: left">$(&quot;[href$='.jpg']&quot;)</td><td style="text-align: left">所有 href 属性的值包含以 &quot;.jpg&quot; 结尾的元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input.asp">:input</a></td><td style="text-align: left">$(&quot;:input&quot;)</td><td style="text-align: left">所有 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_text.asp">:text</a></td><td style="text-align: left">$(&quot;:text&quot;)</td><td style="text-align: left">所有 type=&quot;text&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_password.asp">:password</a></td><td style="text-align: left">$(&quot;:password&quot;)</td><td style="text-align: left">所有 type=&quot;password&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_radio.asp">:radio</a></td><td style="text-align: left">$(&quot;:radio&quot;)</td><td style="text-align: left">所有 type=&quot;radio&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_checkbox.asp">:checkbox</a></td><td style="text-align: left">$(&quot;:checkbox&quot;)</td><td style="text-align: left">所有 type=&quot;checkbox&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_submit.asp">:submit</a></td><td style="text-align: left">$(&quot;:submit&quot;)</td><td style="text-align: left">所有 type=&quot;submit&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_reset.asp">:reset</a></td><td style="text-align: left">$(&quot;:reset&quot;)</td><td style="text-align: left">所有 type=&quot;reset&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_button.asp">:button</a></td><td style="text-align: left">$(&quot;:button&quot;)</td><td style="text-align: left">所有 type=&quot;button&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_image.asp">:image</a></td><td style="text-align: left">$(&quot;:image&quot;)</td><td style="text-align: left">所有 type=&quot;image&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_file.asp">:file</a></td><td style="text-align: left">$(&quot;:file&quot;)</td><td style="text-align: left">所有 type=&quot;file&quot; 的 <input> 元素</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_enabled.asp">:enabled</a></td><td style="text-align: left">$(&quot;:enabled&quot;)</td><td style="text-align: left">所有激活的 input 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_disabled.asp">:disabled</a></td><td style="text-align: left">$(&quot;:disabled&quot;)</td><td style="text-align: left">所有禁用的 input 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_selected.asp">:selected</a></td><td style="text-align: left">$(&quot;:selected&quot;)</td><td style="text-align: left">所有被选取的 input 元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/jquery/selector_input_checked.asp">:checked</a></td><td style="text-align: left">$(&quot;:checked&quot;)</td><td style="text-align: left">所有被选中的 input 元素</td></tr>
</tbody></table>
<h2 id="我用到-jquery-的项目"><a class="header" href="#我用到-jquery-的项目">我用到 jQuery 的项目</a></h2>
<ul>
<li>
<p><a href="https://github.com/wansho/yunxuetang-script">yunxuetang-script</a></p>
</li>
<li>
<p><a href="https://github.com/wansho/wansho_webservice">wansho_webservice</a></p>
</li>
<li>
<p><a href="https://github.com/wansho/bilibili-helper-chrome-extension">bilibili-helper-chrome-extension</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">Javascript</a></h1>
<p>[TOC]</p>
<h2 id="我的思考-1"><a class="header" href="#我的思考-1">我的思考</a></h2>
<h3 id="箭头函数"><a class="header" href="#箭头函数">箭头函数</a></h3>
<pre><code class="language-javascript">const hehe = (input) =&gt; {
	console.log(input);	
}

hehe('nihao');
</code></pre>
<p>箭头函数实际上是把一个函数复制给一个变量，JavaScript 中函数是一等公民。</p>
<h2 id="js-tutorial"><a class="header" href="#js-tutorial">JS Tutorial</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">[A re-introduction to JavaScript]</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript">JavaScript</a> is notorious for being <a href="http://crockford.com/javascript/javascript.html">the world's most misunderstood programming language</a>.</p>
<p>臭名昭著！</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>1995 created, Brendan Eich（布兰登-艾奇）, Netscape</p>
<p>远景公司将 JavaScript 托管给 ECMA(European standards organization)，ECMA 负责 JavaScript 的维护，所以 Javascript 又叫做 ECMAScript，最新的 JavaScript 标准是 ECMAScript edition 6 2015 (<strong>ES2015</strong>, <strong>ES6</strong>)。</p>
<p>JavaScript 没有输入输出的概念，其与外界通信取决于它运行在什么样的环境中：browser, Adobe Acrobat, Adobe Photoshop, SVG images, server-side environments such as <a href="http://nodejs.org/">Node.js</a>, embedded computers, GNOME，JavaScript 在这些环境下（<strong>前端后端</strong>）都可以运行，可以说是一门非常“万能”的语言了。</p>
<p>JavaScript 是一门<strong>多范式</strong>的<strong>动态语言</strong>，其语法基于 Java 和 C，支持<strong>面向对象</strong>编程范式，支持<strong>函数式编程</strong>。在 JavaScript 中，函数是第一公民。JavaScript 采用 object prototypes（<strong>对象原型</strong>）来实现面向对象的机制，而不是 class。</p>
<p>JavaScript is a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Prototype-based_programming">prototype-based</a>, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative（命令式编程）, and declarative (e.g. functional programming) styles.</p>
<p><strong>数据类型</strong>：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> (new in ES2015)</li>
<li><code>Object</code>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a></li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
</ul>
<h3 id="number"><a class="header" href="#number">Number</a></h3>
<h4 id="javascript-只有浮点型数值"><a class="header" href="#javascript-只有浮点型数值">JavaScript 只有浮点型数值</a></h4>
<p>JavaScript 中 Number 的定义是：&quot;double-precision 64-bit format IEEE 754 values&quot;，所有的 Number 都是 8 字节双精度的浮点数。<strong>JavaScript 中的数值类型都是双精度浮点型类型，占 8 个字节，并没有整型数值类型</strong>！</p>
<pre><code class="language-javascript">console.log(3 / 2);             // 1.5, not 1
console.log(Math.floor(3 / 2)); // 1 An apparent integer is in fact implicitly a float.
</code></pre>
<h4 id="parseint-陷阱"><a class="header" href="#parseint-陷阱">parseInt 陷阱</a></h4>
<p>parseInt 有一个可选参数，按照何种进制进行字符串到数字的转换。老的浏览器会将 0 开头的字符串解释成 8 进制数字，为了保证将我们的字符串转换成我们想要的数字，我们在用到 parseInt 时，一定要指定进制数。</p>
<pre><code class="language-javascript">// new browser
parseInt('123', 10); // 123
parseInt('010', 10); // 10
parseInt('11', 2); // 3
parseInt('0x10'); // 16

// older browser
parseInt('010');  //  8
</code></pre>
<p>注意，<code>parseFloat()</code> always uses base 10.</p>
<h4 id="parse-string-to-number-的其他方式"><a class="header" href="#parse-string-to-number-的其他方式">parse string to number 的其他方式</a></h4>
<pre><code class="language-javascript">+ '42';   // 42
+ '010';  // 10
+ '0x10'; // 16
</code></pre>
<h4 id="parseint--parsefloat-与---比较贪心算法"><a class="header" href="#parseint--parsefloat-与---比较贪心算法">parseInt / parseFloat 与 <code>+</code>  比较，贪心算法</a></h4>
<pre><code class="language-javascript">parseFloat('12.3sss', 10) // 12.3
parseInt('123sss', 10) // 123

+ '12.3ss' // NaN
+ '123ss' // NaN
</code></pre>
<h4 id="nan"><a class="header" href="#nan">NaN</a></h4>
<p>A special value called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> (short for &quot;Not a Number&quot;) is returned if the string is non-numeric:</p>
<pre><code class="language-javascript">parseInt('hello', 10); // NaN
</code></pre>
<p>NaN 有毒，如果将其作为一个运算符参与到任何运算，其结果都会是一个 NaN</p>
<pre><code class="language-js">NaN + 5; // NaN
</code></pre>
<p>You can test for <code>NaN</code> using the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><code>isNaN()</code></a> function:</p>
<pre><code class="language-js">isNaN(NaN); // true
</code></pre>
<h4 id="无穷大-infinity"><a class="header" href="#无穷大-infinity">无穷大 Infinity</a></h4>
<pre><code class="language-js">1 / 0; //  Infinity
-1 / 0; // -Infinity
</code></pre>
<p>You can test for <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code> values using the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite"><code>isFinite()</code></a> function:</p>
<pre><code class="language-js">isFinite(1 / 0); // false
isFinite(-Infinity); // false
isFinite(NaN); // false
</code></pre>
<h3 id="string-2"><a class="header" href="#string-2">String</a></h3>
<h4 id="基础知识-1"><a class="header" href="#基础知识-1">基础知识</a></h4>
<p>JavaScript 中的 String 是 Unicode(UTF-16)字符串（没有国际化的问题）。</p>
<p>JavaScript 默认用单引号来定义字符串。</p>
<p>JavaScript 中的字符串，是面向对象的字符串，每一个字符串都是一个对象，既然有对象，那么就有属性和方法：</p>
<pre><code class="language-javascript">'hello'.length; // 5

'hello'.charAt(0); // &quot;h&quot;
'hello, world'.replace('world', 'mars'); // &quot;hello, mars&quot;
'hello'.toUpperCase(); // &quot;HELLO&quot;
</code></pre>
<h4 id="反引号-template-literals"><a class="header" href="#反引号-template-literals">反引号 template literals</a></h4>
<p>They were called &quot;template strings&quot; in prior editions of the ECMAScript 2015 specification. Template literals are supported by Firefox 34, Chrome 41, and Edge 12 and above, but not by Internet Explorer.</p>
<p>ECMAScript 6 comes up with a new type of string literal, using the backtick as the delimiter. These literals do allow basic string interpolation expressions to be embedded, which are then automatically parsed and evaluated.</p>
<pre><code class="language-js">let person = {name: 'RajiniKanth', age: 68, greeting: 'Thalaivaaaa!' };

let usualHtmlStr = &quot;&lt;p&gt;My name is &quot; + person.name + &quot;,&lt;/p&gt;\n&quot; +
  &quot;&lt;p&gt;I am &quot; + person.age + &quot; old&lt;/p&gt;\n&quot; +
  &quot;&lt;strong&gt;\&quot;&quot; + person.greeting + &quot;\&quot; is what I usually say&lt;/strong&gt;&quot;;

let newHtmlStr =
 `&lt;p&gt;My name is ${person.name},&lt;/p&gt;
  &lt;p&gt;I am ${person.age} old&lt;/p&gt;
  &lt;p&gt;&quot;${person.greeting}&quot; is what I usually say&lt;/strong&gt;`;

console.log(usualHtmlStr);
console.log(newHtmlStr);
</code></pre>
<p>As you can see, we used the ``` around a series of characters, which are interpreted as a string literal, but any expressions of the form <code>${..}</code> are parsed and evaluated inline immediately.</p>
<p>One really nice benefit of interpolated string literals is they are allowed to split across multiple lines:</p>
<pre><code class="language-js">var Actor = {&quot;name&quot;: &quot;RajiniKanth&quot;};

var text =
`Now is the time for all good men like ${Actor.name}
to come to the aid of their
country!`;
console.log(text);
// Now is the time for all good men like RajiniKanth
// to come to the aid of their
// country!
</code></pre>
<h3 id="null-undefined-boolean"><a class="header" href="#null-undefined-boolean">null, undefined, Boolean()</a></h3>
<p>null, which is a value that indicates a deliberate non-value. null 是一个值</p>
<p>undefined, which is a value of type <code>undefined</code> that indicates an uninitialized variable — that is, a value hasn't even been assigned yet. undefined 是类型</p>
<p>如果我们在定义变量的时候没有声明变量的值，那么这个变量的类型就是 undefined. </p>
<pre><code class="language-js">var tmp;
typeof(tmp); // undefined
</code></pre>
<p><strong>true</strong> or <strong>false</strong>（这两个值是 JavaScript 中的两个关键字）</p>
<ol>
<li><code>false</code>, <code>0</code>, empty strings (<code>&quot;&quot;</code>), <code>NaN</code>, <code>null</code>, and <code>undefined</code> all become <code>false.</code></li>
<li>All other values become <code>true.</code></li>
</ol>
<pre><code class="language-js">Boolean('');  // false
Boolean(234); // true

Boolean(false) // false
Boolean('false') // true

typeof(true) // boolean
</code></pre>
<p>true 和 false 两个值同样支持 Boolean 运算符：<code>&amp;&amp; || !</code></p>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>变量声明的关键字：<code>let</code>,  <code>const</code>, <code>var</code></p>
<p>关键字声明的变量的生效范围：<code>let</code> &lt; <code>var</code></p>
<p>如果我们在声明变量的时候，没有对其赋值，那么该变量的类型就是 <code>undefined</code></p>
<h4 id="let"><a class="header" href="#let">let</a></h4>
<p>ES6 引入</p>
<p>let 关键字声明的变量仅局限于代码块：</p>
<p>The following is an example of scope with a variable declared with <code>**let**</code>:</p>
<pre><code class="language-js">// myLetVariable is *not* visible out here

for (let myLetVariable = 0; myLetVariable &lt; 5; myLetVariable++) {
  // myLetVariable is only visible in here
}

// myLetVariable is *not* visible out here
</code></pre>
<h4 id="const"><a class="header" href="#const">const</a></h4>
<p>ES6 引入</p>
<p>const 用于声明常量（常量声明后，不能再进行赋值，否则抛出异常）：</p>
<pre><code class="language-js">const Pi = 3.14; // variable Pi is set 
Pi = 1; // will throw an error because you cannot change a constant variable.
</code></pre>
<h4 id="var-1"><a class="header" href="#var-1">var</a></h4>
<p>var 是 JavaScript 中最常见的变量声明关键字。</p>
<p>An example of scope with a variable declared with <strong><code>var</code>:</strong></p>
<pre><code class="language-js">// myVarVariable *is* visible out here

for (var myVarVariable = 0; myVarVariable &lt; 5; myVarVariable++) { 
  // myVarVariable is visible to the whole function 
} 

// myVarVariable *is* visible out here 

function fn(){
    var a = 1;
    console.log(a); // 1
}
console.log(a); // Uncaught ReferenceError: a is not defined
</code></pre>
<p>从上面可以看出，function 可以对 var 进行封装。</p>
<p>上面这种现象的解释：</p>
<blockquote>
<p>An important difference between JavaScript and other languages like Java is that in JavaScript, blocks do not have scope; only functions have a scope. So if a variable is defined using <code>var</code> in a compound statement (for example inside an <code>if</code> control structure), it will be visible to the entire function. However, starting with ECMAScript 2015, <code>let</code> and <code>const</code> declarations allow you to create block-scoped variables.</p>
</blockquote>
<p>正确的做法：</p>
<pre><code class="language-js">for (let myVarVariable = 0; myVarVariable &lt; 5; myVarVariable++) { 
  // myVarVariable is local to this block 
} 
</code></pre>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<h4 id="数值运算符"><a class="header" href="#数值运算符">数值运算符</a></h4>
<pre><code class="language-js">var x = 5;
x += 5;
x = x + 5; 
x ++;
x --;
'hello' + ' world'; // &quot;hello world&quot;
</code></pre>
<p>number 类型和 string 类型相加，number 类型会转成 string 类型</p>
<pre><code class="language-js">'3' + 4 + 5;  // &quot;345&quot;
3 + 4 + '5'; // &quot;75&quot;

3.14 + 's'; // 3.14s
</code></pre>
<h4 id="布尔运算符"><a class="header" href="#布尔运算符">布尔运算符</a></h4>
<p>比较运算符：<code>&gt;, &lt;, &gt;=, &lt;=, ==, ===, !=, !==</code></p>
<p><strong>强制类型转换的坑</strong> </p>
<p>字符和数字进行比较，字符先转成数字！</p>
<p>布尔值与其他对象进行比较，先将布尔值转成数字！</p>
<pre><code class="language-js">123 == '123'; // true
1 == true; // true

123 != '123' // false
1 != true // false
</code></pre>
<p>为了避免强制类型转换导致的意外，改用 <code>===</code> 进行比较：</p>
<pre><code class="language-js">123 === '123'; // false
1 === true;    // false

123 !== '123'; // true
1 !== true;    // true
</code></pre>
<h4 id="位运算符-1"><a class="header" href="#位运算符-1">位运算符</a></h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">[bitwise operations]</a></p>
<h3 id="control-structures"><a class="header" href="#control-structures">Control structures</a></h3>
<h4 id="if-for-while-of-in-switch-case"><a class="header" href="#if-for-while-of-in-switch-case">if, for, while, of, in, switch case</a></h4>
<p>JavaScript 兼容 C 语言的 if, while, for 等语法结构，同时还有自己独特的语法结构：</p>
<pre><code class="language-js">for (let value of array) {
  // do something with value
}

for (let property in object) {
  // do something with object property
}
</code></pre>
<h4 id="-3"><a class="header" href="#-3">|| &amp;&amp;</a></h4>
<p>JavaScript 中的 || 和 &amp;&amp; 是惰性求值，其会先检查操作符的前一部分，如果不符合要求，那么后一部分就不会执行运算检查。</p>
<p>The <code>&amp;&amp;</code> and <code>||</code> operators use short-circuit logic, which means whether they will execute their second operand is dependent on the first. This is useful for <strong>checking for null objects</strong> before accessing their attributes:</p>
<pre><code class="language-js">var name = o &amp;&amp; o.getName();
</code></pre>
<p>Or for caching values (when falsy values are invalid):</p>
<pre><code class="language-js">var name = cachedName || (cachedName = getName()); // 妙啊
</code></pre>
<p>python 和 JavaScript 比较：</p>
<p>不同点：JavaScript 的 || 对应 Python 的 or</p>
<p>相同点：| 和 &amp;  都是位运算</p>
<pre><code class="language-javascript">// The AND operator preserves non-Boolean values and returns them as they are
result = '' &amp;&amp; 'foo';  // result is assigned &quot;&quot; (empty string)
result = 2 &amp;&amp; 0;       // result is assigned 0
result = 'foo' &amp;&amp; 4;   // result is assigned 4
</code></pre>
<h4 id="三目运算符-1"><a class="header" href="#三目运算符-1">三目运算符</a></h4>
<pre><code class="language-js">var allowed = (age &gt; 18) ? 'yes' : 'no';
</code></pre>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<ol>
<li>
<p>JavaScript 中的任何元素都是对象！</p>
</li>
<li>
<p>JavaScript 中的对象都是键值对集合</p>
</li>
<li>
<p>JavaScript 的执行效率非常快！</p>
<p>1, 2 —&gt; 3</p>
</li>
</ol>
<h4 id="创建空对象的两种方式"><a class="header" href="#创建空对象的两种方式">创建空对象的两种方式</a></h4>
<pre><code class="language-js">var obj = new Object();
</code></pre>
<p>And:</p>
<pre><code class="language-js">var obj = {};
</code></pre>
<h4 id="获取对象属性的两种方式"><a class="header" href="#获取对象属性的两种方式">获取对象属性的两种方式</a></h4>
<pre><code class="language-js">var obj = {
  name: 'Carrot',
  for: 'Max', // 'for' is a reserved word, use '_for' instead.
  details: {
    color: 'orange',
    size: 12
  }
};

// chained together
obj.details.color;
obj['details']['size']
</code></pre>
<h4 id="用函数的方法创建类"><a class="header" href="#用函数的方法创建类">用函数的方法创建类</a></h4>
<pre><code class="language-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Define an object
var you = new Person('You', 24); 
// We are creating a new person named &quot;You&quot; aged 24.

you.name;
you['name'];

// can use a variable to define a key
var love = prompt('what is your key?');
you[love] = prompt('what is its value?')

you.for = 'Simon'; // Syntax error, because 'for' is a reserved word
you['for'] = 'Simon'; // works fine
</code></pre>
<h3 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h3>
<p>Array 是一个特殊的 Object。</p>
<pre><code class="language-js">var a = new Array();
a[0] = 'dog';
a[1] = 'cat';
a[2] = 'hen';
a.length; // 3

// 等价于
var a = ['dog', 'cat', 'hen'];
a.length; // 3
</code></pre>
<h4 id="arraylength"><a class="header" href="#arraylength">array.length</a></h4>
<p>注意，array.length 获取到的并不是 array 里面元素的个数，而是 array 的长度：</p>
<pre><code class="language-js">var a = ['dog', 'cat', 'hen'];
a[100] = 'fox';
a.length; // 101 the length of the array is one more than the highest index.
</code></pre>
<h4 id="for-foreach-for-of"><a class="header" href="#for-foreach-for-of">for, forEach, for of</a></h4>
<p>遍历 array：</p>
<pre><code class="language-js">for (var i = 0; i &lt; a.length; i++) {
  // Do something with a[i]
}

// ES6 引入
for (const currentValue of a) {
  // Do something with currentValue
}

// ES5 引入
['dog', 'cat', 'hen'].forEach(function(currentValue, index, array) {
  // Do something with currentValue or array[index]
});
</code></pre>
<h4 id="增删改查"><a class="header" href="#增删改查">增删改查</a></h4>
<p>Arrays come with a number of methods. See also the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">full documentation for array methods</a>.</p>
<table><thead><tr><th style="text-align: left">Method name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>a.toString()</code></td><td style="text-align: left">Returns a string with the <code>toString()</code> of each element separated by commas.</td></tr>
<tr><td style="text-align: left"><code>a.toLocaleString()</code></td><td style="text-align: left">Returns a string with the <code>toLocaleString()</code> of each element separated by commas.</td></tr>
<tr><td style="text-align: left"><code>a.concat(item1[, item2[, ...[, itemN]]])</code></td><td style="text-align: left">Returns a new array with the items added on to it.</td></tr>
<tr><td style="text-align: left"><code>a.join(sep)</code></td><td style="text-align: left">Converts the array to a string — with values delimited by the <code>sep</code> param</td></tr>
<tr><td style="text-align: left"><code>a.pop()</code></td><td style="text-align: left">Removes and returns the last item.</td></tr>
<tr><td style="text-align: left"><code>a.push(item1, ..., itemN)</code></td><td style="text-align: left">Appends items to the end of the array.</td></tr>
<tr><td style="text-align: left"><code>a.shift()</code></td><td style="text-align: left">Removes and returns the first item.</td></tr>
<tr><td style="text-align: left"><code>a.unshift(item1[, item2[, ...[, itemN]]])</code></td><td style="text-align: left">Prepends items to the start of the array.</td></tr>
<tr><td style="text-align: left"><code>a.slice(start[, end])</code></td><td style="text-align: left">Returns a sub-array.</td></tr>
<tr><td style="text-align: left"><code>a.sort([cmpfn])</code></td><td style="text-align: left">Takes an optional comparison function.</td></tr>
<tr><td style="text-align: left"><code>a.splice(start, delcount[, item1[, ...[, itemN]]])</code></td><td style="text-align: left">Lets you modify an array by deleting a section and replacing it with more items.</td></tr>
<tr><td style="text-align: left"><code>a.reverse()</code></td><td style="text-align: left">Reverses the array.</td></tr>
</tbody></table>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>JavaScript 中的函数也是对象！</p>
<p>JavaScript 的函数就是 class</p>
<p>如果函数没有返回值，JavaScript 默认返回 <code>undefined</code>。</p>
<h4 id="传参"><a class="header" href="#传参">传参</a></h4>
<p>JavaScript 允许传入 0 参数，或者传入超过定义数量的参数：</p>
<pre><code class="language-js">function add(x, y) {
  var total = x + y;
  return total;
}

add(); // NaN
// You can't perform addition on undefined

add(2, 3, 4); // 5
// added the first two; 4 was ignored
</code></pre>
<h4 id="arguments--args"><a class="header" href="#arguments--args">arguments / ...args</a></h4>
<p>JavaScript 的函数中，有一个array-like 的 <code>arguments</code> 变量，可以直接访问，里面存储了传入函数的所有参数</p>
<pre><code class="language-js">function add() {
  var sum = 0;
  for (var i = 0, j = arguments.length; i &lt; j; i++) {
    sum += arguments[i];
  }
  return sum;
}

add(2, 3, 4, 5); // 14
</code></pre>
<p>利用 <code>...args</code> 的 mini 版本：</p>
<pre><code class="language-js">function avg(...args) {
  var sum = 0;
  for (let value of args) {
    sum += value;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5
// 等价于
avg.apply(null, [2, 3, 4, 5]); // 3.5  avg 对象化 function 是第一公民？
</code></pre>
<p>JavaScript 的 <code>...args</code> 与 Python 的 <code>*args</code> 机制相同，都可以将存储剩下来的参数。</p>
<h4 id="anonymous-functions-1"><a class="header" href="#anonymous-functions-1">anonymous functions</a></h4>
<p>创建匿名函数并赋值给一个变量：</p>
<pre><code class="language-js">var avg = function() {
  var sum = 0;
  for (var i = 0, j = arguments.length; i &lt; j; i++) {
    sum += arguments[i];
  }
  return sum / arguments.length;
};
</code></pre>
<p>匿名函数立即执行：</p>
<pre><code class="language-js">var a = 1;
var b = 2;

(function() {
  var b = 3;
  a += b;
})();

a; // 4
b; // 2
</code></pre>
<pre><code class="language-js">var charsInBody = (function counter(elm) {
  if (elm.nodeType == 3) { // TEXT_NODE
    return elm.nodeValue.length;
  }
  var count = 0;
  for (var i = 0, child; child = elm.childNodes[i]; i++) {
    count += counter(child);
  }
  return count;
})(document.body); // 最后的 (document.body) 是指创建完匿名函数后，立刻执行该匿名函数，传入的参数是 docu…
</code></pre>
<p>The name provided to a function expression as above is only available to the function's own scope. This allows more optimizations to be done by the engine and results in more readable code. The name also shows up in the debugger and some stack traces, which can save you time when debugging.</p>
<h3 id="javascript-面向对象的实现机制"><a class="header" href="#javascript-面向对象的实现机制">JavaScript 面向对象的实现机制</a></h3>
<p>JavaScript 通过函数来定义类，类就是函数！</p>
<p>JavaScript 采用 object prototypes（<strong>对象原型</strong>）来实现面向对象的机制，而不是 class。</p>
<p>JavaScript uses functions as classes.</p>
<h4 id="prototype-based-programming"><a class="header" href="#prototype-based-programming">Prototype-based programming</a></h4>
<p><strong>Prototype-based programming</strong> is a style of <a href="https://developer.mozilla.org/en-US/docs/Glossary/OOP">object-oriented programming</a> in which <a href="https://developer.mozilla.org/en-US/docs/Glossary/Class">classes</a> are not explicitly defined, but rather derived by adding properties and methods to an instance of another class or, less frequently, adding them to an empty object.</p>
<p>In simple words: <strong>this type of style allows the creation of an <a href="https://developer.mozilla.org/en-US/docs/Glossary/Object">object</a> without first defining its <a href="https://developer.mozilla.org/en-US/docs/Glossary/Class">class</a>.</strong></p>
<h4 id="ugly-design"><a class="header" href="#ugly-design">ugly design</a></h4>
<pre><code class="language-js">function makePerson(first, last) {
  return {
    first: first,
    last: last
  };
}
function personFullName(person) {
  return person.first + ' ' + person.last;
}
function personFullNameReversed(person) {
  return person.last + ', ' + person.first;
}

var s = makePerson('Simon', 'Willison');
personFullName(s); // &quot;Simon Willison&quot;
personFullNameReversed(s); // &quot;Willison, Simon&quot;
</code></pre>
<h4 id="good-design"><a class="header" href="#good-design">good design</a></h4>
<pre><code class="language-js">function makePerson(first, last) {
  return {
    first: first,
    last: last,
    fullName: function() {
      return this.first + ' ' + this.last;
    },
    fullNameReversed: function() {
      return this.last + ', ' + this.first;
    }
  };
}

var s = makePerson('Simon', 'Willison');
s.fullName(); // &quot;Simon Willison&quot;
s.fullNameReversed(); // &quot;Willison, Simon&quot;
</code></pre>
<p>Note on the <code>this</code> keyword. Used inside a function, <code>this</code> refers to the current object. </p>
<h4 id="this-new"><a class="header" href="#this-new">this, new</a></h4>
<pre><code class="language-js">function Person(first, last) {
  this.first = first;
  this.last = last;
  this.fullName = function() {
    return this.first + ' ' + this.last;
  };
  this.fullNameReversed = function() {
    return this.last + ', ' + this.first;
  };
}
var s = new Person('Simon', 'Willison');
</code></pre>
<h4 id="better-design"><a class="header" href="#better-design">better design</a></h4>
<p>Our person objects are getting better, but there are still some ugly edges to them. Every time we create a person object we are creating two brand new function objects within it — wouldn't it be better if this code was shared?</p>
<pre><code class="language-js">function personFullName() {
  return this.first + ' ' + this.last;
}
function personFullNameReversed() {
  return this.last + ', ' + this.first;
}
function Person(first, last) {
  this.first = first;
  this.last = last;
  this.fullName = personFullName;
  this.fullNameReversed = personFullNameReversed;
}
</code></pre>
<h4 id="better-better-design-prototype"><a class="header" href="#better-better-design-prototype">better better design: prototype</a></h4>
<p>That's better: we are creating the method functions only once, and assigning references to them inside the constructor. Can we do any better than that? The answer is yes:</p>
<pre><code class="language-js">function Person(first, last) {
  this.first = first;
  this.last = last;
}
Person.prototype.fullName = function() {
  return this.first + ' ' + this.last;
};
Person.prototype.fullNameReversed = function() {
  return this.last + ', ' + this.first;
};
</code></pre>
<p>This is an incredibly powerful tool. JavaScript lets you <strong>modify something's prototype at any time in your program</strong>, which means you can add extra methods to existing objects at runtime:</p>
<pre><code class="language-js">var s = new Person('Simon', 'Willison');
s.firstNameCaps(); // TypeError on line 1: s.firstNameCaps is not a function

Person.prototype.firstNameCaps = function() {
  return this.first.toUpperCase();
};
s.firstNameCaps(); // &quot;SIMON&quot;
</code></pre>
<p>Interestingly, you can also <strong>add things to the prototype of built-in JavaScript objects</strong>. Let's add a method to <code>String</code> that returns that string in reverse:</p>
<pre><code class="language-js">var s = 'Simon';
s.reversed(); // TypeError on line 1: s.reversed is not a function

String.prototype.reversed = function() {
  var r = '';
  for (var i = this.length - 1; i &gt;= 0; i--) {
    r += this[i];
  }
  return r;
};

s.reversed(); // nomiS
</code></pre>
<p>重写 <code>toString()</code> 方法：</p>
<pre><code class="language-js">var s = new Person('Simon', 'Willison');
s.toString(); // [object Object]

Person.prototype.toString = function() {
  return '&lt;Person: ' + this.fullName() + '&gt;';
}

s.toString(); // &quot;&lt;Person: Simon Willison&gt;&quot;
</code></pre>
<h3 id="inner-functions"><a class="header" href="#inner-functions">Inner functions</a></h3>
<h4 id="内部函数变量作用域"><a class="header" href="#内部函数变量作用域">内部函数变量作用域</a></h4>
<p>函数的函数，内部函数可以访问父函数的作用域内的变量。</p>
<pre><code class="language-js">function parentFunc() {
  var a = 1;

  function nestedFunc() {
    var b = 4; // parentFunc can't use this
    return a + b; 
  }
  return nestedFunc(); // 5
}
</code></pre>
<h4 id="内部函数的使用场景"><a class="header" href="#内部函数的使用场景">内部函数的使用场景</a></h4>
<p>This provides a great deal of utility in writing more maintainable code. If a called function relies on one or two other functions that are not useful to any other part of your code, you can nest those utility functions inside it. This keeps the number of functions that are in the global scope down, which is always a good thing.</p>
<p>This is also a great counter to the lure of global variables. When writing complex code it is often tempting to use global variables to share values between multiple functions — which leads to code that is hard to maintain. Nested functions can share variables in their parent, so you can use that mechanism to couple functions together when it makes sense without polluting your global namespace — &quot;local globals&quot; if you like. This technique should be used with caution, but it's a useful ability to have.</p>
<h4 id="闭包"><a class="header" href="#闭包">闭包</a></h4>
<pre><code class="language-js">function makeAdder(a) {
  return function(b) {
    return a + b;
  };
}
var add5 = makeAdder(5);
var add20 = makeAdder(20);
add5(6); // 11
add20(7); // 27
</code></pre>
<p>A <strong>closure</strong> is the combination of a function and the scope object in which it was created. Closures let you save state — as such, they can often be used in place of objects. You can find <a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">several excellent introductions to closures</a>.</p>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">[Mozilla JavaScript Doc]</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">[Introduction to Object-Oriented JavaScript]</a></p>
<p><a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">[Several excellent introductions to closures]</a></p>
<p><a href="https://www.tinyblog.dev/blog/2020-07-13-javascript-roro-pattern/">如何改善函数的可读性</a></p>
<h2 id="js-history"><a class="header" href="#js-history">JS History</a></h2>
<ul>
<li><a href="https://www.swyx.io/writing/js-third-age/">[JS-Third-Age]</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3386327">[JavaScript: The First 20 Years]</a> 2020-06 出版，作者：Allen Wirfs-Brock (editor of ES6)，Brendan Eich</li>
</ul>
<p><img src="computer-science-notebook/front-end/assets/image-20200917150355760.png" alt="image-20200917150355760" /></p>
<h2 id="es5-新特性"><a class="header" href="#es5-新特性">ES5 新特性</a></h2>
<h3 id="use-strict"><a class="header" href="#use-strict">use strict</a></h3>
<pre><code class="language-JavaScript">// 严格模式下你不能使用未声明的变量
&quot;use strict&quot;;
x = 3.14;       // 报错 (x 未定义)

function myFunction() {
   &quot;use strict&quot;;
    y = 3.14;   // 报错 (y 未定义)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-102"><a class="header" href="#javascript-102">javascript 102</a></h1>
<p>[TOC]</p>
<h2 id="单线程和-event-loop"><a class="header" href="#单线程和-event-loop">单线程和 event-loop</a></h2>
<p>http://www.ruanyifeng.com/blog/2014/10/event-loop.html</p>
<p>javascript 是单线程，不可以在程序中写多线程。</p>
<p>JavaScript 把异步的任务，单独管理，如果异步任务完成，则往任务队列中添加一个事件。JavaScript 执行完所有同步任务后，就会去执行任务队列中的异步任务。</p>
<h2 id="模块化编程"><a class="header" href="#模块化编程">模块化编程</a></h2>
<p>ES5 https://www.liaoxuefeng.com/wiki/1022910821149312/1023027697415616</p>
<h2 id="es6"><a class="header" href="#es6">ES6</a></h2>
<h3 id="解构赋值"><a class="header" href="#解构赋值">解构赋值</a></h3>
<pre><code class="language-javascript">let point={x: 1, y: 3, z: 5};
const {x, y} = point; 
console.log(x);
</code></pre>
<h3 id="backtick-反引号"><a class="header" href="#backtick-反引号">backtick 反引号</a></h3>
<h3 id="块级作用域"><a class="header" href="#块级作用域">块级作用域</a></h3>
<p><strong>块语句</strong>（或其他语言的<strong>复合语句</strong>）用于组合零个或多个语句。该块由一对大括号界定。只要出现大括号，就是一个块级作用域。</p>
<p><code>let</code> 和 <code>const</code> 声明的变量，其作用域只局限于其所处的块级作用域。</p>
<pre><code class="language-js">const c = 1;
{
  const c = 2;
}
console.log(c); // 输出1, 而且不会报错
</code></pre>
<p>注意，位于块范围之内的 <code>const c = 2</code> 并不会抛出<code>SyntaxError: Identifier 'c' has already been declared</code>这样的语法错误，因为在它自己的块中它可能是唯一一个被声明的常量。</p>
<pre><code class="language-js">var a = [];
for (var i = 0; i &lt; 10; i++) {
      a[i] = function () {console.log(i);};
}
a[0]();                // 10
a[1]();                // 10
a[6]();                // 10

/********************/

var a = [];
for (let i = 0; i &lt; 10; i++) {
      a[i] = function () {console.log(i);};
}
a[0]();                // 0
a[1]();                // 1
a[6]();                // 6
</code></pre>
<h3 id="let-const-var"><a class="header" href="#let-const-var">let, const, var</a></h3>
<p>var 声明的变量，其作用域是函数内，其存在变量提升现象；let 声明的变量，其作用域是代码块内，不存在变量提升现象。</p>
<p>在程序和方法的最顶端，**<code>let</code><strong>不像 <strong><code>var</code></strong> 一样，</strong><code>let</code>**不会在全局对象里新建一个属性。比如：</p>
<p>位于函数或代码顶部的**<code>var</code><strong>声明会给全局对象新增属性, 而</strong><code>let</code>**不会。例如:</p>
<pre><code>var x = 'global';
let y = 'global';
console.log(this.x); // &quot;global&quot;
console.log(this.y); // undefined
</code></pre>
<p>let 和 const 唯一的区别，就是 const 用来表示常量，let 用来表示变量</p>
<h3 id="export"><a class="header" href="#export">export</a></h3>
<p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</p>
<p>多行暴露</p>
<pre><code class="language-javascript">//a.js
export function aa1(){
    console.log('分别导出1');
}
export function aa2(){
    console.log('分别导出2');
}

//index.js
//解构赋值
import { aa1 , aa2 } from 'a.js'

</code></pre>
<p>统一暴露</p>
<pre><code class="language-javascript">//b.js
function bb1(){
    console.log('综合导出1');
}
function bb2(){
    console.log('综合导出2');
}
export {bb1,bb2}


//index.js
//解构赋值
import {aa1,aa2} from 'b.js'
</code></pre>
<p>默认暴露</p>
<p>默认暴露只能暴露一次。</p>
<pre><code class="language-javascript">//c.js
export default function cc(){
    console.log('默认导出');
}

//index.js
//使用自定义变量
import c from 'c.js'
c.cc()
</code></pre>
<h2 id="window-对象"><a class="header" href="#window-对象">window 对象</a></h2>
<p>所有浏览器都支持 window 对象。它表示浏览器窗口。</p>
<p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p>
<p>全局变量是 window 对象的属性。</p>
<p>全局函数是 window 对象的方法。</p>
<p>甚至 HTML DOM 的 document 也是 window 对象的属性之一：</p>
<p><code>window.document.getElementById(&quot;header&quot;);</code></p>
<p>与此相同：</p>
<p><code>document.getElementById(&quot;header&quot;);</code></p>
<h2 id="js-边学边记"><a class="header" href="#js-边学边记">JS 边学边记</a></h2>
<ul>
<li>语句可以不加分号，VUE 的源码就不带分号</li>
<li>window 对象</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-兼容-ie11"><a class="header" href="#javascript-兼容-ie11">javascript 兼容 IE11</a></h1>
<p>IE 11 只兼容到 ES5。</p>
<h2 id="ie11-不兼容的特性"><a class="header" href="#ie11-不兼容的特性">IE11 不兼容的特性</a></h2>
<ul>
<li>let</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>简化对象的写法</li>
<li>箭头函数 =&gt; 改成 function</li>
<li><em><code>Array.prototype.find()</code></em> 不兼容</li>
<li>Map, Set</li>
<li>class</li>
<li>Object.values</li>
<li>Object.entries</li>
<li>Array.prototype.includes</li>
<li>for of</li>
<li>Array.fill</li>
<li>Object.assign</li>
<li>String.prototype.replaceAll()</li>
</ul>
<h2 id="ie11-兼容的特性"><a class="header" href="#ie11-兼容的特性">IE11 兼容的特性</a></h2>
<p>注意，以下特性 IE11（ES5）都支持</p>
<ul>
<li>forEach</li>
<li>map, filter</li>
<li>key in Object</li>
<li>Object.keys({})</li>
<li>const</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutablejs"><a class="header" href="#immutablejs">immutable.js</a></h1>
<p>https://github.com/camsong/blog/issues/3</p>
<p>https://segmentfault.com/a/1190000010676878</p>
<h2 id="api"><a class="header" href="#api">api</a></h2>
<pre><code class="language-javascript">// 将一个 js 数据转为 immutable 类型的数据
fromJS()

// 将一个 Immutable 数据转换为 JS 类型的数据。
toJs()

// 值比较（递归比较）
is()

// 新建一个 immutable 类型的 list map
List()
Map()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-库"><a class="header" href="#npm-库">npm 库</a></h1>
<p>[toc]</p>
<h2 id="库"><a class="header" href="#库">库</a></h2>
<h3 id="create-react-app"><a class="header" href="#create-react-app">create-react-app</a></h3>
<p>react 脚手架</p>
<h3 id="lodash"><a class="header" href="#lodash">lodash</a></h3>
<p>Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。</p>
<pre><code class="language-javascript">import '_' from 'lodash';
// 深拷贝
let data = _.cloneDeep(this.state.data);
</code></pre>
<h3 id="dayjs"><a class="header" href="#dayjs">dayjs</a></h3>
<p>时间处理的库。</p>
<h3 id="momentjs"><a class="header" href="#momentjs">moment.js</a></h3>
<p>和 dayjs 一样，是时间处理的库。</p>
<h2 id="功能"><a class="header" href="#功能">功能</a></h2>
<h3 id="代码格式化并在前端高亮展示"><a class="header" href="#代码格式化并在前端高亮展示">代码格式化并在前端高亮展示</a></h3>
<p>代码格式化：<a href="https://github.com/sql-formatter-org/sql-formatter">sql-formatter</a></p>
<p>前端高亮展示：<a href="https://highlightjs.org/">highlight.js</a></p>
<p>在 react 中引入 highlight.js：<a href="https://juejin.cn/post/6969131238493782046">在各种环境中使用 hightlight.js</a></p>
<p>react 中使用 highlight.js 会有如下警告，目前尚未解决：</p>
<pre><code>One of your code blocks includes unescaped HTML. This is a potentially serious security risk.
</code></pre>
<h2 id="cdn"><a class="header" href="#cdn">CDN</a></h2>
<h3 id="cdnjs"><a class="header" href="#cdnjs">cdnjs</a></h3>
<p>https://cdnjs.com/</p>
<h3 id="unpkg"><a class="header" href="#unpkg">unpkg</a></h3>
<p>https://unpkg.com/</p>
<p>unpkg.com/:package@:version/:file</p>
<p>例如，查找 dayjs 的 js 库和插件库，可以来到这个文件夹内：https://unpkg.com/browse/dayjs@1.11.0/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html--css--dom"><a class="header" href="#html--css--dom">HTML &amp; CSS &amp; DOM</a></h1>
<p>[TOC]</p>
<p>HTML 和 CSS 是前端解耦的产物。HTML 负责展示的内容（文本和标签），CSS 负责展示的效果。</p>
<p>网上各种花里胡哨的网页，其本质上还是 HTML 标签加上 CSS 样式做出来的。HTML 是网页显示基础，花里胡哨是 CSS 的功劳。</p>
<h2 id="html"><a class="header" href="#html">HTML</a></h2>
<h3 id="introduction-11"><a class="header" href="#introduction-11">Introduction</a></h3>
<ol>
<li>
<p>HTML 代码由标记组成，代码不区分大小写</p>
</li>
<li>
<p>HTML 代码的标准格式</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;&lt;/head&gt; &lt;!--head部分中放一些初始化和配置信息，head 中的内容会先加载--&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>HTML 标签就是一个<strong>容器</strong>，对容器中的内容进行操作，实际上就是在改变容器的属性值。</p>
</li>
<li>
<p>特殊字符的格式: <code>&amp;name;</code></p>
</li>
</ol>
<p>html 由 html 标签，标签属性构成。</p>
<h3 id="常见标签"><a class="header" href="#常见标签">常见标签</a></h3>
<p>所有标签：https://www.w3school.com.cn/tags/index.asp</p>
<table><thead><tr><th>mark</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>&lt;li&gt; &lt;/li&gt;</code></td><td>无序列表</td></tr>
<tr><td><code>&lt;br/&gt;</code></td><td>换行</td></tr>
<tr><td><code>&lt;h1&gt; &lt;/h1&gt;1,2,3,4,5,6</code></td><td>标题</td></tr>
<tr><td><code>&amp;nbsp;</code></td><td>空格</td></tr>
<tr><td><code>&lt;!-- --&gt;</code></td><td>注释</td></tr>
<tr><td><code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code></td><td>超链接标签，用来链接资源，href 的值的不同，解析方式也不同，可以解析 url, Email, file 资源(文本，图片),</td></tr>
<tr><td><code>&lt;iframe src=&quot;http://www.xxx.xx.com/1.js&quot;&gt; &lt;/iframe&gt;</code></td><td>画中画标签</td></tr>
<tr><td><code>&lt;form&gt;&lt;/form&gt;</code></td><td>用于创建供用户输入的 HTML 表单。实际上是一个<strong>表单容器</strong>form 标签包含一个或多个如下的表单: <code>&lt;input&gt;</code>, <code>textarea</code>,<code>button</code>,<code>select</code>, <code>option</code>, <code>optgroup</code>, <code>fieldset</code>, <code>label</code></td></tr>
<tr><td><code>&lt;textarea&gt;</code></td><td>一个大的 input</td></tr>
<tr><td><code>&lt;select&gt;</code></td><td>下拉选项</td></tr>
<tr><td><code>&lt;div&gt;</code></td><td>用来封装整行区域(换行)</td></tr>
<tr><td><code>&lt;span&gt;</code></td><td>用来封装行内区域(不换行)</td></tr>
<tr><td><code>&lt;p&gt;</code></td><td>段落标签</td></tr>
<tr><td><code>&lt;style&gt;</code></td><td>定义样式标签</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h3 id="常见属性"><a class="header" href="#常见属性">常见属性</a></h3>
<p>下面列出了适用于大多数 HTML 标签的属性：</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">值</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">class</td><td style="text-align: left"><em>classname</em></td><td style="text-align: left">规定元素的类名（classname）</td></tr>
<tr><td style="text-align: left">id</td><td style="text-align: left"><em>id</em></td><td style="text-align: left">规定元素的唯一 id</td></tr>
<tr><td style="text-align: left">style</td><td style="text-align: left"><em>style_definition</em></td><td style="text-align: left">规定元素的行内样式（inline style）</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left"><em>text</em></td><td style="text-align: left">规定元素的额外信息（可在工具提示中显示）</td></tr>
</tbody></table>
<h3 id="标签的分类"><a class="header" href="#标签的分类">标签的分类</a></h3>
<ol>
<li>
<p>块级标签（元素）</p>
<p>标签结束后都有换行</p>
</li>
<li>
<p>行内标签（元素）</p>
<p>标签结束后无换行</p>
</li>
</ol>
<h3 id="超链接标签详解"><a class="header" href="#超链接标签详解">超链接标签详解</a></h3>
<p>超链接标签的作用：链接资源（注意其并不只是用来链接到其他网页）</p>
<p>超链接标签当有了 href 属性，才会有点击效果；</p>
<p>href 属性中协议的不同，其解析方式也不同</p>
<p><strong>href 协议</strong></p>
<pre><code class="language-html">&lt;!--http协议，表示链接到网址--&gt;
&lt;a href=&quot;http://www.sohu.com.cn&quot; target=&quot;_blank&quot;&gt;新浪网站&lt;/a&gt; 

&lt;!--图片协议，表示链接到图片--&gt;
&lt;a href=&quot;imgs/1.jpg&quot;&gt;美女图片&lt;/a&gt;

&lt;!--邮箱协议，表示链接到邮箱--&gt;
&lt;a href=&quot;mailto:abs@sina.com&quot;&gt;联系我们&lt;/a&gt;

&lt;!--迅雷协议，表示链接到迅雷--&gt;
&lt;a href=&quot;thunder://wertyuioasdfghjklwertyuio==&quot;&gt;复仇者联盟&lt;/a&gt;

&lt;!--自定义超链接点击效果--&gt;
&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;alert('我弹')&quot;&gt;这是一个超链接&lt;/a&gt;
</code></pre>
<p><strong>取消超链接效果</strong></p>
<pre><code class="language-html">&lt;a href=&quot;javascript:void(0)&quot;&gt;这是一个超链接&lt;/a&gt;
</code></pre>
<p><strong>利用超链接实现锚</strong></p>
<pre><code class="language-html">&lt;a name=top&gt;顶部位置&lt;/a&gt;
&lt;hr/&gt;
&lt;img src=&quot;111.jpg&quot; height=900 width=400 border=10/&gt;
&lt;hr/&gt;
&lt;a name=center&gt;中间位置&lt;/a&gt;
&lt;hr/&gt;
&lt;img src=&quot;111.jpg&quot; height=900 width=400 border=10/&gt;
&lt;a href=&quot;#top&quot;&gt;回到顶部位置&lt;/a&gt;
&lt;a href=&quot;#center&quot;&gt;回到中间位置&lt;/a&gt;
</code></pre>
<h3 id="表单详解"><a class="header" href="#表单详解">表单详解</a></h3>
<pre><code class="language-html">&lt;!--
如果要给服务端提交数据，表单中的组件必须有name和value属性。
否则服务器不知道这些标签中的值究竟是什么
--&gt;
&lt;form&gt;
	输入名称： &lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot; /&gt;&lt;br/&gt;
	输入密码： &lt;input type=&quot;password&quot; name=&quot;psw&quot; /&gt;&lt;br/&gt;
	选择性别： &lt;!--单选，必须放在一个组里，name 是一样的--&gt;
	&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;nan&quot; /&gt;男
	&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;nv&quot; checked=&quot;checked&quot; /&gt;女
	&lt;br/&gt;
	选择技术： &lt;!--复选--&gt;
	&lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;java&quot;/&gt;JAVA
	&lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;html&quot;/&gt;HTML
	&lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;css&quot;/&gt;CSS
    &lt;BR/&gt;
    选择文件： 
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;br/&gt;
    一个图片： &lt;!--图片具备 submit button 的功能，可以替代 submit--&gt;
    &lt;input type=&quot;image&quot; src=&quot;11.jpg&quot;/&gt;
    &lt;br/&gt;
    隐藏组件： &lt;!--数据不需要客户端知道，但是可以将其提交服务端。 --&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;myke&quot; value=&quot;myvalue&quot;/&gt;&lt;br/&gt;
    一个按钮： 
    &lt;input type=&quot;button&quot; value=&quot;有个按钮&quot; onclick=&quot;alert('有个阿牛')&quot;/&gt;
    &lt;br/&gt;
    &lt;select name=&quot;country&quot;&gt;
        &lt;option value=&quot;none&quot;&gt;--选择国家--&lt;/option&gt;
        &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt;
        &lt;option value=&quot;en&quot;&gt;英国&lt;/option&gt;
        &lt;option value=&quot;cn&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt;
    &lt;/select&gt;
    &lt;textarea name=&quot;text&quot;&gt;&lt;/textarea&gt;
    &lt;br/&gt;
    &lt;!--重置表单--&gt;
    &lt;input type=&quot;reset&quot; value=&quot;清除数据&quot;/&gt;
    &lt;!--提交数据--&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交数据&quot;/&gt;
&lt;/form&gt;
</code></pre>
<h2 id="css"><a class="header" href="#css">CSS</a></h2>
<p><strong>Cascading Style Sheets (层叠样式表)</strong></p>
<p>https://www.runoob.com/cssref/css-reference.htmlasp</p>
<h3 id="common-style"><a class="header" href="#common-style">Common Style</a></h3>
<table><thead><tr><th>style</th><th>Explanation</th><th>Demo</th><th>Reference</th></tr></thead><tbody>
<tr><td>padding</td><td>内边距</td><td><code>padding: 20px 20px; </code></td><td></td></tr>
<tr><td>margin</td><td>外边距</td><td><code>margin:2cm 4cm 3cm 4cm;</code></td><td><a href="http://www.w3school.com.cn/cssref/pr_margin.asp">reference </a> 上右下左（顺时针）</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h3 id="css-资源"><a class="header" href="#css-资源">CSS 资源</a></h3>
<ul>
<li><a href="https://cssfx.dev/">Clikc to Copy</a></li>
</ul>
<h3 id="css-开发技巧"><a class="header" href="#css-开发技巧">CSS 开发技巧</a></h3>
<ul>
<li>CSS 可以在 Chrome 浏览器中进行编辑，所见即所得，特别好用！</li>
<li>GitHub 上有大量的 CSS 库，当我们需要什么特效时，直接去 Github 搜索即可，然后导入即可用</li>
<li>正常开发时，通常是需要什么特效，就去 Github 上找相应的 CSS 类库，然后加载进来直接使用即可</li>
</ul>
<h3 id="css-代码格式"><a class="header" href="#css-代码格式">CSS 代码格式</a></h3>
<pre><code class="language-css">div /*选择器名称*/
{
    属性名: 属性值1 属性值2; 
    属性名: 属性值; 
    属性名: 属性值;
}
</code></pre>
<h3 id="选择器"><a class="header" href="#选择器">选择器</a></h3>
<p>选择器用于指定 css 要作用的标签，标签的名称就是选择器，意为：选择哪个容器。</p>
<p>选择器有三大类：</p>
<ol>
<li>
<p>html 标签名选择器，即选择器名称为 html 的标签名</p>
<pre><code class="language-css">div /*选择所有 &lt;div&gt; 元素。*/
{
    属性名: 属性值; 
}
</code></pre>
</li>
<li>
<p>class 选择器，即选择器名称为标签中的 class 属性值</p>
<pre><code class="language-css">.intro{ /*选择 class=&quot;intro&quot; 的所有元素。*/
    
}
</code></pre>
</li>
<li>
<p>id 选择器，即选择器名称为标签中的 id 属性</p>
<pre><code class="language-css">#firstname{ /*选择 id=&quot;firstname&quot; 的所有元素。*/
    
}
</code></pre>
</li>
</ol>
<p>每一个标签都可以定义 class 和 id 属性，用于对标签进行标识，方便对标签进行同意管理，多个标签的 class 属性值可以相同，而 id 要唯一。</p>
<h3 id="html-和-css-的两种结合方式"><a class="header" href="#html-和-css-的两种结合方式">HTML 和 CSS 的两种结合方式</a></h3>
<ol>
<li>
<p><strong>同一个文件中的样式复用 ——&gt; 将样式抽取到 head 标签中</strong></p>
<p>每个 html 标签都可以定义 style 属性，该属性的值就是 css 代码；通常用 style 标签的方式对通用的 css 进行抽取，然后定义在 head 标签中（head 最先加载）</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt; &lt;!-- text/css 表示内容是 css 代码 --&gt;
        &lt;!-- css 代码 --&gt;
        div{ &lt;!-- div 表示下列 css 样式只对 div 生效 --&gt;
            background-color: #000;
            color: #F00;
        }  
        
        div.body{ /* 为 div 标签定义一个名叫 body 的 css样式，用于类加载 */
            background-color: #000;
            color: #FFF;
        }

        .body{ /* 定义一个名叫 body 的 css样式，用于类加载 */
            background-color: #000;
            color: #FFF;
        }
        
        /*关联选择器，选择器中的选择器；空格隔开*/
        span b{ /* 定义 span 中的 b 标签的样式，选择器嵌套 */
            
        }
        
        /*组合选择器，多个标签使用同一种样式, 逗号隔开*/
        .body, span b{ /* 定义 span 中的 b 标签的样式 */
            
        }
       
        
    &lt;/style&gt; 
&lt;/head&gt;

&lt;body&gt;
    
    &lt;div style=&quot;background-color: #000; color: #F00;&quot;&gt; &lt;!-- 最直接的 css --&gt;  
    &lt;/div&gt;
    
	&lt;div class=&quot;div.body&quot;&gt; &lt;!-- 使用 div标签的类选择器来指定 css --&gt; 
    &lt;/div&gt;
    
    &lt;span class=&quot;body&quot;&gt; &lt;!-- 使用类选择器来指定 css --&gt;
        &lt;b&gt;&lt;/b&gt;
    &lt;/span&gt;

&lt;/body&gt;
</code></pre>
</li>
<li>
<p><strong>多个文件中的样式复用 ——&gt; 将样式抽取到一个单独的 css 文件中</strong></p>
<p>创建 div.css</p>
<pre><code class="language-css">@charset &quot;utf-8&quot;;

div{ /* 为 div 标签定义css样式，用于css加载 */
	background-color: #000;
    color: #FFF;
}
</code></pre>
<p>在 head 标签中通过 css 代码导入该样式</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt; /* text/css 表示内容是 css 代码 */
        @import url(div.css) /* 通过 css 代码导入*/
    &lt;/style&gt; 
&lt;/head&gt;
</code></pre>
<p>或者在 head 标签中通过 html 标签导入该样式</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;div.css&quot; type=&quot;text/css&quot; /&gt;
&lt;/head&gt;
</code></pre>
</li>
</ol>
<h3 id="css-样式优先级"><a class="header" href="#css-样式优先级">CSS 样式优先级</a></h3>
<p>css 样式可以覆盖，其优先级为：</p>
<p><strong>由上到下，由外到内，优先级由低到高。</strong></p>
<p><strong>标签选择器 &lt; 类选择器 &lt; ID 选择器 &lt; style 属性</strong></p>
<h3 id="伪元素选择器"><a class="header" href="#伪元素选择器">伪元素选择器</a></h3>
<p>预定义好的选择器，常用于定义超链接的样式</p>
<pre><code class="language-css">a:link{ /*超链接没点击之前的状态*/
    text-decoration: none; /*取消下划线*/
    color: #BABABA;
}

a:hover{ /*鼠标悬停*/   
}

a:active{ /*鼠标点击*/   
}

a:visited{ /*访问后*/   
}

p:first-letter{ /*定义段落首字母的样式*/    
}

p:first-letter{ /*定义段落首字母的样式*/    
}

input:focus{ /*定义段落首字母的样式*/    
    
}

/*注意，link, hover, first-letter 这些伪元素，对其他常用标签也起作用*/
</code></pre>
<h3 id="盒子模型"><a class="header" href="#盒子模型">盒子模型</a></h3>
<p>盒子模型：div + css，一个 div 就是一个盒子</p>
<pre><code class="language-css">.post {
  margin: 1em auto; /*外边距*/
  padding: 10px 10px; /*内边距*/
  background-color: #fff;
  border: 1px solid #ddd; /*盒子边框*/
  box-shadow: 0 0 2px #ddd;
}

.posts  {
  .post:first-child {
    margin-top: 0;
  }
  .post-title {
    font-size: 1.2em;

    .post-title-link {
      color: #368CCB;
      text-decoration: none;
    }
  }

  .post-sub-info {
    color: #BABABA;
    font-size: 0.7em;
    a {
      color: #BABABA;
      text-decoration: none;
      &amp;:hover {
        color: #368CCB;
      }
    }
  }  
}
</code></pre>
<h2 id="get--post"><a class="header" href="#get--post">GET &amp; POST</a></h2>
<p><strong>get 提交 和 post 提交 的区别</strong></p>
<pre><code>表单向服务器提交数据有两种方式：get 提交 和 post 提交
1,
    get提交，提交的信息都显示在地址栏中。
    post提交，提交的信息不显示地址栏中。
2，
    get提交，对于敏感的数据信息不安全。
    post提交，对于敏感信息安全。
3，
    get提交，对于大数据不行，因为地址栏存储体积有限。
    post提交，可以提交大体积数据。
4，
    get提交，将信息封装到了请求消息的请求行中。
    post提交，将信息封装到了请求体中。
</code></pre>
<p>综上，表单提交数据到服务器应该采用 <strong>post提交</strong></p>
<p><strong>Demo</strong></p>
<pre><code class="language-html">&lt;!--action 为服务器地址，method 定义提交方式--&gt;
&lt;form action=&quot;http://10.1.31.69:9090&quot; method=&quot;post&quot;&gt;
    &lt;!--将所有的表单放入 table 中进行格式化--&gt;
    &lt;table border=&quot;1&quot; bordercolor=&quot;#0000ff&quot; cellpadding=10 cellspacing=0 width=600&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;注册表单&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;用户名称： &lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;输入密码： &lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;password&quot; name=&quot;psw&quot; /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;确认密码： &lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;password&quot; name=&quot;repsw&quot; /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;选择性别： &lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;nan&quot; /&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;nv&quot; /&gt;女
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;选择技术： &lt;/td&gt;
            &lt;td&gt;
                &lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;java&quot; /&gt;JAVA
                &lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;html&quot; /&gt;HTML
                &lt;input type=&quot;checkbox&quot; name=&quot;tech&quot; value=&quot;css&quot; /&gt;CSS
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;选择国家： &lt;/td&gt;
            &lt;td&gt;
                &lt;select name=&quot;country&quot;&gt;
                    &lt;option value=&quot;none&quot;&gt;--选择国家--&lt;/option&gt;
                    &lt;option value=&quot;usa&quot;&gt;--美国--&lt;/option&gt;
                    &lt;option value=&quot;en&quot;&gt;--英国--&lt;/option&gt;
                    &lt;option value=&quot;cn&quot;&gt;--中国--&lt;/option&gt;
                &lt;/select&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;
                &lt;input type=&quot;reset&quot; value=&quot;清除数据&quot; /&gt;
                &lt;input type=&quot;submit&quot; value=&quot;提交数据&quot; /&gt;
            &lt;/th&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
</code></pre>
<h2 id="和服务端交互的三种方式"><a class="header" href="#和服务端交互的三种方式">和服务端交互的三种方式</a></h2>
<ol>
<li>地址栏输入 url 访问 get</li>
<li>超链接 get</li>
<li>表单 get, post</li>
</ol>
<h2 id="dom"><a class="header" href="#dom">DOM</a></h2>
<p>Document Object Model</p>
<p>HTML DOM 定义了所有 HTML 元素的<em>对象</em>和<em>属性</em>，以及访问它们的<em>方法</em>。</p>
<p>换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。</p>
<h2 id="ui-库"><a class="header" href="#ui-库">UI 库</a></h2>
<ul>
<li>bootstrap</li>
<li>layui https://layui.itze.cn/index.html</li>
<li>flat ui</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm"><a class="header" href="#wasm">wasm</a></h1>
<p>[TOC]</p>
<h2 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h2>
<p>wasm 是 web 的第四大开发技术。将其他语言的代码，编译成 wasm，然后在浏览器中执行。</p>
<p>https://www.bilibili.com/video/BV13i4y1n74s</p>
<img src="computer-science-notebook/front-end/assets/image-20220621081217549.png" alt="image-20220621081217549" style="zoom:50%;" />
<h2 id="生态"><a class="header" href="#生态">生态</a></h2>
<ul>
<li><a href="https://webassembly.org/getting-started/developers-guide/">wasm org</a></li>
<li>python -&gt; wasm: <a href="https://pyodide.org/en/stable/">Pyodide</a>, a Python distribution for the browser and Node.js based on WebAssembly.</li>
<li>python -&gt; wasm: <a href="https://pyscript.net/">PyScript</a> Run Python in Your HTML </li>
<li>C++ -&gt; wasm 的在线工具：https://mbebenita.github.io/WasmExplorer/</li>
</ul>
<h2 id="demo-7"><a class="header" href="#demo-7">demo</a></h2>
<p>计算斐波那契，f(40)，C++ 用了 200ms，JavaScript 用了 700+ms，wasm 用了 500+ms</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nlp"><a class="header" href="#nlp">NLP</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nlp-learning"><a class="header" href="#nlp-learning">NLP Learning</a></h1>
<p>[TOC]</p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<h3 id="nlpcloud"><a class="header" href="#nlpcloud">NLPCloud</a></h3>
<p><a href="https://netlabe.com/real-time-context-targeting-using-nlp-baceb4324fc4">如何用自然语言处理（NLP）推送广告？</a>（英文）</p>
<p>经过测试，只支持中文。</p>
<h3 id="openai-gpt-3-api"><a class="header" href="#openai-gpt-3-api">OpenAI GPT-3 API</a></h3>
<p><a href="https://openai.com/blog/openai-api/">OpenAI API</a></p>
<p>2020-06-11，openAi 公司发布其基于 GPT-3 模型的接口，GPT-3 是耗费上千万训练出来的顶级自然语言处理模型，包含有 1750 亿个参数。</p>
<p>该接口是，<code>Text in，Text out</code> 类型的接口，我已申请使用该接口。等有空玩一玩。</p>
<p>相关的项目：<a href="https://github.com/elyase/awesome-gpt3">awesome-gpt3</a>，<a href="https://github.com/shreyashankar/gpt3-sandbox">gpt3-sandbox</a>，<a href="https://github.com/minimaxir/gpt-3-experiments">gpt-3-experiments</a> <a href="https://www.pingwest.com/a/214772">品玩 gpt-3</a></p>
<h3 id="其他-5"><a class="header" href="#其他-5">其他</a></h3>
<p>百度云、阿里云</p>
<h2 id="学术会议"><a class="header" href="#学术会议">学术会议</a></h2>
<ul>
<li>ACL: Association for Computational Linguistics() 国际计算语言协会
<ul>
<li>AACL 亚太分会</li>
</ul>
</li>
<li>EMNLP: Empirical Methods in Natural Language Processing</li>
<li>IJCNLP: International Joint Conference on Natural Language Processing, EMNLP 和 IJCNLP 合并</li>
<li>NLPCC: Natural Language Processing and Chinese Computing</li>
</ul>
<h2 id="书籍和视频"><a class="header" href="#书籍和视频">书籍和视频</a></h2>
<ul>
<li><a href="https://web.stanford.edu/%7Ejurafsky/slp3/">Speech and Language Processing</a></li>
<li><a href="https://www.pdfdrive.com/natural-language-processing-with-pytorch-build-intelligent-language-applications-using-deep-learning-e188037921.html">Natural Language Processing with PyTorch</a></li>
<li><a href="https://www.bilibili.com/video/av13383754">Stanford NLP CS224N</a></li>
</ul>
<h2 id="会议-deadline-查看工具"><a class="header" href="#会议-deadline-查看工具">会议 Deadline 查看工具</a></h2>
<p><a href="https://aideadlin.es/?sub=ML,CV,NLP,RO,SP,DM">aideadline</a></p>
<h2 id="知识图谱与智能问答"><a class="header" href="#知识图谱与智能问答">知识图谱与智能问答</a></h2>
<p><a href="https://pan.baidu.com/s/1pxIN7KiFooyL1tUdSZFeSw">东南大学王萌</a></p>
<ol>
<li>
<p>第一阶段：TBSL 手动定义问题模板 2012</p>
<p>TBSL Template-Based Model 的两个核心贡献：</p>
<ul>
<li>Constructs a query template that directly mirrors thelinguistic structure of the question</li>
<li>Instantiates the template by matching natural language expressions with ontology concepts</li>
</ul>
<p>TBSL的模板定义为SPARQL query模板， 将其直接与自然语言相映射。</p>
</li>
<li>
<p>第二阶段：Semantic Parsing-Based Model   自动生成模板 2017</p>
<ul>
<li>提出了QUINT，能够根据utterance-answer对，根据依存树自动学习utterance-query模板</li>
<li>利用自然语言的组成特点， 可以使用从简单问题中学到的模板来解决复杂问题</li>
</ul>
</li>
</ol>
<h2 id="模型介绍"><a class="header" href="#模型介绍">模型介绍</a></h2>
<h3 id="bert-vs-gpt-3"><a class="header" href="#bert-vs-gpt-3">Bert vs GPT-3</a></h3>
<p><a href="https://mp.weixin.qq.com/s/Rm7t7YRCnJPwZ9BlkLsClg">GPT-3「全面」开放，变现模式开启！</a></p>
<p>BERT虽然是个划时代的模型，但它真正应用起来却无法避免finetune步骤，只能通过两种方式盈利：</p>
<ol>
<li>买方提需求，卖方出人力精调，赚这个需求的钱。但之后每个需求还是要付出一样的人力，边际成本不能很好递减</li>
<li>买方直接购买基模型，做一次性生意，无法持续获利</li>
</ol>
<p>以上两种方式都不够理想，使得BERT不能成为一个长期产品。而GPT-3的NB之处，就在于它的zero-shot能力，在不精调、或者利用prompt的情况下就有一定效果，显著减少了第一种模式的边际成本，可以通过卖服务长期捞金。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="machine-learning"><a class="header" href="#machine-learning">Machine-Learning</a></h1>
<p>[TOC]</p>
<h2 id="books-1"><a class="header" href="#books-1">Books</a></h2>
<ul>
<li><a href="https://github.com/deeplearning-ai/machine-learning-yearning-cn">machine-learning-yearning</a></li>
</ul>
<h2 id="算法"><a class="header" href="#算法">算法</a></h2>
<h3 id="latent-dirichlet-allocation"><a class="header" href="#latent-dirichlet-allocation">Latent Dirichlet Allocation</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Latent_Dirichlet_allocation">隐含狄利克雷分布</a>，是一种非监督的文档主题生成模型，其本质上是一个三层的贝叶斯概率图模型。</p>
<h2 id="好玩的模型"><a class="header" href="#好玩的模型">好玩的模型</a></h2>
<h3 id="deepfake"><a class="header" href="#deepfake">DeepFake</a></h3>
<ul>
<li><a href="https://github.com/anandpawara/Real_Time_Image_Animation">[慈禧的痛生成软件]</a></li>
<li><a href="https://www.deepfaker.xyz/">[deepfake中文站]</a></li>
<li><a href="https://github.com/iperov/DeepFaceLab">[DeepfaceLab]</a></li>
</ul>
<h3 id="效果爆炸的开源漫画变身-ai"><a class="header" href="#效果爆炸的开源漫画变身-ai">效果爆炸的开源漫画变身 AI</a></h3>
<p><strong>在线 Demo：</strong></p>
<p>https://huggingface.co/spaces/akhaliq/AnimeGANv2</p>
<p><strong>Colab 版本：</strong></p>
<p>https://colab.research.google.com/drive/1jCqcKekdtKzW7cxiw_bjbbfLsPh-dEds?usp=sharing#scrollTo=niSP_i7FVC3c</p>
<p><strong>GitHub 地址：</strong></p>
<p>https://github.com/TachibanaYoshino/AnimeGANv2</p>
<p>https://github.com/bryandlee/animegan2-pytorch</p>
<h2 id="keep-learning"><a class="header" href="#keep-learning">Keep Learning</a></h2>
<h3 id="pipeline-vs-end2end-流水线-vs-端到端"><a class="header" href="#pipeline-vs-end2end-流水线-vs-端到端">Pipeline vs End2End (流水线 vs 端到端)</a></h3>
<p>流水线，顾名思义，要经过一条流水线进行处理，数据从输入到输出，要经过多个模块，<strong>工业界</strong>的应用通常是流水线；</p>
<p>端到端，是只有输入输出，没有中间过程。很多神经网络算法，都是端到端的，<strong>学术届</strong>的研究通常是端到端的。</p>
<table><thead><tr><th></th><th>流水线</th><th>端到端</th></tr></thead><tbody>
<tr><td>Demo1</td><td><img src="computer-science-notebook/nlp/assets/1565605359908.png" alt="流水线" /></td><td><img src="computer-science-notebook/nlp/assets/1565605288693.png" alt="端到端" /></td></tr>
<tr><td>面向群体</td><td>工业界</td><td>学术界</td></tr>
<tr><td>优缺点</td><td>需要进行特征工程，适合小数据量的机器学习；将一个复杂的任务拆解成一个个子任务，每一个子任务都相对简单，需要较少的数据量就可以完成。</td><td>需要大量的标注数据，但是效果往往很好</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-1"><a class="header" href="#linux-1">Linux</a></h1>
<p>[TOC]</p>
<h2 id="linux-文档"><a class="header" href="#linux-文档">Linux 文档</a></h2>
<h3 id="man"><a class="header" href="#man">man</a></h3>
<pre><code class="language-shell"># man 是一个 Linux 命令手册大全
man ls
man head
man man
man -k keyword # 按照关键字查找相关的命令手册
</code></pre>
<h3 id="--help"><a class="header" href="#--help">--help</a></h3>
<pre><code class="language-shell"># 大多数命令都支持 --help 参数， --help 相当于手册的精简版，会列出几个重要的命令参数
ls --help
cat --help
</code></pre>
<h2 id="linux-术语"><a class="header" href="#linux-术语">Linux 术语</a></h2>
<h3 id="consoleterminalttyshell"><a class="header" href="#consoleterminalttyshell">console，terminal，tty，shell</a></h3>
<p><a href="https://www.zhihu.com/question/21711307">知乎解答</a></p>
<p><strong>console</strong> 是电脑的控制台，一台电脑只有一个 console；</p>
<p>一台大型主机往往需要支持许多用户同时使用，每个用户所使用操作的设备，叫做 <strong>Terminal</strong>；</p>
<p>tty（Teletypewriter）电传打字机，是最流行的 Terminal；</p>
<p>shell 是一个交互式软件，用于用户和操作系统进行交互，用户在 Terminal 上登陆后，就会进入 shell；</p>
<h2 id="shell-tricks"><a class="header" href="#shell-tricks">shell Tricks</a></h2>
<pre><code class="language-shell"># 换行，注意换行第二行不要带空格！
/ + 回车

# 显示当前时间
date

# 展示所有的命令可能
tab + tab 

# 终端快捷键
tab # 自动补全
ctrl + a # 光标移到行首 head
ctrl + e # 光标移到行末 end
esc + . # 复用上一条命令的参数 
ctrl + r # 从 history 中模糊匹配执行的命令 键入 ctrl + r 后，输入相关的命令，一边输入，会一边进行匹配 research 
ctrl + w # 删除 cmd 的最后一个单词 word 
ctrl + u # 从头删除 cmd 到光标处(不包括光标)
ctrl + k # 删除从光标处(包括光标)到 cmd 的末尾
ctrl + l # 清屏

# 快速取消 bash 终端中的输入，另起一行的做法
ctrl + a, 输入 #，如果后期还想用到这个命令，可以直接在 history 中查找

# 在终端中键入空格，应该加反斜杠进行转义
\ 
</code></pre>
<h3 id="history"><a class="header" href="#history">history</a></h3>
<pre><code class="language-shell"># bash 运行中的 history 记录是记录在内存中的，只有在推出 bash 时，才会将新的记录写入 $HOME/.bash_history
history # 查看运行过的命令
!num # 运行 history 中的编号为 num 的命令
history 100  # 列出最近的100条
!! # 执行上一条命令
</code></pre>
<h2 id="文本和字符串处理相关命令"><a class="header" href="#文本和字符串处理相关命令">文本和字符串处理相关命令</a></h2>
<h3 id="通配符"><a class="header" href="#通配符">通配符</a></h3>
<pre><code>常用通配符
?: 一个字符
*: 零个或多个字符
[a-z]: 匹配 a-z
[abc]: 匹配 abc

Demos:
ls -l /bin/c* # 列出系统中以 c 开头的命令
rm /home/work/odp/log/* # 删除 log 目录下所有文件
ls -lF lin[a-z]x # 查看所有 lin[]x 文件的详情 
</code></pre>
<h3 id="cat--tac"><a class="header" href="#cat--tac">cat / tac</a></h3>
<pre><code class="language-shell">cat -n file # 打印出行号 -n number
cat -b file # 只给有文本的行加上行号, -b: --number-nonblank

tac # 从后往前看日志
tac log.txt | more
</code></pre>
<h3 id="echo-1"><a class="header" href="#echo-1">echo</a></h3>
<pre><code class="language-shell">man echo # echo 手册
# echo 换行
echo -e [global]\\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple &gt; pip.conf # -e 表示对反斜线进行转义， \\ 表示反斜线，\\n 就等价于 \n 换行，结果就是：
# [global]
# index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h3 id="more"><a class="header" href="#more">more</a></h3>
<pre><code># 分页显示文件内容，显示内容百分比
# 敲回车查看下边的内容，不支持回看
# 敲空格可以翻页 

# 停止：q
# 搜索（向下搜索）：/要搜索的内容  
</code></pre>
<h3 id="less"><a class="header" href="#less">less</a></h3>
<pre><code># 分页显示文件内容

# 向下搜索：/要搜索的内容
# 向上搜索：?要搜索的内容
# n 重复前一个搜索
# less 支持回看，支持上下键翻看

# 停止：q
</code></pre>
<h3 id="head"><a class="header" href="#head">head</a></h3>
<pre><code># -n number
# 查看文件前n行内容，默认显示头 10 行
head -n 20 file # 200 显示头 200 行, 可以简写成 head -20 file
</code></pre>
<h3 id="tail"><a class="header" href="#tail">tail</a></h3>
<pre><code># 实现 log 文件的实时监控
tail -f file # -f: follow

# 查看后 20 行的内容
tail -n 20 file # 可以简写成 tail -20 file
</code></pre>
<h3 id="wc--计算文件行数"><a class="header" href="#wc--计算文件行数">wc  计算文件行数</a></h3>
<pre><code>参数：
-c: 打印字节的个数
-m: 打印字符的个数
-l：打印行数
-w: 打印单词的个数

wc file # 行数 + 单词数 + 字节数
wc -l file # 行数
</code></pre>
<h3 id="sort-3"><a class="header" href="#sort-3">sort</a></h3>
<pre><code>参数
-n --numeric-sort 
-f --ignore-case
-c check if it has been sorted
-u unique # 去除重复行
-r reverse
-b --ignore-leading-blanks # 会忽略每一行前面的所有空白部分，从第一个可见字符开始比较。
-k # --key=KEYDEF KEYDEF gives location and type 指定按照第几列进行排序，从 1 开始数，
-t # --field-separator=SEP # 分隔符

Demo：
sort -u data.txt &gt; test.txt # 去除重复行
sort -r number.txt &gt; num.txt # 降序排列（默认升序）
sort -n number.txt 按照数值进行排序（而不是字符串）

# 按照指定列进行排序，用 -k 来指定列数 第4列，-t ',' 设置间隔符为逗号
sort -k 4 -t ',' 微博数据_valid.csv &gt; sorted.csv
</code></pre>
<h3 id="grep"><a class="header" href="#grep">grep</a></h3>
<pre><code class="language-shell">全称：
global search regular expression(RE) and print out the line

参数：
-i, --ignore-case         ignore case distinctions
-o, --only-matching       show only the part of a line matching PATTERN
-v, --invert-match        select non-matching lines 反向匹配



Demos:
grep match_pattern file # 输出 file 中匹配到 pattern 的行

# grep 命令从后往前查找
tac log.txt | grep &quot;regx&quot;

# 反向匹配，不匹配包含 match_pattern 的数据，把 grep 这个进程过滤掉
ps -fe | grep java | grep -v grep 
</code></pre>
<h3 id="awk-命令"><a class="header" href="#awk-命令">awk 命令</a></h3>
<p>awk 是一个强大的文本处理工具，通常用于生成格式化的日志文件，其本质上更像是一个管道中的文本处理器。</p>
<p>awk 会自动给一行中的每个数据元素分配一个变量，默认情况下，awk 会将如下变量分配给其在文本行中发现的字段：</p>
<pre><code>$0 代表整个文本行
$1 代表文本行中的第一个数据字段
$2 代表文本行中的第二个数据字段
$n 代表文本行中的第n个数据字段
</code></pre>
<p>awk 中内置很多函数，例如算数函数:  <code>int()</code>，字符串函数: <code>substr(), length()</code>等，具体参考: <a href="http://www.runoob.com/w3cnote/awk-built-in-functions.html">awk内置函数</a></p>
<p><strong>语法</strong></p>
<pre><code class="language-shell">echo &quot;Hello linux&quot; | awk '{awk_cmd}' # 必须是 单引号 + 大括号
</code></pre>
<p><strong>常见命令选项</strong></p>
<table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody>
<tr><td><code>-F</code></td><td>指定划分数据字段的分隔符</td></tr>
<tr><td><code>-f file</code></td><td>c从指定文件中读取 awk 脚本程序</td></tr>
</tbody></table>
<p><strong>Demo</strong></p>
<pre><code class="language-shell"># 不管输入什么，输出都是 nihao, linux
echo &quot;hello&quot; | awk '{print &quot;nihao, linux&quot;}'

# 从文件输入文本进行处理，输出每行的第一个字符串
awk '{print $1}' data.txt

# 指定分隔符为 :
awk -F: '{print $1}' data.txt

# 执行多个命令: 将名称替换成 dongxin，然后打印全行
echo &quot;hello my name is wansho&quot; | awk '{$5=&quot;dongxin&quot;; print $0}'

# 获取缓存的大小
buff_cache=`free -h | grep Mem: | awk '{print int(substr($6,0,length($6)))}'`

# 将 awk 命令存储到文件中
cat script.awk
{print $1 &quot;'s home directory is &quot; $6}
awk -F: -f script.awk /etc/passwd
</code></pre>
<h3 id="sed-命令"><a class="header" href="#sed-命令">sed 命令</a></h3>
<pre><code class="language-shell"># 常见的 sed 替换字符串的语法，全局替换某个字符串
sed -i 's/Search_String/Replacement_String/g' Input_File
</code></pre>
<h3 id="diff-命令"><a class="header" href="#diff-命令">diff 命令</a></h3>
<p>用于比较同一文件，两个版本的区别。</p>
<h3 id="输入输出重定向"><a class="header" href="#输入输出重定向">输入输出重定向</a></h3>
<h4 id="-4"><a class="header" href="#-4">&gt; &lt; &gt;&gt; &lt;&lt;</a></h4>
<p>Linux 有三个标准文件描述符：</p>
<table><thead><tr><th>描述符</th><th>描述</th><th>作用</th></tr></thead><tbody>
<tr><td>0</td><td>stdin</td><td>标准输入，默认是键盘</td></tr>
<tr><td>1</td><td>stdout</td><td>标准输出，默认是屏幕</td></tr>
<tr><td>2</td><td>stderr</td><td>标准错误，默认是屏幕</td></tr>
</tbody></table>
<p>数据流重定向符：</p>
<table><thead><tr><th>符号</th><th>作用</th><th>Demo</th></tr></thead><tbody>
<tr><td>&gt;</td><td>对输出进行重定向，也就是不输出到屏幕，改输出目的地</td><td><code>ls -al test1 1&gt; file </code> #将标准输出重定向号file</td></tr>
<tr><td>&lt;</td><td>对输入进行重定向，也就是不再从键盘输入，改从其他源输入</td><td></td></tr>
</tbody></table>
<p>Demos</p>
<pre><code class="language-shell"># 将 standard output 写入到 file 中
echo content &gt; filename # 将输出覆盖到 filename 中，等价于 echo content 1&gt; filename
echo 内容 &gt;&gt; filename     # 给文件追加内容

# 将 standard error 写入到文件中
cmd 2&gt; file # 

# 将日志分开存储
ls -al test test2 test3 2&gt; err.log 1&gt; info.log
ls -al test test2 test3 2&gt;&gt; err.log 1&gt;&gt; info.log # 日志追加

# 所有输出都重定向到一个文件
ls -al test test2 test3 &amp;&gt; info.log

# 重定向到 null device，null device 是 Linux 系统的垃圾桶，可以把任何垃圾丢到这里，并且返回一个操作成功的返回码
echo &quot;demo&quot; &gt; /dev/null
# https://en.wikipedia.org/wiki/Null_device
</code></pre>
<h4 id="tee-cmd"><a class="header" href="#tee-cmd">tee cmd</a></h4>
<p>tee 命令相当于管道的一个 T 型接头，它可以将输出发往两处：一个是 stdout，一个是指定的文件名。</p>
<p>相当于我之前在 django 中定义的既可以将 log 写入文件，又可以将 log 打印到控制台的功能。</p>
<p>Demo:</p>
<pre><code class="language-shell">date | tee log.log 
date | tee -a log.log # -a：--append 追加
python demo.py | tee -a log.log
</code></pre>
<h3 id="创建临时文件和目录-mktemp"><a class="header" href="#创建临时文件和目录-mktemp">创建临时文件和目录 mktemp</a></h3>
<pre><code class="language-shell"># /tmp 文件夹，大多数 Linux 发行版会默认在系统启动时删除 /tmp 目录的所有文件
mktemp log.XXXXXX # 在本地目录下创建一个临时文件，log 为文件名，mktemp 会用六个随机字符替换后面的六个X，该命令返回创建的临时文件的 name
mktemp -t log.XXXXXX # 强制在系统的临时目录(/tmp)来创建该文件，并返回该临时文件的全路径
mktemp -d tempdir.XXXXXX # 创建临时目录
</code></pre>
<h2 id="文件与设备管理"><a class="header" href="#文件与设备管理">文件与设备管理</a></h2>
<h3 id="tree-1"><a class="header" href="#tree-1">tree</a></h3>
<pre><code class="language-shell">生成目录树
tree -I dir # 忽略某一个文件夹
</code></pre>
<h3 id="cd"><a class="header" href="#cd">cd</a></h3>
<pre><code class="language-shell">cd # 切换到 home 目录，等价于 cd ~
cd . # 当前的文件夹
cd - # 回到刚才的文件夹  重点！！！
cd ~ # 回到当前用户的主文件夹
cd ~user # 到某个用户的家目录
cd .. # 转到上一级文件夹
</code></pre>
<h3 id="ls"><a class="header" href="#ls">ls</a></h3>
<pre><code class="language-shell">ls -h # human  人类易读的方式，文件大小会转成人易读的方式，加上单位
ls -t # 将文件按照最新修改的时间进行排序

ls -l # long 详细信息
    文件详细信息展示后，按照信息开头的字母，可以分成如下文件：
    1. d 目录
    2. - 文件
    3. l 连接文件
    4. c 设备文件中的串行端口设备，例如键盘、鼠标

ls -a # all, 包含隐藏的文件
ls -F # --classify，使输出文件的文件类型可分辨。（文件夹带上/, 可执行文件加上*）
ls -i # 显示文件的 id (inode 编号，第一个属性)
ls --group-directories-first # 优先显示文件夹
</code></pre>
<h3 id="mv"><a class="header" href="#mv">mv</a></h3>
<pre><code class="language-bash">-i: --interactive

mv oldname newname # 更改文件名字
mv olddir/ newdir # 更改文件夹名称

mv file directory # 将文件移动到 directory 中
mv file_oldname dir/file_newname # 将文件移动到 dir 中并改名字
mv -i oldname newname # 加 -i 会在 newname 文件已经存在的情况下得到提示 
mv dir new_path # 不加参数的移动整个文件夹

# Note:
# 移动过后的文件夹，其文件的属性不会有任何改变，时间戳和 inode 编号也不会有改变。
</code></pre>
<h3 id="cp"><a class="header" href="#cp">cp</a></h3>
<pre><code class="language-shell">cp 源文件 复制文件
cp -R/-r 目录  目标目录  # 递归复制&quot;目录&quot;需要添加参数-R
cp *.sh dir # 复制所有的 sh 文件到某个文件夹
</code></pre>
<h3 id="file"><a class="header" href="#file">file</a></h3>
<pre><code>file 文件 # 查看文件是什么文件
</code></pre>
<h3 id="mkdir"><a class="header" href="#mkdir">mkdir</a></h3>
<pre><code class="language-shell">mkdir -p /home/work/odp/app/bq # no error if existing, make parent directories as needed
# 创建文件夹后并进入该文件夹
cd $_ # $_ 记录了上一个命令最后一个参数
</code></pre>
<h3 id="tar--zip"><a class="header" href="#tar--zip">tar / zip</a></h3>
<pre><code class="language-bash"># 打包压缩
tar -czvf haha.tar.gz file1 file2

# 拆包解压缩
tar -xzvf haha.tar.gz
tar -xzvf haha.tar.gz -C path # 解压到指定文件夹
# tar 命令解压的文件，会覆盖原文件

# zip
zip
unzip
</code></pre>
<h3 id="查找命令-which-find-locate-whereis"><a class="header" href="#查找命令-which-find-locate-whereis">查找命令 which, find, locate, whereis</a></h3>
<p><strong>which</strong> 在 path 变量中查找命令</p>
<pre><code class="language-shell"># which 用来在所有的 PATH 路径中查找 某个命令 所在地址，例如查找 ls, cat 命令所在地址，注意每一个用户的 PATH 命令可能是不一样的，不同用户使用 which 查找某个命令的结果可能有所区别，有的用户可能找不到某个命令的地址
which cat
which ls
which -a ls # 查找所有的 ls 命令所在地址，可能 ls 不止一个
</code></pre>
<p><strong>find</strong></p>
<pre><code class="language-shell">find -name ./ 文件名 # 在当前目录下查找某个文件

find -type f ./  # 查找当前文件夹下的 一般文件

# 注意 \; 用来告诉 find 命令查询已结束，The \; part is basically telling find &quot;okay, I'm done with the command I wanted to execute&quot;.
# 注意: -exec 并不是管道命令，其是 find 自带的参数，xargs 是管道命令，应该和管道一起使用 
find ./ -type f -name &quot;*.txt&quot; -exec cp {} /test \;
find ./ -type f -name &quot;*.txt&quot; -exec ls -l {}  \; # 查看当前文件夹下的 txt 文件的详细信息
find ./ -type f -name &quot;*.txt&quot; -print | xargs ls -l # 不需要加 \; 因为是管道命令
</code></pre>
<p><strong>whereis 和 locate</strong></p>
<pre><code class="language-shell">whereis 和 locate 是使用数据库来搜寻数据，类似于 everything。但是 whereis 和 locate 命令有一个缺点，对于新生成的文件和已删除的文件，不能及时的更新和维护数据库，所以可能导致新的文件查不到。
实际情况下，locate 的效果要优于 whereis

# locate 依据 /var/lib/mlocate 内癿数据库记载，找出用户输入癿关键词文件名
locate -i passwd # 查找包含文件名包含 passwd 字符串的文件，忽略大小写

# 及时更新文件数据库的命令。根据 /etc/updatedb.conf 的设定去搜寻系统硬盘内的文件名
updatedb # 更新db,比较耗时
</code></pre>
<h3 id="ln"><a class="header" href="#ln">ln</a></h3>
<pre><code class="language-bash"># make links between files. 默认创建 硬链接

# 参数：
# -s: --symbolic, make symbolic links instead of hard links

# Demos:
# 创建硬链接，本质上是同一个文件，共享 inode 编号，而且文件显示并非链接文件，而实正常的文件，如果把源文件删除，硬链接仍然有效！注意，硬链接可执行文件复制到 PATH 变量包含的目录后，可以直接通过命令运行。
ln file link_file
ln file dir/
# 创建符号 (symbolic) 软件链接，生成一个链接类型的文件，文件大小很小，文件类型为 l
ln -s file file_link 
</code></pre>
<h2 id="文件权限"><a class="header" href="#文件权限">文件权限</a></h2>
<h3 id="用户增删改查"><a class="header" href="#用户增删改查">用户增删改查</a></h3>
<p><strong>增加用户, useradd</strong></p>
<pre><code class="language-shell">参数:
-u --uid UID                 user ID of the new account
-p --password PASSWORD       encrypted password of the new account
-D --defaults print or change default useradd configuration
-m --create-home             create the user's home directory
-c --comment COMMENT         GECOS field of the new account
-g --gid GROUP               name or ID of the primary group of the new account
-s --shell 				login shell of the new account

Demos:
useradd -m -c &quot;for work&quot; -u 8888 -p xxxxxx -s /bin/bash work

# 注意：
# 1. 默认情况下，useradd 不会创建用户目录 
# 2. useradd 在创建用户主目录后，会将 /etc/skel/ 下的文件复制到用户目录下，这些文件时 shell 下的标准启动文件，用于用户级别的初始化
</code></pre>
<p><strong>删除用户，userdel</strong></p>
<pre><code class="language-shell"># 删除用户，当并没有删除属于该账户的任何文件
userdel wansho

# 删除用户，并删除该用户相关的文件
userdel -r wansho # -r --remove
</code></pre>
<p><strong>修改用户，usermod, passwd</strong></p>
<pre><code class="language-shell">usermod 参数
-c, --comment COMMENT         new value of the GECOS field
-G, --groups GROUPS           new list of supplementary GROUPS
-a, --append	append the user to the supplemental GROUPS, mentioned by the -G option without removing him/her from other groups
-l, --login NEW_LOGIN         new value of the login name
-L, --lock                    lock the user account
-U, --unlock                  unlock the user account
-p, --password PASSWORD       use encrypted password for the new password

passwd 参数
-a, --all                     report password status on all accounts
-d, --delete                  delete the password for the named account

Demos:
usermod -c &quot;wansho test&quot; wansho # 修改用户说明
usermod -G work wansho # 将用户 wansho 加入 work 用户组 (wansho 只属于 work 组)
usermod -a -G work wansho # 把用户 wansho 添加到 work 组，之前所属组不影响
usermod -p xxxxxx wansho # 修改 wansho 的密码为 xxxxxx

passwd wansho # 修改 wansho 用户的密码

# 注意：
# 1. 对组关系进行更改后，需要登出系统再登陆，组关系变更才会生效
# 2. 当一个用户在 /etc/passwd 中制定了某个组作为默认组后，该用户账户就不会作为该组成员在 /etc/group
</code></pre>
<p><strong>查看所有用户 whoami, /etc/passwd, /etc/shadow</strong></p>
<pre><code class="language-shell"># 存储用户信息的文件: /etc/passwd
# 注意，该文件中有很多账户，但是大多数都是系统账户，Linux 系统会为各种各样的功能创建不同的用户账户，这些账户并不是真正的用户
# Linux 为系统账户预留了 500 以下的 UID
# /etc/passwd 中每行记录的具体内容，例如：
work:x:1001:1001::/home/work:/bin/bash
账户名:密码:UID:GroupID:备注:用户家目录:用户默认的shell类型

# /etc/passwd 中存储着每个用户的加密后的密码

# whoami 命令可以查看目前登陆的用户是谁
</code></pre>
<h3 id="用户组增删该查"><a class="header" href="#用户组增删该查">用户组增删该查</a></h3>
<p><strong>增加用户组 groupadd</strong></p>
<pre><code class="language-shell">Demos:
groupadd test_group # 新建一个用户组
usermod -G test_group wansho # 将 wansho 加入该用户组
</code></pre>
<p><strong>删除用户组 groupdel</strong></p>
<pre><code>Demo:
groupdel group_name # 删除一个用户组
</code></pre>
<p><strong>修改用户组 groupmod</strong></p>
<pre><code class="language-shell">参数：
-n, --new-name NEW_GROUP      change the name to NEW_GROUP

Demo:
groupmod -n test_group new_group 

# 注意，更改了用户组的组名后，不会影响该用户组里的用户，因为是对于用户组的引用都是基于编号的
</code></pre>
<p><strong>查看所有用户组 /etc/group</strong></p>
<pre><code class="language-shell">Demo:
cat /etc/group # 查看所有用户组
</code></pre>
<p>###文件权限管理</p>
<p><strong>修改读写和执行的权限 chmod</strong></p>
<pre><code class="language-shell">r  用4表示 
w  用2表示
x  用1表示

u user
g group
o other
a all

-R 选项: 递归修改文件内的权限

Demos
chmod 755 file
7 111 表示所有者的权限是 可读可写可运行
5 101 表示所有组的权限是 可读不可写可执行
1 001 表示其他人的权限是 可执行 

chmod 755 -R dir # 递归修改 dir 的权限

chomod -R g+rwx dir # 递归地对 dir 加上对于用户组的 rwx 权限
</code></pre>
<p><strong>修改文件所属用户 chown</strong></p>
<pre><code class="language-shell">chown owner file # 修改 file 的 所有者 为 owner
chown owner -R dir # 递归修改
</code></pre>
<p><strong>修改文件所属用户组 chgrp</strong></p>
<pre><code class="language-shell">chgrp grp file # 修改 file 的组为 grp
chgrp grp -R dir # 递归修改
</code></pre>
<p><strong>实现文件的组内共享</strong></p>
<pre><code>需求：配置 wansho 的某个文件夹在 work 用户组中共享
实现：
1. 配置该文件对于用户组的权限：可读可写可执行 chmod g+r
2. 配置该文件所属用户(wansho)属于用户组(work)：usermod -a -G group work
</code></pre>
<h2 id="进程磁盘资源管理"><a class="header" href="#进程磁盘资源管理">进程/磁盘/资源管理</a></h2>
<h3 id="进程层次图"><a class="header" href="#进程层次图">进程层次图</a></h3>
<p><img src="computer-science-notebook/linux/assets/1559723349422.png" alt="进程层次图" /></p>
<h3 id="top"><a class="header" href="#top">top</a></h3>
<pre><code>top
显示当前系统中耗费资源最多的进程 
查看各个进程的资源占用情况，提供当前进程的快照，即时查看最活跃的进程。

top 命令的 %CPU 显示的实际上是该进程占用的单个 CPU 的大小
而 CPU(s) 显示的才是 总的 CPU 的占比。按 1 键可以切换 CPU，查看其他 CPU 的情况。
</code></pre>
<p><img src="computer-science-notebook/linux/assets/1559723252567.png" alt="Top 命令详解" /></p>
<h3 id="ps"><a class="header" href="#ps">ps</a></h3>
<p>process snapshot.</p>
<pre><code># 参数
-a 不与 terminal 相关的所有进程
-u 有效用户
-x 与 a 使用，可列出完整信息

-f --full-format listing,类似于 -l
-e 选择所有的进程
--forest 显示进程树，列出父子进程的关系

# demo
ps -fe # 等价于 ps aux
ps -ef | grep vim

ps -l # 查看自己 bash 相关的进程
ps -e # 查看所有的进程， 如果不加 e，那么只会列出该 bash 下的进程


查看所有进程的所有信息，通常与 grep 命令组合使用。查不出来进程所占用的资源量。
</code></pre>
<h3 id="kill"><a class="header" href="#kill">kill</a></h3>
<pre><code class="language-shell">kill -9 PID # 无条件杀死某个进程
kill -HUP pid # 重新加载配置文件
ps -fe | grep Aug.*python | grep -v grep | awk '{print $2}' | xargs kill -9 # 批量杀死包含某个关键字的进程

killall http* # 结束所有以 http 开头的进程
</code></pre>
<h3 id="free"><a class="header" href="#free">free</a></h3>
<pre><code>命令参数
-b 　以Byte为单位显示内存使用情况。 
-k 　以KB为单位显示内存使用情况。 
-m 　以MB为单位显示内存使用情况。
-g   以GB为单位显示内存使用情况。 
-o 　不显示缓冲区调节列。 
-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 
-t 　显示内存总和列。 
-V 　显示版本信息。**

Demos:
free -h # 结果中的 Mem 行就是内存的使用情况
</code></pre>
<h3 id="df"><a class="header" href="#df">df</a></h3>
<pre><code class="language-shell">disk free

df -h path # 查看某个文件夹所挂在的磁盘的使用情况
df -h # 查看所有挂在的磁盘的使用情况
</code></pre>
<h3 id="du-disk-usage"><a class="header" href="#du-disk-usage">du (disk usage)</a></h3>
<pre><code class="language-shell"># disk usage 列出指定的文件占用的磁盘空间

du -hs file|path|* # 列出文件占用磁盘的空间
du -h --max-depth=1 # 查看当前一级目录下的文件或者文件夹占用磁盘的大小
</code></pre>
<h3 id="pgrep-pkill"><a class="header" href="#pgrep-pkill">pgrep, pkill</a></h3>
<pre><code class="language-shell"># find or signal process by name 

pgrep -l mysql  # 返回 MySQL 的 pid
pkill -x mysql # 
</code></pre>
<h3 id="systemctl"><a class="header" href="#systemctl">systemctl</a></h3>
<p>system-control</p>
<pre><code class="language-shell">systemctl stop firewalld # 关闭防火墙
</code></pre>
<h3 id="ulimit"><a class="header" href="#ulimit">ulimit</a></h3>
<p>Linux ulimit 命令用于控制进程的资源。</p>
<ul>
<li>-a 　显示目前资源限制的设定。</li>
<li>-c &lt;core文件上限&gt; 　设定core文件的最大值，单位为区块。</li>
<li>-d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。</li>
<li>-f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。</li>
<li>-H 　设定资源的硬性限制，也就是管理员所设下的限制。</li>
<li>-m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。</li>
<li>-n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。</li>
<li>-p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。</li>
<li>-s &lt;堆叠大小&gt; 　指定堆叠的上限，单位为KB。</li>
<li>-S 　设定资源的弹性限制。</li>
<li>-t &lt;CPU时间&gt; 　指定CPU使用时间的上限，单位为秒。</li>
<li>-u &lt;程序数目&gt; 　用户最多可开启的程序数目。</li>
<li>-v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。</li>
</ul>
<pre><code class="language-shell"># 查看当前 shell 配置的
ulimit -a 

# ulimit -n will only display the soft limit.
ulimit -n
</code></pre>
<p>配置进程资源 <code>/ect/security/limits.conf</code>，<code>/etc/security/limits.conf</code> 文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 <code>pam_limits.so</code> 的配置文件。有 soft，hard和 <code>-</code>，soft 指的是当前系统生效的设置值，软限制也可以理解为警告值。 hard 表名系统中所能设定的最大值。soft 的限制不能比 hard 限制高，用 <code>-</code> 表明同时设置了 soft 和 hard 的值。https://www.cnblogs.com/operationhome/p/11966041.html</p>
<pre><code class="language-shell"># 修改 LINUX 系统对用户的内存大小和文件句柄限制限制
echo &quot;ems soft nofile 65536&quot; &gt;&gt; /etc/security/limits.conf
echo &quot;ems hard nofile 65536&quot; &gt;&gt; /etc/security/limits.conf
echo &quot;ems hard memlock unlimited&quot; &gt;&gt; /etc/security/limits.conf
echo &quot;ems soft memlock unlimited&quot; &gt;&gt; /etc/security/limits.conf
# max size virtual memory [] for user [] is too low, increase to [unlimited]
# https://www.elastic.co/guide/en/elasticsearch/reference/master/max-size-virtual-memory-check.html
echo &quot;ems - as unlimited&quot; &gt;&gt; /etc/security/limits.conf
echo &quot;root - as unlimited&quot; &gt;&gt; /etc/security/limits.conf
echo &quot;ems - fsize unlimited&quot; &gt;&gt; /etc/security/limits.conf
</code></pre>
<p>https://superuser.com/questions/740000/modify-and-apply-limits-conf-without-reboot</p>
<p>修改完 limits.conf 配置后，重新 ssh 登录用户即可生效。</p>
<p>注意！<strong>wildcard <code>*</code> won't apply for <code>root</code> user.</strong> 通配符并不适用于 root 用户，如果需要配置 root 用户，则需要明文配置！</p>
<p>These limits will be applied after reboot.</p>
<p>If you want to apply changes without reboot, modify <code>/etc/pam.d/common-session</code> by adding this line at the end of file:</p>
<pre><code>session required pam_limits.so
</code></pre>
<p>查看一个进程的资源限制：</p>
<pre><code class="language-shell">cat /proc/&lt;pid&gt;/limits

# 获取当前 shell 的进程号
ps | grep $$
</code></pre>
<h3 id="limit"><a class="header" href="#limit">limit</a></h3>
<p>动态修改当前用户的资源配置。</p>
<pre><code class="language-shell"># 修改虚拟内存
limit vmemoryuse unlimited

# 显示所有的可改选项
limit

cputime      unlimited
filesize     unlimited
datasize     unlimited
stacksize    8192 kbytes
coredumpsize 521000 kbytes
memoryuse    unlimited
vmemoryuse   unlimited
descriptors  1024
memorylocked unlimited
maxproc      65535
maxlocks     unlimited
maxsignal    513621
maxmessage   819200
maxnice      0
maxrtprio    0
maxrttime    unlimited
</code></pre>
<h2 id="网络相关"><a class="header" href="#网络相关">网络相关</a></h2>
<h3 id="ifconfig"><a class="header" href="#ifconfig">ifconfig</a></h3>
<pre><code class="language-shell">ifconfig # 查看网卡信息，注意是查看已经配置好的网卡信息

ifconfig -a # 查看所有的网卡信息，没有配置的也是
</code></pre>
<h3 id="netstat"><a class="header" href="#netstat">netstat</a></h3>
<p><strong>介绍</strong></p>
<p>netstat 用于显示网络相关信息，可以用于查看端口被那个进程占用了</p>
<pre><code class="language-shell">netstat -tunpl | grep 端口号
</code></pre>
<h3 id="1024以下的端口"><a class="header" href="#1024以下的端口">1024以下的端口</a></h3>
<pre><code># Linux 系统的 1024 以下的端口只有 root 用户才能占用。
</code></pre>
<h3 id="lsof"><a class="header" href="#lsof">lsof</a></h3>
<p>lsof - list open files</p>
<pre><code class="language-shell">lsof -i:port # 查看指定端口被哪个进程占用，功能类似于 netstat -tunpl | grep 端口号
</code></pre>
<h3 id="wget-curl"><a class="header" href="#wget-curl">wget, curl</a></h3>
<pre><code class="language-shell"># post 请求
curl -XPOST http://localhost:8080/a
# 显示详细信息
curl -v  http://localhost:8080/hello
# 加入头信息
curl -H &quot;Authorization: Basic dXNlcjphMmNmYTU3Yy0xNzA3LTQzOGYtODBlNi04MDFiZTQ0YTM0MDk=&quot; http://localhost:8080/hello
# http basic 认证
curl -u user:a2cfa57c-1707-438f-80e6-801be44a3409  http://localhost:8080/hello
# 多个 header
curl -v -H &quot;Authorization: key123456&quot; -H &quot;Request-Id: 123456&quot; http://localhost:8080/hello

curl 域名 # 在终端中打印 HTML 源码，注意这里只是域名，不是完整的URL链接
curl -O http://man.linuxde.net/text.iso # O 大写，下载文件
curl -o tmp.iso http://man.linuxde.net/text.iso # 下载文件并重命名
wget http://man.linuxde.net/text.iso # 不加任何参数，直接下载文件
wget -O /home/work/temp/tmp.iso http://man.linuxde.net/text.iso # 下载文件到指定文件夹下并重命名
wget http://man.linuxde.net/text.iso -P /home/work/test  # 下载文件到指定文件夹
注意 wget 命令的 -O 参数功能包含了 -P 参数，所以两个参数不需要重复出现，demo:
wget -O /home/work/test/measure_site/measure_site/data/tmp/deploy_value_diff/baidu_ps-se-fe-tpl_aladdin-atom-1.0.362.1-53707.tar.gz ftp://getprod:getprod@getprod.scm.baidu.com/data/prod-aos/prod-64/baidu/ps-se-fe-tpl/aladdin-atom/aladdin-atom_1-0-362-1_PD_BL/aladdin-atom_1.0.362.1.tar.gz 

下载文件夹，即递归下载一个文件夹
wget -r url

重点:
wget url
curl -o rename url
</code></pre>
<p>wget 和 curl 的区别：</p>
<ul>
<li><code>wget</code> is a tool to download files from servers。wget 用来从服务器下载文件</li>
<li><code>curl</code> is a tool that let's you exchange requests/responses with a server。curl 用来和服务器进行交互，其更像是一个类似浏览器的客户端。curl 支持多种应用层协议。</li>
</ul>
<h3 id="ssh-1"><a class="header" href="#ssh-1">ssh</a></h3>
<p>ssh(secured shell) 用来远程登录访问。</p>
<p>ssh (SSH client) is a program for logging into a remote machine and for executing commands on a remote machine.  It is intended to provide secure en‐crypted communications between two untrusted hosts over an insecure network.  X11 connections, arbitrary TCP ports and UNIX-domain sockets can also be forwarded over the secure channel.</p>
<p>ssh connects and logs into the specified destination, which may be specified as either [user@]hostname or a URI of the form ssh://[user@]hostname[:port]. The user must prove his/her identity to the remote machine using one of several methods (see below).</p>
<p><a href="https://www.jianshu.com/p/b10c2b163100">[ssh 实例讲解]</a></p>
<p>命令格式：<code>ssh [-p port] user@remote</code>，Demo：<code>ssh -p 22 deepin2@192.168.56.132</code> </p>
<h3 id="route"><a class="header" href="#route">route</a></h3>
<p>多网络间路由配置（配置静态路由）</p>
<p>route:</p>
<img align="left" src="computer-science-notebook/linux/assets/image-20201029085228873.png" alt="image-20201029085228873" style="zoom:80%;" />
<img align="left" src="computer-science-notebook/linux/assets/image-20201029085638645.png" alt="image-20201029085638645" style="zoom:80%;" />
<p>Demo:</p>
<pre><code>Linux1:
	10.0.0.128
	
Linux2:
	10.0.0.129
	192.168.1.129
	
Linux3:
	192.168.1.130
	192.168.2.130

其中 Linux2 作为路由器

添加静态路由常用参数：

add 增加路由
del 删除路由
-net 设置到某个网段的路由
-host 设置到某台主机的路由
gw     出口网关 IP地址
dev 出口网关 物理设备名

设置到某个网段的路由:
	route add -net 目标网段 gw 网关(路由器)
	例如：
	从 1 到 3，经过路由 2：route add –net 192.168.1.0/24 gw 10.0.0.129
	从 3 到 1，经过路由 2：route add -net 10.0.0.0/24 gw 10.0.0.129
</code></pre>
<p>注意，直接在 shell 中通过 route 增加静态路由，是临时的，系统重启后，则失效，如果想开启生效的话，需要在开机脚本中进行配置。</p>
<h3 id="telnet"><a class="header" href="#telnet">telnet</a></h3>
<p>一个与其他主机进行通信的工具集。</p>
<p>The telnet command is used for interactive communication with another host using the TELNET protocol. It begins in command mode, where it prints a telnet prompt (&quot;telnet&gt; &quot;). If telnet is invoked with a host argument, it performs an open command implicitly; </p>
<p><strong>测试远程主机的端口是否打开</strong></p>
<pre><code class="language-shell">telnet ip port
# 退出 telnet：ctrl + ]，然后 quit
</code></pre>
<h3 id="防火墙"><a class="header" href="#防火墙">防火墙</a></h3>
<p>开放防火墙上的一个端口</p>
<pre><code class="language-shell">firewall-cmd --zone=public --add-port=3306/tcp --permanent
firewall-cmd --reload
</code></pre>
<p>关闭防火墙</p>
<pre><code class="language-shell">systemctl stop firewalld # 关闭防火墙 system-control
</code></pre>
<p>能 ping 通，但是访问不了，netstat 看一下端口，可能是防火墙的问题</p>
<h2 id="硬件相关"><a class="header" href="#硬件相关">硬件相关</a></h2>
<h3 id="ethtool"><a class="header" href="#ethtool">ethtool</a></h3>
<p>需要 root 权限</p>
<pre><code class="language-shell">ethtool -p 网口名字 秒数 # 让某个网口亮多少秒，服务器上的网口是可以亮的，因为服务器上通常有很多网口，不好分辨
</code></pre>
<h3 id="crontab"><a class="header" href="#crontab">crontab</a></h3>
<p>在线生成 crontab 的网址：https://crontab-generator.org/</p>
<p>crontab 命令用于定义循环执行的工作。</p>
<p>注意，crontab 一定是准时准点运行的。</p>
<p>crontab 命令 由 系统的 cron 系统服务控制。linux 系统上有很多例行性工作，所以 cront 系统服务是默认启动的。
crontab 如果设置每隔 半小时 执行一次，它会在 crontab 设置成功的那一刻开始计时，而不是在标准的 10.00 10.30 执行。</p>
<p>配置可以使用 crontab 命令的账户：<code>/etc/cron.allow</code>
配置不可以使用 crontab 命令的账户：<code>/etc/cron.deny</code>
默认情况下，只要用户不被列入 <code>/etc/cron.deny</code>，就可以执行 crontab 命令。</p>
<p>Summary
​    1. crontab 最小的执行单位是 分钟，所以是 年月日时分 五个时间参数。
​    2. * * * * * 分别代表 分 时 日 月 星期几
​    3. crontab 用于定时执行一些重复的工作，例如每天定时发一封邮件，定时备份，每天定时提醒自己做什么事，都可以在 linux 中执行
​    4. crontab 类似 linux 下的 shell 脚本，其中的注释 为 # </p>
<p>crontab 命令的参数</p>
<pre><code>-l 查阅所有的 crontab 任务
-e 进入 vim 编辑crontab命令
-r 删除所有的 crontab 命令
</code></pre>
<p>crontab 时间参数</p>
<pre><code class="language-shell">* * * * * 分别代表 分 时 日 月 星期几
* 代表任意时刻都可以
, 表示或者的关系，例如 0 3,5 * * * command 表示 凌晨 3 点 和 5 点 执行命令
- 表示一段时间，例如 0-10 * * * * command 表示每小时的 0 — 10 分执行 command 命令
/n n 代表数字，即每隔 n 时间间隔执行一次，例如 */5 * * * * command 用 * 与 /5 进行搭配，表示每隔 5 分钟执行一次，也可以写成 0-59/5 * * * * * command，意思相同
 /n n 代表数字，即每隔 n 时间间隔执行一次，例如 * */1 * * * command 用 * 与 /5 进行搭配，表示每隔 一小时 执行一次
</code></pre>
<p>Demo</p>
<pre><code class="language-shell">* * * * * date &gt;&gt; /home/work/tmp # 每过一分钟，将日期存储到 tmp 文件中
* * * * * python /home/work/test/crontab_test/crontab_test.py &gt;&gt; /home/work/test/crontab_test/log.txt # 将标准输出 1 打印的日志存储到 log.txt 中
* * * * * python /home/work/test/crontab_test/crontab_test.py &gt;&gt; /home/work/test/crontab_test/log.txt 2&gt;&amp;1 # 将标准错误输出 2 写入到 log 文件中，并且借助了 1 的管道，注意此处的 2&gt;&amp;1 不能改成 2&gt;&gt;&amp;1
* * * * * python /home/work/test/crontab_test/crontab_test.py &gt;&gt; /home/work/test/crontab_test/log.txt 2&gt;&gt; /home/work/test/crontab_test/err_log.txt # 将正确输出信息写入 log 文件，将错误输出信息写入 error_log 文件
0 12 * * * command # 每年每月每天的中午 12:00 执行 command
* * * * * mail dmtsai -s &quot;at&quot;
</code></pre>
<p>注意，我们在使用 crontab 运行 Linux shell script 时，一定要指定脚本的 shell，并且尽量使用绝对路径，否则容易因为环境的原因，出现各种乱七八糟的问题：</p>
<pre><code class="language-shell">*/5 * * * * /bin/bash /home/work/wansho_webservice/wansho_webservice/shell_scripts/buff-cache-monitor.sh &gt;&gt; /home/work/wansho_webservice/log/buff-cache-monitor.log 2&gt;&gt; /home/work/wansho_webservice/log/buff-cache-monitor.log
# 其中 /bin/bash 制定了运行的 shell
</code></pre>
<h3 id="rz-sz"><a class="header" href="#rz-sz">rz, sz</a></h3>
<p><strong>安装 rz sz 命令</strong></p>
<pre><code>sudo apt-get install lrzsz
</code></pre>
<p><strong>rz</strong></p>
<pre><code>rz 将本地文件上传到 linux 当天文件夹
参数如下：

-b 以二进制方式，默认为文本方式。（Binary (tell it like it is) file transfer override.）
-e 对所有控制字符转义。（Force sender to escape all control characters; normally XON, XOFF, DLE, CR-@-CR, and Ctrl-X are escaped.）

如果要保证上传的文件内容在服务器端保存之后与原始文件一致，最好同时设置这两个标志，如下所示方式使用：
rz -be
</code></pre>
<p><strong>sz</strong></p>
<pre><code>sz 从线上机器拉取文件到本地 
参数如下：

-a 以文本方式传输（ascii）。
-b 以二进制方式传输（binary）。
-e 对控制字符转义（escape），这可以保证文件传输正确。

如果能够确定所传输的文件是文本格式的，使用 sz -a files
如果是二进制文件，使用 sz -be files

sz 好像默认不能下载文件夹，先在 服务端把文件夹打包，然后下载比较好
</code></pre>
<h3 id="reboot-halt-shutdown"><a class="header" href="#reboot-halt-shutdown">reboot, halt, shutdown</a></h3>
<pre><code class="language-shell">shutdown -r +5 # 5分钟后关机

reboot # 重启

halt # 关机
</code></pre>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<pre><code>进入完全命令模式 init 3
进入图形化界面   init 5
重启           init 6

0 停机（千万不能把initdefault 设置为0）
1 单用户模式
2 多用户，没有 NFS(和级别3相似，会停止部分服务)
3 完全多用户模式，进入命令行界面
4 没有用到
5 x11(Xwindow) 进入图形化界面
6 重新启动（千万不要把initdefault 设置为6）
</code></pre>
<h3 id="sudo"><a class="header" href="#sudo">sudo</a></h3>
<pre><code>既然切换到 root 用户需要 root 密码，那么 root 用户的密码难免被各个用户知道，为了防止 root 密码外漏，给出了 sudo 方法。并不是所有的用户都可以执行 sudo 命令，必须经过 root 用户的配置。配置完后，被配置的用户就可以使用 sudo 命令短暂的用 root 的身份执行命令，而且 sudo 后输入的密码是 用户自己的密码，这样就防止了 root 用户密码的泄漏。

在 root 下配置 sudo 命令的教程：
visudo
    在文件最后一样加入：
    work ALL=(ALL) ALL # 其中 work 是赋予 sudo 权限的普通用户，后面模式固定
    work ALL=(ALL:ALL) NOPASSWD:ALL # 该命令是赋予 work 用户 root 的权利，不需要密码
</code></pre>
<h3 id="su-命令"><a class="header" href="#su-命令">su 命令</a></h3>
<pre><code>switch user

su - root # 等价于 su -
su - user # 切换到某个用户的家目录
su root 也可以切换到root用户，但是没有管理员权限
</code></pre>
<h2 id="shell-详解-和-环境变量"><a class="header" href="#shell-详解-和-环境变量">Shell 详解 和 环境变量</a></h2>
<h3 id="基础知识-2"><a class="header" href="#基础知识-2">基础知识</a></h3>
<pre><code>1. shell 是 Linux 系统上的一个软件，是 Linux 系统和用户进行交互的接口。
2. Bash 是 shell 的一种，是一个可执行文件 /bin/bash, (ls -alF /bin/bash)
3. 有的系统，其系统内核的 shell 和默认的交互式 shell 是不一样的，例如 ubuntu 的的默认系统 shell 为 /bin/dash
</code></pre>
<p><strong>zsh</strong></p>
<p>目前 geek 使用最多的 shell，是 Z Shell(zsh)，zsh 已经成为了 Mac OS 的默认 shell，<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH">[install]</a> <a href="https://www.cyberciti.biz/faq/how-to-change-shell-to-bash/">[change shell]</a></p>
<pre><code class="language-shell"># 查看当前 shell
echo $SHELL

# 查看系统支持的 shell
echo /etc/shells
</code></pre>
<h3 id="父-shell-和-子-shell后台模式jobscoproc"><a class="header" href="#父-shell-和-子-shell后台模式jobscoproc">父 shell 和 子 shell、后台模式、jobs、coproc</a></h3>
<p><strong>概念</strong></p>
<pre><code class="language-shell"># 父shell 和 子shell 的关系，是父进程和子进程的关系，子shell 并不是真正的多进程处理，因为终端控制着 子shell 的 IO

# 开启一个 子shell，也就是一个子bash，这个子shell，也是一个子进程
bash # 由于 /bin/ 在 PATH 环境变量中进行了配置，所以可以直接输入 bash，等价于 /bin/bash

# 注意，生成 子shell 后，只有在 父shell 中 export 的变量，才会被复制到 子shell 环境中，而且 子shell 对于 父shell 的变量只有 可读 的权力
</code></pre>
<p><strong>命令列表</strong></p>
<pre><code># 作用：在 本shell 中批量执行命令
pwd; ls; date; sleep 10
</code></pre>
<p><strong>进程列表 (cmd1;cmd2;cmd3)</strong></p>
<pre><code class="language-shell"># 进程列表是用括号包围起来的一组命令，其能够创建 子shell（子bash）来执行这些命令，注意，进程列表执行仍然会阻塞 父shell

# 进程列表的功能：
# 1. 在 子shell 中批量执行命令

# 在 子shell(子bash) 中执行命令列表
(date;pwd;ls) # 括号的加入使得命令列表变成了进程列表，并生成了一个 子shell 来执行对应的命令

# 查看当前 bash 的进程数
ps --forest
</code></pre>
<p><strong>后台模式 &amp; 、jobs 命令、coproc</strong></p>
<pre><code class="language-shell"># 进程列表的运行仍然会阻塞父shell，在后台模式中运行命令可以在处理命令的同时，让出 CLI(Command Line Interface)，以供他用。开启后台模式运行的命令，其就是一个后台作业，可以用 jobs 命令查看后台作业的详情
# 后台模式的进程就是一个 daemon，守护进程

# 开启后台模式
cmd&amp; # 可以理解成，从前台进程转为后台守护进程
# 运行结果：[num] pid，其中 num 为 jobs 号，pid 后台作业的 进程id。

# 查看当前运行在后台模式中的所有作业
jobs
jobs -l # 查看所有后台作业的详情

# 杀死 jobs
kill -9 pid

# 将进程列表置于后台运行
(cmd1;cmd2;cmd3)&amp; # 这么做的好处是，在 子shell 中进行繁重的处理工作，同时不会让 子shell 的 IO 受制于终端

# coproc （cop process）在后台模式执行 cmd。等价于（后台模式）
# https://www.gnu.org/software/bash/manual/html_node/Coprocesses.html
coproc cmd # 在后台模式中执行 cmd
coproc (cmd1;cmd2) # 创建一个 子shell，并在 子shell 中执行命令列表
type coproc # coproc is a shell keyword

</code></pre>
<p><strong>后台模式和进程列表的关系</strong></p>
<p>进程列表会进入一个子bash，并在该bash中运行命令</p>
<pre><code>(sleep 100; echo &quot;hehe&quot;)
bash
\_ bash
  \_ sleep
</code></pre>
<p>后台模式是创建了一个job，这个job是父bash直接创建的子进程，并且在后台运行，不会影响到父bash</p>
<pre><code>sleep 100&amp;
bash
\_ sleep
</code></pre>
<h3 id="type-外部命令和内建命令"><a class="header" href="#type-外部命令和内建命令">type, 外部命令和内建命令</a></h3>
<pre><code class="language-shell"># shell 中执行的命令分为 外部命令 和 内部命令，外部命令通常位于 /bin, /usr/bin/,/sbin/,/usr/sbin 中
# 注意：当外部命令执行时，会创建一个 子进程(不是子shell)，这种操作叫做 forking(衍生)
# Demo: ps 是一个外部命令，所以其在 bash 中运行时，会被 bash 创建一个 子进程，其父进程就是 bash
ps -f 
UID        PID  PPID  C STIME TTY          TIME CMD
work     31967 31966  0 09:43 pts/0    00:00:00 -bash
work     32418 31967  0 10:08 pts/0    00:00:00 ps -f

# 外部命令和内部命令的区别
内部命令是 bash 中集成的命令，与 bash 编译成一体，不需要 new 一个 子进程 来运行

# 如何判断一个命令是外部命令还是内建命令
type cmd
type -a echo # --all, 有的命令有内建和外部命令两种实现方式，通过 -a 可以都显示出来

# 注意，如果一个命令的结果返回的是 xxx is hashed (/bin/xxx),那么该命令就是一个外部命令，为了加快命令的查找速度，将其路径进行 hash.
</code></pre>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>Linux 的环境变量指的是系统中的各种重要的变量，环境变量并不是 PATH ！环境变量是一系列 key-value 的键值对。我们可以使用 <code>printenv</code> 来查看所有的环境变量。</p>
<p><strong>printenv, env, set</strong></p>
<pre><code class="language-shell"># 定义：bash 用一种叫做环境变量的特性来存储有关 shell 会话和工作环境的信息。
环境变量
\_全局环境变量
\_局部环境变量
\_用户定义变量
  \_用户定义局部环境变量
  \_用户定义全局环境变量

# 全局环境变量
printenv # 查看全局环境变量
env # 同上
printenv PATH # 查看个别全局环境变量
printenv HOME # 同上
echo $PATH # 查看环境变量的值

# 让变量作为命令行参数
ls $HOME # 变量可以直接在命令行中使用

# 局部环境变量
# Linux 中没有一个只显示局部变量的命令，set 命令会显示所有变量
set # 显示所有的变量
</code></pre>
<p><strong>创建和删除环境变量</strong></p>
<pre><code class="language-shell"># 定义一个局部环境变量,局部环境变量只在 父shell 中生效，不能传递给 子shell，也不能在 exit 后保存
my_para=&quot;wansho&quot;
echo $my_para

# export
# 定义全局环境变量，在 父shell 中生效后，可以传递给 子shell，但是也不能在 exit 后保存；子shell 对于 父shell 的全局环境变量只具有 可读性，无法进行修改、删除的操作，即使修改了，也无法向上传递给 父shell  
my_para=&quot;wansho&quot;
export my_para 

# 删除环境变量
unset my_para
</code></pre>
<h3 id="path一个特殊的环境变量"><a class="header" href="#path一个特殊的环境变量">PATH：一个特殊的环境变量</a></h3>
<pre><code class="language-shell"># PATH 首先是一个环境变量，然后才是一个特殊的环境变量（全局），其定义了用于进行命令和程序查找的目录。

# 修改 PATH，加入新的路径
PATH=$PATH:new_way # PATH 中的路径都用 : 隔开，通过这种方式修改的环境变量，其效果只能维持到退出或重启系统，不能永久保持环境变量

# 想要修改后的 path 变量每次开机都生效，就得将 path 的改动写入 $HOME/.profile or /etc/profile (for a system-wide installation)
</code></pre>
<h3 id="系统环境变量所在地址固化环境变量开机启动项"><a class="header" href="#系统环境变量所在地址固化环境变量开机启动项">系统环境变量所在地址、固化环境变量、开机启动项</a></h3>
<p><strong>/etc/profile 全局级配置文件</strong></p>
<pre><code class="language-shell"># /etc/profile 文件（全系统全局的配置文件）
# /etc/profile 文件是系统上默认的 bash shell 的主启动文件。每个用户登陆，都会执行该文件。
# 正常情况下，我们可以在该脚本中配置一些全局的环境变量和开机启动项。脚本的内容如下：
if [ &quot;$PS1&quot; ]; then
  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then
    # The file bash.bashrc already sets the default PS1.
    # PS1='\h:\w\$ '
    if [ -f /etc/bash.bashrc ]; then
      . /etc/bash.bashrc
    fi
  else
    if [ &quot;`id -u`&quot; -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi
  fi
fi

if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do # 遍历 /etc/profile.d/文件夹中的 sh脚本
    if [ -r $i ]; then
      . $i
    fi
  done
  unset i
fi

# 如果升级了 Linux，那么 /etc/profile 文件也可能 update,那么我们之前在该文件中加入的环境变量和启动项都会被覆盖掉
# 综上，配置全局持久化变量的做法为：
# 在 /etc/profile.d/ 文件夹中建立一个 sh脚本，然后进行环境变量和开机启动的配置
# 我在 profile.d 文件夹下创建了一个 sophic_start.sh 脚本，其内容为
cd /users/ems
./linux_sophic.sh
# 然后授予该脚本执行权限：chmod +x sophic_start.sh
</code></pre>
<p><strong>$HOME下的用户级文件</strong></p>
<pre><code class="language-shell"># 用户级的配置文件
# shell 会按照以下顺序查找文件，并运行第一个被找到的文件，其余的则被忽略（三个文件不一定全都存在）
$HOME/.bash_profile # .bash_profile 会去执行 .bashrc 文件
$HOME/.bash_login
$HOME/.profile

# 交互式 shell
在 CLI 下输入 bash，就会进入交互式shell，此 shell 访问 /etc/profile，只会去访问 $HOME/.bashrc # 没有 .bashrc 则创建该文件

# 综上，配置用户级别的环境变量和开启启动方法为：
配置 $HOME/.bashrc

# 注意，每次登陆 Linux 系统，bash 都会访问 /etc/profile 和 用户目录下的三个隐藏文件
</code></pre>
<h3 id="sourcedotsh"><a class="header" href="#sourcedotsh">source，dot，sh</a></h3>
<p><strong>区别：</strong></p>
<ul>
<li>
<p><code>source</code>, <code>. </code>： Execute commands from a file in the current shell. 注意：是 <strong>current shell</strong></p>
</li>
<li>
<p>sh 是 new 一个子 shell，然后在子 shell 中执行脚本，不会污染当前 shell</p>
</li>
</ul>
<p><strong>详细解释</strong>：</p>
<p><code>source script</code>命令只是简单的运行了脚本中的命令，并且是在当前的 shell 进程中运行，并不会 new 一个 子shell 来运行。运行完后，所有的变量都会保留在当前的 shell 进程中。</p>
<p>例如，当我们修改完环境变量时，我们可以用 source 命令运行这个脚本，使新配置的环境变量在当前的 shell 中生效。</p>
<p><code>. script等价于 </code>source<code>，是 </code>source<code>的 alias，但是 ubuntu 的 crontab 不支持</code>source<code>命令，所以以后用到</code>source<code>的地方，都用</code>.` 代替。</p>
<p><code>sh script</code> 是 new 了一个子 shell，然后在这个子shell中执行脚本，执行结果不会影响父shell。</p>
<h2 id="软件程序安装"><a class="header" href="#软件程序安装">软件程序安装</a></h2>
<h3 id="包管理器安装"><a class="header" href="#包管理器安装">包管理器安装</a></h3>
<p><strong>PMS</strong></p>
<pre><code>Package Manage System 利用一个数据库来记录软件安装的相关信息：

1. Linux 系统安装了什么软件包
2. 每个包安装了什么文件
3. 每个已安装包的版本

两个常见的 PMS 工具：dpkg, rpm
基于 Debian 的发行版(ubuntu,Mint)使用 dpkg 命令
基于 RedHat 的发行版(Fdeora, opensuse) 使用 rpm 命令

dpkg 和 rpm 都是 PMS 的核心。
核心    前端接口
dpkg   apt-get
rpm	   yum

# 方便记忆
debian dpkg apt-get
redhat rpm  yum
</code></pre>
<h3 id="dpkg--apt-get--apt"><a class="header" href="#dpkg--apt-get--apt">dpkg / apt-get / apt</a></h3>
<p>apt-get is a <strong>command line</strong> <strong>interface</strong> for retrieval of packagesand information about them from authenticated sources and
for installation, upgrade and removal of packages together with their dependencies.</p>
<p>apt is a <strong>commandline package manager</strong> and provides commands forsearching and managing as well as querying information about packages. It provides the same functionality as the specialized APT tools, like apt-get and apt-cache, but enables options more suitable for interactive use by default.</p>
<p>apt-get 是一个接口，apt 是一个包管理器。</p>
<pre><code class="language-shell"># dpkg 是 PMS 的核心，其前端实现中最常用的命令是 apt-get 命令

# apt-get 命令 Demos
sudo apt-get update # 更换源后的更新命令
sudo apt-get install packagename # 安装一个新的软件
sudo apt-get install git # 例如安装 git
sudo apt-get remove packagename # 卸载一个已安装的软件包（保留配置文件）
sudo apt-get -purge remove packagename # 卸载一个已安装的软件包（删除配置文件）
sudo apt-get upgrade # 更新所有已经安装的软件
sudo apt-get dist-upgrade # 将系统升级到最新版本

# dpkg 命令 Demos
dpkg -l # 查看所有已安装的软件
dpkg -L vim # 查看 vim 所安装的全部文件
dpkg --search /usr/bin/xxx # 查找某个文件始属于哪个软件包，必须是绝对路径
dpkg -r packagename
</code></pre>
<h3 id="rpm-和-yum"><a class="header" href="#rpm-和-yum">rpm 和 yum</a></h3>
<pre><code class="language-shell"># rpm 是 PMS 的核心，其前端实现中最常用的命令是 yum 命令

# yum 命令 Demos
yum list installed 
yum provides file_name # 查看 file_name 属于哪个软件包
yum install pakcage_name
yum install package_name.rpm # 安装下载好的 rpm 安装文件，进行本地安装
yum list update # 列出所有的更新
yum update package_name 
yum update # 更新所有软件
yum remove pakcage_name
yum erase package_name # 卸载软件，删除文件
</code></pre>
<pre><code class="language-shell"># 查询软件包：
rpm -qa          # 查询系统中安装的所有RPM软件包
rpm -q 软件名    # 查询指定的软件包是否被安装    
rpm -qi 软件名    # 查询系统中已安装的软件包的详细信息
rpm -ql 软件名    # 查询已安装软件包包含的文件
rpm -qf 文件名    # 查询指定的文件所属的软件包是哪个

# 如你要查你的mysql的版本可以用下面的命令：
rpm -qa | grep mysql
# 然后下面就会出来一些mysql的软件，你就可以看到它的版本
</code></pre>
<h2 id="linux-运维"><a class="header" href="#linux-运维">Linux 运维</a></h2>
<h3 id="磁盘挂载-mount--mkfs--blkid--fstab"><a class="header" href="#磁盘挂载-mount--mkfs--blkid--fstab">磁盘挂载 mount / mkfs / blkid / fstab</a></h3>
<p>将新盘或者多余的盘，挂在到某一个目录下，并实现开机的自动化挂载</p>
<pre><code class="language-shell">fdisk -l # 查看分区的符号
mkfs.xfs /dev/sdb # 格式化新盘
mount /dev/sdb /mysqldata # 将某块盘挂载到某一个目录下

# 实现开机自动化挂载
blkid # 查看分区的 UUID 并复制
# 编辑 /etc/fstab，增加一行：
UUID=上面查看的字符串 /mysqldata  xfs  defaults 0  0
</code></pre>
<h3 id="raid"><a class="header" href="#raid">Raid</a></h3>
<p>Raid 分为软 Raid 和硬 Raid。</p>
<p>raid0 可以提高读写速度，但并不能提供数据冗余（单纯的把数据分散到多个磁盘中，并行读取）；</p>
<p>raid1 可以实现数据冗余，但是空间利用率是 50%（raid 1 在 raid 0 的基础上，加上了数据冗余）；</p>
<p>raid5 兼顾存储性能和存储成本，是 raid0 和 raid1 的折中方案；</p>
<h3 id="远程连接协议"><a class="header" href="#远程连接协议">远程连接协议</a></h3>
<h4 id="xdmcp"><a class="header" href="#xdmcp">XDMCP</a></h4>
<p>远程桌面，端口号：177</p>
<h4 id="sftp-1"><a class="header" href="#sftp-1">SFTP</a></h4>
<p>端口号：22</p>
<h4 id="ssh-2"><a class="header" href="#ssh-2">SSH</a></h4>
<p>端口号：22</p>
<h3 id="swap-交换空间"><a class="header" href="#swap-交换空间">Swap 交换空间</a></h3>
<p>交换空间，就是以磁盘空间换内存空间，内存不够用的时候，把一部分内存挪到磁盘里，腾出一部分内存。</p>
<h2 id="linux-发行版"><a class="header" href="#linux-发行版">Linux 发行版</a></h2>
<h3 id="lsb_release"><a class="header" href="#lsb_release">lsb_release</a></h3>
<p>查看当前 Linux 系统是哪个发行版</p>
<p>lsb_release - print distribution-specific information</p>
<h3 id="uname"><a class="header" href="#uname">uname</a></h3>
<p>unix name</p>
<p>输出系统信息</p>
<p>uname - print system information</p>
<pre><code class="language-shell">uname -a # 查看所有信息
</code></pre>
<p>另外 <code>/proc/version</code> 文件中也有系统信息</p>
<p>如果查看 redhat 版本的话，还有一个文件可以查看版本号：<code>cat /etc/redhat-release</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="增强的-linux-命令"><a class="header" href="#增强的-linux-命令">增强的 Linux 命令</a></h1>
<p>[TOC]</p>
<h2 id="top---htop"><a class="header" href="#top---htop">top -&gt; htop</a></h2>
<p>https://htop.dev/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-使用心得"><a class="header" href="#linux-使用心得">Linux 使用心得</a></h1>
<p>[TOC]</p>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<ul>
<li><code>/usr</code> 目录存储用户相关的静态文件，包括安装程序的静态文件，<code>/usr/lib/systemd/system</code></li>
<li><code>/var</code> 目录存储用户相关的动态文件，例如 <code>/var/lib</code> 中存储了 mysql 和 elasticsearch 的动态文件</li>
</ul>
<h2 id="linux-版本"><a class="header" href="#linux-版本">Linux 版本</a></h2>
<p>我最常用的 Linux 版本是 Ubuntu16.04，使用了 Ubuntu18 后，我发现 18 有很多兼容性问题，所以我又切换到 14。</p>
<p>Ubuntu16.04 自带了 Python2.7 和 Python3.5，Git 等软件。</p>
<h2 id="linux-系统的理解"><a class="header" href="#linux-系统的理解">Linux 系统的理解</a></h2>
<h3 id="如何判断一个人-linux-的水平"><a class="header" href="#如何判断一个人-linux-的水平">如何判断一个人 Linux 的水平？</a></h3>
<p>问他：查看某一个命令的帮助文档的两种方式，如果太长了想一页一页的看怎么办？</p>
<p>这其实考察了一个人遇到问题后能否通过自学解决问题的能力。</p>
<h3 id="linux-最常用的几个目录"><a class="header" href="#linux-最常用的几个目录">Linux 最常用的几个目录</a></h3>
<ul>
<li>
<p><strong>/etc</strong> </p>
<p>系统配置</p>
</li>
<li>
<p><strong>/usr/bin</strong></p>
<p>下载安装的软件的位置，例如 Python，Mysql</p>
</li>
<li>
<p><strong>/home</strong></p>
<p>用户目录</p>
</li>
<li>
<p><strong>/bin</strong></p>
<p>存放用户级别的 Linux 工具，例如 cat, ls, chown</p>
</li>
<li>
<p><strong>/sbin</strong></p>
<p>存放 root 用户才能用的 Linux 工具</p>
</li>
</ul>
<h3 id="忘记了命令怎么使用怎么办"><a class="header" href="#忘记了命令怎么使用怎么办">忘记了命令怎么使用怎么办？</a></h3>
<p>如果忘记了某个命令的使用，我们有两个方法：</p>
<pre><code class="language-bash">cmd --help

man cmd
</code></pre>
<p>而不是去百度！</p>
<h3 id="linux-环境变量到底是什么"><a class="header" href="#linux-环境变量到底是什么">Linux 环境变量到底是什么</a></h3>
<p>Linux 的环境变量指的是系统中的各种重要的变量，环境变量并不是 PATH ！环境变量是一系列 key-value 的键值对。我们可以使用 <code>printenv</code> 来查看所有的环境变量：</p>
<pre><code class="language-bash">SHELL=/bin/bash
TERM=xterm
HISTSIZE=1000
OLDPWD=/home/work/webservice/redis/redis/redis-stable/src
USER=work
VIRTUAL_ENV=/home/work/webservice/venv
MAIL=/var/mail/work
PATH=/home/work/webservice/venv/bin:/home/work/bin:/home/work/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/snap/bin
PWD=/home/work/webservice/redis/redis/redis-stable
LANG=en_US.utf8
PS1=(venv) \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ 
SHLVL=1
HOME=/home/work
LOGNAME=work
LESSOPEN=| /usr/bin/lesspipe %s
PROMPT_COMMAND=history -a; 
DISPLAY=localhost:10.0
LESSCLOSE=/usr/bin/lesspipe %s %s
HISTTIMEFORMAT=%F %T 
_=/usr/bin/printenv
</code></pre>
<h3 id="linux-是如何安装软件的configure--make-sudo-make-install"><a class="header" href="#linux-是如何安装软件的configure--make-sudo-make-install">Linux 是如何安装软件的？configure / make /sudo make install</a></h3>
<p><a href="https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install">The magic behind configure, make, make install</a></p>
<p>There are three distinct steps in this process:</p>
<pre><code class="language-bash">./configure # check env and config
make # 编译源码，生成可执行文件
sudo make install # 将二进制执行文件，库，文档拷贝到系统相关的位置。
</code></pre>
<ol>
<li>
<p>Configure the software</p>
<p>The <code>configure</code> script is responsible for getting ready to build the software on your specific system. It makes sure all of the dependencies for the rest of the build and install process are available, and finds out whatever it needs to know to use those dependencies.</p>
<p>Unix programs are often written in C, so we’ll usually need a C compiler to build them. In these cases the <code>configure</code> script will establish that your system does indeed have a C compiler, and find out what it’s called and where to find it.</p>
</li>
<li>
<p>Build the software</p>
<p>Once <code>configure</code> has done its job, we can invoke <code>make</code> to build the software. This runs a series of tasks defined in a <code>Makefile</code> to build the finished program from its source code.</p>
<p>The tarball you download usually doesn’t include a finished <code>Makefile</code>. Instead it comes with a template called <code>Makefile.in</code> and the <code>configure</code> script produces a customised <code>Makefile</code> specific to your system.</p>
</li>
<li>
<p>Install the software</p>
<p>Now that the software is built and ready to run, the files can be copied to their final destinations. The <code>make install</code> command will <strong>copy</strong> the built program, and its libraries and documentation, to the correct locations.</p>
<p>This usually means that the program’s binary will be copied to a directory on your <code>PATH</code>, the program’s manual page will be copied to a directory on your <code>MANPATH</code>, and any other files it depends on will be safely stored in the appropriate place.</p>
<p>Since the install step is also defined in the <code>Makefile</code>, where the software is installed can change based on options passed to the <code>configure</code> script, or things the <code>configure</code> script discovered about your system.</p>
<p>Depending on where the software is being installed, you might need escalated permissions for this step so you can copy files to system directories. Using <code>sudo</code> will often do the trick.</p>
</li>
</ol>
<h3 id="linux-usr-文件夹到底是啥"><a class="header" href="#linux-usr-文件夹到底是啥">Linux /usr 文件夹到底是啥？</a></h3>
<p><a href="https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/usr.html">Linux 官方文档解释</a></p>
<p><code>usr</code> 文件夹中包含了所有用户的二进制可执行文件、文档、库文件、依赖、头文件等各种用户相关的只读文件。用户的程序，例如 ftp, telnet 都安装在这个目录中。在 Unix 最初的设计中，<code>/usr</code> 被设计为用户的 home 目录，也就是说，<code>/usr/someone</code> 就是现在的 <code>/home/someone</code>。在现在的 Unix 系统中，<code>/usr</code> 的作用变窄，从存储任何用户相关的数据和程序，到存储用户安装的程序及其产生的数据。(<code>from &quot;everything user related&quot; to &quot;user usable programs and data&quot;</code>) </p>
<p>我的理解：<code>/usr</code> 中存放了一切和应用程序相关的<strong>静态只读数据</strong>，类似于 <strong>Windows 的 Program files</strong> 文件夹。</p>
<table><thead><tr><th>文件夹</th><th>解释</th><th>我的理解</th></tr></thead><tbody>
<tr><td><code>/usr/bin</code></td><td>This directory contains the vast majority of binaries on your system. Executables in this directory vary widely. For instance vi, gcc, gnome-session and mozilla and are all found here.</td><td>存放二进制可执行文件，有很多软链接</td></tr>
<tr><td><code>/usr/sbin</code></td><td>This directory contains programs for administering a system, meant to be run by 'root'.</td><td>存放 root 用户才有权使用的二进制可执行文件</td></tr>
<tr><td><code>/usr/doc</code></td><td>The central documentation directory. Documentation is actually located in <code>/usr/share/doc</code> and linked from here.</td><td>存放应用程序的说明文档，大多是软链接，源文件地址在 <code>/usr/share/doc</code></td></tr>
<tr><td><code>/usr/include</code></td><td>The directory for 'header files', needed for compiling user space source code.</td><td>存放应用程序的头文件</td></tr>
<tr><td><code>/usr/include/'package-name'</code></td><td>Application specific header files.</td><td></td></tr>
<tr><td><code>/usr/lib</code></td><td>This directory contains program libraries. Libraries are collections of frequently used program routines.</td><td>存放程序执行依赖的库文件</td></tr>
<tr><td><code>/usr/local</code></td><td>keep self-compiled or third-party programs. The /usr/local hierarchy is for use by the system administrator when installing software locally.</td><td>存放 <strong>root</strong> 用户自编译和安装的第三方应用</td></tr>
<tr><td><code>/usr/share</code></td><td>This directory contains 'shareable', architecture-independent files (docs, icons, fonts etc).</td><td>存放应用程序的一些只读的静态文件</td></tr>
<tr><td><code>/usr/share/doc</code></td><td>Location of package specific documentation files.</td><td>存放应用程序的文档</td></tr>
<tr><td><code>/usr/share/man</code></td><td>Manual pages.</td><td>应用程序手册</td></tr>
<tr><td><code>/usr/src</code></td><td>The 'linux' sub-directory holds the Linux kernel sources, header-files and documentation.</td><td>存放 Linux 内核相关的文件。</td></tr>
<tr><td><code>/proc</code></td><td>/proc is very special in that it is also a virtual filesystem. It's sometimes referred to as a process information pseudo-file system. It doesn't contain 'real' files but runtime system information (e.g. system memory, devices mounted, hardware configuration, etc). For this reason it can be regarded as a control and information centre for the kernel. In fact, quite a lot of system utilities are simply calls to files in this directory. For example, 'lsmod' is the same as 'cat /proc/modules' while 'lspci' is a synonym for 'cat /proc/pci'. By altering files located in this directory you can even read/change kernel parameters (sysctl) while the system is running.</td><td>process 信息</td></tr>
</tbody></table>
<p>问题：如何找到系统安装的 Mysql 中存储的数据？</p>
<h3 id="linux-中-mysql-数据库中存储的数据存放在那里"><a class="header" href="#linux-中-mysql-数据库中存储的数据存放在那里">Linux 中 Mysql 数据库中存储的数据存放在那里？</a></h3>
<p>Mysql 存储的数据属于动态数据，所以不能存放在静态文件夹 <code>/usr</code> 中，实际上存放在了<strong>动态文件夹</strong> <code>/var</code> (<code>variable</code>) 中。如果具体去分析，Mysql 的数据实际存放在了 <code>/var/lib</code> 中。</p>
<h2 id="ubuntu-初始化"><a class="header" href="#ubuntu-初始化">Ubuntu 初始化</a></h2>
<h3 id="切换软件仓库源"><a class="header" href="#切换软件仓库源">切换软件仓库源</a></h3>
<p>Ubuntu 安装软件是统一从一个软件仓库进行安装，但是该仓库源的速度非常慢，所以通常会切换成国内的源：</p>
<p><a href="http://mirrors.ustc.edu.cn/help/ubuntu.html">中科大 ubuntu 源</a></p>
<h3 id="新建用户给用户配置-sudo"><a class="header" href="#新建用户给用户配置-sudo">新建用户，给用户配置 sudo</a></h3>
<p>Ubuntu 安装软件的命令是 apt-get，普通用户使用的画，需要加 sudo，为了方便普通用户的使用，需要授予用户  sudo 的权限：</p>
<pre><code class="language-bash"># 新建 work 用户
useradd -m -c &quot;for work&quot; -u 8888 -p passwd? -s /bin/bash work
# 授予 work 用户 sudo 权限
visudo
# 在最后一行添加：work ALL=(ALL:ALL) NOPASSWD:ALL
</code></pre>
<h3 id="python-初始化"><a class="header" href="#python-初始化">Python 初始化</a></h3>
<p>ubuntu16.04 自带了两个 Python 版本：Python2.7 和 Python3.5 (从 /usr/bin 中可以看出)，和 apt-get 一样，Python 的包管理器的仓库源速度也非常慢，也需要切换到国内的源：</p>
<pre><code class="language-bash">mkdir -p ~/.config/pip/ &amp;&amp; cd $_
touch pip.conf
echo -e [global]\\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple &gt; pip.conf
</code></pre>
<p>Python 要配合 virtualenv 来使用：</p>
<pre><code class="language-bash">pip install virtualenv
virtualenv -p python3 venv # python3.5
source venv/bin/activate
deactivate
</code></pre>
<h2 id="linux-提高工作效率的工具"><a class="header" href="#linux-提高工作效率的工具">Linux 提高工作效率的工具</a></h2>
<p>Xshell，Xftp，Samba，MobaXterm，VSCode Remote-SSH</p>
<h3 id="xshell--xftp"><a class="header" href="#xshell--xftp">Xshell / Xftp</a></h3>
<ul>
<li>
<p>多窗口多任务模式</p>
<p><img src="computer-science-notebook/linux/assets/1574584401783.png" alt="多窗口工作" /></p>
</li>
<li>
<p>利用 Xftp 实现大文件的快速上传(云服务器往往下行带宽很小，上行带宽很大)。</p>
</li>
<li>
<p>利用 Xftp 实现云端文本本地编辑 <a href="https://blog.csdn.net/xuezhisdc/article/details/49621231">设置Notepad++为默认文本编辑器</a></p>
</li>
</ul>
<h3 id="moboxterm"><a class="header" href="#moboxterm">MoboXterm</a></h3>
<p>终端神器</p>
<p>链接：https://pan.baidu.com/s/1UGv8kn3fdsjiuM1NXZ7oBQ 
提取码：yivm</p>
<h3 id="vscode-remote-ssh"><a class="header" href="#vscode-remote-ssh">VSCode Remote-SSH</a></h3>
<p><a href="https://www.cnblogs.com/liyufeia/p/11405779.html">Remote-SSH</a> </p>
<p>远程连接服务器，编写代码的工具，类似于 Samba。</p>
<p><strong>Secure Shell</strong> (<strong>SSH</strong>) is a <a href="https://en.wikipedia.org/wiki/Cryptography">cryptographic</a> <a href="https://en.wikipedia.org/wiki/Network_protocol">network protocol</a> for operating network services securely over an unsecured network.[<a href="https://en.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1">1]</a> Typical applications include remote <a href="https://en.wikipedia.org/wiki/Command-line_interface">command-line</a>, <a href="https://en.wikipedia.org/wiki/Login">login</a>, and remote command execution, but any <a href="https://en.wikipedia.org/wiki/Network_service">network service</a> can be <strong>secured</strong> with SSH.</p>
<p>SSH provides a <a href="https://en.wikipedia.org/wiki/Secure_channel">secure channel</a> over an unsecured network by using a <strong><a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client–server</a></strong> architecture, connecting an <a href="https://en.wikipedia.org/wiki/SSH_client">SSH client</a> application with an <a href="https://en.wikipedia.org/wiki/SSH_server">SSH server</a>.</p>
<h3 id="zsh"><a class="header" href="#zsh">zsh</a></h3>
<p>一款最流行的 shell.</p>
<p>https://ohmyz.sh/</p>
<h2 id="linux-开发"><a class="header" href="#linux-开发">Linux 开发</a></h2>
<ul>
<li>
<p><strong>cmake</strong>, <strong>qmake</strong>, <strong>make</strong> 命令的区别</p>
<p>cmake 和 qmake 都是用于生成 makefile，make 工具调用 makefile 中的命令，对大型工程进行编译</p>
</li>
</ul>
<h2 id="在-windows-系统上进行-linux-开发"><a class="header" href="#在-windows-系统上进行-linux-开发">在 Windows 系统上进行 Linux 开发</a></h2>
<p>想要实现在 Windows 上进行 Linux 开发，虚拟机太笨重，占用 Windows 系统太多的资源，Windows10 提供了一个 Linux 子系统，WSL：Windows Subsystem for Linux，与 Windows 深度融合，可以通过 VSCode + Remote-WSL 访问 Linux 子系统</p>
<p><a href="https://blog.csdn.net/qq_36634690/article/details/108011872">[Win10 使用WSL 配合VSCode 搭建C/C++开发环境]</a></p>
<p>令我感到惊奇的是，两个系统的互通性极强，体现在：</p>
<ul>
<li>
<p>WSL 共享 Windows 的网络（在 wsl 中 <code>ifconfig</code> 显示的信息与 Windows <code>ipconfig</code> 显示的信息一致），都可以互相 Ping 通，子系统的 IP 地址就是 <code>127.0.0.1</code>，也就是在 Windows 上，可以通过 <code>127.0.0.1</code> 访问 Linux 子系统</p>
<img align='left' src="computer-science-notebook/linux/assets/image-20200913111750152.png" alt="image-20200913111750152" style="zoom:67%;" />
</li>
<li>
<p>通过 Remote-WSL + VSCode，我可以直接在 VSCode 上打开 Linux 上的 project 进行开发，Windows 的 VSCode 充当了 Linux 的图形化开发界面</p>
<img align='left' src="computer-science-notebook/linux/assets/image-20200913112611902.png" alt="image-20200913112611902" style="zoom:67%;" />
</li>
<li>
<p>在测试 Python 的时候，我安装了 Django，由于 Linux 的子系统 IP 就是 <code>127.0.0.1</code>，所以我可以直接在 Windows 系统中访问 Django Web 服务</p>
<img align="left" src="computer-science-notebook/linux/assets/image-20200913112823735.png" alt="image-20200913112823735" style="zoom: 50%;" />
</li>
<li>
<p>文件传输：可以直接右击 VSCode 的 project，选择 Reveal in Explorer 来打开 Linux 的文件，进行两个系统的文件传输</p>
</li>
<li>
<p>连接 WSL，不需要打开 WSL App，只需要在用 VSCode 的 Remote-WSL 插件连接就行了，WSL 应该有一个后台服务一直在跑</p>
</li>
<li>
<p>WSL 可以通过配置 Windows 的代理实现 fq</p>
</li>
</ul>
<p><strong>以后开发，尽量都在 ubuntu 子系统中进行开发。</strong></p>
<h2 id="wsl-使用技巧"><a class="header" href="#wsl-使用技巧">WSL 使用技巧</a></h2>
<p>in ubuntu, type <code>code .</code>，就可以激活 VSCode 打开当前文件夹</p>
<p>使用 file - open folder 来打开文件夹。</p>
<h2 id="linux-兼容-windows-应用"><a class="header" href="#linux-兼容-windows-应用">Linux 兼容 Windows 应用</a></h2>
<p><a href="https://github.com/Fmstrat/winapps">winapps</a></p>
<p>一个在 Ubuntu 里面运行 Windows 应用的虚拟机，特点是 Windows 应用就像 Linux 的原生应用一样，直接运行，而不会出现 Windows 的系统环境。</p>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="虚拟机-buffcache-占用内存太大"><a class="header" href="#虚拟机-buffcache-占用内存太大">虚拟机 buff/cache 占用内存太大</a></h3>
<p><a href="https://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/">https://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/</a></p>
<p>buff 是准备写入磁盘的缓存，cache 是从磁盘读出内容的缓存。 buff/cache 占用过高的原因在于，频繁的从磁盘读写文件，例如读取模型文件，读写文本文件。</p>
<p>如果我们释放了缓存，那么会增加磁盘的读写压力，所以还是小心为妙。</p>
<p>释放缓存的命令：</p>
<pre><code class="language-shell">sync; echo 1 &gt; /proc/sys/vm/drop_caches # 效果最好 Clear PageCache， 只推荐用这一种方式
sync; echo 2 &gt; /proc/sys/vm/drop_caches # Clear dentries and inodes
sync; echo 3 &gt; /proc/sys/vm/drop_caches # Clear PageCache, dentries and inodes
# sync 用于将 buff 写入磁盘
</code></pre>
<p>如果非要释放缓存不可，我们可以用 crontab 定期在深夜进行缓存的释放，并且在释放前，要先 sync，再释放.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-devops"><a class="header" href="#linux-devops">Linux Devops</a></h1>
<p>[TOC]</p>
<h2 id="服务管理"><a class="header" href="#服务管理">服务管理</a></h2>
<p>参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/starting-elasticsearch.html">elastic-search service</a></p>
<h3 id="systemd"><a class="header" href="#systemd">Systemd</a></h3>
<h4 id="部署守护进程服务"><a class="header" href="#部署守护进程服务">部署守护进程/服务</a></h4>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">阮一峰 Systemd 入门教程：实战篇</a> </p>
<ol>
<li>-创建服务启动脚本 auth.sh</li>
</ol>
<pre><code class="language-shell">#!/bin/csh
source /users/ems/.cshrc
cd $WEBSOPHIC_HOME/nr_cloud/service/auth
java -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC auth-service.jar
</code></pre>
<ol start="2">
<li>
<p>在 <code>/usr/lib/systemd/system</code> 中新建系统运行脚本 <code>auth.service</code>，<code>.service</code> 只是一种命名方式</p>
<p>dpkg 安装的软件，在 <code>/usr/lib/systemd/system</code> 下会创建一个服务。</p>
<pre><code class="language-shell">[Unit]
Description=auth service
After=src.service           # 指定要在哪个服务之后开启

[Service]
Type=simple
User=root # 指定用户
EnvironmentFile=/users/xxx/xxx/etc/web-env # 指定环境变量所在文件
ExecStart=/users/xxx/xxx/xxx/bin/auth.sh # 启动脚本绝对路径
ExecReload=/bin/kill -s HUP $MAINPID # $MAINPID 是存在的
ExecStop=/bin/kill -s QUIT $MAINPID
Restart=always # 服务挂掉后，立即重启
PrivateTmp=true

[Install]
WantedBy=multi-user.target
</code></pre>
</li>
<li>
<p>重新加载系统运行脚本：<code>systemctl daemon-reload</code></p>
</li>
<li>
<p>启动服务：<code>systemctl start auth.service</code>，也可以简写成 <code>systemctl start auth</code></p>
</li>
<li>
<p>配置服务开机自启：<code>systemctl enable auth</code></p>
</li>
<li>
<p>关闭开启自启： <code>systemctl disable auth</code></p>
</li>
<li>
<p>查看服务状态：<code>systemctl status auth</code> 这个很重要！</p>
</li>
</ol>
<p>服务部署完后，即使是服务被 kill 掉了，还是会马上自启！</p>
<pre><code>ExecReload 字段：重启服务时执行的命令
ExecStop 字段：停止服务时执行的命令
ExecStartPre 字段：启动服务之前执行的命令
ExecStartPost 字段：启动服务之后执行的命令
ExecStopPost 字段：停止服务之后执行的命令
</code></pre>
<p>注意，ExecStart 配置的路径，必须是绝对路径！</p>
<h3 id="systemctl-1"><a class="header" href="#systemctl-1">systemctl</a></h3>
<p>systemctl 和 docker 有点类似，都对软件的开启关闭重启注册开启自启进行了封装。</p>
<pre><code class="language-shell"># 列出当前系统服务的状态
systemctl list-units

# 查看服务是否开机自启
systemctl list-unit-files

# 查看指定服务的状态 -l: 查看详细信息
systemctl status -l xxx

# 开启指定服务
systemctl start xxx           

# 从新启动服务
systemctl restart sshd          

# 设定指定服务开机开启
systemctl enable sshd           

# 设定指定服务开机关闭
systemctl disable sshd          

# 使指定服务从新加载配置
systemctl reload sshd           

</code></pre>
<h3 id="journalctl"><a class="header" href="#journalctl">journalctl</a></h3>
<p>指定某个服务的日志进行查看</p>
<p><code>journalctl -u elastic-search</code></p>
<h3 id="sysvinit"><a class="header" href="#sysvinit">Sysvinit</a></h3>
<h2 id="网络问题"><a class="header" href="#网络问题">网络问题</a></h2>
<h3 id="测试远程主机的端口是否打开"><a class="header" href="#测试远程主机的端口是否打开">测试远程主机的端口是否打开</a></h3>
<pre><code class="language-shell">telnet ip port
# 退出 telnet：ctrl + ]，然后 quit
</code></pre>
<h3 id="关闭防火墙"><a class="header" href="#关闭防火墙">关闭防火墙</a></h3>
<pre><code class="language-shell">firewall-cmd --zone=public --add-port=3306/tcp --permanent
firewall-cmd --reload
</code></pre>
<pre><code class="language-shell">systemctl stop firewalld # 关闭防火墙 system-control
</code></pre>
<p>能 ping 通，但是访问不了，netstat 看一下端口，可能是防火墙的问题</p>
<h3 id="查看端口被哪个进程占用"><a class="header" href="#查看端口被哪个进程占用">查看端口被哪个进程占用</a></h3>
<p>netstat 用于显示网络相关信息，可以用于查看端口被那个进程占用了</p>
<pre><code class="language-shell">netstat -tunpl | grep 端口号
</code></pre>
<p>lsof - list open files</p>
<pre><code class="language-shell">lsof -i:port # 查看指定端口被哪个进程占用，功能类似于 netstat -tunpl | grep 端口号
</code></pre>
<h2 id="开机自启"><a class="header" href="#开机自启">开机自启</a></h2>
<p><strong>全局-面向所有用户</strong></p>
<ul>
<li><code>/etc/rc.local</code> 每次OS启动都会执行一次,所以一般放服务器管理方面的</li>
<li><code>/etc/profile</code> 每次login都会被执行一次,修改后,下次用户登录就会生效,不需要重启</li>
</ul>
<p><strong>面向某个用户</strong></p>
<p>用户登录时，shell 会按照以下顺序查找文件，并运行第一个被找到的文件，其余的则被忽略（三个文件不一定全都存在）</p>
<ul>
<li><code>$HOME/.bash_profile</code> # <code>.bash_profile</code> 会去执行 <code>.bashrc</code> 文件</li>
<li><code>$HOME/.bash_login</code></li>
<li><code>$HOME/.profile</code></li>
</ul>
<h2 id="进程相关"><a class="header" href="#进程相关">进程相关</a></h2>
<p>基本思想：</p>
<p><strong>我们远程登陆的每一个终端，实际上都是一个 shell 进程，在该终端中运行的每个命令，都是new一个子进程（也叫作业），如果我们运行的是一个脚本，那么就会new一个子shell来运行该脚本我们在终端中输入的任何命令（或发送信号），实际上都是和 shell 进程进行交互。当我们退出终端时，那么该终端的所有子进程（包括后台模式的进程）都会结束。</strong></p>
<p>这解释了，为什么我们用 <code>&amp;</code> 实现后端守护进程后，在关闭终端还是挂掉了，因为父 shell 结束了！如果想要在终端关闭时，保证后台进程不关闭，就要用 <code>nohup</code></p>
<h3 id="与-bash-交互-ctrl--c-ctrl--z-kill--9"><a class="header" href="#与-bash-交互-ctrl--c-ctrl--z-kill--9">与 bash 交互 ctrl + C, ctrl + Z, kill -9</a></h3>
<p>Ctrl + c 会生成 SIGINT(中止进程) 信号，并将其发送到 shell 中运行的所有进程，中止所有运行在该 shell 中的子进程。</p>
<p>Ctrl + z 会生成 SIGTSTP (暂停进程) 信号，并将其发送到 shell 中运行的所有进程，暂停所有子进程。</p>
<p><code>kill -9 pid</code> 会发送一个 SIGKILL（无条件终止） 信号，并杀死指定 pid 的进程</p>
<h3 id="后台模式详解"><a class="header" href="#后台模式详解">后台模式详解 &amp;</a></h3>
<p>后台模式运行的进程，会将该进程与 bash shell 分离，将该进程作为系统中的一个独立的后台进程运行。</p>
<p>后台模式运行的进程，其仍然会将标准输出和标准错误输出打印到终端。</p>
<p>后台模式运行的进程，在终端 exit 的时候，同样会被杀死</p>
<h3 id="nohup-在-exit-时保留该进程"><a class="header" href="#nohup-在-exit-时保留该进程">nohup 在 exit 时保留该进程</a></h3>
<p>nohup 可以实现脚本一直运行，不管 shell 是否 exit。注意，nohup 会将脚本执行的所有输出，包括标准错误输出，都重定向到一个叫 <code>nohup.out</code> 的文件中。</p>
<p>Demo:</p>
<pre><code class="language-shell">nohup python demo.py &amp;
</code></pre>
<h3 id="作业控制-jobs-kill-bg-fg"><a class="header" href="#作业控制-jobs-kill-bg-fg">作业控制 jobs, kill, bg, fg</a></h3>
<p>jobs 命令 和 kill 命令用于 shell 进程中所有子进程的作业控制。</p>
<p>Demo:</p>
<pre><code class="language-shell">jobs # 查看所有后台进程，带 + 号的作业是默认作业，当前的默认作业完成后，带减号的成为下一个默认作业，任何时候，都只有一个带 + 号的作业和一个带 — 号的作业
jobs -l # 查看详细信息

kill pid # 默认发送一个 SIGHUP（挂起进程） 信号给 pid 进程

# bg 以后台模式重启停止的作业
python demo.py
ctrl + Z # 脚本暂停执行
bg # 以后台模式重启默认作业（带 + 号的作业）
bg job_id # # 按照作业 id 以后台模式重启指定的作业

# fg 以前台模式重启某作业 
fg job_id
</code></pre>
<h3 id="nice-renice-调整进程优先级"><a class="header" href="#nice-renice-调整进程优先级">nice, renice 调整进程优先级</a></h3>
<p>调度优先级是一个整数，从 -20 — +19，-20 优先级最高，+19 优先级最低。默认情况下， bash shell 中的子进程的 nice 值都是 0。注意：0 以下的优先级，只有 root 用户可以分配。</p>
<p>Demo</p>
<pre><code class="language-shell">nice -n 0 python demo.py # 指定优先级 0 来运行脚本 demo.py

# renice 
# 注意：只能通过 renice 来降低进程优先级，如果想要通过 renice 提高优先级，只能使用 root 权限（sudo）
renice -n 10 -p pid 
</code></pre>
<h2 id="expect-交互式自动化"><a class="header" href="#expect-交互式自动化">expect 交互式自动化</a></h2>
<p>https://linux.die.net/man/1/expect</p>
<p>expect 是一款 Linux 系统的软件，用 expect 可以定义脚本，用于和交互式的程序进行自动化交互。</p>
<p><strong>Expect</strong> is a program that &quot;talks&quot; to other interactive programs according to a script.</p>
<p>Expect 包含以下常用命令：</p>
<h3 id="spawn"><a class="header" href="#spawn">spawn</a></h3>
<p>Creates a new process running <em>program args</em>. Its stdin, stdout and stderr are connected to Expect, so that they may be read and written by other <strong>Expect</strong> commands. The connection is broken by <strong>close</strong> or if the process itself closes any of the file identifiers.</p>
<h3 id="exp_continue"><a class="header" href="#exp_continue">exp_continue</a></h3>
<p>The command <strong>exp_continue</strong> allows <strong>expect</strong> itself to continue executing rather than returning as it normally would. By default <strong>exp_continue</strong> resets the timeout timer.</p>
<p>继续执行</p>
<h3 id="expect"><a class="header" href="#expect">expect</a></h3>
<p>waits until one of the patterns matches the output of a spawned process, a specified time period has passed, or an end-of-file is seen.</p>
<pre><code class="language-shell">expect {
    busy               {puts busy\n ; exp_continue}
    failed             abort
    &quot;invalid password&quot; abort
    timeout            abort
    connected
}
</code></pre>
<h3 id="interact"><a class="header" href="#interact">interact</a></h3>
<p>gives control of the current process to the user, so that keystrokes are sent to the current process, and the stdout and stderr of the current process are returned.</p>
<p>把控制权交给终端用户，并且把运行结果打印出来。</p>
<h3 id="send"><a class="header" href="#send">send</a></h3>
<p>Sends <em>string</em> to the current process. For example, the command</p>
<pre><code>send &quot;hello world\r&quot;
</code></pre>
<p>sends the characters, h e l l o <blank> w o r l d <return> to the current process. (Tcl includes a printf-like command (called <strong>format</strong>) which can build arbitrarily complex strings.)</p>
<h3 id="demos-4"><a class="header" href="#demos-4">demos</a></h3>
<pre><code class="language-shell">#!/usr/bin/expect
set timeout 10
spawn ssh -X -p [lindex $argv 0] [lindex $argv 1]
expect {
        &quot;Are you sure you want?*&quot;     
        {
                send &quot;yes\r&quot;
                exp_continue
        }
        &quot;(yes/no)?*&quot;     
        {
                send &quot;yes\r&quot;
                exp_continue
        }
        &quot;*assword:*&quot;
        {
                send &quot;[lindex $argv 2]\r&quot;
        }
        timeout {
                puts &quot;connect is timeout&quot;
                exit 3
        }
    }
interact
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-初始化"><a class="header" href="#linux-初始化">Linux 初始化</a></h1>
<p>1991 年， Linux 诞生。</p>
<p>[TOC]</p>
<h2 id="1-系统安装"><a class="header" href="#1-系统安装">1. 系统安装</a></h2>
<p>先到 中科大镜像网站下载 Ubuntu 17.10 版本的ISO镜像文件，然后解压到U盘里面</p>
<p>此为下载链接：
http://mirrors.ustc.edu.cn/ubuntu-releases/17.10/ubuntu-17.10.1-desktop-amd64.iso</p>
<p>常用软件的下载链接（Google Chrome、为知笔记、坚果云、markdown编辑器、搜狗输入法、Anaconda、Lantern）
链接：https://pan.baidu.com/s/1w1Cy8JNGvmqEnJtl-lH4aA 密码：t2dv</p>
<p>系统安装教程
https://jingyan.baidu.com/article/e3c78d6460e6893c4c85f5b1.html</p>
<p>在安装的时候，把软件更新和另外一个选项都勾选</p>
<h2 id="2-切换ubuntu的源地址"><a class="header" href="#2-切换ubuntu的源地址">2. 切换Ubuntu的源地址</a></h2>
<p><strong>安装好linux后，第一件事，就是先切换源。</strong></p>
<p><strong>安装好linux后，第一件事，就是先切换源。</strong></p>
<p><strong>安装好linux后，第一件事，就是先切换源。</strong></p>
<p>在软件更新（update）中，直接切换成中科大的镜像源就好
http://mirrors.ustc.edu.cn/help/ubuntu.html </p>
<p>切换完后，记得更新一下：<code>sudo apt-get update</code></p>
<p>在update源信息的过程中，如果出现error，记住这个链接，然后打开software和更新，到<code>Other Software</code>中将对应的链接源删除。就不会再报错。</p>
<h2 id="安装经验"><a class="header" href="#安装经验">安装经验</a></h2>
<ol>
<li>没用的软件不要乱删除</li>
<li>系统不要随便更新</li>
</ol>
<h2 id="3-安装中文输入法"><a class="header" href="#3-安装中文输入法">3. 安装中文输入法</a></h2>
<p>不建议安装搜狗输入法和rime输入法，</p>
<p>先安装 <strong>fcitx</strong> 框架，然后再安装<strong>sunpinyin</strong> 输入法</p>
<p>切换 fcitx 的步骤：
系统设置 ——&gt; 区域和语言 ——&gt; Manage Installed Languages ——&gt; 切换键盘输入法系统为 fcitx</p>
<p>添加sunpinyin输入法的步骤：
sudo apt-get install fcitx-sunpinyin
系统设置 ——&gt; 区域和语言 ——&gt; 点击左下角的加号 ——&gt; 点击<strong>汉语</strong>(注意汉语里面还有选项) ——&gt; 选择 sunpinyin 输入法</p>
<h2 id="4-安装-sh-格式的软件"><a class="header" href="#4-安装-sh-格式的软件">4. 安装 .sh 格式的软件</a></h2>
<p>举例：Anaconda</p>
<p>下载好Anaconda后，先设置Anaconda.sh文件可执行（<code>chmod 777 anaconda.sh</code>），然后再 <code>./ anaconda.sh </code> 安装</p>
<p>安装的时候，不要离开安装的窗口，否则Anaconda的path不会被引入，导致Spyder不能被打开，如果确实打不开Spyder，那么参考如下的方法：http://blog.csdn.net/x_lock/article/details/53170321</p>
<h2 id="5-安装deb软件的命令"><a class="header" href="#5-安装deb软件的命令">5. 安装deb软件的命令</a></h2>
<p><code>sudo dpkg -i name.deb</code></p>
<p>如果出现包依赖的问题，那么fix一下：</p>
<p><code>sudo apt-get install -f</code></p>
<p>-f 是 --fix-broken  的简写</p>
<p>通常安装某一个deb软件的标准流程就是：</p>
<pre><code>sudo dpkg -i name.deb
sudo apt-get install -f
</code></pre>
<p>此方法适用于安装所有的deb软件</p>
<h2 id="6-安装appimage的软件"><a class="header" href="#6-安装appimage的软件">6. 安装AppImage的软件</a></h2>
<p>举例：安装  为知笔记</p>
<p>为知笔记的安装包是 AppImage 格式的，该要设置该文件为可执行，然后直接双击执行就好了。</p>
<h2 id="7-apt-get-命令介绍"><a class="header" href="#7-apt-get-命令介绍">7. apt-get 命令介绍</a></h2>
<p>apt advance package tools</p>
<p>首先 apt-get 是一个命令，它和 ls 等命令一样，都是命令。</p>
<p>命令详解：</p>
<h3 id="更换源后的更新命令"><a class="header" href="#更换源后的更新命令">更换源后的更新命令</a></h3>
<p><code>sudo apt-get update</code></p>
<h3 id="安装一个新的软件"><a class="header" href="#安装一个新的软件">安装一个新的软件</a></h3>
<p>直接查看apt工具集里有没有该软件</p>
<p><code>sudo apt-get install packagename</code></p>
<p>例如安装 git</p>
<p><code>sudo apt-get install git</code></p>
<h3 id="卸载一个已安装的软件包保留配置文件"><a class="header" href="#卸载一个已安装的软件包保留配置文件">卸载一个已安装的软件包（保留配置文件）</a></h3>
<p><code>sudo apt-get remove packagename</code></p>
<h3 id="卸载一个已安装的软件包删除配置文件"><a class="header" href="#卸载一个已安装的软件包删除配置文件">卸载一个已安装的软件包（删除配置文件）</a></h3>
<p><code>sudo apt-get --purge remove packagename</code></p>
<h3 id="更新所有已经安装的软件"><a class="header" href="#更新所有已经安装的软件">更新所有已经安装的软件</a></h3>
<p><code>sudo apt-get upgrade</code></p>
<h3 id="将系统升级到最新版本"><a class="header" href="#将系统升级到最新版本">将系统升级到最新版本</a></h3>
<p><code>sudo apt-get dist-upgrade</code></p>
<h2 id="linux-磁盘分区"><a class="header" href="#linux-磁盘分区">Linux 磁盘分区</a></h2>
<h2 id="修改主题"><a class="header" href="#修改主题">修改主题</a></h2>
<pre><code>安装Gnome-tweak-tool
sudo apt-get install gnome-tweak-tool
打开软件商城，分别安装如下几个插件：
user themes
dash to dock

安装 Numix 主题和图标
sudo add-apt-repository ppa:numix/ppa
sudo apt-get update
sudo apt-get install numix-gtk-theme numix-icon-theme-circle

打开 Utilities中的Tweaks，开始设置
</code></pre>
<h2 id="适配hexo"><a class="header" href="#适配hexo">适配Hexo</a></h2>
<p>https://blog.csdn.net/lyb3b3b/article/details/78706077</p>
<h2 id="小知识"><a class="header" href="#小知识">小知识</a></h2>
<p>ubuntu 17.10截图命令：shift + printSc键</p>
<h2 id="sdkman"><a class="header" href="#sdkman">SDKMan</a></h2>
<p>利用 https://sdkman.io/ SDKMAN 来安装开发环境。</p>
<p>DEMO：</p>
<pre><code class="language-shell">sdk install java
sdk install scala 2.12.1
sdk list # 查看当前仓库有哪些开发环境
sdk install spring
sdk current # 查看当前安装了哪些开发环境
</code></pre>
<p>SDKMan 安装的各种软件，其目录都在 <code>$HOME/.sdkman/</code> 下，可以用 which java 查看安装目录。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim-命令"><a class="header" href="#vim-命令">VIM 命令</a></h1>
<p>[TOC]</p>
<h2 id="查找-1"><a class="header" href="#查找-1">查找</a></h2>
<p>查找 是在命令模式下进行的。
在命令模式下输入&quot; <code>/ 要查找的子字符串</code>&quot;</p>
<p>按  <code>n</code>  重复上一个搜索模式。</p>
<h2 id="跳到文档开头或末尾"><a class="header" href="#跳到文档开头或末尾">跳到文档开头或末尾</a></h2>
<p>跳到文档开头: gg
跳到文档末尾: G
跳到指定行： nG 或 ngg， n 代表行数  或者在命令模式下直接输入行号，然后回车。</p>
<h2 id="翻页"><a class="header" href="#翻页">翻页</a></h2>
<pre><code>ctrl + F # 下一页 ctrl + forward
ctrl + B # 前一页 ctrl + backward
</code></pre>
<h2 id="光标移动"><a class="header" href="#光标移动">光标移动</a></h2>
<pre><code>0 光标移动到行首
$ 光标移动到行末
</code></pre>
<h2 id="复制-与-粘贴"><a class="header" href="#复制-与-粘贴">复制 与 粘贴</a></h2>
<pre><code>yy 复制光标所在行
nyy 复制光标所在的向下 n 行
yG 复制光标所在行到最后一行
p 粘贴在光标下一行
P 粘贴在光标上一行
</code></pre>
<h2 id="保存和离开命令"><a class="header" href="#保存和离开命令">保存和离开命令</a></h2>
<pre><code>:q! 不保存修改，强制离开
:wq! 强制保存后离开
</code></pre>
<h2 id="删除命令"><a class="header" href="#删除命令">删除命令</a></h2>
<pre><code>dd 删除光标所在的一整行
ndd 删除光标所在的向下 n 行
dG 删除光标所在行到最后一行的所有数据
ggdG 删除所有数据
</code></pre>
<h2 id="编辑"><a class="header" href="#编辑">编辑</a></h2>
<pre><code>u 撤销
a 在光标所在字符后面追加数据
A 在光标所在行行尾追加数据
x 删除光标所在位置的字符

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-bash"><a class="header" href="#shell-bash">Shell-Bash</a></h1>
<p>[TOC]</p>
<p>教程：https://github.com/dylanaraps/pure-bash-bible.git</p>
<h2 id="shell"><a class="header" href="#shell">shell</a></h2>
<p><strong>定义</strong>
内核 Kernel 管理计算机的硬件，内核需要被保护，一般用户只能通过 shell 来和内核通信。</p>
<p>shell 提供用户操作系统的接口</p>
<p><strong>为什么要学习 命令行 shell</strong></p>
<ol>
<li>各个 linux 系统发行版的 shell 通用</li>
<li>方便远程管理</li>
</ol>
<p><strong>shell 的种类</strong>
bourne again shell, C shell, k shell, tcsh, bourne shell(sh, zsh
Linux 默认使用 bourne again shell (bash)，即 bash, bash 兼容 sh</p>
<p>可以利用 <code>cat /etc/shells</code> 命令查看 linux 提供的 shell，默认使用 bash </p>
<p>查看当前所用 shell：</p>
<pre><code class="language-shell">echo $SHELL
</code></pre>
<table><thead><tr><th>shell</th><th>全称</th><th>介绍</th></tr></thead><tbody>
<tr><td>sh</td><td>Bourne shell</td><td>unix 默认 shell</td></tr>
<tr><td>bash</td><td>GNU Bourne-Again SHell</td><td>linux 默认 shell，兼容 sh</td></tr>
<tr><td>csh</td><td></td><td></td></tr>
<tr><td>zsh</td><td>Z shell</td><td>macOS 默认 shell，Oh My Zsh 是 zsh 的主题</td></tr>
</tbody></table>
<h2 id="bash"><a class="header" href="#bash">Bash</a></h2>
<p><strong>Bourne Again SHell</strong></p>
<p>Linux 是多用户、多任务的环境，每个人登录系统都能取得一个 bash。</p>
<p>bash 是 Linux 中的 标准 shell，优点如下：</p>
<ol>
<li>命令记忆能力：history</li>
<li>命令与文件补全功能：tab</li>
<li>程序脚本：shell script 小型程序语言</li>
<li>通配符</li>
</ol>
<p>进入子进程，打开一个新的 shell：<code>bash</code></p>
<p><img src="computer-science-notebook/linux/assets/1547349880487.png" alt="1547349880487" /></p>
<h2 id="变量相关"><a class="header" href="#变量相关">变量相关</a></h2>
<ol>
<li>环境变量通常用大写字符表示</li>
<li>变量在被显示时，前面必须加上字符 &quot;$&quot;</li>
<li>显示变量
<code>echo $variable, echo $PATH</code></li>
<li>赋值符号 = 两边不能加空格</li>
<li>设置变量： <code>myname=wanshuo</code>,这一这里 wanshuo 就是字符串，不需要加  &quot; &quot;</li>
<li>变量内如果有空格符，那么可以用 &quot;&quot; 或 '' 将内容结合，但是 &quot; &quot; 内的特殊字符如 $，可以保持原本的特性，例如 
<code>var=&quot;lang is $LANG&quot; 则 echo $var 可得 lang is en_US</code>，而 ' ' 内的所有字符都成了一般字符</li>
<li>增加变量内容：<code>varname=&quot;$varname&quot;增加的内容</code>
例如增加环境变量 ：<code>PATH=&quot;$PATH&quot;:/home/work </code></li>
<li>如果变量需要被子进程使用，那么 需要用 export 来使变量变成环境变量：<code>export varname</code></li>
<li>大写的变量通常为系统的环境变量，在任何进程下通用，小写的变量通常为用户在某个进程下自定义的变量</li>
<li>取消变量：<code>unset 变量名</code></li>
<li>转义字符 <code>\</code> 可以对特殊符号 <code>回车、空格、$ 、！ </code> 进行转义</li>
<li>在命令中运行命令，例如：</li>
</ol>
<pre><code class="language-script">version=$(uname -r) 或者
version=`uname -r` 运行命令，把结果复制给一个变量
echo $version 结果为 版本号
</code></pre>
<ol start="13">
<li>查看所有变量的命令 ：<code>set</code></li>
</ol>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<ol>
<li>查看环境变量的命令：<code>env</code>，<code>export</code></li>
</ol>
<h3 id="ps1-变量"><a class="header" href="#ps1-变量">PS1 变量</a></h3>
<p>PS1 变量用于设置 命令提示符，即 <code>[work@yq01-yq-qadev-wanshuo wanshuo]$</code>
打印 PS1 变量：<code>echo $PS1</code>，结果为：<code>[\u@\h \W]\$</code>，其中，[ ] 代表命令提示符的框框，PS1 变量的内容类似于正则表达式,
\u 表示目前用户的账号，@ 就是正常的 @ 字符， \h 表示取主机名在第一个小数点之前的名字， \W 表示工作目录最后一个目录名，
$ 是提示符，root 的提示符为 #，非 root 用户提示符为 $。</p>
<p>设置 PS1 变量：<code>PS1='[.......]\$'</code>
默认设置成：PS1='[\u \W]$'</p>
<h3 id="-变量"><a class="header" href="#-变量">$ 变量</a></h3>
<p>变量 $ 表示当前 shell 的线程代号 。
<code>echo $$</code></p>
<h3 id="-变量-1"><a class="header" href="#-变量-1">? 变量</a></h3>
<p>存储着上一个命令的回传码</p>
<p>每执行完一个命令，都会有一个回传码，如果命令正确并执行完毕，那么回传码为 0，如果命令错误，执行错误，就会传回来一个非 0 的值。</p>
<pre><code>12name=wanshuo
echo $?
这里会传回一个第一个命令运行结果码，由于赋值错误，打印出来的值应该是一个非 0 的数。
</code></pre>
<h3 id="_-变量"><a class="header" href="#_-变量">_ 变量</a></h3>
<p>The <code>$_</code> variable, in bash, is the last argument given to the previous command.</p>
<p>用途：<code>mkdir dir &amp;&amp; cd $_</code> 创建文件夹并切换</p>
<h3 id="环境变量-和-自定义变量的区别"><a class="header" href="#环境变量-和-自定义变量的区别">环境变量 和 自定义变量的区别</a></h3>
<ol>
<li><code>env</code> 命令专门用来查询环境变量</li>
<li><code>set</code> 命令可以查询所有的变量</li>
<li>两者区别在于 该变量是否会被子进程所继续引用，当利用 <code>bash</code> 命令进入一个子进程后，父进程的变量就失效了，<code>子进程只能继承父进程的环境变量</code>。 <code>export 变量名</code> 命令用于将普通变量提升为环境变量。</li>
<li>单独的 'export' 命令可以列出所有的环境变量。</li>
<li>环境变量 == 全局变量， 自定义变量 == 局部变量</li>
</ol>
<h2 id="read-命令-读取来自键盘的输入"><a class="header" href="#read-命令-读取来自键盘的输入">read 命令 读取来自键盘的输入</a></h2>
<p><code>read [-pt] variable</code>
<code>-p 后面接提示符</code>
<code>-t 后面接等待的秒数</code></p>
<pre><code>Demo

read atest
输入内容
echo $atest

read -p &quot;请输入用户名&quot; -t 30 name  # 等待30秒让用户输入用户名，并把值赋给 name 
</code></pre>
<h2 id="声明变量类型-declare--typeset"><a class="header" href="#声明变量类型-declare--typeset">声明变量类型 declare / typeset</a></h2>
<p><code>declare [-aixr] variable</code>
<code>-a 将 variable 定义为数组类型</code>
<code>-i 定义为整数数字类型</code>
<code>-x 作用和 export 一样，都是将变量变成环境变量</code>
<code>-r 将变量设置为 readonly 类型</code></p>
<pre><code>Demo

declare -i sum=1+2+3
echo $sum

declare -r sum # 设置 sum 只读
declare -x sum # 设置 sum 为环境变量
declare +x sum # 取消 sum 的环境变量属性

#定义数组
var[1]=&quot;str1&quot;
var[2]=&quot;str2&quot;
</code></pre>
<p>linux 中变量的类型默认为 字符串 类型，bash 环境中的数值运算，默认最多支持整数类型，所以 1 / 3 = 0</p>
<h2 id="script-脚本编程经验"><a class="header" href="#script-脚本编程经验">script 脚本编程经验</a></h2>
<ol>
<li>命令太长要换行，用 <code>\</code> 将换行符转义</li>
<li>写 shell 脚本应该直接在 vim 环境下写，如果在 windows 下写，会出现各种格式问题，导致命令无法执行</li>
<li></li>
</ol>
<h2 id="shell-编程-demo"><a class="header" href="#shell-编程-demo">shell 编程 Demo</a></h2>
<pre><code>#!/bin/bash 
# -v 是排除 grep 进程本身， print $2 是获取第二个参数，也就是 PID，反引号是为了运行后面的脚本
pid=`ps -fe | grep &quot;python cpu_consume.py&quot; | grep -v grep | awk '{print $2}'` 
kill $pid
python /home/work/cpu_consume/cpu_consume.py
exit 0</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-脚本-demos"><a class="header" href="#shell-脚本-demos">Shell 脚本 Demos</a></h1>
<p>[TOC]</p>
<h2 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/264346586?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">[一篇教会你写90%的shell脚本]</a></li>
<li><a href="https://betterdev.blog/minimal-safe-bash-script-template/">完善的 Bash 脚本的最简单形式</a></li>
</ul>
<h2 id="-的作用"><a class="header" href="#-的作用"><code>#!</code> 的作用</a></h2>
<p><code>#</code> 用于注释，<code>!</code> 用于指定用哪个 shell 来运行脚本。</p>
<p>通常是 <code>#!/bin/bash</code></p>
<h2 id="监控进程是否运行的脚本"><a class="header" href="#监控进程是否运行的脚本">监控进程是否运行的脚本</a></h2>
<pre><code class="language-shell">#!/bin/bash
# -v 是排除 grep 进程本身， print $2 是获取第二个参数，也就是 PID，反引号是为了运行后面的脚本
pid=`ps -fe | grep &quot;python /home/work/cpu_consume/cpu_consume.py&quot; | grep -v grep | awk '{print $2}'`
if [ -z &quot;$pid&quot; ]; then # $ pid 字符串为空
    echo &quot;無程序運行&quot;
else
    echo &quot;有程序運行&quot;
    kill $pid
fi
exit 0
</code></pre>
<h2 id="监控缓存超过-300m就释放"><a class="header" href="#监控缓存超过-300m就释放">监控缓存，超过 300M，就释放</a></h2>
<pre><code class="language-shell">#!/usr/bin/env bash

buff_cache=`free -h | grep Mem: | awk '{print int(substr($6,0,length($6)))}'`
# 结果有两种，xxxM 或 x.xG
if (( $buff_cache &lt;= 4 )); then
    buff_cache=1000
fi

# buff 和 cache 的阈值，超过阈值，则清理缓存
buff_cache_threshold=300
if (( $buff_cache &gt; $buff_cache_threshold )); then
    sync; sync; sync; echo 1 &gt; /proc/sys/vm/drop_caches
    date
    echo &quot;release cache success&quot;
else
    echo &quot;do not need to release cache&quot;
fi
</code></pre>
<h2 id="磁盘分区-demo"><a class="header" href="#磁盘分区-demo">磁盘分区 Demo</a></h2>
<pre><code class="language-shell"># 有问题的脚本
#!/bin/bash

# 输入 raid 盘的名字，以 sd 开头
read -p &quot;please input raid name:&quot; raid_name

# 对输入的 raid 盘名进行校验
# todo

# 判断 raid 是否已自动挂载，如果已挂载，则取消对 raid 盘的挂载，否则无法进行分区操纵
# todo

# 对 raid 盘进行分区
# 注意，分区的时候设置的文件系统类型关系不大，后面要对其进行格式化的
# 可选的文件系统类型为：ext2fat16, fat32 hfs, hfs+, hfsx linux-swap NTFS reiserfs ufs btrfs
parted -s &quot;/dev/&quot;${raid_name} \
    mklabel gpt \
    mkpart part-efi fat32 0GB 1GB \
    mkpart part-boot xfs 1GB 2GB \
    mkpart part-biosboot xfs 2GB 3GB \
    mkpart part-swap linuxswap 3GB 19GB \
    mkpart part-other xfs 19GB 100%

# 对 U 盘进行测试分区
#parted -s &quot;/dev/&quot;${raid_name} \
#    mklabel gpt \
#    mkpart part-efi xfs 0GB 1GB \
#    mkpart part-boot xfs 1GB 2GB \
#    mkpart part-other xfs 2GB 100%

# 对分区进行格式化
mkfs.fat &quot;/dev/&quot;${raid_name}&quot;1&quot;
mkfs.xfs &quot;/dev/&quot;${raid_name}&quot;2&quot;
mkfs.xfs &quot;/dev/&quot;${raid_name}&quot;3&quot;
mkfs.xfs &quot;/dev/&quot;${raid_name}&quot;4&quot;
mkfs.xfs &quot;/dev/&quot;${raid_name}&quot;5&quot;

# 挂载
mkdir  /boot/efi
mount &quot;/dev/&quot;${raid_name}&quot;1&quot; /boot/efi
mount &quot;/dev/&quot;${raid_name}&quot;2&quot; /boot
mount &quot;/dev/&quot;${raid_name}&quot;3&quot; /biosboot
# swap 分区挂载并激活
mkswap &quot;/dev/&quot;${raid_name}&quot;4&quot;
swapon &quot;/dev/&quot;${raid_name}&quot;4&quot;
mount &quot;/dev/&quot;${raid_name}&quot;5&quot; /

echo &quot;over&quot;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-历史和各发行版"><a class="header" href="#linux-历史和各发行版">Linux 历史和各发行版</a></h1>
<h2 id="linux-各种发行版"><a class="header" href="#linux-各种发行版">Linux 各种发行版</a></h2>
<p><img src="computer-science-notebook/linux/assets/image-20200609191129523.png" alt="image-20200609191129523" /></p>
<p>Linux 有两大派系：</p>
<ul>
<li>debian —&gt; Ubuntu
<ul>
<li>代表发行版：Ubuntu</li>
<li>debian 的包管理器是 dpkg，其前端接口是 apg-get</li>
<li>个人感觉，redhat 派系的发行版，多用于桌面系统</li>
</ul>
</li>
<li>redhat —&gt; CentOS
<ul>
<li>代表发行版：cent-os</li>
<li>redhat 的包管理器是 rpm，其前端接口是 yum</li>
<li>个人感觉，redhat 派系的发行版，多用于服务器</li>
</ul>
</li>
</ul>
<h2 id="red-hat"><a class="header" href="#red-hat">Red Hat</a></h2>
<p>https://en.wikipedia.org/wiki/Red_Hat</p>
<p>Red Hat 是一家美国的跨国公司，专门向企业提供定制版的 Linux 系统，成立于 1993 年。2019 年 7 月被 IBM 收购。</p>
<p>Red Hat 擅长向企业提供企业级的红帽操作系统：<a href="https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux">Red Hat Enterprise Linux(Rhel)</a></p>
<p>Red Hat 衍生出了（Redhat 是 Cent-OS 的爸爸）：</p>
<ul>
<li>Red Hat
<ul>
<li>Red Hat Enterprise Linux
<ul>
<li>Cent Os</li>
</ul>
</li>
<li>Fedora (Red Hat 开发版，相当于开发版分支，提供各种最新的功能)</li>
</ul>
</li>
</ul>
<h2 id="debian"><a class="header" href="#debian">debian</a></h2>
<p>代表发行版：Ubuntu</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github"><a class="header" href="#github">GitHub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-1"><a class="header" href="#github-1">GitHub</a></h1>
<p>[TOC]</p>
<p>Long Live GitHub.</p>
<h2 id="github-经验总结"><a class="header" href="#github-经验总结">github 经验总结</a></h2>
<ul>
<li>
<p>github-pages 必须公开仓库，才能生效。</p>
</li>
<li>
<p>白嫖 License</p>
<p>可以使用 github 进行免费 license 查询，有很多粗心的程序员，会把一些 license 上传到公共仓库</p>
<p>例如我想获取 http://ig507.com/data/time/real/xxx?licence=xxx  的 license，可以直接去 github 中搜索 <code>http://ig507.com/data/time/real/ licence</code>，然后去 code 中查询！</p>
</li>
</ul>
<h2 id="github-高级搜索"><a class="header" href="#github-高级搜索">github 高级搜索</a></h2>
<h3 id="in"><a class="header" href="#in">in</a></h3>
<p>Demo: 查找秒杀</p>
<pre><code>seckill in:name # 项目名包含秒杀
seckill in:description # 项目描述包含秒杀
seckill in:readme # 项目 readme 包含秒杀

seckill in:readme,name,description # 组合搜索
</code></pre>
<h3 id="stars--forks"><a class="header" href="#stars--forks">stars / forks</a></h3>
<p>demo:</p>
<pre><code>springboot stars:&gt;=5000 # 注意不要有空格
springboot forks:&gt;=5000 # 
springboot forks:100..200 stars:80..100 # 之间
</code></pre>
<h3 id="代码高亮-l"><a class="header" href="#代码高亮-l">代码高亮 #L</a></h3>
<p>63 行到 82 行代码高亮</p>
<pre><code>https://github.com/wansho/DASFAA2020/blob/master/samplepaper.tex#L63-L82
</code></pre>
<h3 id="项目内搜索-t"><a class="header" href="#项目内搜索-t">项目内搜索 t</a></h3>
<p>在 GitHub 仓库页面，按 <code>t</code> 键，在项目内进行搜索</p>
<h3 id="常用搜索关键字"><a class="header" href="#常用搜索关键字">常用搜索关键字</a></h3>
<h4 id="awesome"><a class="header" href="#awesome">awesome</a></h4>
<pre><code>awesome springboot
awesome 南航计算机考研
</code></pre>
<h2 id="github-官方信息"><a class="header" href="#github-官方信息">github 官方信息</a></h2>
<p>信息源：https://github.com/github/roadmap</p>
<h3 id="feature-areas"><a class="header" href="#feature-areas">Feature Areas</a></h3>
<p>The following is a list of our current product areas:</p>
<ul>
<li><strong>code:</strong> Code experiences (Repositories, Pull Requests, Gists)</li>
<li><strong>planning:</strong> Planning and tracking tools (Issues, Projects)</li>
<li><strong>code-to-cloud:</strong> Code-to-cloud DevOps (Actions, Packages)</li>
<li><strong>collaboration:</strong> Collaboration features (Pages, Wikis, Discussions)</li>
<li><strong>security &amp; compliance:</strong> Code security and compliance features</li>
<li><strong>admin-server:</strong> Administrative features specific to GitHub Enterprise Server</li>
<li><strong>admin-cloud:</strong> Administrative features specific to GitHub Cloud</li>
<li><strong>community:</strong> Community and social features</li>
<li><strong>ecosystem:</strong> Ecosystem and API features</li>
<li><strong>learning:</strong> Education and learning features</li>
<li><strong>insights:</strong> Continuous learning and insights features</li>
<li><strong>client-apps:</strong> Client applications (Desktop, Mobile)</li>
<li><strong>other:</strong> Other features</li>
</ul>
<h3 id="feature"><a class="header" href="#feature">Feature</a></h3>
<p>The following is a list of our current features and products, with distinct labels for filtering:</p>
<ul>
<li><strong>actions:</strong> GitHub Actions</li>
<li><strong>docs:</strong> GitHub Docs</li>
<li><strong>packages:</strong> GitHub Packages</li>
<li><strong>pages:</strong> GitHub Pages</li>
</ul>
<h3 id="我的分析"><a class="header" href="#我的分析">我的分析</a></h3>
<p>当前，Github Actions 是 Github 的重点，GitHub Actions 是 Code-to-Cloud 的一种实现。</p>
<h2 id="webhooks"><a class="header" href="#webhooks">Webhooks</a></h2>
<p>Webhooks allow external services to be notified when certain events happen. When the specified events happen, we’ll send a POST request to each of the URLs you provide. Learn more in our <a href="https://developer.github.com/webhooks/">Webhooks Guide</a>.</p>
<p>当仓库发生某些动作的时候，就发起外部请求。</p>
<h2 id="github-周边软件"><a class="header" href="#github-周边软件">GitHub 周边软件</a></h2>
<ul>
<li>
<p><a href="https://github.com/gitpod-io/gitpod">Gitpod</a></p>
<p>Gitpod is an open-source Kubernetes application providing fully-baked, collaborative development environments in your browser - powered by VS Code. Tightly integrated with GitLab, GitHub, and Bitbucket, Gitpod automatically and continuously prebuilds dev environments for all your branches. </p>
<p>一个在线的 VSCode，与 Github 紧密集成在一起。缺点：加载很慢，不太好用。</p>
</li>
</ul>
<h2 id="仓库收藏"><a class="header" href="#仓库收藏">仓库收藏</a></h2>
<ul>
<li>
<p>尝试对加密过的文本，进行解密：<a href="https://github.com/Ciphey/Ciphey">Ciphey</a> </p>
</li>
<li>
<p>开源项目讲解：<a href="https://github.com/HelloGitHub-Team/Article">Article</a></p>
</li>
<li>
<p>软件测试：<a href="https://github.com/abhivaikar/howtheytest">how they test</a></p>
</li>
<li>
<p>黑客帝国终端模拟器特效：<a href="https://github.com/GitSquared/edex-ui">edex-ui</a></p>
</li>
<li>
<p><a href="https://github.com/yihong0618/running_page">running_page</a></p>
<p>国产的跑步数据管理软件，可以备份 Nike、Runtastic（Adidas Run）、佳明的 gpx 跑步数据，生成个人的跑步主页。</p>
<p>这个老哥，两年学成，而且很有想法，真的佩服，感觉很惭愧</p>
</li>
<li>
<p><a href="https://github.com/prabhuignoto/react-chrono">react-chrono</a></p>
<p>React 的时间轴组件</p>
</li>
<li>
<p><a href="https://github.com/wei/socialify">socialify</a></p>
<p>generating a beautiful project image</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优雅锋利的-gitbook"><a class="header" href="#优雅锋利的-gitbook">优雅锋利的 GitBook</a></h1>
<p>[TOC]</p>
<p>首先抛结论，GitBook 目前满足了我对记笔记的所有幻想，它没有 Hexo 那么多花里胡哨的功能，它就像一把锋利的小刀，简单克制，完美解决了我使用 Hexo 中的一些痛点，满足了笔记创作者和读者最原始的需求，让创作者专注于创作，让读者专注于阅读。</p>
<p><img src="computer-science-notebook/github/assets/1558619487053.png" alt="GitBook" /></p>
<p>先总结一下 GitBook 的优点：</p>
<ul>
<li>实时同步 Github 仓库中的笔记</li>
<li>支持自定义域名</li>
<li>GitBook + Typora + GitHub 完美解决图床问题，采用 github 仓库作为图床</li>
<li>界面优雅克制，让内容创作者专注于内容创作，让读者专注于阅读</li>
</ul>
<p>注意，我这里写的 GitBook 是指 GitBook 提供的新版在线服务：<a href="https://www.gitbook.com/%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%87%AA%E5%B7%B1%E6%A0%B9%E6%8D%AE%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BA%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF">https://www.gitbook.com/</a> 而不是自己根据开源代码搭建的服务，也不是 GitBook 的老版服务：<a href="https://legacy.gitbook.com/">https://legacy.gitbook.com/</a> (已停止新用户注册)。下面详细介绍以下新版 GitBook 服务的优点。</p>
<h2 id="gitbook-界面优雅克制"><a class="header" href="#gitbook-界面优雅克制">GitBook 界面优雅克制</a></h2>
<p>如无必要，勿增实体。GitBook 的 UI 简洁优雅，功能也很克制，其更专注于内容创作，更专注于满足笔记创作者和读者最原始的需求，而不是其他博客框架那样，搞出各种花里胡哨的功能，但是对创作者和读者来说，实际体验并不会很好。</p>
<h2 id="实时同步-github-仓库中的笔记"><a class="header" href="#实时同步-github-仓库中的笔记">实时同步 GitHub 仓库中的笔记</a></h2>
<p><strong>解决的痛点</strong>：只需要在本地编辑完笔记并 push 到 GitHub，web 端立刻同步，不需要任何花里胡哨的操作，一步到位。还有一个优点，采用 Github 作为笔记仓库，可以实现笔记的版本控制。</p>
<p>在将 GitBook 中的 space 和 GitHub 中的仓库(指定的笔记仓库) 绑定(<a href="https://docs.gitbook.com/integrations/github%3E">how to bind</a>)后，GitBook 会自动地同步仓库中存储的笔记。当我们本地对笔记进行编辑后并 push 到 Github 仓库后，GitBook 会立即与 GitHub 仓库进行同步。</p>
<h2 id="gitbook-支持自定义域名"><a class="header" href="#gitbook-支持自定义域名">GitBook 支持自定义域名</a></h2>
<p><a href="https://docs.gitbook.com/hosting/custom-domains%3E">How to</a></p>
<p>只需要配置一个二级域名，然后配置 CNAME 指向 GitBook，即可通过我们自己的域名访问笔记。我在阿里云上配置了一个二级域名 <a href="https://gitbook.wansho.cn/%EF%BC%8C%E5%B9%B6%E9%85%8D%E7%BD%AE">https://gitbook.wansho.cn/，并配置</a> CNAME 指向 GitBook。</p>
<h2 id="gitbook-采用-github-仓库作为图床"><a class="header" href="#gitbook-采用-github-仓库作为图床">GitBook 采用 Github 仓库作为图床</a></h2>
<p><strong>解决的痛点</strong>：采用 GitHub 作为图床，本地 markdown 编辑完毕后，把 文本 + 图片 一同 push 到 GitHub 仓库，GitBook 能够完美解析 markdown 中嵌入的图片，不需要寻找其他不靠谱的图床。</p>
<p>使用 Hexo 搭建过博客的同学应该都有过找图床的经历。通常需要将图片上传到云上，然后拿到图片链接再嵌入到 markdown 笔记中，过程十分繁琐，令人倒胃口。但是使用 Typora(markdown 编辑器 <a href="https://typora.io/#windows%3E">Download</a>) + GitHub + GitBook 就可以完美的解决这个痛点！步骤如下：</p>
<ol>
<li>
<p>利用 Typora 编辑器，在本地仓库建立图床，markdown 中插入的图片，链接到本仓库图床</p>
<p>配置 Typora 中图片插入的模式为：<code>复制图片到 .assets 文件夹</code>(即为图床)，然后我们可以直接复制想要插入的图片到编辑器中，插入的图片会被复制到新建的 <code>.assets</code> 文件夹中，并且图片的链接为相对链接，链接到 <code>.assets</code> 的图片。</p>
</li>
<li>
<p>将 markdown文本 + 本地仓库图床 push 到 GitHub</p>
<p>由于图片在仓库中，并且 markdown 中的链接为相对链接，所以 markdown 在 GitHub 上的显示是正常的，但是也仅限于在 Github 上显示正常。如果想要发布到 Hexo 上，还是需要图片的绝对路径，这个时候就不可避免的需要再存储一份图片到云端图床。</p>
</li>
<li>
<p>GitBook 自动同步 GitHub 仓库，对 markdown 中嵌入的相对路径图片地址进行解析，加载 GitHub 仓库图床中的图片</p>
<p>如此 GitBook 就可以完美利用 GitHub 仓库作为图床，完美的解决图床问题。</p>
</li>
</ol>
<p><strong>注意</strong>：GitBook 笔记中引用的图片，必须是和 md 文件同目录下的 assets 中的图片，例如：<code>assets/123.png</code>，不支持的引用方式：<code>../assets/123.png</code></p>
<h2 id="tips-for-gitbook"><a class="header" href="#tips-for-gitbook">Tips for GitBook</a></h2>
<ul>
<li>不要在 GitBook 上进行在线编辑，因为在线编辑的内容会同步到 GitHub 上，如果本地也进行了相同文件的编辑，则可能会产生冲突，导致 GitBook 因为冲突而不能同步 GitHub 上的最新笔记。</li>
<li>每一个二级目录下，都必须存放一个 README.md 用于解释该文件夹内的笔记</li>
<li>如果内容不能和 GitHub 及时同步，那么最简单有效的方法是重新绑定 GitHub 的仓库</li>
<li>如果有一个页面在 GitBook 端显示为空，那原因多半出在 SUMMARY.md 的笔记配置上，一定要注意笔记的路径</li>
</ul>
<h2 id="gitbook-服务的不足"><a class="header" href="#gitbook-服务的不足">GitBook 服务的不足</a></h2>
<ul>
<li>小白上手比较难：<a href="https://docs.gitbook.com/%3E">DOC</a> 没有汉化，Github 有学习成本</li>
<li>没有免费的评论系统</li>
<li>GitHub 同步偶尔会有小毛病</li>
<li>频繁修改线上笔记，需要多次 commit</li>
<li>不支持 markdown 文本中的 html 渲染</li>
</ul>
<h2 id="gitbook-周边"><a class="header" href="#gitbook-周边">gitbook 周边</a></h2>
<ul>
<li><a href="https://github.com/fuergaosi233/gitbook2pdf">gitbook2pdf</a> 将 gitbook 转成 pdf，亲测能用，不支持 https</li>
<li><a href="https://github.com/zhangjikai/gitbook-use"> gitbook-use</a> 记录GitBook的一些配置及插件信息</li>
</ul>
<h2 id="gitbook-本地部署"><a class="header" href="#gitbook-本地部署">gitbook 本地部署</a></h2>
<p>切换到 root 用户</p>
<ol>
<li>
<p>用 nvm 安装 node v12.16.3</p>
<pre><code class="language-shell">nvm install 12.16.3
nvm use v12.16.3
</code></pre>
</li>
<li>
<p>卸载 gitbook</p>
<pre><code class="language-shell">npm uninstall -g gitbook
</code></pre>
</li>
<li>
<p>安装 gitbook</p>
<pre><code>npm install -g gitbook-cli
</code></pre>
</li>
<li>
<p>查看 gitbook 是否安装成功</p>
<pre><code class="language-shell">gitbook -V
# 会 Installing GitBook 3.2.3，顺带着安装 book.json 中的插件，非常耗时，等一个晚上
</code></pre>
</li>
<li>
<p>找到 <code>~/.gitbook/versions/3.2.3/lib/output/website/copyPluginAssets.js</code> 文件,然后找到这个文件里面的所有的confirm配置项(一共2个地方),将原来的值 true 更改为 false.</p>
<p><code>confirm: false</code></p>
<p>一共有2个地方,更改一下就可以了</p>
</li>
<li>
<p>运行 gitbook 服务器</p>
<pre><code class="language-shell">gitbook serve
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-深入学习"><a class="header" href="#git-深入学习">Git 深入学习</a></h1>
<p>[TOC]</p>
<h2 id="introduction-12"><a class="header" href="#introduction-12">Introduction</a></h2>
<p>如果你不满足仅仅会用 <code>git add/commit/push/clone/</code> 等等这些 Git 最基础的命令，想要知其然，也知其所以然，那么我强烈推荐你去阅读 <a href="https://git-scm.com/book/en/v2">《Pro Git》</a> ，哪怕只把前 101 页读完，都可以对 Git 有一个系统的理解。</p>
<p>学习 Git 的资源：</p>
<ul>
<li>
<p><a href="https://git-scm.com/docs">Git Reference </a> Git 速查手册</p>
</li>
<li>
<p><a href="https://git-scm.com/book/en/v2f">《Pro Git》</a> </p>
</li>
</ul>
<p>本文是我读 <a href="https://git-scm.com/book/en/v2">《Pro Git》</a> 的学习笔记， 95% 的内容来源了该书前 101 页的内容，我对我认为重要的内容进行了归纳整理。</p>
<p>学习 Git，用上述两个官方资源，足矣。</p>
<h2 id="名词解释-1"><a class="header" href="#名词解释-1">名词解释</a></h2>
<table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody>
<tr><td>master</td><td>仓库的默认分支</td></tr>
<tr><td>HEAD</td><td>HEAD 指针，指向当前工作分支的指针</td></tr>
<tr><td>origin</td><td>指代远程库</td></tr>
</tbody></table>
<h2 id="questions-7"><a class="header" href="#questions-7">Questions</a></h2>
<p>几个经常忘记的命令，基本上都和 checkout，reset 有关</p>
<ul>
<li>
<p>取消某个文件的修改</p>
<p><code>git checkout -- file</code></p>
</li>
<li>
<p>取消加入暂存区，只需要让这个文件回滚到之前的一个版本即可</p>
<p><code>git reset file</code></p>
<p><code>git reset</code> 取消所有添加到暂存区的内容</p>
</li>
<li>
<p>回滚到某个版本</p>
<p><code>git reset --hard 459f</code></p>
</li>
</ul>
<h2 id="使用-git-做开发"><a class="header" href="#使用-git-做开发">使用 Git 做开发</a></h2>
<h3 id="git-开发分支"><a class="header" href="#git-开发分支">Git 开发分支</a></h3>
<p><a href="https://zepel.io/blog/5-git-workflows-to-improve-development/">5 Git workflows you can use to deliver better code and improve your development process</a></p>
<table><thead><tr><th>Git Feature Branch Workflow</th><th>Git Feature Workflow with Develop Branch</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/github/assets/image-20200807205239022.png" alt="image-20200807205239022" /></td><td><img src="computer-science-notebook/github/assets/image-20200807205247838.png" alt="image-20200807205247838" /></td></tr>
</tbody></table>
<p>其他分支：</p>
<p>gh-pages 分支：存放静态文件，通常用于静态网页部署</p>
<h3 id="git-辅助软件"><a class="header" href="#git-辅助软件">Git 辅助软件</a></h3>
<ul>
<li>
<p><a href="https://www.sourcetreeapp.com/">SourceTree: A free Git client for Windows and Mac</a></p>
<p>Git 装饰软件，提供了一系列可视化的功能</p>
</li>
</ul>
<h2 id="vcs-introduction"><a class="header" href="#vcs-introduction">VCS Introduction</a></h2>
<p>Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. </p>
<p>It allows you to revert selected files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead. </p>
<h3 id="history-of-version-control"><a class="header" href="#history-of-version-control">History of Version Control</a></h3>
<ol>
<li>
<p>Copy files to another directory</p>
</li>
<li>
<p>Local version control system</p>
</li>
<li>
<p>Centralized version control system</p>
<p>For example: SVN</p>
<p>Advantage: help people collaborate with others</p>
<p>Disadvantage: loss everything if central machine break down</p>
</li>
<li>
<p>Distributed Version Control System</p>
<p>For example: Git (2005)</p>
</li>
</ol>
<p>软件开发中对于版本控制的需求推动了版本控制系统的发展。正是因为正式开发中出现过中心服务器崩溃导致历史版本代码丢失的问题，才会催生出分布式的版本控制工具。</p>
<h3 id="environments-to-use-vcs"><a class="header" href="#environments-to-use-vcs">Environments to use VCS</a></h3>
<p>只要涉及到文本文件，无论是写 Blog，还是写代码，都可以用 Git 进行版本控制，上传到 Github 进行分布式的管理。</p>
<h3 id="difference-between-git-and-other-vcsfor-example-svn"><a class="header" href="#difference-between-git-and-other-vcsfor-example-svn">Difference between Git and other VCS(for example: SVN)</a></h3>
<ol>
<li>
<p>Main difference: Snapshots, Not Differences </p>
<p>SVN: Think of the information they store as a set of files and the changes made to each file over time (this is commonly described as delta-based version control) </p>
<p>Git: Git thinks about its data more like astream of snapshots. </p>
</li>
<li>
<p>Nearly Every Operation Is Local (offline work)</p>
</li>
<li>
<p>Git uses hash to checksum each subtle chage of file</p>
</li>
</ol>
<h2 id="git-terminology"><a class="header" href="#git-terminology">Git Terminology</a></h2>
<h3 id="centralized-vs-distributed"><a class="header" href="#centralized-vs-distributed">Centralized Vs Distributed</a></h3>
<p>CVS 和 SVN 都是集中式的版本控制工具
Git 是分布式的版本控制工具</p>
<p>集中式版本控制工具有一个中央服务器，所有的 client 都要从与 server 进行通信，如果 server 挂掉了，那么所有的 history 就没了。</p>
<p>分布式版本控制工具是去中心化的，没有中央服务器，每个人的电脑都有一个完整的版本库。 if any server dies, and these systems werecollaborating via that server, any of the client repositories can be copied back up to the server to restore it. Every clone is really a full backup of all the data</p>
<h3 id="three-sections-working-directory-staging-area-repository"><a class="header" href="#three-sections-working-directory-staging-area-repository">Three sections: Working Directory, Staging Area, Repository</a></h3>
<p>Working directory: 工作区.git dir 所在文件夹
Staging Area：暂存区
Repository：仓库</p>
<p><code>git add</code>：把 工作区 中的 modified 的内容添加到 暂存区；
<code>git commit</code>：把暂存区的所有内容提交到当 仓库 中。</p>
<h3 id="untracked-or-tracked"><a class="header" href="#untracked-or-tracked">untracked or tracked</a></h3>
<p>Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows about. </p>
<p>Untracked files are everything else — any files in your working directory that were not in your last
snapshot and are not in your staging area. </p>
<p>tracked 文件就是 Git 开始追踪的文件；untracked 文件就是 Git 没有追踪的文件，如果需要追踪，需要 <code>git add</code></p>
<h3 id="gitignore"><a class="header" href="#gitignore">.gitignore</a></h3>
<p>Create a file named <code>.gitignore</code> to list patterns to match the untracked files.</p>
<p>.gitignore 文件可以有多个，每个文件只在当前文件夹内递归生效.</p>
<p>.gitignore 的语法规则：</p>
<ol>
<li>注释：#</li>
<li>兼容 Linux 的通配符规则，并且规则有递归性</li>
<li><code>/pattern</code> 表示只当前文件夹下的 pattern 匹配到的文件</li>
<li><code>pattern/</code> 表示忽略所有 pattern 匹配到的文件夹</li>
<li><code>!pattern</code> 表示 track 该 pattern 匹配到的文件</li>
</ol>
<p>Demos:</p>
<pre><code class="language-shell"># ignore all .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the TODO file in the current directory, not subdir/TODO
/TODO
# ignore all files in any directory named build
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf

# 添加一个空文件夹
*
!.gitignore
</code></pre>
<h3 id="origin"><a class="header" href="#origin">origin</a></h3>
<p>origin 是对 remote-repos 的 shortname</p>
<p>官方解释</p>
<blockquote>
<p>Just like the branch name “master” does not have any special meaning in Git, neither does “origin”. While “master” is the default name for a starting branch when you run git init which is the only reason it’s widely used, “origin” is the default name for a remote when you run git clone. If you run git clone -o booyah instead, then you will have booyah/master as your default remote branch. </p>
</blockquote>
<p>In Git, &quot;origin&quot; is a shorthand name for the remote repository that a project was originally cloned from.</p>
<h3 id="head-1"><a class="header" href="#head-1">HEAD</a></h3>
<p>官方解释</p>
<blockquote>
<p>How does Git know what branch you’re currently on? It keeps a special pointer called HEAD. </p>
<p>This is a pointer to the local branch you’re currently on. </p>
</blockquote>
<p>HEAD 是一个指向当前工作分支的指针</p>
<h3 id="master"><a class="header" href="#master">master</a></h3>
<p>官方解释</p>
<blockquote>
<p>The “master” branch in Git is not a special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the git init command creates it by default and most people don’t bother to change it </p>
</blockquote>
<h3 id="fast-forward"><a class="header" href="#fast-forward">fast-forward</a></h3>
<p>官方解释</p>
<blockquote>
<p>when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together — this is called a “fast-forward.” </p>
</blockquote>
<h3 id="topic-branch"><a class="header" href="#topic-branch">topic branch</a></h3>
<p>官方解释：</p>
<blockquote>
<p>A topic branch is a short-lived branch that you create and use for a single particular feature or related work. This is something you’ve likely never done with a VCS before because it’s generally too expensive to create and merge branches. But in Git it’s common to create, work on, merge, and delete branches several times a day. </p>
</blockquote>
<p><code>git branch</code>技术给小步试错，快速迭代带来了便捷，topic branch 方法是日常开发最常用的方法。</p>
<h2 id="git-commands"><a class="header" href="#git-commands">Git Commands</a></h2>
<h3 id="git-syntax"><a class="header" href="#git-syntax">git syntax</a></h3>
<p>git 的所有命令，自带一个 <code>git</code> 的前缀，实际上第二个 word 才是命令，其并不是一个参数。</p>
<pre><code class="language-shell"># 查看某一个 command 的帮助命令
git command --help 
git command -h
</code></pre>
<h3 id="git-config"><a class="header" href="#git-config">git config</a></h3>
<pre><code class="language-shell">git config --system # 配置所有用户的 git conf
git config --global # 配置当前用户的 git conf
git config --local (== git conf) # 配置当前仓库的 git conf

# user conf
git config --global user.name &quot;wansho&quot;
git config --global user.email wanshojs@hotmail.com
git config --local user.name &quot;wansho&quot;
git config --local user.email wanshojs@hotmail.com

git config --list #  check your configuration settings
git config user.name # check a specific key value

# 查看配置好的 git config
git config -l # --list

# 配置代理
git config --global http.proxy http://127.0.0.1:7890 # 2136 就是翻墙软件代理的端口号
git config --global https.proxy https://127.0.0.1:7890
git config --local http.proxy http://127.0.0.1:7890 # 2136 就是翻墙软件代理的端口号
git config --local https.proxy https://127.0.0.1:7890
# 注意：此模式只适用于 http 协议，不适用于 SSH 协议
# 同样适用于 WSL
# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
</code></pre>
<h3 id="git-clone"><a class="header" href="#git-clone">git clone</a></h3>
<p>官方解释</p>
<blockquote>
<p>Instead of getting just a working copy, Git receives a full copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down by default when you run git clone. In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server back to the state it was in when it was cloned (you may lose some server-side hooks and such, but all the versioned data would be there) </p>
</blockquote>
<pre><code class="language-shell">git clone https://github.com/libgit2/libgit2 # use http:// protocol to transfer
git clone user@server:path/to/repo.git # use SSH protocol to transfer

git clone https://github.com/libgit2/libgit2 mylibgit # change a dir
</code></pre>
<h3 id="git-add"><a class="header" href="#git-add">git add</a></h3>
<p>官方建议</p>
<blockquote>
<p>It may be helpful to think of it more as “add precisely this content to the next commit” rather than “add this file to the project”.</p>
</blockquote>
<pre><code class="language-shell">git add file # 开始追踪一个文件或将文件中修改的内容加入 staging area
git add dir # 开始追踪一个文件夹(递归)，或者将文件夹中修改的内容加入 staging area

git add --all # 将所有的工作区的修改，加入暂存区，对于 untracked 的文件也生效

# 如果指向将 tracked modified 的文件加入暂存区，可以使用，这只对 tracked 的文件生效
git commit -a -m &quot;&quot;

# add 逆向操作 Unstaging a Staged File
git reset HEAD file

# Unmodifying a Modified File 取消工作区的更改
git checkout -- file # 这个命令很危险，如果撤销了，那么文件的修改就全没了，慎用
</code></pre>
<h3 id="git-stash"><a class="header" href="#git-stash">git stash</a></h3>
<p>git stash 多用于多个分支之间切换</p>
<pre><code class="language-shell"># keep the changes you’ve made to that file but still need to get it out of the way for now
</code></pre>
<p>将未提交的更改保存到堆栈，后面再恢复。(对 untrack 的更改不生效)</p>
<pre><code class="language-shell">git stash # 将未 add 和 commit 的内容保存到栈中

git stash save &quot;comment&quot; # 加一个 flag

git stash pop # stash中的内容弹出，并应用到当前分支对应的工作目录上

git stash apply # 不同于git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。

git stash clear # 清除堆栈中的所有 内容
</code></pre>
<p>git stash 是全局的，可以跨 branch，在一个 branch 中 stash，可以在另一个 branch 中释放。</p>
<h3 id="git-diff"><a class="header" href="#git-diff">git diff</a></h3>
<p>官方提醒</p>
<blockquote>
<p>It’s important to note that git diff by itself doesn’t show all changes made since your last commit — only changes that are still unstaged. If you’ve staged all of your changes, git diff will give you no output</p>
</blockquote>
<pre><code class="language-shell">git diff --staged # compare all staged files to the last commit 
git diff --staged file # compare file staged to the last commit

# git diff 的结果是 工作区 并没有进入过暂存区的 diff
git diff # compare all modified files to the file not yet go to the staging area
git diff file # compare one file

# not understand
git diff HEAD -- readme.txt # 查看工作区 和 版本库里面最新版本的区别

# 查看两个分支之间的差异
git diff branch1 branch2
</code></pre>
<h3 id="git-commit"><a class="header" href="#git-commit">git commit</a></h3>
<pre><code class="language-shell">git commit -m &quot;message&quot; # -m: --message

git commit -a -m &quot;message&quot; # 等价于 git add + git commit, -a: --all
# 注意，-a 参数只对 tracked files 生效，对于 untracked files 不生效

# redo that commit, make the additional changes you forgot, stage them, and commit again using the --amend option
git commit --amend 
# 如果自上次提交后没有做任何更改，那么该命令就是修改上次 commit 的 message，通常用 git commit --amend -m &quot;message&quot;
# 如果发现有一个文件修改后忘记 commit，则可以
git add file
git commit --amend -m &quot;message&quot;
# It’s important to understand that when you’re amending your last commit, it’s as if the previous commit never happened, and it won’t show up in your repository history.
# The obvious value to amending commits is to make minor improvements to your last commit, without cluttering your repository history with commit messages of the form, “Oops, forgot to add a file” or “Darn, fixing a typo in last commit”.
</code></pre>
<p>commit 日志标准化</p>
<pre><code>chore: add Oyster build script
docs: explain hat wobble
feat: add beta sequence
fix: remove broken confirmation message
refactor: share logic between 4d3d3d3 and flarhgunnstow
style: convert tabs to spaces
test: ensure Tayne retains clothing

Demo：
feat(db-sync-spring-boot-starter): 增加 insert 的 MySQL 实现
</code></pre>
<h3 id="git-rm"><a class="header" href="#git-rm">git rm</a></h3>
<pre><code class="language-shell"># untrack a file, rm it from the disk
git rm file

# untrack a fie, but keep it in the disk
git rm --cache file

# 误删恢复
git checkout -- file

# 对于已经手动删除的文件，可以直接 add 进入暂存区
git add --all
</code></pre>
<h3 id="git-mv"><a class="header" href="#git-mv">git mv</a></h3>
<pre><code class="language-shell"># rename a file in Git
git mv file_from file_to

# 等价于
mv README.md README
git rm README.md
git add README
</code></pre>
<h3 id="git-log"><a class="header" href="#git-log">git log</a></h3>
<pre><code class="language-shell">git log -p/--patch # shows the difference introduced in each commit

git log -2 # 显示最新的两次 commit history

git log --stat # Show statistics for files modified in each commit.

# --pretty 对 log 输出进行格式化
git log --pretty 
git log --pretty=oneline # 一次 commit 只输出一行 log
git log --pretty=short/full/fuller # more info than online
git log --pretty=format:&quot;%h - %an, %ar : %s&quot;
# The oneline and format options are particularly useful with another log option called --graph. This option adds a nice little ASCII graph showing your branch and merge history:
git log --pretty=format:&quot;%h %s&quot; --graph
git log --oneline --decorate --graph --all # view the commit history

git log --since=2.weeks # gets the list of commits made in the last two weeks

git log --author=&quot;wansho&quot; # filter on a specific author

git log --grep=&quot;test.*&quot; # search for keywords in the commit messages

git log -S  function_name # Only show commits adding or removing code matching the string

# 在 非fast-forward 的类型 的 merge 后，会产生一个 commit 记录，但是这种 commit log 往往是不需要的，可以用 --no-merges 过滤掉这些 merge log  
git log --no-merges # 

#  if you want to see which commits modifying test files in the Git source code history were committed by Junio Hamano in the month of October 2008 and are not merge commits
git log --pretty=&quot;%h - %s&quot; --author='Junio C Hamano' --since=&quot;2008-10-01&quot;  --before=&quot;2008-11-01&quot; --no-merges -- t/

# 查看 branch 树形结构
git log --graph --decorate --oneline --simplify-by-decoration --all
</code></pre>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-&lt;n&gt;</code></td><td>Show only the last n commits</td></tr>
<tr><td>--since, --after</td><td>Limit the commits to those made after the specified date.</td></tr>
<tr><td>--until, --before</td><td>Limit the commits to those made before the specified date.</td></tr>
<tr><td>--author</td><td>Only show commits in which the author entry matches the specified string.</td></tr>
<tr><td>--committer</td><td>Only show commits in which the committer entry matches the specified string.</td></tr>
<tr><td>--grep</td><td>Only show commits with a commit message containing the string</td></tr>
<tr><td>-S</td><td>Only show commits adding or removing code matching the string</td></tr>
</tbody></table>
<h3 id="git-remote"><a class="header" href="#git-remote">git remote</a></h3>
<p><strong>origin</strong>: default name Git gives to the server you cloned from. Git 给默认的远程库起的名称，实际上，origin 只是一个 nick-name，我们给远程库起任何名字都可以。</p>
<p>注意：</p>
<ol>
<li>远程库可能不止一个，尤其是多人协作的时候</li>
<li>远程库并不一定在远程，可能就是在本地电脑上</li>
</ol>
<pre><code class="language-shell"># show all remote repos
git remote
git remote -v # show the url -v: --verbose 冗长的

# add remote repos
git remote add remote-repos-shortname url 
git remote add origin git@github.com:wansho/Last-Statement-of-Death-Row.git
git remote add repos1 git@github.com:wansho/Last-Statement-of-Death-Row.git 
git remote add origin https://github.com/wansho/test.git # 兼容两种协议

# remove remote repos
git remote remove remote-repos-shortname 

# see more info about a remote repos
git remote show remote-repos-shortname
# The command helpfully tells you that if you’re on the master branch and you run git pull, it will automatically merge in the master branch on the remote after it fetches all the remote references. It also lists all the remote references it has pulled down.

# change remote-repos-shortname
git remote rename origin repos1

# remote a remote-repos
git remote remove origin
</code></pre>
<h3 id="git-fetch"><a class="header" href="#git-fetch">git fetch</a></h3>
<p>官方解释</p>
<blockquote>
<p>This command looks up which server “origin” is (in this case, it’s git.ourcompany.com), fetches any data from it that you don’t yet have, and updates your local database, moving your origin/master pointer to its new, more up-to-date position. </p>
<p>Git fetch origin fetches any new work that has been pushed to that server since you cloned (or last fetched from) it. It’s important to note that the git fetch command only downloads the data to your local repository — it doesn’t automatically merge it with any of your work or modify what you’re currently working on. You have to merge it manually into your work when you’re ready .</p>
</blockquote>
<pre><code class="language-shell"># 从远程库拉取所有分支
git fetch origin

# 从指定远程库拉取指定分支
git fetch origin test 
git fetch git://git.kernel.org/pub/scm/git/git.git maint # 从远程库 拉取 maint 分支

git fetch origin +pu:pu maint:tmp
# This updates (or creates, as necessary) branches pu and tmp in the local repository by fetching from the branches (respectively) pu and maint from the remote repository. The pu branch will be updated even if it is does not fast-forward, because it is prefixed with a plus sign; tmp will not be.
</code></pre>
<h3 id="git-pull"><a class="header" href="#git-pull">git pull</a></h3>
<p>git-pull - Fetch from and integrate with another repository or a local branch.</p>
<pre><code class="language-shell"># 从远程仓库拉取某个分支
git pull origin master
# 等价于
git fetch origin master
git merge origin/master

# 将远程仓库与本地仓库合并
git pull origin master --allow-unrelated-histories 
</code></pre>
<h3 id="git-push"><a class="header" href="#git-push">git push</a></h3>
<pre><code class="language-shell"># push local branch to remote repos
git push origin master # origin 代表远程库，master 代表本地的 branch
git push origin dev # dev 是另外一个 local branch

# 将本地的 master 分支推送到 origin，并且指定 origin 为默认主机，后面就可以不加任何参数，使用 git push 了
# 如果我们在 push 的时候，加了 -u 参数，就将本地的 master 分支推送到远程的这个配置，存储了。等到 pull 的时候，git pull 就会默认从远程拉取内容合并到本地的 master 分支，不需要 git pull origin master
git push -u origin master 

# 强制提交到远程仓库 
git push origin HEAD --force 

# 将本地的分支强制提交到远程的某分支
git push -f origin HEAD:远程的分支
</code></pre>
<p>将本地仓库提交到远程新建的仓库，有两个方法：</p>
<ul>
<li>
<p>强制提交到远程仓库，相当于本地仓库直接覆盖了远程，风险很大</p>
</li>
<li>
<p>拉取远程仓库，与本地仓库合并，然后再推送到远程</p>
<pre><code class="language-shell">git pull origin master --allow-unrelated-histories
</code></pre>
</li>
</ul>
<h3 id="git-tag-git-show"><a class="header" href="#git-tag-git-show">git tag, git show</a></h3>
<p>注意：<code>git push</code> 并不会默认将 tags 推送到 remote-repos</p>
<pre><code class="language-shell"># show all the tags
git tag

# show the tags that match a particular pattern
git tag -l &quot;v1.*&quot; # -l: --list

# create a tag
# -a annotate
# -m message
git tag -a tag-name -m tag-message # -a: --annotate
git tag -a v1.4 -m &quot;my version 1.4&quot;

# 为之前的 commit 记录打标签
git tag -a v1.2 commit-hash-str

# show tags with commit message
git show tag-name

# push all tags to the remote-repos that are not already there
git push origin --tags
# push one tag to remote-repos
git push origin tag-name

# delete tags
git tag -d tag-name
git push origin --delete tag-name

# 查看一个标签指向的版本文件
git checkout tag-name
# 则会使仓库进入 detached HEAD 状态，即当前不在任何分支，如果我们在此基础上做了某些修改并 commit，这个 commit 就会因为没有 branch 而丢失，所以如果我们想要修改一个老版本的 bug，应该先创建一个分支：
git checkout -b branch-name tag-name
</code></pre>
<h3 id="git-reset-git-reflog"><a class="header" href="#git-reset-git-reflog">git reset, git reflog</a></h3>
<pre><code class="language-shell"># 回滚到上一个版本
git reset --hard HEAD^
git reset --hard 459f # 此处的版本号不需要写全，写前几个字符就够了，git 会自动去查找补全。

# show all the commits since the initialization of repos
git reflog

# Unstaging a Staged File 取消加入暂存区，git add 的逆操作
git reset HEAD file
</code></pre>
<h2 id="git-branching"><a class="header" href="#git-branching">Git Branching</a></h2>
<h3 id="git-branch-git-checkout"><a class="header" href="#git-branch-git-checkout">git branch, git checkout</a></h3>
<p>Branching means you diverge from the main line of development and continue to do work without messing with that main line. </p>
<p>Git 的杀手级功能，Git 分支的创建是轻量的，快速的。</p>
<p>一个 branch 实际上只是一个指向某一个 commit 对象的指针。</p>
<p><strong>branch</strong> 官方解释：</p>
<blockquote>
<p>A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you start making commits, you’re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically </p>
<p>a branch in Git is actually a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy. Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline) </p>
</blockquote>
<p><strong>master</strong> 官方解释：</p>
<blockquote>
<p>The “master” branch in Git is not a special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the git init command creates it by default and most people don’t bother to change it </p>
</blockquote>
<p><strong>HEAD</strong> 官方解释：</p>
<blockquote>
<p>How does Git know what branch you’re currently on? It keeps a special pointer called HEAD. </p>
<p>This is a pointer to the local branch you’re currently on. </p>
</blockquote>
<pre><code class="language-shell"># new a branch
git branch branch-name
# This creates a new pointer to the same commit you’re currently on

# delete a branch
git branch -d branch-name

# 查看所有分支，包括远程的
git branch -a

# show all the branch
git branch 
# 注意，分支名前面的 * 表示我们当前处于哪一个分支，即 HEAD 指针指向的分支
# show the last commit of all branch
git branch -v
# show which branches are already merged into the branch you refer to
git branch --merged master
# show all the branches that contain work you haven’t yet merged into master
git branch --no-merged master
# 分支更改名称
git branch -m oldname newname

# change branch
git checkout test
# This moves HEAD to point to the testing branch. HEAD points to the current branch
# 注意：如果我们的工作区有没有 commit 的修改，而且与要 checkout 的分支冲突的话，Git 是不允许 checkout 的
git checkout master
# 上面这个命令做了两件事：
# 1. 将 HEAD 指针指向了 master 分支
# 2. 将工作区的文件恢复到 master 的状态
# new a branch and checkout 
git checkout -b branch-name
# new a branch called serverfix pulled from origin/serverfix, a local branch that you can work on that starts where origin/serverfix is
git checkout -b serverfix origin/serverfix

# 查看 commit 的 history
git log --oneline --decorate --graph --all

# 查看 branch 树形结构
git log --graph --decorate --oneline --simplify-by-decoration --all

# 删除远程分支
git push origin --delete &lt;远程分支名称&gt;
</code></pre>
<h3 id="git-merge"><a class="header" href="#git-merge">git merge</a></h3>
<p>没有分叉(<strong>diverged</strong>)的 merge，叫做 <strong>fast-forward</strong> ，其合并后并不会产生一个 commit 记录。</p>
<p>有分叉的 merge，Git 采用 Three-way（two snapshots pointed to by the branch tips and the common ancestor of the two ） merge，Git 根据三方创建了一个新的快照，并产生了一个新的 commit 记录。</p>
<p>fast-forward 官方解释：</p>
<blockquote>
<p>when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together — this is called a “fast-forward.”</p>
</blockquote>
<pre><code class="language-shell"># merge demo, master merge testing
git checkout master
git merge testing

# 将远程仓库的 master 分支 merge 到当前的分支
git merge origin/master
# 如果报错，则
git merge origin/master --allow-unrelated-histories

# 默认情况下执 fast-forward 合并，并不会产生一个 commit 记录，为了保证版本演进的清晰，加上 --no-ff (no fast-forward) 参数，生成 commit 记录
git merge --no-ff develop

# 如果合并后，引起冲突，想取消 git pull，则使用该命令
git merge --abort
</code></pre>
<p><strong>冲突的解决办法</strong></p>
<p>merge 发起后，如果出现了冲突，Git 会一直处于 merging 的状态，并提醒用户处理 conflict，并且冲突的文件里，会用 Git 的 standard conflict-resolution marker 去 mark 有冲突的地方，只有解决了这些有冲突的行，才能继续下去。下面是一个标准的冲突域：</p>
<pre><code class="language-shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id=&quot;footer&quot;&gt;
please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html
</code></pre>
<p><code>=======</code> 上面的是 master 分支的内容，下面的是 testing 分支的内容，我们需要判断保留哪一个版本，或者改成一个新的版本，然后在代码里进行修改，例如修改成如下的内容，注意要把所有的 conflict-resolution marker 全部删除：</p>
<pre><code class="language-html">&lt;div id=&quot;footer&quot;&gt;
please contact us at email.support@github.com
&lt;/div&gt;
</code></pre>
<p>注意此时我们仍然还处于 merging 的状态，可以用 <code>git status</code> 看到我们的状态：<code>All conflicts fixed but you are still merging. </code> 所以最后我们需要将 merge 的修改 commit: <code>git commit -m &quot;message&quot;</code></p>
<h4 id="topic-branch-1"><a class="header" href="#topic-branch-1">topic branch</a></h4>
<p>官方解释：</p>
<blockquote>
<p>A topic branch is a short-lived branch that you create and use for a single particular feature or related work. This is something you’ve likely never done with a VCS before because it’s generally too expensive to create and merge branches. But in Git it’s common to create, work on, merge, and delete branches several times a day. </p>
</blockquote>
<p><code>git branch</code>技术给小步试错，快速迭代带来了便捷</p>
<h3 id="git-cherry-pick"><a class="header" href="#git-cherry-pick">git cherry-pick</a></h3>
<p>遴选！</p>
<p>git merge 是将一个分支的所有变动，合并到另一个分支。有时候我们不需要把所有的变动合并到某个分支，而是只想要把几次 commit 变动的内容合并到其他分支。这个时候就用到了 cherry-pick。</p>
<p>详细介绍：<a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">阮一峰 git cherry-pick 教程</a></p>
<p>demo: 如果我们想把 dev 分支的三个提交  5ea6e 8a28f 8b4bc 合并到 master 分支，可以这么做：</p>
<pre><code class="language-shell">git checkout master
git cherry-pick 5ea6e 8a28f 8b4bc
</code></pre>
<p>master 分支会产生三个新的 commit，内容和 5ea6e 8a28f 8b4bc 完全一致，但是 hash 值变了，表示是新的提交。</p>
<p><strong>注意</strong>：5ea6e 要早于 8a28f，否则命令将失败，但不会报错。</p>
<p>也可以批量合并一个范围</p>
<pre><code class="language-shell">git cherry-pick A..B 
</code></pre>
<h3 id="remote-branches-explanation"><a class="header" href="#remote-branches-explanation">remote branches explanation</a></h3>
<h4 id="cmd-git-remote-show"><a class="header" href="#cmd-git-remote-show">cmd: git remote show</a></h4>
<pre><code class="language-shell"># show remote branch and info of remote-repos
git remote show origin
</code></pre>
<h4 id="cmd-git-push"><a class="header" href="#cmd-git-push">cmd: git push</a></h4>
<pre><code class="language-shell"># push local branch to remote repos
git push origin master # origin 代表远程库，master 代表本地的 main branch
git push origin dev # dev 是另外一个 local branch

# Take my serverfix and make it the remote’s serverfix
git push origin serverfix:serverfix
# push your local serverfix branch to the awesomebranch branch on the remote project
git push origin serverfix:awesomebranch
</code></pre>
<h4 id="concept-remote-tracking-branches"><a class="header" href="#concept-remote-tracking-branches">concept: Remote-tracking branches</a></h4>
<p>remote-tracking branch 是一个本地的指向 remote branch 的指针。</p>
<p>官方解释：</p>
<blockquote>
<p>Remote-tracking branches are references to the state of remote branches. They’re local references that you can’t move; Git moves them for you whenever you do any network communication, to make sure they accurately represent the state of the remote repository. Think of them as bookmarks, to remind you where the branches in your remote repositories were the last time you connected to them. </p>
</blockquote>
<p>form of remote-tracking branch：<code>&lt;remote&gt;/&lt;branch&gt; </code></p>
<p>实际上，<code>git fetch</code> 命令只是用来 update remote-tracking branches，它会 fetches any data from it that you don’t yet have, and updates your local database, moving your origin/master pointer to its new, more up-to-date position. </p>
<p>官方解释</p>
<blockquote>
<p>It’s important to note that when you do a fetch that brings down new remote-tracking branches, you don’t automatically have local, editable copies of them. In other words, in this case, you don’t have a new serverfix branch — you have only an origin/serverfix pointer that you can’t modify.</p>
</blockquote>
<h4 id="concept-tracking-branches"><a class="header" href="#concept-tracking-branches">concept: Tracking Branches</a></h4>
<p>顾名思义，指的是一个本地的分支，与  remote-repos/branch 关联，然后变成了要给 tracking branch</p>
<p>官方解释</p>
<blockquote>
<p>When you clone a repository, it generally automatically creates a master branch that tracks
origin/master. </p>
<p>Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch” (and the branch it tracks is called an “upstream branch”). Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and type git pull, Git automatically knows which server to fetch from and which branch to merge in. </p>
</blockquote>
<pre><code class="language-shell"># 使得当前的分支与远程的分支关联
git checkout --track origin/serverfix

# 在本地创建一个分支，并于远程的分支产生关联
git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;

# In fact, this is so common that there’s even a shortcut for that shortcut. If the branch name you’re trying to checkout (a) doesn’t exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you:
git checkout serverfix 

# If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you’re tracking, you can use the -u or --set-upstream-to option to git branch to explicitly set it at any time.
git branch -u origin/serverfix # 修改关联的远程分支

# see what tracking branches you have set up
git branch -vv # 查看本地仓库的分支和远程仓库的分支的 diff 和 relationship

# It’s important to note that these numbers are only since the last time you fetched from each server. This command does not reach out to the servers, it’s telling you about what it has cached from these servers locally. If you want totally up to date ahead and behind numbers, you’ll need to fetch from all your remotes right before running this. You could do that like this
git fetch --all; git branch -vv # 及时更新本地的仓库和远程仓库的 diff

# 删除远程仓库的分支
git push origin --delete serverfix
</code></pre>
<h2 id="fixed-problems-2"><a class="header" href="#fixed-problems-2">Fixed Problems</a></h2>
<h3 id="git-不区分文件名大小写"><a class="header" href="#git-不区分文件名大小写">Git 不区分文件名大小写</a></h3>
<h3 id="中文乱码"><a class="header" href="#中文乱码">中文乱码</a></h3>
<pre><code class="language-shell"># 中文乱码
git config --global core.quotepath false
git status -s
</code></pre>
<h3 id="生成公钥的命令"><a class="header" href="#生成公钥的命令">生成公钥的命令</a></h3>
<pre><code class="language-shell"># 生成公钥的命令
ssh-keygen
# 生成的文件地址：/c/Users/wanshuo/.ssh/id_rsa，一个公钥一个私钥，私钥为 id_rsa, 公钥为 id_rsa.pub
</code></pre>
<h3 id="git-不追踪空文件夹"><a class="header" href="#git-不追踪空文件夹">Git 不追踪空文件夹</a></h3>
<pre><code class="language-shell"># git 不追踪空的文件夹
在空文件夹下加入 .gitignore 文件，内容为
*
!.gitignore
</code></pre>
<h3 id="设置代理"><a class="header" href="#设置代理">设置代理</a></h3>
<pre><code class="language-shell"># git clone 速度慢到几 KB
1. 打开 lantern，使用代理服务器，把端口调整到 lantern 的监听端口
2. 设置 Git 的代理：
git config --global http.proxy http://127.0.0.1:7890 # 2136 就是翻墙软件代理的端口号
git config --global https.proxy https://127.0.0.1:7890

#对于 GitHub 中的仓库，可以局部配置 proxy:
git config --local http.proxy http://127.0.0.1:7890 # 2136 就是翻墙软件代理的端口号
git config --local https.proxy https://127.0.0.1:7890
git config --local user.name &quot;wansho&quot;
git config --local user.email wanshojs@hotmail.com

# 注意：此模式只适用于 http 协议，不适用于 SSH 协议
# 同样适用于 WSL

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy

</code></pre>
<p>测试了一下，github 在中国、日本、韩国都没有服务器，将节点切换到这三个国家速度都很慢，切换到美国速度就非常快。</p>
<h3 id="windows-git-的-vim-无法粘贴"><a class="header" href="#windows-git-的-vim-无法粘贴">Windows git 的 vim 无法粘贴</a></h3>
<pre><code class="language-shell"># windows git 下的 vim 无法粘贴
快捷键：shift + insert
</code></pre>
<h3 id="push--pull-不输入密码"><a class="header" href="#push--pull-不输入密码">push / pull 不输入密码</a></h3>
<pre><code class="language-shell">git config --global credential.helper store
</code></pre>
<h2 id="github-2"><a class="header" href="#github-2">Github</a></h2>
<h3 id="约定俗成的规则"><a class="header" href="#约定俗成的规则">约定俗成的规则</a></h3>
<ol>
<li>Github 的仓库名字的标准：<code>awesome-react-native</code></li>
<li>Github 的 README 渲染不支持 TOC</li>
<li>Github 在 VPN 环境下 clone 时，Https 的协议比 SSH 的协议快</li>
</ol>
<h3 id="github-gist"><a class="header" href="#github-gist">Github Gist</a></h3>
<p>Gist 是一个用来存放文件的仓库，本质上就是一个 Git Repository，不能上传文件夹</p>
<p>With gists, you can share single files, parts of files, and full applications with other people. Directories can't be shared. You can access your gists at <a href="https://gist.github.com/">https://gist.github.com</a>.</p>
<p>Every gist is a Git repository, which means that it can be forked and cloned. The gist editor is powered by <a href="https://codemirror.net/">CodeMirror</a>.</p>
<p><strong>作用</strong></p>
<p>共享文件，例如共享专业课考研资料。</p>
<h3 id="github-collaboration"><a class="header" href="#github-collaboration">GitHub Collaboration</a></h3>
<h4 id="fork"><a class="header" href="#fork">fork</a></h4>
<p>fork 有两个作用：</p>
<ol>
<li>在别人代码的基础上进行自己的开发</li>
<li>向 forked 的 project 提交修改，通常用于代码协作</li>
</ol>
<h4 id="pull-requests"><a class="header" href="#pull-requests">pull requests</a></h4>
<p>pull  request 用于提交修改，通常用于仓库没有写入权限时的多人协作。</p>
<p>如果对于仓库有写入权限，那么用 topic branch 即可。<code>pull request</code>的具体操作如下：</p>
<ol>
<li>
<p>Fork the repository.</p>
</li>
<li>
<p>Make the fix.</p>
</li>
<li>
<p>Submit a <em>pull request</em> to the project owner</p>
</li>
</ol>
<h3 id="github-organization"><a class="header" href="#github-organization">GitHub Organization</a></h3>
<p>Github 可以创建一个 Organization, setting —&gt; organization。</p>
<p>Github Organization 不能自己申请加入，只能通过别人的邀请才能加入</p>
<h3 id="github-contributions-规则"><a class="header" href="#github-contributions-规则">Github Contributions 规则</a></h3>
<ul>
<li>必须是主分支（其他分支不计入 contribution），通常是 master 分支，如果是其他分支的 commit，那么在 merge 到主分支之后，就会加入统计</li>
<li>隐藏的项目，也算作 contribution 的</li>
</ul>
<h3 id="github-projects-介绍"><a class="header" href="#github-projects-介绍">Github projects 介绍</a></h3>
<h3 id="优秀的开源组织"><a class="header" href="#优秀的开源组织">优秀的开源组织</a></h3>
<p><a href="https://github.com/apachecn">ApacheCN</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h1>
<p>Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and <strong>share</strong> actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.</p>
<p>[TOC]</p>
<h2 id="入门-1"><a class="header" href="#入门-1">入门</a></h2>
<ul>
<li><a href="https://docs.github.com/en/actions">官方文档</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">阮一峰入门教程</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/12/github_actions.html">定时发送天气邮件</a></li>
<li><a href="https://github.com/actionsflow/actionsflow">actionsflow</a></li>
</ul>
<h2 id="我的笔记"><a class="header" href="#我的笔记">我的笔记</a></h2>
<ul>
<li>Action 有 crontab 机制，可以定时执行</li>
<li>从 <a href="https://github.com/github/roadmap">Github RoadMap</a> 中可以了解到，Github Actions 是 Code-to-Cloud 的一种方式</li>
<li>Github Action 可以作为主动获取信息的一种工具，当作爬虫，当作定时脚本，薅 Github 的羊毛</li>
<li>Github Action 的运行环境在国外，着意味着，我们可以在国内写脚本，在国外的服务器上运行，这样就可以访问全球的服务</li>
<li>Github Action 的 Crontab 时间，是国际标准时间</li>
<li>GitHub Action 可以跑 Python 脚本：<a href="https://github.com/xiaomustudent/glados-checkin">glados-checkin</a>，我觉得其理论上可以跑任何语言，成为一个云服务平台</li>
</ul>
<h2 id="我的总结"><a class="header" href="#我的总结">我的总结</a></h2>
<ul>
<li>可以在 .github/workflows 中创建多个 workflow，GitHub 容器默认会执行所有的 workflow</li>
<li>Github Actions 的功能，与 <strong>Jenkins</strong> 的功能有耦合</li>
</ul>
<h2 id="官方文档"><a class="header" href="#官方文档">官方文档</a></h2>
<h3 id="基本信息"><a class="header" href="#基本信息">基本信息</a></h3>
<ul>
<li>GitHub Actions 不支持私人仓库</li>
<li>GitHub Actions 默认对每一个仓库开启</li>
<li>查找公开的</li>
</ul>
<h3 id="workflows"><a class="header" href="#workflows">Workflows</a></h3>
<p>Workflows are custom automated processes that you can set up in your repository to build, test, package, release, or deploy any code project on GitHub. （是什么？可以用来对仓库进行构建、测试、打包、发布、部署的脚本）</p>
<p>Workflows run in <strong>Linux</strong>, macOS, Windows, and containers on <strong>GitHub-hosted machines</strong>, called 'runners'. Alternatively, you can also host your own runners to run workflows on machines you own or manage.（可以理解为：在 Github 提供的计算资源上跑这个仓库对应的脚本，脚本语法由 Github 制定）</p>
<p>You can create workflows using actions defined in your repository, open source actions in a public repository on GitHub, or a published Docker container image. （Workflows 由 Actions 组成，actions 可以来源于其他仓库）</p>
<p>Github Marketplace. <a href="https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/using-actions-from-github-marketplace-in-your-workflow">Using actions from GitHub Marketplace in your workflow</a>. （查找公开的 actions）</p>
<h3 id="core-concepts-for-github-actions"><a class="header" href="#core-concepts-for-github-actions">Core-Concepts-for-GitHub-Actions</a></h3>
<h4 id="action-1"><a class="header" href="#action-1">Action</a></h4>
<p>Action 是 Workflow 的最小单位。我们可以创建自己的 action，也可以直接使用别人分享的 action，也可以修改别人公开的 action。</p>
<p>Action 在 Workflow 是一个 step。</p>
<h4 id="artifact"><a class="header" href="#artifact">Artifact</a></h4>
<p>Artifacts are the files created when you build and test your code. For example, artifacts might include binary or package files, test results, screenshots, or log files. </p>
<h4 id="continuous-integration-ci"><a class="header" href="#continuous-integration-ci">Continuous Integration CI</a></h4>
<p>The software development practice of <strong>frequently committing small code changes to a shared repository</strong>. With GitHub Actions, <strong>you can create custom CI workflows that automate building and testing your code</strong>. From your repository, <strong>you can view the status of your code changes and detailed logs for each action</strong> in your workflow. <strong>CI saves developers time by providing immediate feedback on code changes to detect and resolve bugs faster</strong>.</p>
<h4 id="continuous-deployment-cd"><a class="header" href="#continuous-deployment-cd">Continuous Deployment CD</a></h4>
<p>Continuous deployment <strong>builds on continuous integration</strong>. When new code is committed and <strong>passes your CI tests</strong>, the code is <strong>automatically deployed to production</strong>. With GitHub Actions, <strong>you can create custom CD workflows to automatically deploy your code</strong> to any cloud, self-hosted service, or platform from your repository. <strong>CD saves developers time by automating the deployment process and deploys tested, stable code changes more quickly to your customers</strong>.</p>
<h4 id="event"><a class="header" href="#event">Event</a></h4>
<p>A specific activity that <strong>triggers</strong> a workflow run. For example, activity can originate from GitHub when someone <strong>pushes a commit</strong> to a repository or when an <strong>issue</strong> or <strong>pull request</strong> is created. You can also <strong>configure a workflow to run when an external event occurs</strong> using the repository dispatch <strong>webhook</strong>. (可以通过 Webhook 外部条件触发)</p>
<h4 id="github-hosted-runner"><a class="header" href="#github-hosted-runner">GitHub-hosted runner</a></h4>
<p>Github 提供的执行 Actions 的虚拟环境：Linux，Windows，Mac。</p>
<h4 id="job"><a class="header" href="#job">Job</a></h4>
<p>A set of steps that execute on the same runner. You can define the <strong>dependency rules</strong> for how jobs run in a workflow file. Jobs can run at the same time in <strong>parallel</strong> or run <strong>sequentially</strong> depending on the status of a previous job. For example, a workflow can have two sequential jobs that build and test code, where the test job is dependent on the status of the build job. If the build job fails, the test job will not run. For GitHub-hosted runners, each job in a workflow runs in a fresh instance of a virtual environment. （可以并行，也可以按指定顺序执行。每一个 Job 都是隔离的，这意味着一个 Job 的变量，只局限于 Job 的内部使用）</p>
<h4 id="step"><a class="header" href="#step">Step</a></h4>
<p>A step is an individual task that can run commands or actions. <strong>A job configures one or more steps</strong>. Each step in a job executes on the same runner, allowing the actions in that job to share information using the filesystem. （一个 job 中的多个 steps 共享当前 job 的环境变量）</p>
<h4 id="workflow"><a class="header" href="#workflow">Workflow</a></h4>
<p>Workflows are <strong>made up of one or more jobs</strong> and can be scheduled or activated by an event.</p>
<pre><code class="language-yaml">.github/workflows
    workflow-1.yml
    
workflow
	job-1
		step-1
			action-1
			action-2
		step-2
	job-2
		step-1
		step-2
</code></pre>
<h4 id="secrets"><a class="header" href="#secrets">Secrets</a></h4>
<p>Secrets are environment variables that are <strong>encrypted</strong> and only exposed to selected actions. Anyone with <strong>collaborator</strong> access to this repository can use these secrets in a workflow. （Secrets 中通常放一些用户名和密码）</p>
<p>Secrets are not passed to workflows that are triggered by a pull request from a fork. （为了保护 Secrets，GitHub 只允许仓库的 collaborator 访问 secrets 数据，fork 就不能使用）</p>
<h2 id="我的-github-actions-需求"><a class="header" href="#我的-github-actions-需求">我的 GitHub Actions 需求</a></h2>
<ul>
<li>
<p>awesome-kaoyan </p>
<ul>
<li>自动生成最新的文件树</li>
<li>为每一个 markdown 文件自动生成 TOC：已找到 TOC 的 action</li>
<li>用 Actions 定制自己的信息源（语言：Python）
<ul>
<li>做一个脚本，获取每天早上的信息一览：已做了一个发天气的 action</li>
<li>每天早上-中午-晚上的微博热搜</li>
<li>每天早晚两次推送</li>
</ul>
</li>
</ul>
</li>
<li>
<p>监测继保官网的新闻</p>
</li>
</ul>
<h2 id="github-action-配合食用"><a class="header" href="#github-action-配合食用">Github Action 配合食用</a></h2>
<ul>
<li><a href="http://sc.ftqq.com/3.version">Server 酱</a> 「程序员」和「服务器」之间的通信软件</li>
</ul>
<h2 id="好玩的-github-action"><a class="header" href="#好玩的-github-action">好玩的 Github Action</a></h2>
<ul>
<li><a href="https://github.com/Yikun/hub-mirror-action">hub-mirror-action</a> 代码托管平台同步脚本</li>
<li><a href="https://github.com/JunzhouLiu/BILIBILI-HELPER">BILIBILI-HELPER</a> 哔哩哔哩 签到脚本</li>
<li><a href="https://itsopensource.com/publish-github-pages-with-github-actions/">如何使用 GitHub Actions 发布到 GitHub Pages</a></li>
</ul>
<h2 id="reference-3"><a class="header" href="#reference-3">Reference</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/103552188">编写自己的 GitHub Action，体验自动化部署 - 张凯强的文章 - 知乎 </a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown--readme"><a class="header" href="#markdown--readme">markdown &amp; README</a></h1>
<p>[TOC]</p>
<h2 id="markdown--latex"><a class="header" href="#markdown--latex">markdown + latex</a></h2>
<p>Typora  兼容 latex 的公式编辑，这里记录在 Typora 中 用 latex 语法可以打出 一些特殊符号。</p>
<table><thead><tr><th>符号</th><th></th></tr></thead><tbody>
<tr><td>对勾</td><td><code>$\surd$</code></td></tr>
<tr><td>叉号、乘号</td><td><code>$\times$</code></td></tr>
</tbody></table>
<h2 id="authentic-readme"><a class="header" href="#authentic-readme">Authentic README</a></h2>
<p>如何写出纯正的 README</p>
<ul>
<li>
<p>https://github.com/matiassingers/awesome-readme</p>
</li>
<li>
<p>https://github.com/zalando/zalando-howto-open-source/blob/master/READMEtemplate.md</p>
</li>
<li>
<p><a href="https://github.com/anuraghazra/anuraghazra">anuraghazra</a></p>
</li>
<li>
<p><a href="https://github.com/kautukkundan/Awesome-Profile-README-templates">Awesome-Profile-README-templates</a></p>
</li>
</ul>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<pre><code>&lt;!--
**wansho/wansho** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.

Here are some ideas to get you started:

- 🔭 I’m currently working on ...
- 🌱 I’m currently learning ...
- 👯 I’m looking to collaborate on ...
- 🤔 I’m looking for help with ...
- 💬 Ask me about ...
- 📫 How to reach me: ...
- 😄 Pronouns: ...
- ⚡ Fun fact: ...
--&gt;
</code></pre>
<pre><code>Project Name/Intro
Core Technical Concepts/Inspiration
Getting Started/Requirements/Prerequisites/Dependencies
More Specific Topics
Contributing
TODO
Contact
License
</code></pre>
<h3 id="代码-diff"><a class="header" href="#代码-diff">代码 diff</a></h3>
<pre><code class="language-diff">function addTwoNumbers (num1, num2) {
-  return 1 + 2
+  return num1 + num2
}
</code></pre>
<pre><code>```diff
function addTwoNumbers (num1, num2) {
-  return 1 + 2
+  return num1 + num2
}
```
</code></pre>
<h3 id="高级引用"><a class="header" href="#高级引用">高级引用</a></h3>
<p>定义一个引用：</p>
<p>使用一个引用：</p>
<p>我最近正在看这篇技术技术文章：<a href="https://www.zhihu.com/question/317183937/answer/1474629982">jpa mybatis 比较</a></p>
<p>语法：</p>
<pre><code>定义一个引用：
[jpa mybatis比较]: https://www.zhihu.com/question/317183937/answer/1474629982

使用一个引用：注意是两个 [][]
[jpa mybatis 比较][jpa mybatis比较]
</code></pre>
<p>定义的引用相当于注释，生成 pdf 的时候会被删除。</p>
<h3 id="页内引用"><a class="header" href="#页内引用">页内引用</a></h3>
<p>锚</p>
<pre><code>[描述](#id)
</code></pre>
<h3 id="yaml-front-matter"><a class="header" href="#yaml-front-matter">YAML front matter</a></h3>
<p><em>YFM is an</em> <strong>optional</strong> <em>section of valid YAML that is placed at the top of a page and is used for maintaining metadata for the page and its contents.</em></p>
<p>其实对于 markdown 来说，就是注释，只是这注释</p>
<p>语法：</p>
<pre><code>---
title: YAML Front Matter
description: A very simple way to add structured data to a page.
---
</code></pre>
<h3 id="脚注"><a class="header" href="#脚注">脚注</a></h3>
<p>示例：</p>
<p>使用 Markdown<sup class="footnote-reference"><a href="#1">1</a></sup>可以效率的书写文档, 直接转换成 HTML<sup class="footnote-reference"><a href="#2">2</a></sup>, 你可以使用 Typora<sup class="footnote-reference"><a href="#T">3</a></sup> 编辑器进行书写。
<sup class="footnote-reference"><a href="#1">1</a></sup>:Markdown是一种纯文本标记语言
<sup class="footnote-reference"><a href="#2">2</a></sup>:HyperText Markup Language 超文本标记语言
<sup class="footnote-reference"><a href="#T">3</a></sup>:NEW WAY TO READ &amp; WRITE MARKDOWN.</p>
<p>语法：</p>
<pre><code>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。
[^1]:Markdown是一种纯文本标记语言
[^2]:HyperText Markup Language 超文本标记语言
[^T]:NEW WAY TO READ &amp; WRITE MARKDOWN.
</code></pre>
<p>注意，在生成 pdf 的时候，脚注会自动添加到 pdf 的最后。</p>
<h2 id="图片相关"><a class="header" href="#图片相关">图片相关</a></h2>
<h3 id="creating-gifs"><a class="header" href="#creating-gifs">Creating GIFs</a></h3>
<p><a href="https://github.com/matiassingers/awesome-readme#creating-gifs">gif工具集</a></p>
<p><a href="https://giphy.com/">gif图床</a></p>
<p><a href="https://ezgif.com/">gif压缩</a> 选择 resize 和 optimize 两个选项进行压缩，其中 resize 效果最好</p>
<p><a href="https://www.screentogif.com/">gif软件 Screen to Gif </a></p>
<h3 id="超链接功能-图片超链接"><a class="header" href="#超链接功能-图片超链接">超链接功能-图片超链接</a></h3>
<p>正常的超链接语法为: <code>[desc](url)</code></p>
<p>需要注意的是 <strong>desc 并不只限于文本</strong>，也可以插入一个图片，GitHub badge 的原理就是这样的。</p>
<pre><code>[![Build Status](https://travis-ci.org/chinese-poetry/chinese-poetry.svg)](https://travis-ci.org/chinese-poetry/chinese-poetry)
</code></pre>
<p><a href="https://travis-ci.org/chinese-poetry/chinese-poetry"><img src="https://travis-ci.org/chinese-poetry/chinese-poetry.svg" alt="Build Status" /></a></p>
<p>Github Readme Stats 的原理也是这样的：</p>
<pre><code>[![Wansho's github stats](https://github-readme-stats.vercel.app/api?username=wansho)](https://github.com/wansho)
</code></pre>
<p><a href="https://github.com/wansho"><img src="https://github-readme-stats.vercel.app/api?username=wansho" alt="wansho's github stats" /></a></p>
<p><strong>图片超链接的方式可以天然地实现图片的居左显示</strong>，以后不要再缩小居左了，直接用图片超链接的方式！</p>
<h3 id="插入图片"><a class="header" href="#插入图片">插入图片</a></h3>
<pre><code class="language-html">&lt;div align=&quot;left&quot;&gt;
    
    &lt;img src=&quot;/assets/321556185.jpg&quot; width=20% height=20% /&gt;
    &lt;img src=&quot;/assets/QQ群.jpg&quot; width=20% height=20% /&gt;
    
&lt;/div&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;a href=&quot;https://evilmartians.com/?utm_source=size-limit&quot;&gt;
    &lt;img src=&quot;https://evilmartians.com/badges/sponsored-by-evil-martians.svg&quot;
         alt=&quot;Sponsored by Evil Martians&quot; width=&quot;236&quot; height=&quot;54&quot;&gt;
  &lt;/a&gt;
&lt;/p&gt;

</code></pre>
<p>也可以通过图片超链接的方式插入</p>
<h3 id="图床"><a class="header" href="#图床">图床</a></h3>
<p>腾讯云对象存储 cos，赠送免费 50G 容量</p>
<p>https://console.cloud.tencent.com/cos5/bucket/setting?type=filelist&amp;bucketName=blog-pic-1258744409&amp;path=&amp;region=ap-chengdu</p>
<p>图片上传到云端的接口软件：https://github.com/Molunerfinn/PicGo</p>
<p>腾讯只免费赠送 6 个月，不实惠，改用阿里云的OSS存储：</p>
<blockquote>
<p>您可以使用阿里云提供的API、SDK接口或者OSS迁移工具轻松地将海量数据移入或移出阿里云OSS。数据存储到阿里云OSS以后，您可以选择标准类型（Standard）的阿里云OSS服务作为移动应用、大型网站、图片分享或热点音视频的主要存储方式，也可以选择成本更低、存储期限更长的低频访问类型（Infrequent Access）和归档类型（Archive）的阿里云OSS服务作为不经常访问数据的备份和归档。</p>
</blockquote>
<p>阿里云有专属的客户端：<a href="http://gosspublic.alicdn.com/oss-browser/1.9.1/oss-browser-win32-x64.zip?spm=a2c4g.11186623.2.10.42741144jhrm9W&amp;file=oss-browser-win32-x64.zip">ossbrowser</a></p>
<h3 id="项目徽章"><a class="header" href="#项目徽章">项目徽章</a></h3>
<p>Demos：</p>
<pre><code>https://img.shields.io/github/stars/yzhao062/anomaly-detection-resources.svg
https://img.shields.io/github/forks/yzhao062/anomaly-detection-resources.svg
https://img.shields.io/github/license/yzhao062/anomaly-detection-resources.svg
https://img.shields.io/badge/link-996.icu-red.svg

[![Build Status](https://travis-ci.org/chinese-poetry/chinese-poetry.svg)](https://travis-ci.org/chinese-poetry/chinese-poetry)
[![License](http://img.shields.io/badge/license-mit-blue.svg?style=flat-square)](https://github.com/jackeyGao/chinese-poetry/blob/master/LICENSE)
[![](https://img.shields.io/github/contributors/chinese-poetry/chinese-poetry.svg)](https://github.com/chinese-poetry/chinese-poetry/graphs/contributors)![项目徽章举例](https://img.shields.io/github/license/wansho/Last-Statement-of-Death-Row.svg)
</code></pre>
<p>https://shields.io/</p>
<h2 id="markdown-工具"><a class="header" href="#markdown-工具">Markdown 工具</a></h2>
<h3 id="生成-toc---linux-工具"><a class="header" href="#生成-toc---linux-工具">生成 TOC - linux 工具</a></h3>
<p>For Linux, https://github.com/ekalinin/github-markdown-toc</p>
<pre><code class="language-shell">$ wget https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc
$ chmod a+x gh-md-toc
$ ./gh-md-toc README.md # 结果是生成一个 TOC，把该 TOC 粘贴到 markdown 中即可
</code></pre>
<h3 id="生成-toc---nodejs"><a class="header" href="#生成-toc---nodejs">生成 TOC - nodejs</a></h3>
<p>生成 TOC 的场景：在本地其实是用不到生成 TOC 的功能的，因为 Typora 提供了 TOC 功能，生成 TOC 功能主要是给其他人看的，主要用在 GitHub 和 gitlab 的开源项目上。</p>
<p>生成 toc 的工具：<a href="https://github.com/thlorenz/doctoc">doctoc</a></p>
<p>使用教程：</p>
<ol>
<li>
<p>指定要插入 TOC 的地方：</p>
<!-- START doctoc -->
<!-- END doctoc -->
</li>
<li>
<p>指定 toc-title：一条水平分割线 <code>doctoc --title '**Table of Content**' file </code></p>
</li>
<li>
<p>给指定文件生成 toc: <code>doctoc file</code>，或者给所有文件生成 toc：<code>doctoc .</code></p>
</li>
</ol>
<p>目前 doctoc 生成出来的 toc 是兼容 GitHub 和 gitlab 的。</p>
<h3 id="markdown-在线部署"><a class="header" href="#markdown-在线部署">Markdown 在线部署</a></h3>
<ul>
<li>
<p><a href="https://github.com/rust-lang/mdBook">mdBook</a> rust 编写，兼容 gitbook，测试了一下，很优秀，暂时没有 bug</p>
</li>
<li>
<p><a href="https://www.gitbook.com/">[GitBook]</a></p>
<p>完美支持 GitHub，唯一的缺点，就是国内加载太慢，认可度不高</p>
</li>
<li>
<p><a href="https://github.com/mkdocs/mkdocs">[MkDoc]</a></p>
<p>MkDocs is a <strong>fast</strong>, <strong>simple</strong> and <strong>downright gorgeous</strong> static site generator that's geared towards building project documentation. </p>
<p>支持 GitHub 部署</p>
</li>
</ul>
<h3 id="用-markdown-写微信公众号"><a class="header" href="#用-markdown-写微信公众号">用 Markdown 写微信公众号</a></h3>
<p>https://doocs.github.io/md/</p>
<h2 id="typora"><a class="header" href="#typora">typora</a></h2>
<ul>
<li>一个好用的主题：lark https://github.com/imageslr/typora-theme-lark</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-hook"><a class="header" href="#git-hook">git-hook</a></h1>
<h2 id="客户端钩子"><a class="header" href="#客户端钩子">客户端钩子</a></h2>
<p><code>pre-commit</code> 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 <code>lint</code> 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p>
<p><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</p>
<p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p>
<p><code>post-commit</code> 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</p>
<h2 id="服务端钩子"><a class="header" href="#服务端钩子">服务端钩子</a></h2>
<p>除了客户端钩子，作为系统管理员，你还可以使用若干服务器端的钩子对项目强制执行各种类型的策略。 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。</p>
<h4 id="pre-receive"><a class="header" href="#pre-receive"><code>pre-receive</code></a></h4>
<p>处理来自客户端的推送操作时，最先被调用的脚本是 <code>pre-receive</code>。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p>
<h4 id="update"><a class="header" href="#update"><code>update</code></a></h4>
<p><code>update</code> 脚本和 <code>pre-receive</code> 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，<code>pre-receive</code> 只运行一次，相比之下 <code>update</code> 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。</p>
<h4 id="post-receive"><a class="header" href="#post-receive"><code>post-receive</code></a></h4>
<p><code>post-receive</code> 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 <code>pre-receive</code> 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器， 或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态， 所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p>
<h2 id="reference-4"><a class="header" href="#reference-4">reference</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/391221822">知乎：手写 git hooks 脚本（pre-commit、commit-msg）</a></li>
<li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">官方教程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技术栈-2"><a class="header" href="#技术栈-2">技术栈</a></h1>
<p>[TOC]</p>
<h2 id="blueprint"><a class="header" href="#blueprint">Blueprint</a></h2>
<ul>
<li><a href="https://github.com/ruanyf/weekly/blob/master/docs/free-software.md">阮一峰推荐的免费工具</a></li>
<li><a href="https://www.freecodecamp.org/news/web-development-2020/">Web Development in 2020: What Coding Tools You Should Learn</a>：没必要学全部的知识，具体问题具体分析</li>
</ul>
<h2 id="基础学习"><a class="header" href="#基础学习">基础学习</a></h2>
<ul>
<li><a href="https://missing-semester-cn.github.io/">计算机教育缺失的一课</a></li>
</ul>
<h2 id="前端"><a class="header" href="#前端">前端</a></h2>
<h3 id="可视化"><a class="header" href="#可视化">可视化</a></h3>
<ul>
<li>Browser: ECharts, D3, vis.js(timeline, network)</li>
<li>可视化云平台: Baidu Sugar</li>
<li>Python 可视化: matplotlib，seaborn(基于 matplotlib 的高层次接口)，wordcloud，reportlab(生成 pdf 报告)，Demo: <a href="https://github.com/A3M4/YouTube-Report">YouTube-Report</a></li>
<li>流程图：processon, ASCII flowchart: Graph Easy，手绘风格在线绘图 https://excalidraw.com/</li>
<li>历史数据排名可视化：<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js">Historical-ranking-data-visualization-based-on-d3.js</a></li>
<li>代码可视化、代码修饰工具：<a href="https://carbon.now.sh/">Carbon</a></li>
<li><a href="https://www.mapbox.com/">Mapbox</a>  地图展示</li>
</ul>
<h3 id="框架-1"><a class="header" href="#框架-1">框架</a></h3>
<ul>
<li>Bootstrap（HTML，CSS，JQuery，Javascript）</li>
<li>VUE</li>
<li>学术主页搭建：<a href="https://github.com/gcushen/hugo-academic">hugo-academic</a></li>
</ul>
<h3 id="chrome-插件"><a class="header" href="#chrome-插件">Chrome 插件</a></h3>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/singlefilez/offkdfbbigofcgdokjemgjpdockaafjg">SingleFileZ</a> 创建网页快照，对网页进行备份，我用它备份了我的网站：<a href="http://sentiweibo.top/">senti-weibo</a></li>
</ul>
<h3 id="react-技术栈"><a class="header" href="#react-技术栈">React 技术栈</a></h3>
<p><a href="https://github.com/prabhuignoto/react-chrono">[React 时间轴 Chrono]</a> 好漂亮，我一定要学好 React！</p>
<h3 id="静态网页生成"><a class="header" href="#静态网页生成">静态网页生成</a></h3>
<ul>
<li>Gatsby</li>
</ul>
<h2 id="后端"><a class="header" href="#后端">后端</a></h2>
<ul>
<li>框架：Django</li>
<li>Web 服务器：Gunicorn + Nginx </li>
<li>进程监控：Supervisor</li>
<li>数据缓存：Redis</li>
<li>依赖管理：Docker</li>
<li>软件测试：Selenium</li>
<li>一键部署工具：LAMP(Apache Mysql PHP)</li>
<li>运维：<a href="https://github.com/kubesphere/kubesphere">KubeSphere</a> k8s 的封装</li>
</ul>
<h2 id="需求分析"><a class="header" href="#需求分析">需求分析</a></h2>
<p>发现一块最适合我的需求分析工具：processon 的思维导图</p>
<h2 id="数据库"><a class="header" href="#数据库">数据库</a></h2>
<ul>
<li>Mysql</li>
<li>PostgreSQL：最大的开源关系型数据库</li>
<li>Redis：数据缓存，内存数据库</li>
</ul>
<p>数据库连接工具：</p>
<p>Navicat: 收费</p>
<p>DBeaver：开源免费，功能强大</p>
<h2 id="数据分析"><a class="header" href="#数据分析">数据分析</a></h2>
<ul>
<li>Pandas</li>
<li><strong>modin</strong>(enhanced Pandas, fast!)</li>
</ul>
<h2 id="机器学习-1"><a class="header" href="#机器学习-1">机器学习</a></h2>
<ul>
<li>sklearn 传统的机器学习方法</li>
<li>pyToarch 深度学习</li>
</ul>
<h2 id="搜索"><a class="header" href="#搜索">搜索</a></h2>
<ul>
<li>Elasticsearch</li>
<li><a href="https://github.com/prabhatsharma/zinc">Zinc</a> 轻量的全文搜索引擎</li>
</ul>
<h2 id="工作流处理"><a class="header" href="#工作流处理">工作流处理</a></h2>
<ul>
<li>IFTTT</li>
<li>微信自动化工具</li>
</ul>
<h2 id="写作"><a class="header" href="#写作">写作</a></h2>
<ul>
<li>论文：overleaf</li>
<li>笔记：GitBook</li>
<li>开发文档：Read the Docs</li>
<li>自己搭建 Wiki 的首选：<a href="https://wiki.js.org/">wiki.js</a></li>
</ul>
<h2 id="项目管理-1"><a class="header" href="#项目管理-1">项目管理</a></h2>
<ul>
<li>Git</li>
<li>Trello / Github Projects</li>
<li>CC / CQ，ClearCase和ClearQuest来管理代码版本和bug，大公司用的。</li>
<li>文档管理：国产文档工具 <a href="https://www.showdoc.com.cn/">ShowDoc</a></li>
<li>文档协同和知识库管理：Ones wiki</li>
</ul>
<h2 id="其他工具"><a class="header" href="#其他工具">其他工具</a></h2>
<ul>
<li>音频加工，获取声音波形：<a href="https://audiomass.co/">AudioMass</a></li>
<li>Win 10 文件恢复：应用商店 - Windows File Recovery</li>
<li>视频转码压缩软件：VidCoder</li>
<li>提醒我去休息的工具：<a href="https://hovancik.net/stretchly/downloads/">stretchly</a></li>
</ul>
<h2 id="学习资源-1"><a class="header" href="#学习资源-1">学习资源</a></h2>
<ul>
<li><a href="https://clig.dev/">命令行界面设计指南</a></li>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">半小时学习 Rust 语言</a> 一篇英语长文，详细介绍 Rust 语言的基本知识点</li>
<li><a href="https://merely-useful.github.io/py-rse/">Python 软件工程</a> 介绍使用 Python 来做实际的软件项目时，需要了解的各种 Linux 知识，比如命令行、Git、Make 等等</li>
<li><a href="https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/">Top 10 Python libraries of 2020</a></li>
</ul>
<h2 id="软件架构"><a class="header" href="#软件架构">软件架构</a></h2>
<h3 id="多租户"><a class="header" href="#多租户">多租户</a></h3>
<p>每一个购买了我们产品的客户，都是一个租户</p>
<p><a href="https://www.redhat.com/zh/topics/cloud-computing/what-is-multitenancy">Redhat: 什么是多租户？</a></p>
<p>一篇文章读懂SaaS多租户和单租户的分别 - 8Manage企业管理软件的文章 - 知乎 https://zhuanlan.zhihu.com/p/101008212</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea"><a class="header" href="#idea">IDEA</a></h1>
<p>[TOC]</p>
<h2 id="快捷键-shortcut"><a class="header" href="#快捷键-shortcut">快捷键 shortcut</a></h2>
<p>https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html</p>
<p><a href="https://www.zhihu.com/question/300830746/answer/672248406">知乎：IntelliJ IDEA 中有什么让你相见恨晚的技巧?</a></p>
<h3 id="windows"><a class="header" href="#windows">windows</a></h3>
<table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody>
<tr><td>查看类的继承树</td><td>ctrl + H（Hierarchy）</td></tr>
<tr><td>查看当前类的结构</td><td>ctrl + F12</td></tr>
<tr><td>搜索类文件</td><td>ctrl + N</td></tr>
<tr><td>自动补全变量名称</td><td>ctrl + alt + V</td></tr>
<tr><td>代码格式化</td><td>ctrl + alt + L</td></tr>
<tr><td>手动导包</td><td>alt + enter</td></tr>
<tr><td>删除当前行</td><td>ctrl + Y</td></tr>
<tr><td>查看最近看了改了哪些代码</td><td>ctrl + shift + E</td></tr>
<tr><td>给插入提示，例如生成 getter, setter, test，例如</td><td>alt + insert</td></tr>
<tr><td>提示参数类型</td><td>ctrl + P</td></tr>
<tr><td>跳到下一个相同的内容(变量 / 方法)</td><td>alt + J</td></tr>
<tr><td>在所有的相同的内容后添加光标(批量修改)</td><td>ctrl + shift + alt + J</td></tr>
<tr><td>加载导入的依赖</td><td>ctrl + alt + O</td></tr>
<tr><td>在指定位置添加光标</td><td>alt + shift + 鼠标左键</td></tr>
<tr><td>实现接口方法</td><td>ctrl + i</td></tr>
<tr><td>代码上移下移</td><td>alt + shift + 上下</td></tr>
<tr><td>查找文件，包括依赖中的类文件</td><td>ctrl + shift + N</td></tr>
</tbody></table>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody>
<tr><td>查看代码结构</td><td>command + 7</td></tr>
<tr><td>跳到下一个变量</td><td>control + option + ↑ ↓</td></tr>
<tr><td>查看继承关系</td><td>control + H</td></tr>
</tbody></table>
<h2 id="代码模板"><a class="header" href="#代码模板">代码模板</a></h2>
<p>自动代码片的生成快捷键：ctrl + j</p>
<table><thead><tr><th>模板代码</th><th>快捷键</th></tr></thead><tbody>
<tr><td>main 函数</td><td>psvm</td></tr>
<tr><td>System.out.println()</td><td>sout</td></tr>
<tr><td>生成 for 循环</td><td>fori</td></tr>
<tr><td>生成普通 for 循环</td><td>itar</td></tr>
<tr><td>生成增强 for 循环</td><td>iter</td></tr>
<tr><td>生成集合 list 的 for 循环</td><td>list.for</td></tr>
<tr><td>private static final</td><td>prsf</td></tr>
<tr><td>快速生成变量</td><td>.var</td></tr>
<tr><td>打印当前对象</td><td>.sout</td></tr>
<tr><td></td><td>.if</td></tr>
<tr><td></td><td>.for</td></tr>
</tbody></table>
<h2 id="安装-intellij-idea"><a class="header" href="#安装-intellij-idea">安装 <a href="https://www.jetbrains.com/idea/"><strong>IntelliJ IDEA</strong></a></a></h2>
<p>2020.2 版本后的 IDEA 暂时无法破解，所以使用历史版本：2019.3.5 <a href="https://download.jetbrains.com/idea/ideaIU-2019.3.5.exe?_ga=2.167713214.1472044068.1599574265-921529009.1596531522">[download]</a> <a href="https://my.oschina.net/u/4330928/blog/3230470">[破解教程]</a> [[jar包在网盘中]](链接：https://pan.baidu.com/s/1opYMrq1HpDtBUP-1lAnmFQ  提取码：i26t)</p>
<p>需要安装的插件 Plugins：</p>
<ul>
<li><a href="https://projectlombok.org/">Lombok</a> 简化 Java 代码 （读作：lang bao ke）</li>
<li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines/">Alibaba Java Coding Guidelines</a> 阿里巴巴 Java 代码规范</li>
</ul>
<p>可以使用 edu 邮箱到 Jet brain 官网上申请免费使用 jetbrain 的产品，不过得一年激活一次</p>
<h2 id="必装插件"><a class="header" href="#必装插件">必装插件</a></h2>
<ul>
<li>Alibaba Java Coding Guidelines</li>
<li>SonarLint</li>
<li>Lombok</li>
</ul>
<h2 id="小惊喜"><a class="header" href="#小惊喜">小惊喜</a></h2>
<ul>
<li>
<p>todo 功能</p>
<pre><code>// todo todo-content
</code></pre>
</li>
<li>
<p>下边栏的 Problems 可以提供代码规范检查功能</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea-debug"><a class="header" href="#idea-debug">IDEA Debug</a></h1>
<p><a href="https://www.bilibili.com/video/BV1LJ41187hu">程序调试入门</a></p>
<p>[TOC]</p>
<h2 id="idea中的debug步骤"><a class="header" href="#idea中的debug步骤">IDEA中的Debug步骤</a></h2>
<ul>
<li>
<p>设置断点（F9）</p>
</li>
<li>
<p>调试程序（8个按钮）</p>
<p><img src="computer-science-notebook/development-tools/images/2019-09-28_162216.jpg" alt="" /></p>
<table><thead><tr><th>按钮</th><th>说明</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_163744.jpg" alt="" /></td><td>(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164022.jpg" alt="" /></td><td>(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_162345.jpg?lastModify=1569659273?lastModify=1569659273" alt="img" /></td><td>(F7)：步入。如果当前行有方法，可以进入方法内部，<strong>一般用于进入自定义方法内，不会进入官方类库的方法。</strong></td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164200.jpg" alt="" /></td><td>(Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164215.jpg" alt="" /></td><td>(Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164428.jpg" alt="" /></td><td>回退断点。返回到当前方法的调用处。(时光机器)</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164418.jpg" alt="" /></td><td>(Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/images/2019-09-28_164437.jpg" alt="" /></td><td>(Alt + F8)：计算表达式。</td></tr>
</tbody></table>
</li>
<li>
<p>观察变量</p>
<ul>
<li>查看变量有三种方式：
+ 程序区查看变量
+ Debugger的Variables中查看变量
+ 鼠标悬停到变量名上会弹出当前变量的值</li>
</ul>
<p><img src="computer-science-notebook/development-tools/images/2019-09-28_165050.jpg" alt="" /></p>
</li>
<li>
<p>查看输出</p>
</li>
</ul>
<h2 id="计算表达式"><a class="header" href="#计算表达式">计算表达式</a></h2>
<p>动态修改正在运行的变量。牛批。</p>
<ul>
<li>
<p>计算表达式</p>
<ul>
<li>
<p>计算表达式按钮（Alt + F8）<img src="computer-science-notebook/development-tools/images/2019-09-28_164437.jpg" alt="" /></p>
<p><img src="computer-science-notebook/development-tools/images/2019-10-03_182159.jpg" alt="" /></p>
</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 </li>
</ul>
</li>
</ul>
<h2 id="条件断点"><a class="header" href="#条件断点">条件断点</a></h2>
<ul>
<li>
<p>条件断点</p>
<ul>
<li>
<p>右键单击断点处，可以设置进入断点的条件</p>
<p><img src="computer-science-notebook/development-tools/images/2019-10-03_182101.jpg" alt="" /></p>
</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</li>
</ul>
</li>
</ul>
<h2 id="多线程调试"><a class="header" href="#多线程调试">多线程调试</a></h2>
<ul>
<li>
<p>步骤
+ 多线程调试，需要调整断点挂起级别为Thread</p>
<p><img src="computer-science-notebook/development-tools/images/2019-10-05_164127.jpg" alt="" /></p>
<ul>
<li>Frame中选择线程进行调试</li>
</ul>
</li>
</ul>
<h2 id="其他按钮"><a class="header" href="#其他按钮">其他按钮</a></h2>
<table><thead><tr><th>按钮</th><th>说明</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/development-tools/assets/image-20220802143146958.png" alt="image-20220802143146958" /></td><td>重新运行 debug</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/assets/image-20220802143208200.png" alt="image-20220802143208200" /></td><td>跳到下一个断点</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/assets/image-20220802143311194.png" alt="image-20220802143311194" /></td><td>批量管理断点（例如删除断点）</td></tr>
<tr><td><img src="computer-science-notebook/development-tools/assets/image-20220802143414261.png" alt="image-20220802143414261" /></td><td>让所有断点失效</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless"><a class="header" href="#serverless">serverless</a></h1>
<p>无服务器的云计算</p>
<h2 id="vercel"><a class="header" href="#vercel">vercel</a></h2>
<p>一个云计算平台，可以把静态网站托管到 vercel。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20220715170036630.png" alt="image-20220715170036630" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apifox"><a class="header" href="#apifox">apifox</a></h1>
<p>最近才接触到 apifox，相见恨晚。</p>
<p>apifox 不是一个传统的测试工具，甚至 postman 都不是一个传统的测试工具。</p>
<p>我一直以来都误解了 postman，把它当做一个单纯的测试工具来用。</p>
<p>apifox 更像是一个团队协作工具，围绕着接口开发文档，为我们规范了开发的整个流程。</p>
<h2 id="接口设计"><a class="header" href="#接口设计">接口设计</a></h2>
<p>整个 apifox 是围绕开发文档展开的。</p>
<p>接口设计阶段，直接在 apifox 上定义接口。定义接口名称，请求参数。</p>
<p>在响应体中定义响应内容，定义完保存后，本地 mock 就已经开启了，前端就可以调用这个刚定义的接口进行开发了！</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20220707190713460.png" alt="image-20220707190713460" /></p>
<h2 id="前端-mock"><a class="header" href="#前端-mock">前端 mock</a></h2>
<p>接口定义完保存后，这个接口在 apifox 端就被动态地创建了。返回的数据就是我们定义的响应体。</p>
<p>前端调用 mock 的接口进行开发即可：</p>
<pre><code>http://127.0.0.1:4523/m1/1239146-0-default/type/getTypeList
</code></pre>
<h2 id="后端开发"><a class="header" href="#后端开发">后端开发</a></h2>
<p>后端开发完后，可以切到运行进行测试。</p>
<p>如果后端响应的数据不符合开发文档约定的格式，还会告警！</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20220707191755600.png" alt="image-20220707191755600" /></p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>注意，接口，和接口的测试用例，是两个概念。</p>
<p>我之前曾简单把 postman 上定义的一条测试理解为测试用例，其实我只是定义了一个测试接口，加上一个默认的测试数据。如果一个接口测试多种情况的话，我通常只会改一下接口。</p>
<p>接触到 apifox 后，我才清晰地认识到，接口和测试用例，是解耦的。一个接口对应多个测试用例，每个测试用例中的测试数据都有所不同。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20220707192251153.png" alt="image-20220707192251153" /></p>
<p>apifox 还支持自动化测试。</p>
<p>当我们需要进行自动化测试时，是把这些测试用例加在一个集合中去跑，而不是拿接口去跑。</p>
<h2 id="团队协作"><a class="header" href="#团队协作">团队协作</a></h2>
<p>当然，还有一个重磅特性，团队协作。我创建的接口和测试用例，可以同步分享给团队内的其他人，大家共同维护。这样就不需要用 postman 导入导出了，而且团队功能是完全免费的！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链学习"><a class="header" href="#区块链学习">区块链学习</a></h1>
<p><a href="https://www.bilibili.com/video/BV1Vt411X7JF">北京大学肖臻老师《区块链技术与应用》公开课</a></p>
<h2 id="课程简介"><a class="header" href="#课程简介">课程简介</a></h2>
<p>有人说，区块链是最慢的数据库，也有人说，区块链是工业革命，但是真正懂区块链的人，少之又少。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web30"><a class="header" href="#web30">Web3.0</a></h1>
<p>[TOC]</p>
<h2 id="我的理解-3"><a class="header" href="#我的理解-3">我的理解</a></h2>
<p>以太坊是一个开源可编程的智能合约平台，兼容多种语言。</p>
<h2 id="web30-1"><a class="header" href="#web30-1">web3.0</a></h2>
<p>期待打破传统互联网巨头的垄断，创造一个全新的自由世界。</p>
<p>围绕个体构建起来的网络。</p>
<p>Web 2.0 的范式是：用户创造、平台所有、平台控制、平台分配。</p>
<p>Web 3.0 的范式是：<strong>用户创造、用户所有、用户控制、协议分配</strong>。</p>
<h2 id="ethereum-以太坊"><a class="header" href="#ethereum-以太坊">Ethereum 以太坊</a></h2>
<p><strong>以太坊(Ethereum)<strong>是一个基于区块链技术，允许任何人构建和使用去中心化应用的区块链平台。以太坊提供了一个“图灵完备”的虚拟机，称为</strong><a href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2229028693%22%7D">以太坊虚拟机</a>(Ethereum Virtual Machine)</strong>，简称<strong>EVM</strong>，用户可以在EVM上创建<strong>智能合约(Smart Contract)</strong>。以太坊平台中的通用货币为**<a href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E5%B8%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2229028693%22%7D">以太币</a>(Ether)**，简称ETH，以太币可用于账号间的转账交易或者为EVM上运行的合约消耗的资源付费。</p>
<p>以太坊是一门合约编程语言。以太坊语言编写的 app，叫做 DECENTRALIZED APPLICATIONS。通过智能合约的设计开发，以太坊可以实现各种商业与非商业环境下的复杂逻辑，如众筹系统、数字货币、融资租赁资产管理、多重签名的安全账户、供<a href="https://www.zhihu.com/search?q=%E5%BA%94%E9%93%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%22282577523%22%7D">应链</a>的追踪监控等。通过智能合约的应用，可以将传统的软件系统链化，发挥出更强大的管理能力，相当于隐藏了底层技术的复杂性而让应用开发者更多地专注在应用逻辑及商业逻辑上。</p>
<p>作者：蒋勇
链接：https://www.zhihu.com/question/51131233/answer/282577523
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>我们来看一下以太坊的组成结构：</p>
<img align="left" src="computer-science-notebook/development-tools/assets/v2-9bda0efbe9e29b9a91d47ba515eeba06_b.jpg" alt="img" style="zoom:80%;" />
<p>以太坊中的智能合约是运行在虚拟机上的，也就是通常说的 EVM（Ethereum Virtual Machine，以太坊虚拟机）。这是一个智能合约的沙盒，合约存储在以太坊的区块链上，并被编译为以太坊虚拟机字节码，通过虚拟机来运行智能合约。由于这个中间层的存在，以太坊也实现了多种语言的合约代码编译，网络中的每个以太坊节点运行 EVM 实现并执行相同的指令。如果说比特币是二维世界的话，那么以太坊就是三维世界，可以实现无数个不同的二维世界。</p>
<h2 id="dapp"><a class="header" href="#dapp">DApp</a></h2>
<p>Dapps have their backend code (smart contracts) running on a decentralized network and not a centralized server. They use the Ethereum blockchain for data storage and smart contracts for their app logic.</p>
<h2 id="元宇宙"><a class="header" href="#元宇宙">元宇宙</a></h2>
<h2 id="dao"><a class="header" href="#dao">DAO</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<p>[TOC]</p>
<h2 id="我的理解-4"><a class="header" href="#我的理解-4">我的理解</a></h2>
<p>轻量高效的<strong>代码编辑工具</strong>，而不是代码编译工具。其作为一款工具的属性更为突出，而不是一款 IDE。</p>
<h2 id="在-windows-系统上进行-linux-开发-1"><a class="header" href="#在-windows-系统上进行-linux-开发-1">在 Windows 系统上进行 Linux 开发</a></h2>
<p>想要实现在 Windows 上进行 Linux 开发，虚拟机太笨重，占用 Windows 系统太多的资源，Windows10 提供了一个 Linux 子系统，WSL：Windows Subsystem for Linux，与 Windows 深度融合，可以通过 VSCode + Remote-WSL 访问 Linux 子系统</p>
<p><a href="https://blog.csdn.net/qq_36634690/article/details/108011872">[Win10 使用WSL 配合VSCode 搭建C/C++开发环境]</a></p>
<p>令我感到惊奇的是，两个系统的互通性极强，体现在：</p>
<ul>
<li>
<p>WSL 共享 Windows 的网络（网卡、IP 都共享），都可以互相 Ping 通，子系统的 IP 地址就是 <code>127.0.0.1</code>，也就是在 Windows 上，可以通过 <code>127.0.0.1</code> 访问 Linux 子系统</p>
<img align='left' src="computer-science-notebook/development-tools/assets/image-20200913111750152.png" alt="image-20200913111750152" style="zoom:67%;" />
</li>
<li>
<p>通过 Remote-WSL + VSCode，我可以直接在 VSCode 上打开 Linux 上的 project 进行开发，Windows 的 VSCode 充当了 Linux 的图形化开发界面</p>
<img align='left' src="computer-science-notebook/development-tools/assets/image-20200913112611902.png" alt="image-20200913112611902" style="zoom:67%;" />
</li>
<li>
<p>在测试 Python 的时候，我安装了 Django，由于 Linux 的子系统 IP 就是 <code>127.0.0.1</code>，所以我可以直接在 Windows 系统中访问 Django Web 服务</p>
<img align="left" src="computer-science-notebook/development-tools/assets/image-20200913112823735.png" alt="image-20200913112823735" style="zoom: 50%;" />
</li>
<li>
<p>文件传输：可以直接右击 VSCode 的 project，选择 Reveal in Explorer 来打开 Linux 的文件，进行两个系统的文件传输</p>
</li>
<li>
<p>连接 WSL，不需要打开 WSL App，只需要在用 VSCode 的 Remote-WSL 插件连接就行了，WSL 应该有一个后台服务一直在跑</p>
</li>
</ul>
<h2 id="插件"><a class="header" href="#插件">插件</a></h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/liyufeia/p/11405779.html">Remote-SSH</a> </p>
<p>远程连接服务器，编写代码的工具，类似于 Samba</p>
<p><strong>Secure Shell</strong> (<strong>SSH</strong>) is a <a href="https://en.wikipedia.org/wiki/Cryptography">cryptographic</a> <a href="https://en.wikipedia.org/wiki/Network_protocol">network protocol</a> for operating network services securely over an unsecured network.[<a href="https://en.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1">1]</a> Typical applications include remote <a href="https://en.wikipedia.org/wiki/Command-line_interface">command-line</a>, <a href="https://en.wikipedia.org/wiki/Login">login</a>, and remote command execution, but any <a href="https://en.wikipedia.org/wiki/Network_service">network service</a> can be <strong>secured</strong> with SSH.</p>
<p>SSH provides a <a href="https://en.wikipedia.org/wiki/Secure_channel">secure channel</a> over an unsecured network by using a <strong><a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client–server</a></strong> architecture, connecting an <a href="https://en.wikipedia.org/wiki/SSH_client">SSH client</a> application with an <a href="https://en.wikipedia.org/wiki/SSH_server">SSH server</a>.</p>
<p>remote-ssh 会在远程服务器上部署一个 vscode-server，如果远程服务器无法联网，则会报 <code>Running the contributed command: ‘_workbench.downloadResource</code> 的错误，解决方案为：https://blog.csdn.net/ibless/article/details/118610776</p>
</li>
<li>
<p><a href="computer-science-notebook/development-tools/">Remote-WSL</a></p>
<p>Open any folder in the Windows Subsystem for Linux (WSL) and take advantage of Visual Studio Code's full feature set.</p>
</li>
<li>
<p>Live Server</p>
<p>为静态网站开启一个服务器</p>
</li>
</ul>
<h2 id="快捷键"><a class="header" href="#快捷键">快捷键</a></h2>
<table><thead><tr><th>cmd</th><th>desc</th></tr></thead><tbody>
<tr><td>F1 / ctrl + shift + p</td><td>打开 vscode 命令</td></tr>
<tr><td>shift + option + f</td><td>代码格式化</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="snippet-生成快捷键"><a class="header" href="#snippet-生成快捷键">snippet 生成快捷键</a></h2>
<table><thead><tr><th>快捷键</th><th>效果</th></tr></thead><tbody>
<tr><td>rcc</td><td>react 快速生成一个组件</td></tr>
<tr><td>!</td><td>生成 html 模板代码</td></tr>
<tr><td>.classname</td><td>生成一个 <code>&lt;div class=&quot;classname&quot;&gt; &lt;/div&gt;</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>[TOC]</p>
<h2 id="docker-我的理解"><a class="header" href="#docker-我的理解">Docker 我的理解</a></h2>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<pre><code class="language-shell"># 查看正在运行的 docker 容器
docker ps

# 删除容器
docker rm container-name / hash

# 停止容器
docker stop container-name / hash

# 开启容器
docker start container-name

# 进入容器 mariadb 执行命令
docker exec -it mariadb /bin/bash
</code></pre>
<h2 id="docker-arm"><a class="header" href="#docker-arm">Docker ARM</a></h2>
<pre><code class="language-shell"># 拉取 arm 版本的镜像，要加上 --platform 参数，优先使用 arm64 架构的
docker pull --platform linux/amd64 mysql
docker pull --platform linux/arm64 redis
</code></pre>
<h3 id="docker-是什么"><a class="header" href="#docker-是什么">Docker 是什么</a></h3>
<ul>
<li>镜像是静态的，容器是跑起来的镜像，是动态的</li>
<li>Dockerfile 是创建镜像的配置文件</li>
<li>DockerCompose 是批量运行容器的配置文件</li>
</ul>
<h3 id="docker-使用感悟"><a class="header" href="#docker-使用感悟">Docker 使用感悟</a></h3>
<ul>
<li>在安装版本控制软件时，尝试过 gitlab 手动安装和 gogs docker 安装，docker 真的太丝滑了</li>
<li>每一个程序员，都应该像掌握 git 一样，熟练掌握 docker</li>
<li>docker 将每一个软件的安装部署启动环节进行封装，相当于用 <code>run start stop</code> 等命令统一了各种软件的安装部署，属实牛批</li>
<li>任何封装在 Docker 中的服务，都不用安装到系统中了，以往我们如果想要用 mysql，还需要安装 mysql，现在 docker 的镜像屏蔽了安装这个步骤，用 mysql 的时候，只要跑一个 mysql 容器就行了，随用随关</li>
</ul>
<h3 id="docker-使用注意事项"><a class="header" href="#docker-使用注意事项">docker 使用注意事项</a></h3>
<ul>
<li>container 是从镜像生成的，但是  container 也是一个实体，container 关闭后，仍然是存在的，是持久化的</li>
</ul>
<h3 id="demo-8"><a class="header" href="#demo-8">demo</a></h3>
<pre><code class="language-shell">docker run \
--name mariadb \
-v /root/mariadb/config:/etc/mysql/conf.d \
-v /root/mariadb/data:/var/lib/mysql \
--env MARIADB_USER=his \
--env MARIADB_PASSWORD=His@9700 \
--env MARIADB_ROOT_PASSWORD=His@9700 \
-dp 3307:3306 \
mariadb:10.3.28

# --name: 容器名称
# -v xxx:yyy: 把本地 xxx 目录挂载到容器内的 yyy 目录
# --env: mariadb 配置
# -d: detached 后端执行
# -p 3307:3306: 将容器内的 3306 端口映射到宿主机的 3307 端口，可以通过 3307 端口访问容器内的 mariadb
# mariadb:10.3.28: 从哪一个镜像生成容器，如果本地没有这个镜像，则会从远程仓库拉取
</code></pre>
<h2 id="introduction-13"><a class="header" href="#introduction-13">Introduction</a></h2>
<p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. </p>
<p>Docker provides the ability to package and run an application in a loosely isolated environment called a container. The isolation and security allow you to run many containers simultaneously on a given host. Containers are lightweight and contain everything needed to run the application, so you do not need to rely on what is currently installed on the host. You can easily share containers while you work, and be sure that everyone you share with gets the same container that works in the same way.</p>
<p>Docker 是一个和 Git 一样提高工程师效率的工具。</p>
<p><strong>Docker 的机制</strong>：</p>
<p>Linux 操作系统，分为 Linux 内核，和系统库，每一个 Linux 操作系统，内核基本上都是一样的，只有系统库的区别，而 Docker 则将应用程序和系统库一起打包，这样就屏蔽了不同系统的系统库，直达 Linux 内核。</p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<img src="computer-science-notebook/development-tools/assets/image-20210901133209185.png" alt="image-20210901133209185" style="zoom: 67%;" />
<h3 id="image-and-container"><a class="header" href="#image-and-container">Image and Container</a></h3>
<p>An <strong>image</strong> is an <strong>executable</strong> package that includes everything needed to run an application: the code, a runtime, libraries, environment variables, and configuration files.</p>
<p>When running a container, it uses an isolated filesystem. This custom filesystem is provided by a <strong>container image</strong>. Since the image contains the container’s filesystem, it must contain everything needed to run an application - all dependencies, configuration, scripts, binaries, etc. The image also contains other configuration for the container, such as environment variables, a default command to run, and other metadata.</p>
<p>镜像是一个可以执行的包，包中打包了一个应用所需要的运行环境，运行库，环境变量，代码和配置文件等所有的依赖。这是一个静态的镜像，类似于创建的虚拟机的镜像。</p>
<p>A <strong>container</strong> is a runtime instance of an image.</p>
<p>一个镜像被加载运行后，就成了一个容器，容器是动态的，类似于正在运行的虚拟机。</p>
<p>Simply put, a container is simply another process on your machine that has been isolated from all other processes on the host machine. That isolation leverages <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a>, features that have been in Linux for a long time.</p>
<p>Container 就是一个进程。</p>
<h3 id="container-vs-virtual-machine"><a class="header" href="#container-vs-virtual-machine">Container vs Virtual machine</a></h3>
<p><img src="computer-science-notebook/development-tools/assets/image-20210901133414352.png" alt="image-20210901133414352" /></p>
<h3 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h3>
<p>Docker 镜像的配置 manifest 文件，包括：网络接口和存储设备的映射，要加入镜像的依赖/文件等配置。</p>
<h3 id="docker-and-kubernetes"><a class="header" href="#docker-and-kubernetes">Docker and Kubernetes</a></h3>
<p>Kubernetes can automate the whole container deployment process. </p>
<p>Kubernetes 可以实现 Docker 管理，相当于 Dockers 的中控平台。</p>
<h3 id="docker-architecture"><a class="header" href="#docker-architecture">Docker architecture</a></h3>
<p>Docker uses a client-server architecture. The Docker <em>client</em> talks to the Docker <em>daemon</em>, which does the heavy lifting of building, running, and distributing your Docker containers. </p>
<ul>
<li>
<p>The Docker daemon</p>
<p>The Docker daemon (<code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p>
</li>
<li>
<p>The Docker client</p>
<p>The Docker client (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p>
</li>
<li>
<p>Docker registries</p>
<p>A Docker <em>registry</em> stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.</p>
<p>When you use the <code>docker pull</code> or <code>docker run</code> commands, the required images are pulled from your configured registry. When you use the <code>docker push</code> command, your image is pushed to your configured registry.</p>
<p>Docker 官方的 Registry: DockerHub，类似于 GitHub，我们可以在上面分享自己的 Docker 镜像。</p>
</li>
<li>
<p>Docker images</p>
<p>An <em>image</em> is a read-only template with instructions for creating a Docker container. Often, an image is <em>based on</em> another image, with some additional customization. For example, you may build an image which is based on the <code>ubuntu</code> image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.</p>
<p>You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a <em>Dockerfile</em> with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.</p>
</li>
</ul>
<h3 id="the-underlying-technology"><a class="header" href="#the-underlying-technology">The underlying technology</a></h3>
<p>Docker is written in the <a href="https://golang.org/">Go programming language</a> and takes advantage of several features of the Linux kernel to deliver its functionality. Docker uses a technology called <code>namespaces</code> to provide the isolated workspace called the <em>container</em>. When you run a container, Docker creates a set of <em>namespaces</em> for that container.</p>
<p>These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>Docker Desktop for Windows 只支持 Windows 10 Professional or Enterprise 64-bit，不符合的 Windows 版本，例如 Win10 教育版/家庭版或者Win7 的版本，需要安装 <a href="https://github.com/docker/toolbox/releases">Docker Toolbox</a> 来进行 Docker 的兼容。</p>
<p>Docker Toolbox 包含以下组件：</p>
<ul>
<li>Docker CLI client for running Docker Engine to create images and containers</li>
<li>Docker Machine so you can run Docker Engine commands from Windows terminals</li>
<li>Docker Compose for running the <code>docker-compose</code> command</li>
<li>Kitematic, the Docker GUI</li>
<li>the Docker QuickStart shell preconfigured for a Docker command-line environment</li>
<li>Oracle VM VirtualBox</li>
</ul>
<p>注意，如果 Git 已经安装过了，那么 Docker 的 CLI 就打不开，因为其依赖于 Git 的 Bash，此时需要修改 Docker CLI 的打开路径，将其默认路径替换成 Git 中 bash.exe 的路径：<code>/Git/bin/bash.exe</code></p>
<p>如果 WIndows 开启了 Hyper-V，则需要关闭 Hyper-V。</p>
<h2 id="docker-doc"><a class="header" href="#docker-doc">Docker Doc</a></h2>
<p><a href="https://docs.docker.com/">Docker Doc</a> 文档学习。</p>
<p><img src="https://docs.docker.com/engine/images/architecture.svg" alt="Docker Architecture Diagram" /></p>
<h2 id="docker-镜像"><a class="header" href="#docker-镜像">Docker 镜像</a></h2>
<h3 id="镜像名称"><a class="header" href="#镜像名称">镜像名称</a></h3>
<p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731155141362.png" alt="image-20210731155141362" /></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="镜像命令"><a class="header" href="#镜像命令">镜像命令</a></h3>
<p>常见的镜像操作命令如图：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731155649535.png" alt="image-20210731155649535" /></p>
<pre><code class="language-shell">docker images
docker rmi
docker pull
docker push
docker save
dokcer load
</code></pre>
<p>docker save/load</p>
<pre><code class="language-shell"># -o: output
docker save -o mariadb-docker-image.tar mariadb:10.3.28

# -i: input
docker load --input mariadb-docker-image.tar
</code></pre>
<h2 id="docker-容器"><a class="header" href="#docker-容器">Docker 容器</a></h2>
<h3 id="容器相关命令"><a class="header" href="#容器相关命令">容器相关命令</a></h3>
<p>容器操作的命令如图：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731161950495.png" alt="image-20210731161950495" /></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li>docker run：创建并运行一个容器，处于运行状态</li>
<li>docker pause：让一个运行的容器暂停</li>
<li>docker unpause：让一个容器从暂停状态恢复运行</li>
<li>docker stop：停止一个运行的容器，文件系统不清理</li>
<li>docker start：让一个停止的容器再次运行</li>
<li>docker rm：删除一个容器，而且会把文件系统也干掉</li>
</ul>
<h3 id="创建并运行一个容器"><a class="header" href="#创建并运行一个容器">创建并运行一个容器</a></h3>
<p>创建并运行nginx容器的命令：</p>
<pre><code class="language-sh">docker run --name containerName -p 80:80 -d nginx
</code></pre>
<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>--name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如 nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731163255863.png" alt="image-20210731163255863" /></p>
<h3 id="进入容器修改文件"><a class="header" href="#进入容器修改文件">进入容器，修改文件</a></h3>
<p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<pre><code class="language-sh">docker exec -it mn bash
</code></pre>
<p>命令解读：</p>
<ul>
<li>
<p>docker exec ：进入容器内部，执行一个命令</p>
</li>
<li>
<p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>
</li>
<li>
<p>mn ：要进入的容器的名称</p>
</li>
<li>
<p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
</li>
</ul>
<p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731164159811.png" alt="image-20210731164159811" /></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<pre><code class="language-sh">cd /usr/share/nginx/html
</code></pre>
<p>查看目录下文件：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731164455818.png" alt="image-20210731164455818" /></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<pre><code class="language-sh">sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g' index.html
</code></pre>
<p>在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731164717604.png" alt="image-20210731164717604" /></p>
<h2 id="docker-数据卷"><a class="header" href="#docker-数据卷">Docker 数据卷</a></h2>
<p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731172440275.png" alt="image-20210731172440275" /></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="什么是数据卷"><a class="header" href="#什么是数据卷">什么是数据卷</a></h3>
<p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731173541846.png" alt="image-20210731173541846" /></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h3 id="数据卷操作命令"><a class="header" href="#数据卷操作命令">数据卷操作命令</a></h3>
<p>数据卷操作的基本语法如下：</p>
<pre><code class="language-sh">docker volume [COMMAND]
</code></pre>
<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="创建和查看数据卷"><a class="header" href="#创建和查看数据卷">创建和查看数据卷</a></h3>
<p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<pre><code class="language-sh">docker volume create html
</code></pre>
<p>② 查看所有数据</p>
<pre><code class="language-sh">docker volume ls
</code></pre>
<p>结果：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731173746910.png" alt="image-20210731173746910" /></p>
<p>③ 查看数据卷详细信息卷</p>
<pre><code class="language-sh">docker volume inspect html
</code></pre>
<p>结果：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731173809877.png" alt="image-20210731173809877" /></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="挂载数据卷"><a class="header" href="#挂载数据卷">挂载数据卷</a></h3>
<p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<pre><code class="language-sh">docker run \
  --name mn \
  -v html:/root/html \
  -p 8080:80
  nginx \
</code></pre>
<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
<h3 id="案例-给nginx挂载数据卷"><a class="header" href="#案例-给nginx挂载数据卷">案例-给nginx挂载数据卷</a></h3>
<p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<pre><code class="language-sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx
</code></pre>
<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<pre><code class="language-sh"># 查看html数据卷的位置
docker volume inspect html
# 进入该目录
cd /var/lib/docker/volumes/html/_data
# 修改文件
vi index.html
</code></pre>
<h3 id="案例-给mysql挂载本地目录"><a class="header" href="#案例-给mysql挂载本地目录">案例-给MySQL挂载本地目录</a></h3>
<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 ---&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731175155453.png" alt="image-20210731175155453" /></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的 mysql.tar 文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录/tmp/mysql/data</p>
<p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p>
<p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文件</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h2 id="dockerfile-自定义镜像"><a class="header" href="#dockerfile-自定义镜像">Dockerfile 自定义镜像</a></h2>
<p>dockerfile 是创建镜像的配置文件。</p>
<h3 id="镜像结构"><a class="header" href="#镜像结构">镜像结构</a></h3>
<p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731175806273.png" alt="image-20210731175806273" /></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。我们要构建镜像，其实就是实现上述打包的过程。</p>
<h3 id="dockerfile-语法"><a class="header" href="#dockerfile-语法">Dockerfile 语法</a></h3>
<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731180321133.png" alt="image-20210731180321133" /></p>
<p>更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder</p>
<h3 id="构建-java-项目"><a class="header" href="#构建-java-项目">构建 Java 项目</a></h3>
<h4 id="基于-ubuntu-构建-java-项目"><a class="header" href="#基于-ubuntu-构建-java-项目">基于 Ubuntu 构建 Java 项目</a></h4>
<p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 java 项目</p>
<ul>
<li>
<p>步骤1：新建一个空文件夹docker-demo</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801101207444.png" alt="image-20210801101207444" /></p>
</li>
<li>
<p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801101314816.png" alt="image-20210801101314816" /></p>
</li>
<li>
<p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801101410200.png" alt="image-20210801101410200" /></p>
</li>
<li>
<p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801101455590.png" alt="image-20210801101455590" /></p>
<p>其中的内容如下：</p>
<pre><code class="language-dockerfile"># 指定基础镜像
FROM ubuntu:16.04
# 配置环境变量，JDK的安装目录
ENV JAVA_DIR=/usr/local

# 拷贝jdk和java项目的包
COPY ./jdk8.tar.gz $JAVA_DIR/
COPY ./docker-demo.jar /tmp/app.jar

# 安装JDK
RUN cd $JAVA_DIR \
 &amp;&amp; tar -xf ./jdk8.tar.gz \
 &amp;&amp; mv ./jdk1.8.0_144 ./java8

# 配置环境变量
ENV JAVA_HOME=$JAVA_DIR/java8
ENV PATH=$PATH:$JAVA_HOME/bin

# 暴露端口
EXPOSE 8090
# 入口，java项目的启动命令
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
</li>
<li>
<p>步骤5：进入 docker-demo</p>
<p>将准备好的 docker-demo 上传到虚拟机任意目录，然后进入docker-demo目录下</p>
</li>
<li>
<p>步骤6：运行命令：</p>
<pre><code class="language-sh">docker build -t javaweb:1.0 .
</code></pre>
</li>
</ul>
<p>最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</p>
<h4 id="基于-java8-构建-java-项目"><a class="header" href="#基于-java8-构建-java-项目">基于 java8 构建 Java 项目</a></h4>
<p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>
<p>例如，构建 java 项目的镜像，可以在已经准备了 JDK 的基础镜像基础上构建。</p>
<p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p>
<p>实现思路如下：</p>
<ul>
<li>
<p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p>
</li>
<li>
<p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p>
</li>
<li>
<p>③ 编写Dockerfile文件：</p>
<ul>
<li>
<p>a ）基于java:8-alpine作为基础镜像</p>
</li>
<li>
<p>b ）将app.jar拷贝到镜像中</p>
</li>
<li>
<p>c ）暴露端口</p>
</li>
<li>
<p>d ）编写入口ENTRYPOINT</p>
<p>内容如下：</p>
<pre><code class="language-dockerfile">FROM java:8-alpine
COPY ./app.jar /tmp/app.jar
EXPOSE 8090
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
</li>
</ul>
</li>
<li>
<p>④ 使用 docker build 命令构建镜像</p>
</li>
<li>
<p>⑤ 使用 docker run 创建容器并运行</p>
</li>
</ul>
<p>总结：</p>
<ol>
<li>
<p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p>
</li>
<li>
<p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p>
</li>
<li>
<p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>
</li>
</ol>
<h2 id="dockercompose"><a class="header" href="#dockercompose">DockerCompose</a></h2>
<p>DockerCompose 是容器的批量运行脚本。</p>
<p>Docker Compose可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731180921742.png" alt="image-20210731180921742" /></p>
<h3 id="了解-dockercompose"><a class="header" href="#了解-dockercompose">了解 DockerCompose</a></h3>
<p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<pre><code class="language-json">version: &quot;3.8&quot;
 services:
  mysql:
    image: mysql:5.7.25
    environment:
     MYSQL_ROOT_PASSWORD: 123 
    volumes:
     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;
     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;
  web:
    build: .
    ports:
     - &quot;8090:8090&quot;

</code></pre>
<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于 <code>docker build</code> 临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose 的详细语法参考官网：https://docs.docker.com/compose/compose-file/</p>
<p>其实 DockerCompose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p>
<h3 id="部署微服务集群"><a class="header" href="#部署微服务集群">部署微服务集群</a></h3>
<p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p>
<p><strong>实现思路</strong>：</p>
<p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p>
<p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p>
<p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p>
<p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p>
<p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p>
<h4 id="compose文件"><a class="header" href="#compose文件">compose文件</a></h4>
<p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了 docker-compose 文件，而且每个微服务都准备了一个独立的目录：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210731181341330.png" alt="image-20210731181341330" /></p>
<p>内容如下：</p>
<pre><code class="language-yaml">version: &quot;3.2&quot;

services:
  nacos:
    image: nacos/nacos-server
    environment:
      MODE: standalone
    ports:
      - &quot;8848:8848&quot;
  mysql:
    image: mysql:5.7.25
    environment:
      MYSQL_ROOT_PASSWORD: 123
    volumes:
      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;
      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;
  userservice:
    build: ./user-service
  orderservice:
    build: ./order-service
  gateway:
    build: ./gateway
    ports:
      - &quot;10010:10010&quot;
</code></pre>
<p>可以看到，其中包含5个service服务：</p>
<ul>
<li><code>nacos</code>：作为注册中心和配置中心
<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li>
<li><code>environment</code>：环境变量
<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><code>mysql</code>：数据库
<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量
<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li>
</ul>
</li>
<li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li>
</ul>
<p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801095205034.png" alt="image-20210801095205034" /></p>
<p>查看微服务目录，可以看到都包含Dockerfile文件：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801095320586.png" alt="image-20210801095320586" /></p>
<p>内容如下：</p>
<pre><code class="language-dockerfile">FROM java:8-alpine
COPY ./app.jar /tmp/app.jar
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
<h4 id="修改微服务配置"><a class="header" href="#修改微服务配置">修改微服务配置</a></h4>
<p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p>
<p>如下所示：</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false
    username: root
    password: 123
    driver-class-name: com.mysql.jdbc.Driver
  application:
    name: orderservice
  cloud:
    nacos:
      server-addr: nacos:8848 # nacos服务地址
</code></pre>
<h4 id="打包"><a class="header" href="#打包">打包</a></h4>
<p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p>
<p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p>
<pre><code class="language-xml">&lt;build&gt;
  &lt;!-- 服务打包的最终名称 --&gt;
  &lt;finalName&gt;app&lt;/finalName&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>打包后：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801095951030.png" alt="image-20210801095951030" /></p>
<h4 id="拷贝jar包到部署目录"><a class="header" href="#拷贝jar包到部署目录">拷贝jar包到部署目录</a></h4>
<p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p>
<p>user-service：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801100201253.png" alt="image-20210801100201253" /></p>
<p>order-service：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801100231495.png" alt="image-20210801100231495" /></p>
<p>gateway：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801100308102.png" alt="image-20210801100308102" /></p>
<h4 id="部署-1"><a class="header" href="#部署-1">部署</a></h4>
<p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p>
<p>上传到任意目录：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210801100955653.png" alt="image-20210801100955653" /></p>
<p>部署：</p>
<p>进入cloud-demo目录，然后运行下面的命令：</p>
<pre><code class="language-sh">docker-compose up -d
</code></pre>
<h2 id="docker-镜像仓库"><a class="header" href="#docker-镜像仓库">Docker 镜像仓库</a></h2>
<p>Docker Registry。</p>
<p>公共仓库：DockerHub，网易云镜像仓库，阿里云镜像仓库</p>
<p>私有仓库：私有 Docker Registry</p>
<h3 id="简化版镜像仓库"><a class="header" href="#简化版镜像仓库">简化版镜像仓库</a></h3>
<p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>
<p>搭建方式比较简单，命令如下：</p>
<pre><code class="language-sh">docker run -d \
    --restart=always \
    --name registry	\
    -p 5000:5000 \
    -v registry-data:/var/lib/registry \
    registry
</code></pre>
<p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p>
<p>访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像</p>
<h3 id="带有图形化界面版本"><a class="header" href="#带有图形化界面版本">带有图形化界面版本</a></h3>
<p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p>
<pre><code class="language-yaml">version: '3.0'
services:
  registry:
    image: registry
    volumes:
      - ./registry-data:/var/lib/registry
  ui:
    image: joxit/docker-registry-ui:static
    ports:
      - 8080:80
    environment:
      - REGISTRY_TITLE=传智教育私有仓库
      - REGISTRY_URL=http://registry:5000
    depends_on:
      - registry
</code></pre>
<h3 id="配置-docker-信任地址"><a class="header" href="#配置-docker-信任地址">配置 Docker 信任地址</a></h3>
<p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p>
<pre><code class="language-sh"># 打开要修改的文件
vi /etc/docker/daemon.json
# 添加内容：
&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]
# 重加载
systemctl daemon-reload
# 重启docker
systemctl restart docker
</code></pre>
<h3 id="推送拉取镜像"><a class="header" href="#推送拉取镜像">推送、拉取镜像</a></h3>
<p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>
<pre><code class="language-sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 
</code></pre>
<p>② 推送镜像</p>
<pre><code class="language-sh">docker push 192.168.150.101:8080/nginx:1.0 
</code></pre>
<p>③ 拉取镜像</p>
<pre><code class="language-sh">docker pull 192.168.150.101:8080/nginx:1.0 
</code></pre>
<h2 id="-------------------------------------------"><a class="header" href="#-------------------------------------------">-------------------------------------------</a></h2>
<h2 id="cli-1"><a class="header" href="#cli-1">CLI</a></h2>
<h3 id="docker-ps-查看当前正在运行的容器"><a class="header" href="#docker-ps-查看当前正在运行的容器">docker ps 查看当前正在运行的容器</a></h3>
<h3 id="docker-version-查看版本"><a class="header" href="#docker-version-查看版本">docker version 查看版本</a></h3>
<pre><code class="language-shell">docker --version
</code></pre>
<h3 id="docker-image"><a class="header" href="#docker-image">docker image</a></h3>
<p>Docker 镜像的命名规范：</p>
<pre><code class="language-shell"># ls all images in local
docker image ls
</code></pre>
<h3 id="docker-container"><a class="header" href="#docker-container">docker container</a></h3>
<pre><code class="language-shell"># ls all container in local
docker container ls # running
docker container ls --all # all
docker container ls -aq # all in quiet mode
</code></pre>
<h3 id="docker-run"><a class="header" href="#docker-run">docker run</a></h3>
<pre><code class="language-shell">docker run -d -p 80:80 docker/getting-started
</code></pre>
<p>You'll notice a few flags being used. Here's some more info on them:</p>
<ul>
<li><code>-d</code> - run the container in detached mode (in the background)</li>
<li><code>-p 8000:80</code> - map port 8000 of the host to port 80 in the container</li>
<li><code>docker/getting-started</code> - the image to use</li>
</ul>
<p>注意，docker run 以后就创建了一个 container（实体），在 container 关闭后，container 还是存在的，要 rm 掉原来的 container 然后重新编译。</p>
<p>如果本地没有这个 docker 镜像，就会从远程仓库里面找。</p>
<h3 id="docker-build"><a class="header" href="#docker-build">docker build</a></h3>
<p>This command used the Dockerfile to build a new container image. </p>
<pre><code class="language-shell">docker build -t getting-started .
</code></pre>
<p>This command used the Dockerfile to build a new container image. You might have noticed that a lot of “layers” were downloaded. This is because we instructed the builder that we wanted to start from the <code>node:12-alpine</code> image. But, since we didn’t have that on our machine, that image needed to be downloaded.</p>
<p>After the image was downloaded, we copied in our application and used <code>yarn</code> to install our application’s dependencies. The <code>CMD</code> directive specifies the default command to run when starting a container from this image.</p>
<p>Finally, the <code>-t</code> flag tags our image. Think of this simply as a human-readable name for the final image. Since we named the image <code>getting-started</code>, we can refer to that image when we run a container.</p>
<p>The <code>.</code> at the end of the <code>docker build</code> command tells that Docker should look for the <code>Dockerfile</code> in the current directory.</p>
<h3 id="update-1"><a class="header" href="#update-1">Update</a></h3>
<p>代码变更后，更新 Docker 的流程。</p>
<h4 id="docker-build-1"><a class="header" href="#docker-build-1">docker build</a></h4>
<p>先重新编译</p>
<pre><code class="language-shell">docker build -t getting-started .
</code></pre>
<h4 id="docker-ps"><a class="header" href="#docker-ps">docker ps</a></h4>
<p>Get the ID of the container by using the <code>docker ps</code> command.</p>
<pre><code class="language-shell"> docker ps
</code></pre>
<h4 id="docker-stop"><a class="header" href="#docker-stop">docker stop</a></h4>
<p>Use the <code>docker stop</code> command to stop the container.</p>
<pre><code class="language-shell"> # Swap out &lt;the-container-id&gt; with the ID from docker ps
 docker stop &lt;the-container-id&gt;
</code></pre>
<h4 id="docker-rm"><a class="header" href="#docker-rm">docker rm</a></h4>
<p>Once the container has stopped, you can remove it by using the <code>docker rm</code> command.</p>
<pre><code class="language-shell"> docker rm &lt;the-container-id&gt;
</code></pre>
<p>You can stop and remove a container in a single command by adding the “force” flag to the <code>docker rm</code> command. For example: <code>docker rm -f &lt;the-container-id&gt;</code></p>
<h3 id="docker-login"><a class="header" href="#docker-login">docker login</a></h3>
<p>登录 DockerHub：</p>
<pre><code class="language-shell">docker login -u username
</code></pre>
<h3 id="docker-tag"><a class="header" href="#docker-tag">docker tag</a></h3>
<p>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</p>
<pre><code class="language-shell"># docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
docker tag getting-started wansho/getting-started
</code></pre>
<h3 id="docker-push"><a class="header" href="#docker-push">docker push</a></h3>
<p>把本地的 docker 镜像 push 到远程仓库。默认推送到 dockerhub。</p>
<pre><code class="language-shell"> docker push YOUR-USER-NAME/getting-started
</code></pre>
<h3 id="docker-pull"><a class="header" href="#docker-pull">docker pull</a></h3>
<p>从远程仓库拉取 docker image</p>
<pre><code class="language-shell">docker pull wansho/getting-started:latest
</code></pre>
<h2 id="docker-数据持久化"><a class="header" href="#docker-数据持久化">Docker 数据持久化</a></h2>
<p>While containers can create, update, and delete files, those changes are lost when the container is removed and all changes are isolated to that container. With volumes, we can change all of this.</p>
<p><a href="https://docs.docker.com/storage/volumes/">Volumes</a> provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we’d see the same files.</p>
<p>There are two main types of volumes. We will eventually use both, but we will start with <strong>named volumes</strong>.</p>
<h3 id="1-named-volumes"><a class="header" href="#1-named-volumes">1. named volumes</a></h3>
<h4 id="docker-volume-create"><a class="header" href="#docker-volume-create">docker volume create</a></h4>
<pre><code class="language-shell">docker volume create todo-db # 创建一个 named volumes
# 把 todo-db 作为镜像 getting-started 的 volume，并挂载 todo-db 到 /etc/todos 上(实际上并没有真正挂在到 /etc/todos 下面)
docker -dp 3000:3000 -v todo-db:/etc/todos getting-started 

# 查看 docker 实际把我们的数据存储到哪里了
docker volume inspect todo-db
</code></pre>
<pre><code class="language-json">[
    {
        &quot;CreatedAt&quot;: &quot;2021-04-25T20:11:13+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,
        &quot;Name&quot;: &quot;todo-db&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<h3 id="2-bind-mounts"><a class="header" href="#2-bind-mounts">2. bind mounts</a></h3>
<p>With <strong>bind mounts</strong>, we control the exact mountpoint on the host. We can use this to persist data, but it’s often used to provide additional data into containers. When working on an application, we can use a bind mount to mount our source code into the container to let it see code changes, respond, and let us see the changes right away.</p>
<h2 id="multi-container-apps"><a class="header" href="#multi-container-apps">Multi container apps</a></h2>
<p>Up to this point, we have been working with single container apps. But, we now want to add MySQL to the application stack. The following question often arises - “Where will MySQL run? Install it in the same container or run it separately?” In general, <strong>each container should do one thing and do it well.</strong> A few reasons:</p>
<ul>
<li>There’s a good chance you’d have to scale APIs and front-ends differently than databases</li>
<li>Separate containers let you version and update versions in isolation</li>
<li>While you may use a container for the database locally, you may want to use a managed service for the database in production. You don’t want to ship your database engine with your app then.</li>
<li>Running multiple processes will require a process manager (the container only starts one process), which adds complexity to container startup/shutdown</li>
</ul>
<h3 id="docker-network"><a class="header" href="#docker-network">docker network</a></h3>
<p>If two containers are on the same network, they can talk to each other. If they aren’t, they can’t.</p>
<pre><code class="language-shell"># Create the network.
docker network create todo-app

# Start a MySQL container and attach it to the network. 
# You’ll notice we’re using a volume named todo-mysql-data here and mounting it at /var/lib/mysql, which is where MySQL stores its data. However, we never ran a docker volume create command. Docker recognizes we want to use a named volume and creates one automatically for us.
sudo docker run -d \
     --network todo-app --network-alias mysql \
     -v todo-mysql-data:/var/lib/mysql \
     -e MYSQL_ROOT_PASSWORD=secret \
     -e MYSQL_DATABASE=todos \
     mysql:5.7
     
# To confirm we have the database up and running, connect to the database and verify it connects.
docker exec -it &lt;mysql-container-id&gt; mysql -u root -p
</code></pre>
<p>Our app only simply needs to connect to a host named <code>mysql</code> and it’ll talk to the database! It doesn’t get much simpler than that!</p>
<p>重启 getting-started 容器：</p>
<pre><code class="language-shell">#  # -w working dir; -v volume
sudo docker run -dp 3000:3000 \
   -w /app -v &quot;$(pwd):/app&quot; \
   --network todo-app \
   -e MYSQL_HOST=mysql \
   -e MYSQL_USER=root \
   -e MYSQL_PASSWORD=secret \
   -e MYSQL_DB=todos \
   node:12-alpine \
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<h3 id="docker-logs"><a class="header" href="#docker-logs">docker logs</a></h3>
<pre><code>docker logs container-id
</code></pre>
<pre><code> # Previous log messages omitted
 $ nodemon src/index.js
 [nodemon] 1.19.2
 [nodemon] to restart at any time, enter `rs`
 [nodemon] watching dir(s): *.*
 [nodemon] starting `node src/index.js`
 Connected to mysql db at host mysql
 Listening on port 3000
</code></pre>
<h3 id="docker-exec"><a class="header" href="#docker-exec">docker exec</a></h3>
<p>进入容器执行命令</p>
<pre><code class="language-shell"># 在容器中连接 mysql
docker exec -it &lt;mysql-container-id&gt; mysql -u root -p
</code></pre>
<h2 id="docker-compose"><a class="header" href="#docker-compose">Docker Compose</a></h2>
<p>Docker compose 的作用是对 docker run 进行配置封装。ubuntu 安装 docker-compose 的命令：<code>sudo apt-get install docker-compose </code></p>
<p>docker-compose 的优点：</p>
<ul>
<li>自动创建 network</li>
<li>对 docker run 进行封装，进而可以进行版本控制</li>
</ul>
<p><code>docker-compose.yml</code>:</p>
<pre><code class="language-yml">version: &quot;2.0&quot;

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment: 
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
</code></pre>
<pre><code class="language-shell"># 在 docker-compose.yml 所在文件夹下，执行该命令，就可以调起两个容器
docker-compose up -d 
</code></pre>
<pre><code class="language-shell"># 运行日志
 Creating network &quot;app_default&quot; with the default driver
 Creating volume &quot;app_todo-mysql-data&quot; with default driver
 Creating app_app_1   ... done
 Creating app_mysql_1 ... done
</code></pre>
<p>You’ll notice that the volume was created as well as a network! By default, Docker Compose automatically creates a network specifically for the application stack (which is why we didn’t define one in the compose file).</p>
<p>查看实时的运行日志：</p>
<pre><code class="language-shell">docker-compose logs -f # 所有的日志
docker-compose logs -f app # 单个容器的日志
</code></pre>
<p>When the app is starting up, it actually sits and waits for MySQL to be up and ready before trying to connect to it. Docker doesn’t have any built-in support to wait for another container to be fully up, running, and ready before starting another container. For Node-based projects, you can use the <a href="https://github.com/dwmkerr/wait-port">wait-port</a> dependency. Similar projects exist for other languages/frameworks.</p>
<p>关闭 compose</p>
<pre><code class="language-shell">docker-compose down
</code></pre>
<p>Removing Volumes</p>
<p>By default, named volumes in your compose file are NOT removed when running <code>docker-compose down</code>. If you want to remove the volumes, you will need to add the <code>--volumes</code> flag. The Docker Dashboard does <em>not</em> remove volumes when you delete the app stack.</p>
<h2 id="------------------------------------------------------"><a class="header" href="#------------------------------------------------------">------------------------------------------------------</a></h2>
<h2 id="青云-kubesphere"><a class="header" href="#青云-kubesphere">青云 KubeSphere</a></h2>
<p>对 K8s 进行封装，做可视化配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生"><a class="header" href="#云原生">云原生</a></h1>
<h2 id="概念-1"><a class="header" href="#概念-1">概念</a></h2>
<p>原生：原生应用，由各种语言开发的 web 应用。</p>
<p>云原生：原生应用上云的整个过程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h1>
<p>[TOC]</p>
<h2 id="消息队列介绍"><a class="header" href="#消息队列介绍">消息队列介绍</a></h2>
<h3 id="同步和异步通讯"><a class="header" href="#同步和异步通讯">同步和异步通讯</a></h3>
<p>微服务间通讯有同步和异步两种方式：</p>
<p>同步通讯：就像打电话，需要实时响应。</p>
<p>异步通讯：就像发邮件，不需要马上回复。</p>
<h3 id="同步通信的问题"><a class="header" href="#同步通信的问题">同步通信的问题</a></h3>
<p><img src="computer-science-notebook/development-tools/assets/image-20210913103945957.png" alt="image-20210913103945957" /></p>
<h3 id="异步通信的优点"><a class="header" href="#异步通信的优点">异步通信的优点</a></h3>
<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>
<p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p>
<p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker 代理）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20210422095356088.png" alt="image-20210422095356088" /></p>
<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p>好处：</p>
<ul>
<li>
<p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>
</li>
<li>
<p>故障隔离：服务没有直接调用，不存在级联失败问题</p>
</li>
<li>
<p>调用间没有阻塞，不会造成无效的资源占用</p>
</li>
<li>
<p>耦合度极低，每个服务都可以灵活插拔，可替换</p>
</li>
<li>
<p>流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件，短时间内有大量的流量进来，并且每一条请求都比较慢，则采用消息队列模式</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<h3 id="技术对比"><a class="header" href="#技术对比">技术对比</a></h3>
<p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<p>比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody>
<tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr>
<tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr>
<tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr>
<tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr>
<tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr>
<tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr>
<tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h3 id="jms"><a class="header" href="#jms">JMS</a></h3>
<p>JMS 是 Java 消息服务的应用程序接口，和 JDBC 一样，只定义接口，不做具体实现。</p>
<p>JMS 是 Java 对于消息队列 MQ 的一种实现方式。</p>
<p>JMS 的实现：ActiveMQ、RabbitMQ、RocketMQ，其中 RocketMQ 并没有完全遵循 JMS 规范。</p>
<p>注意，Kafka 不是 JMS 的实现。</p>
<h2 id="kafka"><a class="header" href="#kafka">Kafka</a></h2>
<h3 id="同步--异步通信"><a class="header" href="#同步--异步通信">同步 / 异步通信</a></h3>
<p>同步通信：打电话</p>
<p>异步通信：语音信箱 / 发邮件</p>
<h3 id="介绍-3"><a class="header" href="#介绍-3">介绍</a></h3>
<p><a href="http://dataguild.org/?p=7290">[数据工会 - 云上的Kafka]</a></p>
<p>异步通信 / 消息发布，订阅 / 分布式 / 顺序存储-高速 / </p>
<table><thead><tr><th>Kafka 在系统中的作用</th><th>Kafka 的发布订阅机制和微信公众号的发布订阅是一个原理</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/development-tools/assets/image-20200911083219694.png" alt="image-20200911083219694" /></td><td><img src="computer-science-notebook/development-tools/assets/image-20200911083232204.png" alt="image-20200911083232204" /></td></tr>
</tbody></table>
<h2 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h2>
<h3 id="简介-2"><a class="header" href="#简介-2">简介</a></h3>
<p><img src="computer-science-notebook/development-tools/assets/image-20210913104712772.png" alt="image-20210913104712772" /></p>
<p>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>broker：mq 服务器，代理</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<p><img src="computer-science-notebook/development-tools/assets/image-20210913105821725.png" alt="image-20210913105821725" /></p>
<p>workqueue 模式实际上是负载均衡模式</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis-3"><a class="header" href="#redis-3">Redis</a></h1>
<p>[TOC]</p>
<p><strong>In-memory key-value database.</strong></p>
<h2 id="introduction-14"><a class="header" href="#introduction-14">Introduction</a></h2>
<p>学习资源：</p>
<ul>
<li><a href="https://redis.io/">Redis.io</a></li>
<li><a href="http://try.redis.io/">Try-Redis</a></li>
<li><a href="https://www.openmymind.net/2011/11/8/Redis-Zero-To-Master-In-30-Minutes-Part-1/">Redis 30minutes</a></li>
<li><a href="https://github.com/JamzyWang/awesome-redis">Awesome Redis</a></li>
</ul>
<p>Redis 通常被描述为一个存储键值对的内存数据库。内存数据库的特性决定了其存取效率应该是非常高的。</p>
<p>Redis 的应用场景：</p>
<ul>
<li>用 Redis 替换频繁读取数据库稳定数据的逻辑，在 Web 服务与数据库之间充当缓存的功能。</li>
<li>计数器</li>
</ul>
<h2 id="install-3"><a class="header" href="#install-3">install</a></h2>
<pre><code class="language-shell">brew install redis

# 启动 redis
redis-server

# Redis 默认端口是6379，你也可以换个端口号启动，
redis-server --port 6380

# 使用了肯定需要停止，停止怎么弄呢？
# 停止
# 执行命令
redis-cli shutdown
</code></pre>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p><a href="https://redis.io/topics/quickstart">Redis quickstart</a></p>
<h2 id="redis-commands"><a class="header" href="#redis-commands">Redis Commands</a></h2>
<h3 id="get--set--del--setnx--incr"><a class="header" href="#get--set--del--setnx--incr">get / set / del / setnx / incr</a></h3>
<pre><code class="language-shell">set key-name value
get key-name

set name &quot;wansho&quot;
set age 13
get name
get age

# setnx set if not exists
setnx couple &quot;someone&quot;

# atomically increment
incr age # age 自增 1

# del key1, key2, key3 返回删除的键值对的数量，如果返回 0 则代表没有该键值对
</code></pre>
<h3 id="expire--ttl"><a class="header" href="#expire--ttl">expire / ttl</a></h3>
<pre><code class="language-shell">set user-lock &quot;wansho&quot;
expire user-lock 120 # 120 秒后该变量失效

ttl user-lock # time-to-live 查看该变量距离失效还有几秒，如果返回 -2，则说明该变量已经不存在了，要么失效了，要么本身就不存在，如果返回 -1，则说明该变量是永久生效的
# 注意，如果我们重新 set 了某个变量，那么 ttl 就会被重置为初始值：120
</code></pre>
<h3 id="高级数据结构"><a class="header" href="#高级数据结构">高级数据结构</a></h3>
<p>注意：高级数据结构，其只是 value 为高级数据结构，key 依然还是之前的 key</p>
<h4 id="list-2"><a class="header" href="#list-2">list</a></h4>
<pre><code class="language-shell"># list

lpush names &quot;wansho&quot; # 创建一个名为 names 的 list，并且从队尾加入值 &quot;wansho&quot;
rpush names &quot;wangkai&quot; # 从队首加入一个值，返回队列元素的个数

llen names # 返回 队列的长度

lpop names # 从队首弹出一个值，返回被弹出的值
rpop names # 从队尾弹出一个值，返回被弹出的值

lrange names 0 1 # get subset of list, 第 0，1 个元素，注意，redis 的 slice 是包含尾的
lrange names 0 -1 # 获取从第 0 个到最后一个元素
</code></pre>
<h4 id="set--sorted-set--hset"><a class="header" href="#set--sorted-set--hset">set / sorted set / hset</a></h4>
<pre><code class="language-shell"># set

sadd fruits &quot;xigua&quot; &quot;orange&quot;# 新建一个 set，并且加入 xigua，orange, 返回加入 set 成功的个数，注意，元素与元素之间，用空格隔开，如果用逗号隔开，那么 redis 会将逗号作为一个元素
srem fruits &quot;xigua&quot; # remove 

sismember fruits &quot;xigua&quot; # set is member: check 西瓜是否在 set 中，存在返回 1，不存在返回 0

smembers fruits # return a list of all values in set

sunion fruit1 fruit2 # 两个 set 求并集

# sorted set 有序的 set

# hset 存储的值为键值对
</code></pre>
<h2 id="questions-8"><a class="header" href="#questions-8">Questions</a></h2>
<ol>
<li>
<p>Redis 是内存数据库，掉电后数据是否会被保存下来？</p>
<p>Redis 有将内存数据写入磁盘的功能，对于一个计数器，我们可以将计数的数据定时同步到磁盘中。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selenium-1"><a class="header" href="#selenium-1">Selenium</a></h1>
<p>[TOC]</p>
<h2 id="introduction-15"><a class="header" href="#introduction-15">Introduction</a></h2>
<p>Selenium(硒的英文) 是一个用于 浏览器自动化 的工具集，其常用于<strong>网站自动化测试</strong>和<strong>爬虫</strong>(获取 Cookie)。</p>
<p>Selenium 本质上是一个接口工具，其提供了与浏览器进行交互的编程接口。提供了多种编程语言的实现：<code>Java, Python, C#, JavaScript, …</code>。Selenium 就像是 Java 操作数据库的接口：JDBC 一样，针对不同的数据库，实现了统一的接口访问，也就是说，Selenium 针对不同的浏览器，实现了统一的接口访问。与 JDBC 不同的是，Selenium 想要访问不同的浏览器，需要对应浏览器的 Web'Driver:</p>
<p><img src="computer-science-notebook/development-tools/assets/1574584265935.png" alt="Selenium Introduction" /></p>
<h2 id="selenium-支持的浏览器"><a class="header" href="#selenium-支持的浏览器">Selenium 支持的浏览器</a></h2>
<p>最常见的两种：</p>
<table><thead><tr><th>浏览器</th><th>WebDriver</th><th>is support headless</th></tr></thead><tbody>
<tr><td><a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb">Chrome最新版</a> <a href="https://www.chromedownloads.net/chrome64linux/">Chrome历史版本</a></td><td><a href="http://chromedriver.storage.googleapis.com/index.html">Chrome Driver</a></td><td>yes</td></tr>
<tr><td>FireFox</td><td><a href="https://github.com/mozilla/geckodriver/releases">Firefox GeckoDriver</a></td><td>yes</td></tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<ul>
<li>Chrome 的版本和 Chrome Driver 的版本必须匹配！</li>
<li>Selenium 已经放弃了对于 phantomjs 的支持</li>
</ul>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<p>官方文档：<a href="https://selenium.dev/documentation/en/webdriver/browser_manipulation/">Selenium browser_manipulation</a></p>
<p>注意：</p>
<p>使用 Selenium，最常见的问题是：<code> element not interactable</code>，原因是浏览器的运行加载速度，远远慢于代码的运行速度，换句话说，浏览器之所以没有相应，是因为网页还没有加载出来。Selenium 提出了 Waits 来解决浏览器异步加载的问题：</p>
<h3 id="explicit-wait"><a class="header" href="#explicit-wait">Explicit wait</a></h3>
<p>freeze thread 直到 condition 满足。 </p>
<p><em>Explicit waits</em> are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the <em>condition</em> you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.</p>
<pre><code class="language-Python">from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# WebDriverWait(driver, timeout=3).until(some_condition)
# 等待 10 秒，直到发现了 loginName 这个 ID 出现，表明 DOM 加载完毕
WebDriverWait(driver, 10).until(
    EC.visibility_of_element_located((By.ID, &quot;loginName&quot;)
).send_keys(&quot;scmevwqlgkwis-gef@yahoo.com&quot;)
driver.find_element_by_id(self.login_passwd_id).send_keys(&quot;TCqkwqbfvw02&quot;)
</code></pre>
<h3 id="implicit-wait"><a class="header" href="#implicit-wait">Implicit wait</a></h3>
<p>WebDriver会在一定时间内轮询 DOM 以尝试查找元素。该模式是默认关闭的，需要手动打开。</p>
<p>WebDriver polls the DOM for a certain duration when trying to find <em>any</em> element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.</p>
<pre><code class="language-python">driver = Firefox()
driver.implicitly_wait(10) # 重点是这条语句，开了就 OK 了！
driver.get(&quot;http://somedomain/url_that_delays_loading&quot;)
my_dynamic_element = driver.find_element_by_id(&quot;myDynamicElement&quot;)
</code></pre>
<h3 id="fluent-wait"><a class="header" href="#fluent-wait">Fluent wait</a></h3>
<p>是 Explicit 的升级版，加了 check condition 的次数。</p>
<h2 id="ubuntu1604-上运行-headless-chrome"><a class="header" href="#ubuntu1604-上运行-headless-chrome">Ubuntu16.04 上运行 headless Chrome</a></h2>
<h3 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h3>
<pre><code class="language-bash"># 下载 chromedriver
mkdir ~/webservice/dependency/chromedriver &amp;&amp; cd $_
# 各版本 Chromedriver 下载 http://chromedriver.storage.googleapis.com/index.html
wget https://chromedriver.storage.googleapis.com/78.0.3904.105/chromedriver_linux64.zip
unzip chromedriver_linux64.zip
sudo ln chromedriver /usr/bin

# 下载 Chrome
# 各版本 Chrome 下载：https://www.chromedownloads.net/chrome64linux/
sudo apt-get install libxss1 libappindicator1 libindicator7
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb # latest stable version 
sudo dpkg -i google-chrome*.deb  # Might show &quot;errors&quot;, fixed by next line
sudo apt-get install -f

# 安装 selenium
pip install selenium
</code></pre>
<h3 id="demo-9"><a class="header" href="#demo-9">Demo</a></h3>
<pre><code class="language-python">class CookieUpdate:
    &quot;&quot;&quot;更新 Cookie 的脚本，每 1 天的凌晨 1.30 检查一次&quot;&quot;&quot;
    login_url = &quot;https://passport.weibo.cn/signin/login?entry=mweibo&amp;r=https://weibo.cn/&quot;
    login_name_id = &quot;loginName&quot;
    login_passwd_id = &quot;loginPassword&quot;
    login_button_id = &quot;loginAction&quot;
    weibo_index_valid_name = &quot;friends&quot; # 验证微博页面加载出来的 name

    def execute(self):
        invalid_accounts = self.get_accounts()
        for invalid_account in invalid_accounts:
            driver = self.init_driver()
            username = invalid_account[&quot;account&quot;]
            passwd = invalid_account[&quot;passwd&quot;]
            login_result = self.login(username, passwd, driver)
            if not login_result:
                continue
            cookie = self.get_cookie(driver)
            if not cookie:
                continue
            cookie_str = self.cookie_parse(cookie)
            models.sina_account.objects.filter(account=username).update(cookie=cookie_str,
                                                                        is_valid=&quot;Y&quot;,
                                                                        last_modify_time=datetime.datetime.now())
            logger.info(&quot;cookie update success, &quot;
                        &quot;username: {username}, &quot;
                        &quot;cookie:{cookie}&quot;.format(username=username, cookie=cookie_str))
            self.quit_driver(driver)


    def init_driver(self):
        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument('--headless')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--no-sandbox')
        driver = webdriver.Chrome(chrome_options=chrome_options, executable_path=&quot;chromedriver.exe&quot;)
        driver.maximize_window()
        driver.set_page_load_timeout(30)
        driver.set_window_size(1124, 850)
        return driver

    def quit_driver(self, driver):
        driver.quit()

    def login(self, username, passwd, driver):
        login_result = False
        # driver.implicitly_wait(10)
        driver.get(self.login_url)
        try:
            WebDriverWait(driver, 10).until(
                EC.visibility_of_element_located((By.ID, self.login_name_id))
            ).send_keys(username)
            driver.find_element_by_id(self.login_passwd_id).send_keys(passwd)
            button_login = driver.find_element_by_id(self.login_button_id)
            button_login.click()
            login_result = True
        except Exception as e:
            logger.error(&quot;senti_weibo CookieUpdate 登陆失败，账号：{username}, 密码：{passwd}。&quot;.format(username=username,
                                                                                           passwd=passwd) + str(e))
        return login_result

    def get_cookie(self, driver):
        cookie = &quot;&quot;
        # 等待 index 页面加载完毕
        try:
            WebDriverWait(driver, 10).until(
                EC.visibility_of_element_located((By.NAME, self.weibo_index_valid_name))
            )
            cookie = driver.get_cookies()
        except Exception as e:
            logger.error(&quot;senti_weibo CookieUpdate 获取 Cookie 失败:&quot; + str(e))
        return cookie

    def cookie_parse(self, cookie):
        &quot;&quot;&quot;
        :param cookie: dict in list name: value
        :return:
            cookie_string
        &quot;&quot;&quot;
        cookie_str = &quot;; &quot;.join([pairs[&quot;name&quot;] + &quot;=&quot; + pairs[&quot;value&quot;] for pairs in cookie])
        return cookie_str

    def get_accounts(self):
        &quot;&quot;&quot;获取需要更新的账户，更新的原则为：
        1. 手机的账号不再更新
        2. 更新 7 天没有更新 Cookie 的账号
        3. 更新 Cookie 已经失效的账号
        &quot;&quot;&quot;
        seven_days_ago = datetime.datetime.now() - datetime.timedelta(days=7)
        columns = [&quot;account&quot;, &quot;passwd&quot;]
        invalid_accounts = list(models.sina_account.objects.filter(
            Q(last_modify_time__lte=seven_days_ago) | Q(is_valid=&quot;N&quot;)
        ).exclude(account__istartswith=&quot;16&quot;).values(*columns))
        return invalid_accounts

</code></pre>
<h2 id="开源项目参考"><a class="header" href="#开源项目参考">开源项目参考</a></h2>
<ul>
<li><a href="https://github.com/SpiderClub/smart_login">Smart Login</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nginx"><a class="header" href="#nginx">nginx</a></h1>
<h2 id="install-4"><a class="header" href="#install-4">install</a></h2>
<p>ubuntu</p>
<pre><code class="language-shell">apt-get install nginx

# 查看是否安装成功
nginx -v

# 开启 nginx
systemctl start nginx
service nginx start

# 重启，热部署
nginx -s reload

# 关闭
nginx -s stop
</code></pre>
<p>安装后的文件位置</p>
<pre><code>/usr/sbin/nginx：主程序
/etc/nginx：存放配置文件
/usr/share/nginx：存放静态文件
/var/log/nginx：存放日志
</code></pre>
<h2 id="config"><a class="header" href="#config">config</a></h2>
<pre><code class="language-shell"># 找到服务器nginx路径下的default.conf文件，如没有可用vim命令创建一个，编辑这个文件
vim /etc/nginx/conf.d/default.conf

server{
    listen 80;    # 80为公网访问的端口
    server_name 104.*.*.*;  # 填入公网的Ip地址
    rewrite ^/$ / break;  
    location / {
    	proxy_pass http://127.0.0.1:8000;  # django中的地址和端口
    }
}

# 检查语法是否正确
nginx -t
</code></pre>
<p>多服务反向代理 https://www.cnblogs.com/panchanggui/p/12064427.html</p>
<p>一个代理多个子域名的 nginx 配置</p>
<pre><code class="language-nginx">server{
	listen 80;    # 80为公网访问的端口
	server_name *.wansho.top;  # 填入公网的Ip地址
	
	if ($http_host ~* &quot;^(.*?)\.wansho\.top$&quot;) {    #正则表达式
		set $sub_domain $1;                     #设置变量
		set $is_matched 0; 
	}

	location / {
		if ($sub_domain ~* &quot;running|sentiweibo|www&quot;) {
		   proxy_pass http://127.0.0.1:8000;      #域名中有 running sentiweibo，转发到 8000 端口的 Django 服务
		   set $is_matched 1;
		}
		
		if ($sub_domain ~* &quot;rss&quot;) {
		   proxy_pass http://127.0.0.1:1200;      #域名中有shop，转发到 1200 端口的 rss 服务
		   set $is_matched 1;
		}
    
    if ($sub_domain ~* &quot;gitlab&quot;) {
		   proxy_pass http://127.0.0.1:10880;      #域名中有shop，转发到 1200 端口的 rss 服务
		   set $is_matched 1;
		}
    
		
		# 没有匹配到，跳转到默认页面
    if ($is_matched = 0) {
      proxy_pass https://127.0.0.1:8000;
    }
		
		tcp_nodelay     on;

		proxy_set_header Host            $host;
    
    # 配置上传文件大小限制
    client_max_body_size 100m;

		proxy_set_header X-Real-IP       $remote_addr;

		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		
		root html;
		
		index index.html index.htm;
	}
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zookeeper"><a class="header" href="#zookeeper">zookeeper</a></h1>
<p>[TOC]</p>
<h2 id="产品超卖问题"><a class="header" href="#产品超卖问题">产品超卖问题</a></h2>
<p>单线程扣减库存逻辑：</p>
<img align="left" src="computer-science-notebook/development-tools/assets/image-20211005101144964.png" alt="image-20211005101144964" style="zoom:50%;" />
<p>并发环境扣减库存会出现问题：</p>
<p><img src="computer-science-notebook/development-tools/assets/image-20211005101326457.png" alt="image-20211005101326457" /></p>
<p>解决方案：</p>
<ol>
<li>传统的synchronized是无效的，它只针对一个JVM进程内多个线程起到同步作用，对跨
进程无效。</li>
<li>利用数据库select ... for update 语句对库存进行锁定，依赖数据库自身特性，遇到跨库
（分库分表）处理起来比较麻烦。</li>
<li>利用Zookeeper、Redis实现分布式锁特性，通过分布式锁调度进程处理，数据程序级别
控制，处理更为灵活。</li>
</ol>
<img align="left" src="computer-science-notebook/development-tools/assets/image-20211005101416922.png" alt="image-20211005101416922" style="zoom:50%;" />
<p>锁带来的问题：</p>
<p>无论是数据库排它锁，还是ZK、Redis的分布式锁都属于“悲观锁”的范畴，虽然以阻塞的方式保证数据的一致性，但并发量也会直线下降，这是要付出的代价。适用分布式锁有以下几个场景：</p>
<ol>
<li>数据价值大，必须要保证一致性的。例如：金融业务系统间的转账汇款等。</li>
<li>并发量低但重要的业务系统。比如：各种大宗商品的分布式交易</li>
</ol>
<p>总结下：重要的但对并发要求不高的系统可以使用分布式锁，对于并发量高、数据价值小、对一致性要求没那么高的系统可以进行最终一致性(BASE)处理，保证并发的前提下通过重试、程序矫正、人工补录的方式进行处理。</p>
<h2 id="什么是zookeeper"><a class="header" href="#什么是zookeeper">什么是Zookeeper？</a></h2>
<p>Zookeeper（业界简称zk）是一种提供配置管理、分布式协同以及命名的中心化服务，这些提供的功能都是分布式系统中非常底层且必不可少的基本功能，但是如果自己实现这些功能而且要达到高吞吐、低延迟同时还要保持一致性和可用性，实际上非常困难。因此zookeeper提供了这些功能，开发者在zookeeper之上构建自己的各种分布式系统。</p>
<img align="left" src="computer-science-notebook/development-tools/assets/image-20211005102817857.png" alt="image-20211005102817857" style="zoom: 60%;" />
<p>Zookeeper被称为分布式协调服务器，通过对Zookeeper的应用，可以实现分布式系统同步运行，实现各系统功能的协调推进。例如，可以实现集群管理、Master选举、分布式锁、分布式队列等功能，都是ZK协调性机制的体现。</p>
<h2 id="apache-curator"><a class="header" href="#apache-curator">Apache Curator</a></h2>
<p>Zookeeper 的一个高级封装。在实际的 Java 代码中，引入该依赖进行分布式锁的开发。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haproxy-keepalived"><a class="header" href="#haproxy-keepalived">haproxy-keepalived</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="部署自己的-webhook"><a class="header" href="#部署自己的-webhook">部署自己的 webhook</a></h1>
<p>[TOC]</p>
<h2 id="源码"><a class="header" href="#源码">源码</a></h2>
<p><a href="https://github.com/adnanh/webhook">webhook</a></p>
<h2 id="环境部署"><a class="header" href="#环境部署">环境部署</a></h2>
<pre><code class="language-shell"># 安装 go
# install tar.gz https://golang.org/doc/install
rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin
# 把 PATH=$PATH:/usr/local/go/bin 放入 /etc/profile
go version

# 安装部署 webhook
cd /home/work/webhook
git clone https://github.com/adnanh/webhook.git
cd webhook
go build
./webhook -hooks hooks.json -verbose
</code></pre>
<h2 id="hooksjson"><a class="header" href="#hooksjson">hooks.json</a></h2>
<p>在 hooks.json 中配置钩子</p>
<pre><code>id: hook 的 id，与 http 请求 url 最后一个路径相同
execute-command: 该 hook 执行的脚本，支持 bash 和 sh
</code></pre>
<p>hooks.json 举例</p>
<pre><code class="language-json">[
  {
    &quot;id&quot;: &quot;redeploy-gitbook&quot;,
    &quot;execute-command&quot;: &quot;/home/work/webhook/hook-scripts/redeploy-gitbook.sh&quot;
  }
]
</code></pre>
<h2 id="触发-webhook"><a class="header" href="#触发-webhook">触发 webhook</a></h2>
<p>get 请求和 post 请求都可以</p>
<pre><code>http://yourserver:9000/hooks/redeploy-gitbook
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="低代码"><a class="header" href="#低代码">低代码</a></h1>
<p>[TOC]</p>
<h2 id="低代码---后端调研"><a class="header" href="#低代码---后端调研">低代码 - 后端调研</a></h2>
<p>Dataway<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.hasor.net%2Fdoc%2Fdisplay%2Fdataway"> https://www.hasor.net/doc/display/dataway</a></p>
<p>Magic-API <a href="https://gitee.com/link?target=https%3A%2F%2Fssssssss.org%2Fguide%2Fintro.html">https://ssssssss.org/guide/intro.html</a></p>
<p>Rocket-API-Platform https://gitee.com/alenfive/rocket-api-platform</p>
<p>APIjson <a href="https://gitee.com/link?target=http%3A%2F%2Fapijson.org%2F">http://apijson.org/</a></p>
<p>Graphql <a href="https://gitee.com/link?target=https%3A%2F%2Fgraphql.cn%2F">https://graphql.cn/</a></p>
<p>mybatis-plus-generator-ui https://github.com/davidfantasy/mybatis-plus-generator-ui</p>
<h3 id="流程"><a class="header" href="#流程">流程</a></h3>
<p>前端 json —&gt; 脚本语言 —&gt; 脚本引擎解释执行</p>
<h2 id="magic-api"><a class="header" href="#magic-api">magic-api</a></h2>
<p>https://gitee.com/ssssssss-team/magic-api</p>
<p>特性</p>
<ul>
<li>
<p>支持自定义 web api —&gt; 解放了后端，不再需要写胶水代码，允许工程人员自定义数据接口</p>
</li>
<li>
<p>支持自定义模块 —&gt; 自定义数据源插件</p>
</li>
<li>
<p>支持多数据源 —&gt; 符合我们前端多数据源的要求</p>
</li>
<li>
<p>脚本支持断点调试</p>
</li>
<li>
<p>可以通过 magic-script 脚本直接调用 Java —&gt; 对 Java 方法的直接封装</p>
</li>
<li>
<p>提供了与 rest 对应的第三方开发的接口 —&gt; 除了通过 rest 接口与 web api 进行交互外，magic-api 还暴露了第三方开发者接口</p>
</li>
</ul>
<p>我的思考</p>
<ul>
<li>magic-editor 是面向我们开发者的 magic-script 调试工具，在实际的使用时，我们还要对 magic-api 进一步地封装，自动生成 magic-script</li>
</ul>
<h2 id="magic-api-待优化"><a class="header" href="#magic-api-待优化">magic-api 待优化</a></h2>
<h3 id="异常处理-1"><a class="header" href="#异常处理-1">异常处理</a></h3>
<p>在往数据库插入数据的时候，如果主键重复，会报告插入失败：</p>
<pre><code class="language-json">{
    &quot;code&quot;: -1,
    &quot;message&quot;: &quot;系统内部出现错误&quot;,
    &quot;data&quot;: null,
    &quot;timestamp&quot;: 1647393402831,
    &quot;executeTime&quot;: 70
}
</code></pre>
<p>但是错误信息并没有将详细的信息打印出来，此处要修改一下。</p>
<h2 id="todo"><a class="header" href="#todo">todo</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p>多数据源的配置，是否所有的数据源都需要在 yml 中配置？</p>
<p>不需要，只需要在 application.yml 中配置一个主数据源，然后如果增加其他数据源的话，会生成到配置文件中</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>调研 mybatis-plus-generator-ui，学习怎么选列名</p>
</li>
<li><input disabled="" type="checkbox"/>
</li>
<li><input disabled="" type="checkbox"/>
<p>接口信息写入默认的数据库，而不是写入配置文件</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="爬虫总结"><a class="header" href="#爬虫总结">爬虫总结</a></h1>
<p>[TOC]</p>
<h2 id="beautifulsoup"><a class="header" href="#beautifulsoup">BeautifulSoup</a></h2>
<h3 id="beautifulsoup-版本问题"><a class="header" href="#beautifulsoup-版本问题">Beautifulsoup 版本问题</a></h3>
<pre><code>BeautifulSoup 3 的 find_all 版本为 findAll # BeautifulSoup3 已经停止更新，被 4 取代
BeautifulSoup 4 的 find_all 版本为 find_all
两个版本其他方法还有很多的不同
</code></pre>
<h3 id="导包"><a class="header" href="#导包">导包</a></h3>
<pre><code>from bs4 import BeautifulSoup
</code></pre>
<h3 id="常见的用法"><a class="header" href="#常见的用法">常见的用法</a></h3>
<p><strong>模糊查询</strong></p>
<pre><code># 获取包含 class 为 c ，存在id属性的 div 很重要
microblog_soups = soup.find_all('div', attrs = {'class' : 'c'}, id = re.compile('.*'))
comment = microblog_soup.find_all('a', attrs = {'class' : 'cc'}, href = re.compile(re_str))
</code></pre>
<p><strong>获取属性</strong></p>
<pre><code># 获取用户主页 https://weibo.cn/a813689091
index = microblog_soup.find('a',attrs = {'class' : 'nk'}).get('href')
</code></pre>
<p><strong>获取文本</strong></p>
<pre><code>content = microblog_soup.find('span',attrs = {'class' : 'ctt'}).get_text().strip()
</code></pre>
<p><strong>网页修补 &amp; 保存</strong></p>
<pre><code>'''
用beautifulsoap 修补一下网页，并存储，用来研究
'''
def fix_and_write_html(html_str,path):
    # 修补html
    soup = BeautifulSoup(html_str,'html.parser',from_encoding=&quot;gb18030&quot;)
    fixed_html = soup.prettify()
    writer = open(path, 'w', encoding='utf-8')
    writer.write(fixed_html)
    writer.close()
    return fixed_html
</code></pre>
<h2 id="常用代码"><a class="header" href="#常用代码">常用代码</a></h2>
<pre><code>def downloadHtml(url,headers):
    html = -1 # 如果返回 -1，说明爬取失败
    try:
        html = requests.get(url, headers=headers).text
    except Exception as e:
        print(e)
        return html
    return html
'''
用beautifulsoap 修补一下网页，并存储，用来研究
'''
def fix_and_write_html(html_str,path):
    # 修补html
    soup = BeautifulSoup(html_str,'html.parser',from_encoding=&quot;gb18030&quot;)
    fixed_html = soup.prettify()
    writer = open(path, 'w', encoding='utf-8')
    writer.write(fixed_html)
    writer.close()
    return fixed_html
</code></pre>
<h2 id="解析xml"><a class="header" href="#解析xml">解析xml</a></h2>
<p>事实上，读取到的xml和HTML没啥区别，解析方式也与HTML没啥区别</p>
<pre><code class="language-python">comment_url = 'https://comment.bilibili.com/' + cid + '.xml'
comment_text = requests.get(comment_url, headers=xml_headers).content
comment_selector = etree.HTML(comment_text)
comment_content = comment_selector.xpath('//i')
comment_list = []
for comment_each in comment_content:
comments = comment_each.xpath('//d/text()')
for comment in comments:
comment_list.append(comment)
</code></pre>
<h2 id="下载网页的两种方式"><a class="header" href="#下载网页的两种方式">下载网页的两种方式</a></h2>
<h3 id="urllibrequest"><a class="header" href="#urllibrequest">urllib.request</a></h3>
<pre><code>from urllib.request import urlopen
from urllib.request import Request

req = Request(url=url, headers=headers)
try: 
    # 这里read()后得到的其实是byte类型的数据，必须通过decode()转成字符型的，这个步骤经常出问题
    html = urlopen(req).read().decode('utf-8')
except Exception as e:
    print(e)
return html
</code></pre>
<h3 id="request"><a class="header" href="#request">request</a></h3>
<pre><code>import requests

# 这个在B站上试了，没有出现问题
html = requests.get(url, headers=headers).text
</code></pre>
<h2 id="爬虫的原网页分析url构造分析与爬取内容分析"><a class="header" href="#爬虫的原网页分析url构造分析与爬取内容分析">爬虫的原网页分析（url构造分析与爬取内容分析）</a></h2>
<p>有些时候，我们要爬取的内容在源代码中没有显示，目前知道有两个可能：</p>
<ol>
<li>网页内容是动态加载的</li>
<li>网页内容存储在一个文件中</li>
</ol>
<p>对于第一种可能，我暂时还不懂怎么爬取，但是第二种可能，其实是有迹可循的。这里以哔哩哔哩为例。</p>
<p>我们想要爬取哔哩哔哩的弹幕，但是根据文字搜索源码找不到弹幕，但是弹幕又是提前加载好的，动态加载的可能性很小，所以我们猜测弹幕应该是存储在一个文件中，从服务器发过来，然后再解析。</p>
<p>那么，如何分析服务器发过来的文件？ 这是有方法的。</p>
<p>通常步骤是，在浏览器的network中刷新，然后下面列表中内容就是从服务器返回的各种数据。通过分析，我们找到了一个可疑文件，打开后，就是我们要寻找的弹幕文件。</p>
<h2 id="爬虫代码的健壮性"><a class="header" href="#爬虫代码的健壮性">爬虫代码的健壮性</a></h2>
<ol>
<li>
<p>beautifulsoap 要进行判空处理</p>
</li>
<li>
<p>要对断网的情况进行异常处理</p>
</li>
<li>
<p>要对IO进行异常处理</p>
</li>
<li>
<p>要小心测试反爬虫检测的频率</p>
</li>
</ol>
<h2 id="selenium-自动登陆获取cookie-和-网页"><a class="header" href="#selenium-自动登陆获取cookie-和-网页">Selenium 自动登陆，获取cookie 和 网页</a></h2>
<pre><code>import json
import urllib2

from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

def get_html(username, password):
    driver = webdriver.Chrome()
    driver.get('http://nmg-compass.baidu.com:8081/index')
    assert &quot;INF DC COMPASS&quot; in driver.title 
    login_link = driver.find_element_by_id(&quot;login-submit&quot;)
    ActionChains(driver).move_to_element(login_link).click().perform()
    login_name = WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located((By.ID, &quot;username&quot;))
    )
    login_password = driver.find_element_by_id(&quot;password&quot;)
    login_name.send_keys(username)
    login_password.send_keys(password)
    login_button = driver.find_element_by_id(&quot;login-submit&quot;)
    login_button.click()
    
    url = 'http://nmg-compass.baidu.com:8081/history?page=1&amp;size=5000&amp;advfilter=true&amp;projcontain=image&amp;flowcontain=&amp;usercontain=&amp;status=0&amp;begin=07/20/2018 12:00 AM&amp;end=07/21/2018 12:00 AM'
    driver.get(url)
    driver.refresh() # 有时候 get 不出来，要 刷新一下
    locator = (&quot;id&quot;, &quot;next&quot;)
    WebDriverWait(driver, 10).until(    
        EC.text_to_be_present_in_element(locator, &quot;Next&quot;)
    )

    html = driver.page_source
    if 'Next' not in html: 
        print &quot;采集的网页有问题&quot;
        html = ''
      
    driver.close()
    
    return html

if __name__ == '__main__':
    WeiBoAccounts = [
            {'username': 'ws949178872@hotmail.com', 'password': 'xxxxxx'}
            ]
    username = WeiBoAccounts[0].get('username')
    password = WeiBoAccounts[0].get('password')
    print(get_cookie_from_weibo(username, password))

</code></pre>
<h2 id="经验总结-2"><a class="header" href="#经验总结-2">经验总结</a></h2>
<ol>
<li>
<p>beautifulsoap 也可以解析xml文件</p>
</li>
<li>
<p>如果不是对效率要求特别高,可以不需要进行断点存储或爬取,只需要继续从当天开始爬取,然后去重即可.</p>
</li>
<li>
<p>HTTP Error 403: Forbidden  是被服务器拒绝访问的异常,
一旦一个账号被forbidden了,那么该账号就已经被列入了黑名单,成为了重点检测的对象.</p>
</li>
<li>
<p>爬虫的代码设计过程充满了随机性，有些错误是不可控的，只能在bug出现的时候去及时修复bug</p>
</li>
<li>
<p>爬取数据的时候,最好不要开启vpn,否则会出现意想不到的错误,例如爬取速度非常慢</p>
</li>
<li>
<p>Common Crawl 是一个非盈利的组织，他们爬取网站的数据并免费共享出去</p>
</li>
<li>
<p>简单的页面内容解析用正则表达式足矣，复杂而且有规律的内容，才用到 bs 或者 xpath</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hexo-theme"><a class="header" href="#hexo-theme">Hexo Theme</a></h1>
<p>[TOC]</p>
<h2 id="开发步骤"><a class="header" href="#开发步骤">开发步骤</a></h2>
<p><a href="https://github.com/hexojs/awesome-hexo">awesome-hexo</a></p>
<ol>
<li>
<p>找到标准的 学术主题 简历模板</p>
<p>参考：</p>
<p>https://nlp.stanford.edu/people/</p>
<p>https://cs.stanford.edu/~danqi/</p>
<p>http://parnec.nuaa.edu.cn/huangsj/</p>
<p>http://lotabout.me/hexo-theme-noise/</p>
</li>
<li>
<p>主题制作教程</p>
<p>https://segmentfault.com/a/1190000008040387</p>
<p>https://molunerfinn.com/make-a-hexo-theme/#%E5%89%8D%E8%A8%80</p>
<p>http://chensd.com/2016-06/hexo-theme-guide.html</p>
<p>http://theme-next.iissnan.com/faqs.html</p>
</li>
<li>
<p>模仿的主题</p>
<p>https://github.com/ahonn/theme-example</p>
</li>
<li>
<p>辅助工具</p>
<p>https://blog.cofess.com/2017/08/16/comon-plug-in-and-usage-of-hexo-blog.html</p>
</li>
</ol>
<h2 id="技术栈-3"><a class="header" href="#技术栈-3">技术栈</a></h2>
<h3 id="ejs"><a class="header" href="#ejs">ejs</a></h3>
<p>https://ejs.bootcss.com/</p>
<p>&quot;E&quot; 代表 &quot;effective&quot;，即【高效】。EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。 实际上是一种嵌入 html 的 JavaScript 扩展动态语言。</p>
<p>代码格式：</p>
<pre><code>&lt;%= EJS %&gt;
</code></pre>
<h3 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h3>
<h2 id="hexo-cmd"><a class="header" href="#hexo-cmd">Hexo CMD</a></h2>
<table><thead><tr><th>CMD</th><th>Explanation</th></tr></thead><tbody>
<tr><td>hexo server --debug</td><td>开发中的 debug 调试模式</td></tr>
<tr><td>hexo new &quot;&quot;</td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h2 id="开发教程"><a class="header" href="#开发教程">开发教程</a></h2>
<h3 id="代码框架生成器"><a class="header" href="#代码框架生成器">代码框架生成器</a></h3>
<p>https://github.com/tcrowe/generator-hexo-theme</p>
<h3 id="永久链接"><a class="header" href="#永久链接">永久链接</a></h3>
<p>https://hexo.io/zh-cn/docs/permalinks.html</p>
<p>用于格式化网站的链接。编辑 hexo 文件夹下的 permalink 选项，即可更改网站的链接格式。</p>
<h3 id="新建主题"><a class="header" href="#新建主题">新建主题</a></h3>
<p>https://hexo.io/zh-cn/docs/themes</p>
<pre><code>.
├── _config.yml 该主题的配置文件
├── languages	配置语言，用于国际化
├── layout		存放模板文件，hexo 根据模板文件的扩展名来决定所使用的模板引擎
├── scripts		在启动时，Hexo 会载入此文件夹内的 JavaScript 文件
└── source
</code></pre>
<h3 id="辅助函数"><a class="header" href="#辅助函数">辅助函数</a></h3>
<table><thead><tr><th>Func</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>&lt;%= __('index.title') %&gt;</code></td><td>__() 国际化函数</td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<h3 id="模板"><a class="header" href="#模板">模板</a></h3>
<p><strong>hexo 支持的模板引擎</strong></p>
<p>EJS / Jade / Swig，选用 EJS</p>
<p><strong>hexo 支持的 css 预处理器</strong></p>
<p>SASS / LESS / Stylus，选用 Stylus</p>
<p><strong>六大基础模板</strong></p>
<table><thead><tr><th>Template</th><th>Fallback</th><th>Page Description</th></tr></thead><tbody>
<tr><td><code>index</code></td><td>None</td><td>This the home page of the blog, the main entry point. In our case it will display a list of blog excerpts.</td></tr>
<tr><td><code>post</code></td><td><code>index</code></td><td>This is the detail page for posts. Here we will display only one post in full, with a comment section.</td></tr>
<tr><td><code>page</code></td><td><code>index</code></td><td>This is the detail page for pages. Same as post but for ‘page type’ posts.</td></tr>
<tr><td><code>archive</code></td><td><code>index</code></td><td>This is the archive page. It will display a list of all the posts in our blog with just titles and links to the detail page.</td></tr>
<tr><td><code>category</code></td><td><code>archive</code></td><td>This is the category page. Similar to the archive page but filtered for one category.</td></tr>
<tr><td><code>tag</code></td><td><code>archive</code></td><td>This is the tag page. Similar to the archive page page but filtered for one tag.</td></tr>
</tbody></table>
<p><strong>Common layout</strong></p>
<p>每一个模板都会去渲染这个 layout，layout中包含了通用的 header, footer, menu, sidebar 等元素。</p>
<p><code>layout.ejs</code></p>
<p><strong>_partial</strong></p>
<p>_partial 文件夹中存放着可以被各个模板复用的 模块。其调用语法为：</p>
<p><code>partial('path' [, arguments]) </code></p>
<h3 id="ejs-1"><a class="header" href="#ejs-1">EJS</a></h3>
<p>https://ejs.bootcss.com/</p>
<h3 id="stylus"><a class="header" href="#stylus">Stylus</a></h3>
<p>http://stylus-lang.com/</p>
<h2 id="调试工具"><a class="header" href="#调试工具">调试工具</a></h2>
<ol>
<li>
<p>hexo-browsersync</p>
<p>https://github.com/hexojs/hexo-browsersync</p>
<p>能够在你修改了主题文件的时候自动帮你刷新浏览器，省去刷新的动作。</p>
</li>
</ol>
<h2 id="调试问题"><a class="header" href="#调试问题">调试问题</a></h2>
<ol>
<li>
<p>之前写好的主题，样式出错</p>
<p>尝试 <code>hexo clean</code></p>
</li>
</ol>
<h2 id="to-do"><a class="header" href="#to-do">To Do</a></h2>
<ol>
<li>代码高亮</li>
<li>about 页面制作</li>
<li>文章标题下面加入标签 tags</li>
<li>汇总页面制作</li>
</ol>
<h2 id="hexo-theme-xoxo"><a class="header" href="#hexo-theme-xoxo">Hexo-Theme-xoxo</a></h2>
<p>由于时间有限，不能短时间内速成一个简约又不缺核心功能的主题，所以只能退而求其次，找一个自己满意的主题，然后修改。</p>
<p>主题地址：<a href="https://github.com/KevinOfNeu/hexo-theme-xoxo">Github Hexo-Theme-xoxo</a></p>
<p>主题Demo: https://blog.0xff000000.com/</p>
<p>注意：要实现 tags 和 search 两个功能，需要进行如下配置：</p>
<pre><code>step1:
	hexo new page tags
	
step2:
	编辑 /source/tags/index.md，增加 type
	---
    title: tags
    date: 2016-06-08 16:19:38
    type: &quot;tags&quot;
    ---

search 同理，只需要将 tags 改成 search
	
参考：https://github.com/iissnan/hexo-theme-next/issues/339
</code></pre>
<h2 id="hexo-theme-cactus"><a class="header" href="#hexo-theme-cactus">Hexo-Theme-Cactus</a></h2>
<p>https://github.com/wansho/hexo-theme-cactus</p>
<h2 id="搜索引擎seo"><a class="header" href="#搜索引擎seo">搜索引擎SEO</a></h2>
<p>https://hjptriplebee.github.io/hexo%E7%9A%84SEO%E6%96%B9%E6%B3%95.html/</p>
<h3 id="sitemap-生成"><a class="header" href="#sitemap-生成">sitemap 生成</a></h3>
<pre><code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save
</code></pre>
<h3 id="google-网站收录"><a class="header" href="#google-网站收录">Google 网站收录</a></h3>
<p>Google 站长工具：<a href="https://search.google.com/search-console?resource_id=http%3A%2F%2Fwansho.cn%2F">Google Search Consle</a></p>
<p>在 <code>&lt;head&gt;&lt;/head&gt;</code> 中加入 <code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;kbZW7brfuXT60agTnG6EdltkfF13JGQ55M4qOr_ZbA8&quot; /&gt;</code></p>
<h3 id="baidu-网站收录"><a class="header" href="#baidu-网站收录">Baidu 网站收录</a></h3>
<p>Baidu 站长工具：https://ziyuan.baidu.com/</p>
<p>同上加入：<code>&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;JDQZRxjUWp&quot; /&gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swagger-1"><a class="header" href="#swagger-1">Swagger</a></h1>
<h2 id="版本"><a class="header" href="#版本">版本</a></h2>
<p>主流的版本，是 swagger2.9.2，</p>
<p>Swagger 可以看作是一个遵循了 OpenAPI 规范的一项技术，而 springfox 则是这项技术的具体实现。</p>
<h2 id="springfox-swagger2"><a class="header" href="#springfox-swagger2">springfox-swagger2</a></h2>
<p>切换到 3.0.0 分支 git checkout 3.0.0</p>
<p>开发环境：</p>
<p>node 12.16.2</p>
<p>gradle 6.5</p>
<p>使用的中央仓库：jcenter，jcenter 已被启用</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="软件测试"><a class="header" href="#软件测试">软件测试</a></h1>
<p>[TOC]</p>
<h2 id="books-2"><a class="header" href="#books-2">Books</a></h2>
<ul>
<li><a href="https://book.douban.com/subject/1445661/">软件测试的艺术</a> 软件测试领域必读圣经</li>
<li><a href="https://book.douban.com/subject/25742200/">Google软件测试之道</a> </li>
</ul>
<h2 id="测试经验总结-1"><a class="header" href="#测试经验总结-1">测试经验总结</a></h2>
<p>熟练使用 postman，不要使用 chrome 进行 get 请求的测试，不可靠。</p>
<p>熟练使用 postman 的 environment 进行不同环境下相同服务的测试，例如本机环境下和线上环境的搜索服务的测试</p>
<h2 id="持续集成--自动化"><a class="header" href="#持续集成--自动化">持续集成 / 自动化</a></h2>
<p>Jenkins</p>
<p>使用 Jenkins 之前，首先要有一个自动化的需求</p>
<h2 id="jmeter"><a class="header" href="#jmeter">jmeter</a></h2>
<p>jmeter 运行在 Java 虚拟机中，是跨平台的</p>
<pre><code class="language-shell"># run
cd bin
./jmeter
</code></pre>
<p>Ramp-up Period（in seconds）：启动完所有线程所需时间。如果线程数是 500，ramp-up period 是 1 秒，那么就是 1 秒并发 500 次。如果想要 1 秒并发 100 次，则线程数设置为 100，ramp-up period 设置成 1。</p>
<h2 id="测试开放性问题"><a class="header" href="#测试开放性问题">测试开放性问题</a></h2>
<ul>
<li>
<p>某城市部分移动用户反馈无法刷新今日头条的信息流， 并且总是提示网络错误。 可能是什么原因导致的？</p>
<p>可以从用户和公司两个角度来解答：</p>
<p>用户: 用户手机欠费，用户所在地区网络不好，用户手机没有联网</p>
<p>公司：服务该地区的机房出现问题，大概率是上线导致的问题</p>
</li>
<li>
<p>如何测试一个消息系统，这个消息系统包含了：今日头条的评论消息、点赞消息、关注提醒、头条号提醒、问答邀请和系统消息（比如头条活动）</p>
<p>Kafka</p>
</li>
</ul>
<h2 id="jenkins--springboot--docker--github"><a class="header" href="#jenkins--springboot--docker--github">Jenkins + SpringBoot + Docker + GitHub</a></h2>
<p>https://zhuanlan.zhihu.com/p/78396471</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uml"><a class="header" href="#uml">UML</a></h1>
<p>Unified Modeling Language</p>
<p><img src="computer-science-notebook/software-engineering/assets/image-20221010150813165.png" alt="image-20221010150813165" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h1>
<h2 id="基本流程"><a class="header" href="#基本流程">基本流程</a></h2>
<ul>
<li>git push</li>
<li>gitlab wekhook</li>
<li>jenkins 拉取 gitlab 代码</li>
<li>jenkins 编译代码生成 jar 包</li>
<li>jenkins 上传 jar 包到服务器</li>
<li>jenkins 重启 jar 包</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-version"><a class="header" href="#software-version">Software Version</a></h1>
<p>[TOC]</p>
<h2 id="参考文献-3"><a class="header" href="#参考文献-3">参考文献</a></h2>
<p><a href="https://www.python.org/dev/peps/pep-0440/">[Python PEP-440]</a> | <a href="https://en.wikipedia.org/wiki/Software_versioning">[Wiki-Software_versioning]</a> | <a href="https://semver.org/lang/zh-CN/">[Github  Semantic Versioning]</a> | <a href="https://www.zhihu.com/question/20289602/answer/20068112">[知乎介绍]</a></p>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<ul>
<li>修复 bug：增加修订号</li>
<li>增加新功能：增加次版本号</li>
<li>进行不兼容的修改：增加主版本号</li>
</ul>
<h2 id="github-sematic-versioning"><a class="header" href="#github-sematic-versioning">Github Sematic Versioning</a></h2>
<p>考虑使用这样的版本号格式：</p>
<p><strong>X.Y.Z （主版本号.次版本号.修订号）</strong></p>
<p>修复问题但不影响API 时，递增修订号 (<strong>修复了一个 bug</strong>)；</p>
<p>API 保持向下兼容的新增及修改时，递增次版本号 (<strong>增加了新功能</strong>)；</p>
<p>进行不向下兼容的修改时，递增主版本号 (<strong>例如 Python2 —&gt; Python3</strong>)。</p>
<h2 id="语义化版本控制规范semver"><a class="header" href="#语义化版本控制规范semver">语义化版本控制规范（SemVer）</a></h2>
<p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）</p>
<ol>
<li></li>
</ol>
<p>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</p>
<ol start="2">
<li></li>
</ol>
<p>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</p>
<ol start="3">
<li></li>
</ol>
<p>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。</p>
<ol start="4">
<li></li>
</ol>
<p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</p>
<ol start="5">
<li></li>
</ol>
<p>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</p>
<ol start="6">
<li></li>
</ol>
<p>修订号 Z（x.y.Z <code>|</code> x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</p>
<ol start="7">
<li></li>
</ol>
<p>次版本号 Y（x.Y.z <code>|</code> x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</p>
<ol start="8">
<li></li>
</ol>
<p>主版本号 X（X.y.z <code>|</code> X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</p>
<ol start="9">
<li></li>
</ol>
<p>先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</p>
<ol start="10">
<li></li>
</ol>
<pre><code>版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
</code></pre>
<ol start="11">
<li></li>
</ol>
<pre><code>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。
</code></pre>
<h2 id="为什么要使用语义化的版本控制"><a class="header" href="#为什么要使用语义化的版本控制">为什么要使用语义化的版本控制？</a></h2>
<p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p>
<p>举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。</p>
<p>作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。</p>
<p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="在-0yz-初始开发阶段我该如何进行版本控制"><a class="header" href="#在-0yz-初始开发阶段我该如何进行版本控制">在 0.y.z 初始开发阶段，我该如何进行版本控制？</a></h3>
<p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p>
<h3 id="如何判断发布-100-版本的时机"><a class="header" href="#如何判断发布-100-版本的时机">如何判断发布 1.0.0 版本的时机？</a></h3>
<p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p>
<h3 id="这不会阻碍快速开发和迭代吗"><a class="header" href="#这不会阻碍快速开发和迭代吗">这不会阻碍快速开发和迭代吗？</a></h3>
<p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p>
<h3 id="对于公共-api若即使是最小但不向下兼容的改变都需要产生新的主版本号岂不是很快就达到-4200-版"><a class="header" href="#对于公共-api若即使是最小但不向下兼容的改变都需要产生新的主版本号岂不是很快就达到-4200-版">对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</a></h3>
<p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p>
<h3 id="为整个公共-api-写文件太费事了"><a class="header" href="#为整个公共-api-写文件太费事了">为整个公共 API 写文件太费事了！</a></h3>
<p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p>
<h3 id="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办"><a class="header" href="#万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办">万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</a></h3>
<p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p>
<h3 id="如果我更新了自己的依赖但没有改变公共-api-该怎么办"><a class="header" href="#如果我更新了自己的依赖但没有改变公共-api-该怎么办">如果我更新了自己的依赖但没有改变公共 API 该怎么办？</a></h3>
<p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p>
<h3 id="如果我变更了公共-api-但无意中未遵循版本号的改动怎么办呢意即在修订等级的发布中误将重大且不兼容的改变加到代码之中"><a class="header" href="#如果我变更了公共-api-但无意中未遵循版本号的改动怎么办呢意即在修订等级的发布中误将重大且不兼容的改变加到代码之中">如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</a></h3>
<p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p>
<h3 id="我该如何处理即将弃用的功能"><a class="header" href="#我该如何处理即将弃用的功能">我该如何处理即将弃用的功能？</a></h3>
<p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p>
<h3 id="语义化版本对于版本的字串长度是否有限制呢"><a class="header" href="#语义化版本对于版本的字串长度是否有限制呢">语义化版本对于版本的字串长度是否有限制呢？</a></h3>
<p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="禅道"><a class="header" href="#禅道">禅道</a></h1>
<p>[TOC]</p>
<p>官方文档 https://www.zentao.net/book/zentaopmshelp/40.html</p>
<h2 id="简介-3"><a class="header" href="#简介-3">简介</a></h2>
<p>禅道在设计的时候，基础框架是基于 scrum 的，同时又补充完善了测试，文档，发布，计划等功能。</p>
<p>核心的三种角色：产品经理、研发团队和测试团队。</p>
<p>新手教程包含8个任务：创建帐号、创建产品、创建需求、创建项目、管理团队、关联需求、分解任务、提Bug。</p>
<p>在【用户名】—&gt; 【帮助】—&gt;【新手教程】下面有一个新手教程，入门靠这个就可以了。</p>
<h2 id="scrum-敏捷开发流程"><a class="header" href="#scrum-敏捷开发流程">Scrum 敏捷开发流程</a></h2>
<p>介绍：https://zhuanlan.zhihu.com/p/49048186</p>
<ol>
<li>产品经理提需求 List</li>
<li>需求 List 转为开发 List（开发 List 为优先级 List）</li>
<li>小组分配任务</li>
<li>每天站会讨论</li>
<li>阶段会议展示成果</li>
</ol>
<h2 id="功能-1"><a class="header" href="#功能-1">功能</a></h2>
<ol>
<li>
<p>产品经理创建产品</p>
</li>
<li>
<p>产品经理创建需求</p>
</li>
<li>
<p>项目经理创建项目</p>
</li>
<li>
<p>项目经理确定项目要做的需求</p>
</li>
<li>
<p>项目经理分解任务，指派到人。</p>
</li>
<li>
<p>测试人员测试，提交bug。</p>
</li>
</ol>
<h3 id="项目管理-2"><a class="header" href="#项目管理-2">项目管理</a></h3>
<ol>
<li>创建项目</li>
<li>绑定团队</li>
<li>分解创建任务（故事）</li>
<li>管理任务</li>
</ol>
<h3 id="bug-管理"><a class="header" href="#bug-管理">Bug 管理</a></h3>
<p>大家可以通过这个平台互相提 bug。</p>
<ol>
<li>
<p>创建产品（Bug 附属在产品概念）</p>
</li>
<li>
<p>提 Bug</p>
</li>
<li>
<p>处理 Bug</p>
</li>
</ol>
<h3 id="冲刺"><a class="header" href="#冲刺">冲刺</a></h3>
<p>冲刺就是设置 ddl</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件工程"><a class="header" href="#软件工程">软件工程</a></h1>
<p>[TOC]</p>
<h2 id="软件开发模式"><a class="header" href="#软件开发模式">软件开发模式</a></h2>
<p>敏捷开发：小步快跑</p>
<p>瀑布流开发：需求分析 —&gt; 设计 —&gt; 开发 —&gt; 测试（每一个步骤以前一个步骤为前提）</p>
<p><img src="computer-science-notebook/software-engineering/assets/image-20220223141212890.png" alt="image-20220223141212890" /></p>
<h2 id="思想定律"><a class="header" href="#思想定律">思想定律</a></h2>
<ul>
<li>
<p>康威定律</p>
<p>设计系统的架构受制于产生这些设计的组织的沟通结构。</p>
<p>比如公司内有两个独立的小组，那整个系统设计肯定会划分出两个独立的模块，相互之间有明确的界限。</p>
</li>
<li>
<p>计科：<em>abstraction</em> </p>
<p>数学：<em>formalization</em> </p>
<p>设计：<em>design is how it works</em> </p>
<p>软工：<em>indirection - &quot;All problems in computer science can be solved by another level of indirection&quot;</em></p>
</li>
<li></li>
</ul>
<h2 id="人月神话"><a class="header" href="#人月神话">人月神话</a></h2>
<p>《人月神话》</p>
<p>所有软件活动包括：
根本任务 -- 打造构成抽象软件实体的复杂概念结构。
次要任务 -- 使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言。</p>
<p>举个例子，比如要实现一款发工资的软件，里面涉及到如何计算所得税，那就得实现个人所得税的计算方法，用什么语言实现这个算法属于「次要任务」，而这个算法本身属于「根本任务」，无论用什么方式实现，你都不可能降低这个算法复杂度，比如个人所得税有 7 个层级，那就一定在某个地方有 7 个 if 语句。</p>
<p>低代码平台主要解决的是「次要任务」，用更简化的方式来实现同样的功能。</p>
<h2 id="架构"><a class="header" href="#架构">架构</a></h2>
<ul>
<li>
<p>web 接口的设计模式</p>
<ul>
<li><strong>强类型模式</strong>：强类型模式指的是查询接口返回的是POJO对象，每一个查询结果对应POJO中的一个明确的具有特定业务含义的字段。</li>
<li><strong>弱类型模式</strong>：弱类型模式指的是查询结果以K-V或JSON模式返回，没有明确的静态字段。例如 GraphQL</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用软件整理"><a class="header" href="#常用软件整理">常用软件整理</a></h1>
<p>[TOC]</p>
<h2 id="软件开发"><a class="header" href="#软件开发">软件开发</a></h2>
<table><thead><tr><th>软件名</th><th>Windows</th><th>macOS</th><th>备注</th></tr></thead><tbody>
<tr><td>jdk</td><td></td><td>zulu arm jdk</td><td>环境变量配置</td></tr>
<tr><td>maven</td><td></td><td></td><td></td></tr>
<tr><td>git</td><td></td><td></td><td>配置 GitHub 账户密码</td></tr>
<tr><td>sourceTree</td><td></td><td></td><td></td></tr>
<tr><td>python</td><td></td><td></td><td></td></tr>
<tr><td>nodejs</td><td></td><td></td><td></td></tr>
<tr><td>IDEA</td><td></td><td></td><td>配置同步</td></tr>
<tr><td>PyCharm</td><td></td><td></td><td>配置同步</td></tr>
<tr><td>VSCode</td><td></td><td></td><td>配置同步</td></tr>
<tr><td>Notepad++</td><td></td><td>CotEditor / VSCode</td><td></td></tr>
<tr><td>Terminal</td><td>Windows Terminal</td><td>iTerm + oh-my-zsh</td><td></td></tr>
<tr><td>ssh</td><td>MobaXterm</td><td>shuttle</td><td></td></tr>
<tr><td>包管理</td><td></td><td>homebrew</td><td></td></tr>
<tr><td>Typora</td><td></td><td></td><td>github 主题，1.0 版本以下</td></tr>
<tr><td>Clash</td><td></td><td></td><td>tangtang.win</td></tr>
<tr><td>Docker</td><td></td><td></td><td></td></tr>
<tr><td>DBeaver</td><td></td><td></td><td></td></tr>
<tr><td>Go</td><td></td><td></td><td></td></tr>
<tr><td>PostMan</td><td></td><td></td><td></td></tr>
<tr><td>MySQL</td><td></td><td>docker 安装</td><td></td></tr>
<tr><td>开发文档</td><td></td><td>dash</td><td></td></tr>
</tbody></table>
<h2 id="chrome-浏览器"><a class="header" href="#chrome-浏览器">Chrome 浏览器</a></h2>
<p>账户同步</p>
<p>油猴脚本：</p>
<table><thead><tr><th>功能</th><th>备注</th></tr></thead><tbody>
<tr><td>百度 / Google 搜索结果美化</td><td></td></tr>
<tr><td>CSDN 广告屏蔽</td><td></td></tr>
<tr><td>百度网盘直链下载</td><td></td></tr>
</tbody></table>
<h2 id="办公--系统工具"><a class="header" href="#办公--系统工具">办公 / 系统工具</a></h2>
<table><thead><tr><th>软件名</th><th>Windows</th><th>macOS</th><th>备注</th></tr></thead><tbody>
<tr><td>压缩解压缩</td><td>bandzip</td><td>keka</td><td></td></tr>
<tr><td>Office</td><td></td><td></td><td></td></tr>
<tr><td>视频播放</td><td>potplayer</td><td>IINA</td><td></td></tr>
<tr><td>搜索</td><td>everything</td><td>locate / Alfred</td><td></td></tr>
<tr><td>输入法</td><td>Windows 自带</td><td>手心输入法 / 自带输入法</td><td></td></tr>
<tr><td>pdf 阅读器</td><td>福昕阅读器</td><td>pdf export / 福昕阅读器</td><td></td></tr>
<tr><td>截图工具 Snipaste</td><td></td><td></td><td></td></tr>
<tr><td>下载器</td><td>IDM</td><td>Motrix</td><td></td></tr>
<tr><td>视频下载器</td><td>IDM</td><td>Downie 4</td><td></td></tr>
<tr><td>百度网盘</td><td></td><td></td><td></td></tr>
<tr><td>微信 / QQ / 钉钉</td><td></td><td></td><td></td></tr>
<tr><td>坚果云</td><td></td><td></td><td></td></tr>
<tr><td>腾讯会议</td><td></td><td></td><td></td></tr>
<tr><td>向日葵</td><td></td><td></td><td></td></tr>
<tr><td>系统管家</td><td>火绒</td><td>lemon</td><td></td></tr>
<tr><td>录屏 gif 工具</td><td>screenToGif</td><td>Kap</td><td></td></tr>
<tr><td>视频格式转换</td><td></td><td>HandBrake</td><td></td></tr>
</tbody></table>
<h2 id="创作"><a class="header" href="#创作">创作</a></h2>
<table><thead><tr><th>软件名</th><th>Windows</th><th>macOS</th><th>备注</th></tr></thead><tbody>
<tr><td>OBSStudio</td><td></td><td></td><td></td></tr>
<tr><td>bilibili 直播姬</td><td></td><td></td><td></td></tr>
<tr><td>bilibili 投稿工具</td><td></td><td></td><td></td></tr>
<tr><td>视频格式转换</td><td></td><td>handbrake</td><td></td></tr>
<tr><td>视频剪辑</td><td></td><td>iMovie</td><td></td></tr>
</tbody></table>
<h2 id="娱乐-放松"><a class="header" href="#娱乐-放松">娱乐 放松</a></h2>
<table><thead><tr><th>软件名</th><th>Windows</th><th>macOS</th><th>备注</th></tr></thead><tbody>
<tr><td>网易云音乐</td><td></td><td></td><td></td></tr>
<tr><td>QQ 音乐</td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<p>https://github.com/jaywcjlove/awesome-mac</p>
<h3 id="todo-1"><a class="header" href="#todo-1">todo</a></h3>
<p>深入学习</p>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Alfred</p>
<p>增加浏览器历史记录搜索</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Shuttle</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>iTerm </p>
</li>
</ul>
<h3 id="快捷键--触摸板操作"><a class="header" href="#快捷键--触摸板操作">快捷键 / 触摸板操作</a></h3>
<pre><code># 全屏
fn + f (fullscreen)
# 锁屏
电源键
# 关闭当前窗口
command + w
# 退出当前应用
command + q
# 把应用从一个屏幕移到另一个屏幕
退出全屏幕 -&gt; 悬停全屏按钮 -&gt; 移到另一个屏幕
# 显示隐藏的文件
command + shift + .
# 在相同应用的不同实例之间切换
command + `
# 三指拖动选中
三个手指选中，然后左右一根手指拖动
# 最小化
command + m

# chrome
# 打开一个 tab
command + t (tab)
# 关闭一个 tab
command + w
# 刷新
command + r (refresh)

# 输入表情包
ctrl + command + space

# 反撤销
shift + command + z

# Chrome 强制刷新
shift + command + R
</code></pre>
<h3 id="alfred"><a class="header" href="#alfred">Alfred</a></h3>
<p>Alfred 就是定义一些命令</p>
<pre><code># 搜索文件或者文件夹
space + xxx 或者 open + xxx

# 配置了百度搜索
dd xxx

# command + 回车
打开文件所在文件夹而不是打开文件
</code></pre>
<h3 id="iterm"><a class="header" href="#iterm">iTerm</a></h3>
<p>横竖向分屏：command + D，command + D + shift</p>
<p><a href="https://www.cyberciti.biz/faq/apple-osx-mountain-lion-mavericks-install-xquartz-server/">iTerm 实现 ssh X11 forwarding</a></p>
<h3 id="shuttle-穿梭"><a class="header" href="#shuttle-穿梭">shuttle 穿梭</a></h3>
<p>在 macOS 中穿梭</p>
<h3 id="autojump"><a class="header" href="#autojump">autojump</a></h3>
<p>和 shuttle 类似，autojump 可以在命令行中穿梭。</p>
<h3 id="经验总结-3"><a class="header" href="#经验总结-3">经验总结</a></h3>
<pre><code>* 配置 clash 运行规则，兼容内网
* 配置 oh-my-zsh 和 zsh
* 能够通过 nvm 安装各种版本的 nodejs
* 支持 Java 开发，Springboot 的一个项目，从 8 秒减少到 4 秒
</code></pre>
<h3 id="软件资源"><a class="header" href="#软件资源">软件资源</a></h3>
<p>https://macwk.com/</p>
<h3 id="docker-1"><a class="header" href="#docker-1">Docker</a></h3>
<p>docker 适合安装服务和中间件</p>
<ul>
<li>mysql</li>
<li>redis</li>
<li>nginx</li>
</ul>
<h3 id="特有软件"><a class="header" href="#特有软件">特有软件</a></h3>
<table><thead><tr><th>软件</th><th>功能</th><th>备注</th></tr></thead><tbody>
<tr><td>homebrew</td><td>用 homebrew 安装各种程序</td><td></td></tr>
<tr><td>Easy New File</td><td>集成到Finder的插件，可以在finder的任意位置点击鼠标右键，新建文件夹、txt、word、xsl、ppt、markdown、html等格式文件</td><td></td></tr>
<tr><td>Go2Shell</td><td>集成到finder中的插件，在finder的任意路径下，点击该图标都可以快速的打开terminal，且将terminal的路径自动前进到该文件夹路径下</td><td></td></tr>
<tr><td>iStat</td><td>资源监控</td><td></td></tr>
<tr><td>Itsycal</td><td>日历软件</td><td></td></tr>
<tr><td>Alfred 4</td><td>全自动效率神器</td><td></td></tr>
<tr><td>PopClip</td><td>划词搜索</td><td>70 块钱</td></tr>
<tr><td>Moom</td><td>屏幕分屏</td><td>60 块钱</td></tr>
<tr><td>mouse catch</td><td>多个屏幕间快速移动鼠标</td><td></td></tr>
<tr><td><a href="https://pilotmoon.com/scrollreverser/">Scroll Reverser</a></td><td>插上鼠标后，滚轮自然切换</td><td></td></tr>
</tbody></table>
<h3 id="公司软件兼容"><a class="header" href="#公司软件兼容">公司软件兼容</a></h3>
<table><thead><tr><th>软件</th><th>是否兼容</th></tr></thead><tbody>
<tr><td>VPN easyvpn</td><td>兼容</td></tr>
<tr><td>VDrive</td><td></td></tr>
<tr><td>连接内网</td><td>兼容</td></tr>
</tbody></table>
<h3 id="文件目录规划"><a class="header" href="#文件目录规划">文件目录规划</a></h3>
<pre><code>softwares
code
	demo
		springboot/
		
nr-code
doc
	nr
	mydoc
docker
	config
	data
	
</code></pre>
<h3 id="homebrew"><a class="header" href="#homebrew">homebrew</a></h3>
<pre><code class="language-bash"># 安装带有界面的软件
brew install --cask firefox
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技术经验"><a class="header" href="#技术经验">技术经验</a></h1>
<p>[TOC]</p>
<p>想要学好一门编程语言：看源码 / 看书 + 实战模仿</p>
<h2 id="代码调试"><a class="header" href="#代码调试">代码调试</a></h2>
<p>不调试代码，不按 F10 或F11，水平永远也无法提上来，所以，要想学好一门编程语言，最好的办法就是多调试。</p>
<h2 id="工欲善其事必先利其器"><a class="header" href="#工欲善其事必先利其器">工欲善其事必先利其器</a></h2>
<ul>
<li><a href="https://help.github.com/en/github/developing-online-with-codespaces/about-codespaces">GitHub codespace</a> 在线编程 </li>
</ul>
<h2 id="经验总结-4"><a class="header" href="#经验总结-4">经验总结</a></h2>
<p><strong>学习技术，最重要的一点是打破自己心理上的障碍，走出对于新技术的恐惧，走出自己的舒适区。</strong></p>
<ul>
<li>看书一定要快看，因为实践才是重点，实践的时候，想到书上讲了可以这么做，然后去查书，看如何实践。不实践，就等于没看书。核心在于快看书，后实践。</li>
<li>more thinking, less coding.</li>
<li>多看书，stay hungry，stay foolish。多思考。看书还要思考！</li>
<li>有理想，有追求！自由精神，独立思想。Don't Follow。 对完美的不懈追求。我们是为了改变世界，而不是单纯的学技术。</li>
<li>基础乃治学之本，多学基础知识，不要把主要精力放在新技术上</li>
<li>每天把学习到的知识，用思维导图的方式进行总结，可以有效的复习知识点，<strong>思维导图</strong> 有利于知识体系的构建</li>
</ul>
<p><strong>技术问题归根结底还是数学问题</strong></p>
<ul>
<li>将一个实际问题抽象成数学问题的能力，然后用数学的做题思维来解决</li>
<li>没有什么代码是读不懂的，只要头脑清晰，一段代码一段代码地看下去，总能看懂的</li>
<li>没有什么开发问题(正常的开发问题)是解决不了的，因为其本质上还是一个数学的计算问题，都可以抽象成一个一个小步骤，慢慢解决</li>
<li>在编程的世界中，最重要的便是<strong>抽象能力</strong></li>
</ul>
<h2 id="如何学习技术"><a class="header" href="#如何学习技术">如何学习技术</a></h2>
<p>Google: 大量的英文资料</p>
<p>官网：第一手的资料</p>
<p>官网的 Tutorial：最佳入门资料</p>
<p>wiki：快速了解</p>
<p>知乎，百度：中文的资料</p>
<p>经典书籍：</p>
<p>遇到问题：去 Google 搜索英文资料，英文资料有更好的沉淀</p>
<h2 id="代码规范-和-编程思想"><a class="header" href="#代码规范-和-编程思想">代码规范 和 编程思想</a></h2>
<h3 id="dry-原则"><a class="header" href="#dry-原则">DRY 原则</a></h3>
<p>DRY</p>
<h3 id="二八定律"><a class="header" href="#二八定律">二八定律</a></h3>
<p>80% 的时间用来思考，20% 的时间用来编码</p>
<h3 id="写代码前-git"><a class="header" href="#写代码前-git">写代码前 Git?</a></h3>
<pre><code>1. 是否需要建立仓库？建仓库
2. 是否需要切换分支？切换分支
3. 是否需要另起一个分支？新建分支
4. 是否有研发记录文档？
</code></pre>
<h3 id="写完代码后"><a class="header" href="#写完代码后">写完代码后</a></h3>
<pre><code>1. 写文档总结一下遇到的 bug，以后再遇到的话可以快速定位，DRY 原则
2. 是否需要测试？写一份测试文档
</code></pre>
<h3 id="代码测试"><a class="header" href="#代码测试">代码测试</a></h3>
<p>代码测试是代码编辑的相当重要的环节。</p>
<ol>
<li>每一个模块，每一个 if 分支都要测试，代码运行正常并不代表没有 bug，可能只是没有遇到触发 bug 的情景。</li>
<li>代码测试的时间甚至可能比代码编写的时间还要多</li>
<li>写代码的时候 think more，测试的时候 bug less</li>
<li>测试的以后 think more，后期的 bug less</li>
</ol>
<h3 id="编程思想和编程原则"><a class="header" href="#编程思想和编程原则">编程思想和编程原则</a></h3>
<p>程序员修炼之道</p>
<pre><code>* 代码是写给人看的，不是写给机器看的！
* 先思考！先理清思路和需求！再编码！这是最重要的！！！
* 不要浅层思考，不要意识流
* 考虑可扩展性，需求改了后会不会改变
* 冗余的代码很难维护，因为改了一个地方，可能第二个地方也要修改，但是你不知道
* 代码要后期可维护，具有适量的注释，高内聚，低耦合
* 代码要有可读性
* 修改代码或变量的时候要注意与其相关的会不会受牵连，如果受牵连，怎么解耦
* 会产生异常的地方一定不能忽视，前面留下的问题，以后要花更多的时间解决
* 注意不要硬编码
* Dry 原则
    不要出现重复的代码，SQL语句等

* 程序的运行要遵循一条主线的原则，在一条主线上加入分支，不要多条主线，灵活运用 break，continue
* 墨菲定律：觉得会出问题的地方，一定会出问题！！！（不要容忍破窗户，要严谨编码）
* 一条需求、一项任务，如果能够用语言将其描述，那么代码实现起来应该也不会太难。
* 软件开发规律和人的直觉是相反的。
* Think more ——&gt; code less
* 编码在整个项目中一般只占 10% 左右的时间， 50 % 的时间用于沟通
* 编码之前一定要严格要求自己，建立好的品味
* 一个系统工程师的培养需要至少 8 - 10 年的时间
* 各个模块一定要正交！！！函数、模块、类的正交
* 函数一定要短小：在一屏内完成，适合解耦。写好函数的秘诀：将函数写的短小！！

* 代码是一种表达方式，代码是写给人看的！可读性最重要！代码是写给人看的！代码是写给人看的！代码是写给人看的！
* 多用声明式编程，少用命令式编程，声明式编程的Demo：注解，Stream 编程
</code></pre>
<h3 id="代码优化原则"><a class="header" href="#代码优化原则">代码优化原则</a></h3>
<pre><code>* 找到可以优化的地方
找细节
找循环（重复的地方）

* 还要考虑的地方
减少访问文件的次数
减少访问数据库的次数
减少请求网络的次数

* 优化的玄学
代码质量与代码的整洁程度成正比。如果代码一眼望去，杂乱无章，没有阅读的欲望，那么多半代码的质量也很差。这就提供了一个直觉，如果代码看起来“很丑”，那么多半需要优化了。
</code></pre>
<h3 id="可读性"><a class="header" href="#可读性">可读性</a></h3>
<pre><code>* 尽量不要有三层以上的代码缩进
* 命名不能随意，否则后面代码维护的时候自己都看不懂，代码的可读性和可维护性很重要！
</code></pre>
<h3 id="if-语句避免嵌套过多的技巧"><a class="header" href="#if-语句避免嵌套过多的技巧">if 语句避免嵌套过多的技巧</a></h3>
<pre><code>1. 德摩根律
    非(p 且 q) == 非p 或 非 q
    非(p 或 q) == 非p 且 非 q

2. 先对一些特殊条件进行处理，及时 return，主线原则
</code></pre>
<h3 id="命名"><a class="header" href="#命名">命名</a></h3>
<pre><code>* 一个好的命名可以免去了写注释的麻烦，多思考，少重复
* 命名一定不能随意，否则程序可读性非常差，后面可能自己都读不懂。
* 匈牙利命名法：把变量的『类型』缩写，放到变量名的最前面，我写 Java 的时候，通常放在后面
</code></pre>
<h3 id="后期修改-bug修改代码的原则维护的原则"><a class="header" href="#后期修改-bug修改代码的原则维护的原则">后期修改 bug，修改代码的原则，维护的原则</a></h3>
<pre><code>* 修改后一定要想一想修改会不会引起新的变动。会不会导致之前写的代码不能用，出 bug。
* 修改完 Bug 一定要写文档记录一下，否则后面可能还会重复之前的劳动
</code></pre>
<h3 id="注释-1"><a class="header" href="#注释-1">注释</a></h3>
<pre><code>* 加注释最好在上一行加，不要在行末加，否则会触发 diff 检查
* 复杂的逻辑，一定要加注释！
</code></pre>
<h3 id="布尔表达式少用取非的逻辑-"><a class="header" href="#布尔表达式少用取非的逻辑-">布尔表达式少用取非的逻辑 !</a></h3>
<p>在 bool 表达式前面取非，会导致代码的可读性变差</p>
<p>如何优化：</p>
<pre><code class="language-java">StringUtils.isNotEmpty();
StringUtils.isEmpty();
</code></pre>
<p>把取非得操作，也封装起来，增强代码可读性。</p>
<h3 id="日志"><a class="header" href="#日志">日志</a></h3>
<p>访问其他接口获取到的重要数据，可以直接打印到日志中，方便出错后 debug</p>
<h2 id="面向对象编程思想"><a class="header" href="#面向对象编程思想">面向对象编程思想</a></h2>
<ul>
<li>层与层之间面向接口进行编程，先定义接口，再进行实现</li>
</ul>
<h2 id="异常处理经验"><a class="header" href="#异常处理经验">异常处理经验</a></h2>
<ul>
<li>网络请求，通常都需要加异常的，这是佳哥提醒我的，也确实是一个基本的经验</li>
</ul>
<h2 id="其他经验"><a class="header" href="#其他经验">其他经验</a></h2>
<h3 id="json-2"><a class="header" href="#json-2">json</a></h3>
<p>json 的数据格式是 {}，不能直接存储 [ ]，json 就是一个对象，是一个 bean</p>
<pre><code class="language-json">{
    
}
</code></pre>
<h2 id="debug-经验"><a class="header" href="#debug-经验">Debug 经验</a></h2>
<p><strong>查看 log 日志的重要性</strong></p>
<p>遇到问题，先查看日志。</p>
<p>Debug 要考虑 有没有 log 文件可以分析，这是第一手资料</p>
<p>Debug 思路要清晰，不能慌</p>
<p><strong>解决方案</strong></p>
<ul>
<li>ODP 环境 和 数据库放在一台机器上</li>
<li>优化访问数据库的代码</li>
</ul>
<p><strong>经验总结</strong></p>
<ul>
<li>正常的语句运行，例如赋值，加减等操作，不会耗费很多时间，即使是在循环中，也不会耗费太多时间</li>
<li>访问数据库是一个很耗时的操作，如果数据库是远程数据库，那么很容易忽略数据的传输时间，而实际上，如果网速不好，或者开发机和数据库之间经过了多次路由，那么网络传输时间可能远远多于数据库的查询时间</li>
<li>再复杂的语句，只要元语句是简单语句，那么其运行耗时都可能是 ms 级的，如果运行耗时是 s 级别的，那么要考虑数据库效率问题 和 网络传输问题</li>
<li>Bug 总能解决的，决定Bug能否解决的因素，往往是一个人的态度，而不是这个人的专业素质，困难也是如此</li>
<li>网络采集模块出 bug 的概率比较高</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="computer-science-keep-learning"><a class="header" href="#computer-science-keep-learning">Computer Science Keep Learning</a></h1>
<p>[TOC]</p>
<h2 id="逛-github-的思考"><a class="header" href="#逛-github-的思考">逛 Github 的思考</a></h2>
<ul>
<li>能不能自己也做一个类似的东西</li>
<li>能不能发现项目中的问题，提交一些 bug</li>
</ul>
<h2 id="学习教程-1"><a class="header" href="#学习教程-1">学习教程</a></h2>
<ul>
<li>
<p>Github Action: <a href="https://devops.novalagung.com/en/cicd-serverless-ebook-gitbook-github-pages-actions-calibre.html">Serverless Ebook using Gitbook CLI, Github Pages, Github Actions CI/CD, and Calibre</a></p>
</li>
<li>
<p>最经典的线性代数入门课程：<a href="https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/index.htm">麻省理工</a></p>
</li>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/c_programming_language_textbooks.html">阮一峰-学习C语言的教材</a></p>
</li>
<li>
<p><a href="https://www.internalpointers.com/post/build-binary-deb-package-practical-guide">如何构建二进制 Deb 软件包</a></p>
</li>
<li>
<p><a href="https://zenodo.org/record/3707008">JavaScript 的前20年</a></p>
</li>
</ul>
<h2 id="笔记本触摸板手势操作"><a class="header" href="#笔记本触摸板手势操作">笔记本触摸板手势操作</a></h2>
<ul>
<li><strong>三指操作</strong>：左右移动切换应用，上下切换回到桌面或回到应用</li>
</ul>
<h2 id="技术名词"><a class="header" href="#技术名词">技术名词</a></h2>
<h3 id="图灵完备"><a class="header" href="#图灵完备">图灵完备</a></h3>
<p>图灵完备意味着你的语言可以做到能够用图灵机能做到的所有事情，可以解决所有的可计算问题。</p>
<h3 id="shadowsocks"><a class="header" href="#shadowsocks">Shadowsocks</a></h3>
<p><a href="https://github.com/JadaGates/ShadowsocksBio">Shadowsocks 笔记</a></p>
<p>SS 最先发布在 V2EX 社区，作者是 clowwindy。</p>
<p>Shadowsocks 不同于 VPN，SS 的一大特点是网络分流技术（部分代理），配置文件中的网站走代理通道，配置文件之外的地址全部走直连通道。</p>
<p>Shadowsocks 原理和 VPN 类似，其同样受限于服务器。</p>
<h3 id="uml-sequence-diagram"><a class="header" href="#uml-sequence-diagram">UML Sequence Diagram</a></h3>
<ul>
<li><strong>什么是 UML 时序图？</strong></li>
</ul>
<p><img src="computer-science-notebook/technology-lecture/assets/image-20191219212729263.png" alt="UML 时序图 Demo by ProcessOn" /></p>
<ul>
<li>
<p><strong>UML 时序图绘制教程</strong></p>
<ul>
<li><a href="https://www.lucidchart.com/pages/uml-sequence-diagram#top">UML Sequence Diagram Tutorial</a></li>
<li><a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-sequence-diagram/">What is Sequence Diagram?</a></li>
<li><a href="https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/">Unified Modeling Language (UML) | Sequence Diagrams</a></li>
</ul>
</li>
<li>
<p><strong>绘制 UML 时序图的工具</strong></p>
<ul>
<li>所见即所得
<ul>
<li>ProcessOn</li>
<li>draw.io (更好)</li>
</ul>
</li>
<li>代码生成
<ul>
<li><a href="http://plantuml.com/zh/">plantuml</a> </li>
<li><a href="https://app.zenuml.com/">zenuml</a> </li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>绘图注意事项</strong></p>
<ul>
<li>一个 Activation box 就是一个任务，box 越长，代表任务越长，发起的请求应该指向 box 的头部，create 除外</li>
</ul>
</li>
</ul>
<h3 id="vpn"><a class="header" href="#vpn">VPN</a></h3>
<p>VPN 就是在国外的一台机器上搭建了一个服务端，然后用国内的客户端进行连接，建立特殊的通道（VPN），将上网的所有流量，通过国外的机器打出去。</p>
<p><img src="computer-science-notebook/technology-lecture/assets/1564559916530.png" alt="VPN" /></p>
<h3 id="https"><a class="header" href="#https">HTTPs</a></h3>
<p>HTTPS == HTTP Secure == Secured HTTP</p>
<h3 id="mongodb"><a class="header" href="#mongodb">MongoDB</a></h3>
<p>MongoDB is a general purpose, <strong>document-based</strong>, <strong>distributed</strong> database built for <strong>modern application</strong> developers and for the <strong>cloud era</strong>. </p>
<p>MongoDB 和 MySQL 最大的不同：stores data in JSON-like document other than the traditional row/column model. MongoDB 存储的数据结构为 JSON，而传统的存储则是按照表进行存储。MongoDB 适用于 Node.js 项目。</p>
<h3 id="docx-和-xlsx-文档"><a class="header" href="#docx-和-xlsx-文档">docx 和 xlsx 文档</a></h3>
<p>docx 和 xlsx 文档实际上是一个压缩包，可以用解压软件打开，压缩包内有大量的 xml 文件，实际上 docx 格式的文档是一种<strong>标记语言文档</strong>，其和 markdown / HTML 没有本质的区别。</p>
<p>docx 的 x 是 xml(Extensible Markup Language)。</p>
<p>注意：doc 和 xlsx 文档并不是一种标记语言文档，其压缩包内的文件并不是纯文本。</p>
<h3 id="秒毫秒微秒纳秒"><a class="header" href="#秒毫秒微秒纳秒">秒/毫秒/微秒/纳秒</a></h3>
<table><thead><tr><th>单位</th><th>换算</th><th>English</th></tr></thead><tbody>
<tr><td>1 毫秒</td><td>$1s = 10^3ms$</td><td>millisecond</td></tr>
<tr><td>1 微秒</td><td>$1s = 10^6μs$</td><td>microseconds</td></tr>
<tr><td>1 纳秒</td><td>$1s = 10^9ns$</td><td>nanosecond</td></tr>
</tbody></table>
<h3 id="101"><a class="header" href="#101">101</a></h3>
<p>Demo: <a href="https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101">Streaming 101</a>，<a href="https://baike.baidu.com/item/%E7%81%AB%E7%AE%AD%E5%B0%91%E5%A5%B3101/22681022?fr=aladdin">火箭少女 101</a></p>
<p>101 代表一个领域的 Introduction。</p>
<h3 id="华为鸿蒙"><a class="header" href="#华为鸿蒙">华为鸿蒙</a></h3>
<p>关键词：微内核 / 分布式 / 开源  / 可扩展性(兼容性好)</p>
<p>不管技术上实现难度如何，华为此举是非常具有战略性意义的，鸿蒙是一款面向云计算 / 物联网 / 5G 的下一代操作系统，是一款划时代的，面向未来的操作系统。</p>
<p>我们究竟需要什么样的操作系统？</p>
<ul>
<li>对于用户来说，我们希望我们的各种设备：电脑 / 手机 / 平板 / 可穿戴设备 / 智能家居嵌入式设备，都能获得良好的一致性体验</li>
<li>对于开发者来说，我们希望我们的代码能够一端开发，多端运行</li>
</ul>
<p>当我了解到鸿蒙操作系统的特性时，我联想到了 VSCode，鸿蒙有些特点和 VSCode 非常相似：</p>
<table><thead><tr><th></th><th>鸿蒙</th><th>VSCode</th></tr></thead><tbody>
<tr><td>可扩展性</td><td>面向物联网，兼容各种设备，一次开发，多端运行</td><td>Extensions for each language</td></tr>
<tr><td>内核</td><td>精简的微内核</td><td>VSCode vs VS</td></tr>
<tr><td>是否开源</td><td>开源</td><td>open source</td></tr>
</tbody></table>
<p>云计算 / 物联网 / 5G 这些变革，早晚会催生出一款大一统的操作系统，华为抓住了这一机遇，所以说鸿蒙是非常具有战略意义的。如果说，VSCode 是 IDE 的未来，那么我觉得鸿蒙可能是操作系统的未来，或者说，面向云计算 / 物联网 / 5G 的操作系统，是操作系统的未来。</p>
<h3 id="restful-api-1"><a class="header" href="#restful-api-1">Restful API</a></h3>
<p><strong>Representational state transfer</strong> (<strong>REST</strong>) is a <a href="https://en.wikipedia.org/wiki/Software_architecture">software architectural style</a> which uses a subset of <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>.[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a> It is commonly used to create <a href="https://en.wikipedia.org/wiki/Interactivity">interactive</a> applications that use <a href="https://en.wikipedia.org/wiki/Web_service">Web services</a>. A Web service that follows these guidelines is called <em>RESTful</em>. Such a Web service must provide its <a href="https://en.wikipedia.org/wiki/Web_resource_framework">Web resources</a> in a textual representation and allow them to be read and modified with a <a href="https://en.wikipedia.org/wiki/Stateless_protocol">stateless protocol</a> and a predefined set of operations. </p>
<p>REST 是一套用于构建 Web Service 的规范。</p>
<h3 id="许可证"><a class="header" href="#许可证">许可证</a></h3>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201105/bg2011050101.png" alt="img" /></p>
<p>常用的开源许可证有两个：</p>
<ol>
<li>
<p>允许做任何事情，包括闭源：MIT</p>
<p>The <a href="https://choosealicense.com/licenses/mit/">MIT License</a> is short and to the point. It lets people do almost anything they want with your project, including to make and distribute closed source versions. </p>
</li>
<li>
<p>要求使用后开源：GUN GPLv3</p>
<p>The <a href="https://choosealicense.com/licenses/gpl-3.0/">GNU GPLv3</a> also lets people do almost anything they want with your project, <em>except</em> to distribute closed source versions. </p>
</li>
</ol>
<h3 id="持续集成--持续交付--持续部署--上线流程"><a class="header" href="#持续集成--持续交付--持续部署--上线流程">持续集成 / 持续交付 / 持续部署 / 上线流程</a></h3>
<p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么</a></p>
<p><a href="https://blog.csdn.net/mrzhouxiaofei/article/details/84191517">利用 Webhooks 实现代码的自动拉取</a></p>
<ul>
<li><strong>持续集成(Continuous Integration CI)</strong>：持续频繁的将代码集成到主干，小步快跑（集成到主干之前，必须经过自动化测试）
<ul>
<li>目的：快速高质量的迭代产品</li>
<li>优点：快速发现问题，防止分支大幅度偏离主干</li>
<li>面向团队：研发</li>
</ul>
</li>
<li><strong>持续交付</strong>：持续集成的下一步，交付给质量团队评审
<ul>
<li>面向团队：测试</li>
<li>主要工作：自动化测试</li>
</ul>
</li>
<li><strong>持续部署</strong>：持续交付的下一个阶段，交给运维团队部署上线
<ul>
<li>面向团队：运维</li>
</ul>
</li>
</ul>
<p><strong>一次上线的标准流程</strong>：</p>
<p>研发将最新的代码提交到 Github 上，commit 配置了 hook，触发了服务端的 Jenkins，Jenkins 从 Github 同步代码进行自动化测试。</p>
<h3 id="uri-url"><a class="header" href="#uri-url">URI URL</a></h3>
<p>URI: Uniform Resource Identifier 统一资源标识符</p>
<p>URL: Uniform Resource Locator 统一资源定位符</p>
<p>URI 是一个 ID，URL 是一个路径，URL 是用一个路径来描述一个 URI，所以 URI 包含 URL。</p>
<p>HTTP 协议中 URI 和 URL 有什么区别？ - denight的回答 - 知乎 https://www.zhihu.com/question/21950864/answer/154309494</p>
<h2 id="业务名词"><a class="header" href="#业务名词">业务名词</a></h2>
<h3 id="去-ioe"><a class="header" href="#去-ioe">去 IOE</a></h3>
<p>I: IBM 小型机 / 大型机</p>
<p>O: Oracle 数据库软件</p>
<p>E: EMC 存储</p>
<h3 id="分发"><a class="header" href="#分发">分发</a></h3>
<p>分发，顾名思义，就是将任务分配给他人发送。例如我开发了一个 app，然后为了更多的人能够下载，将该 app 上架到各大 APP 商店（分发渠道）。</p>
<h3 id="2b2c"><a class="header" href="#2b2c">2B，2C</a></h3>
<p><strong>B2B</strong>：Business 2 Business 商家对商家，例如阿里巴巴</p>
<p><strong>B2C</strong>：Business 2 Consumer 商家对个人，例如京东自营</p>
<p><strong>C2C</strong>：Consumer 2 Consumer 个人对个人，例如淘宝</p>
<p><strong>O2O</strong>：Online 2 Offline 线上对线下，例如美团团购，淘票票，偏向于线下消费</p>
<h3 id="okr"><a class="header" href="#okr">OKR</a></h3>
<p>Objective Key Result</p>
<p>我的理解：OKR = O + KPI，OKR 给 KPI 加了一个更高层次的使命感和意义。</p>
<h2 id="data-engineering-cookbook"><a class="header" href="#data-engineering-cookbook">Data Engineering Cookbook</a></h2>
<p><a href="https://github.com/andkret/Cookbook">Data Engineering Cookbook</a> 可以充当一本口袋书。</p>
<h3 id="大数据三驾马车"><a class="header" href="#大数据三驾马车">大数据三驾马车</a></h3>
<p><strong>计算机的核心：计算资源和存储资源（冯诺依曼架构：计算/存储/输入输出）。任何一个系统都离不开这两个部分。大数据就是分布式的计算和存储。</strong></p>
<ul>
<li><strong>分布式计算</strong>：MapReduce</li>
<li><strong>分布式存储</strong>：HDFS(分布式文件系统), HBase(分布式数据库)</li>
</ul>
<h3 id="平台蓝图"><a class="header" href="#平台蓝图">平台蓝图</a></h3>
<p><img src="computer-science-notebook/technology-lecture/assets/1564560673722.png" alt="大数据平台蓝图" /></p>
<ul>
<li>消息队列工具：Apache Kafka, RabbitMQ or AWS Kinesis</li>
<li>数据分析平台：MapReduce or AWS Elastic MapReduce to Apache Spark and AWS lambda</li>
<li>数据存储：Hadoop HDFS, Hbase, Amazon S3 or DynamoDB</li>
<li>数据可视化：eCharts, D3, Baidu Sugar</li>
</ul>
<h3 id="业务量剧增的解决方法"><a class="header" href="#业务量剧增的解决方法">业务量剧增的解决方法</a></h3>
<p>可以联想到分级平台压力增大后的解决方法，其优化的方向无非是 Scaling up 和 Scaling out：</p>
<p><strong>Scaling up: 申请性能更强的机器</strong></p>
<p><strong>Scaling out: 申请两台机器进行负载均衡</strong></p>
<table><thead><tr><th></th><th>Description</th><th>Demo</th></tr></thead><tbody>
<tr><td><strong>Scaling up</strong></td><td>提升目前服务器的性能</td><td>申请一台更强的机器 <img src="computer-science-notebook/technology-lecture/assets/1564561278937.png" alt="1564561278937" /></td></tr>
<tr><td><strong>Scaling out</strong></td><td>将压力均匀的分配出去</td><td>分布式计算/分布式存储，多台机器进行负载均衡<img src="computer-science-notebook/technology-lecture/assets/1564561259512.png" alt="1564561259512" /></td></tr>
</tbody></table>
<h3 id="什么时候考虑用大数据技术来解决问题"><a class="header" href="#什么时候考虑用大数据技术来解决问题">什么时候考虑用大数据技术来解决问题</a></h3>
<p>需要 Scaling 的时候，才考虑使用大数据技术来解决问题。</p>
<p>当平台性能掣肘之时，或者我们需要针对某一个模块进行优化的时候，就可以考虑从 scaling up 和 scaling out 两个方向来引入大数据的技术来解决问题。例如对实时性要求高，就可以考虑用缓存或者 Kafka 来暂存数据；数据量太大，可以考虑用 HDFS 来进行分布式存储。</p>
<h3 id="batch-processing-vs-streaming-processing"><a class="header" href="#batch-processing-vs-streaming-processing">Batch Processing vs Streaming Processing</a></h3>
<table><thead><tr><th></th><th>Description</th><th>Feature</th></tr></thead><tbody>
<tr><td><strong>Batch Processing</strong></td><td>先存储再分析<img src="computer-science-notebook/technology-lecture/assets/1564562169282.png" alt="Batch Processing" /></td><td>懒汉式</td></tr>
<tr><td><strong>Streaming Processing</strong></td><td>在存储前会有分析<img src="computer-science-notebook/technology-lecture/assets/1564562241002.png" alt="Streaming Processing" /></td><td>饿汉式，实时性强</td></tr>
</tbody></table>
<h3 id="hadoop-和-hadoop-生态"><a class="header" href="#hadoop-和-hadoop-生态">Hadoop 和 Hadoop 生态</a></h3>
<p>一个分布式存储和计算平台。</p>
<p><strong>Hadoop 流行的原因</strong>：Adoption to many Apache projects. —&gt; Turn into an ecosystem. Hadoop 有丰富的<strong>周边产品</strong>，并且已经形成了生态。</p>
<p><img src="computer-science-notebook/technology-lecture/assets/1564572791617.png" alt="Hadoop Ecosystem" /></p>
<p><img src="computer-science-notebook/technology-lecture/assets/1564577236405.png" alt="Connection between tools" /></p>
<p>You use Apache Kafka to ingest data, and store the it in HBase. </p>
<ul>
<li><strong>Zookeeper</strong>：ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. </li>
<li><strong>Kafka</strong>：Data cache and Message Queue</li>
<li><strong>YARN</strong>：resource management </li>
<li>**Zookeeper **：configuration management service to use Kafka and HBase </li>
<li><strong>HDFS</strong>：Hadoop File System</li>
<li><strong>HBase</strong>：Hadoop Database</li>
</ul>
<p><strong>Hadoop 生态的缺点</strong></p>
<p>Hadoop 生态部署后非常耗费资源（尤其在单台机器上），我们至少需要 5台机器去部署一个 Hadoop 集群，否则无法发挥 Hadoop 的威力。所以<strong>我们应该了解这个生态的每一个模块，当我们需要某个功能时，能联想到 Hadoop 的某个模块，然后拿来用即可。</strong></p>
<p><strong>Hadoop 生态的核心工具</strong></p>
<p>Yarn Zookeeper HDFS Oozie Flume Hive </p>
<h3 id="mapreduce"><a class="header" href="#mapreduce">MapReduce</a></h3>
<p>Map 和 Reduce 这两个阶段都可以实现分布式并行计算。</p>
<p>Demo:</p>
<p><img src="computer-science-notebook/technology-lecture/assets/1564582931560.png" alt="MapReduce Demo: Get Average Temperature" /></p>
<ol>
<li>the map stage could be done by nine mappers in parallel because each map is independent
from all the others.</li>
<li>The reduce stage could still be done by three tasks in parallel.</li>
</ol>
<h3 id="spark"><a class="header" href="#spark">Spark</a></h3>
<p><strong>Spark 和 Hadoop 的关系</strong></p>
<p>Hadoop 是一个生态，包括分布式计算和存储，而 Spark 只是一个计算平台，没有存储能力，Spark 属于 Hadoop 生态。</p>
<h3 id="database-1"><a class="header" href="#database-1">Database</a></h3>
<ul>
<li><strong>InfluxDB</strong>：Time Series Database </li>
</ul>
<h3 id="machine-learning-in-big-data"><a class="header" href="#machine-learning-in-big-data">Machine Learning in Big Data</a></h3>
<p><strong>目前比较棘手的问题</strong>：Automatic re-training and re-deploying. （自动化模型迭代和上线）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统---尚硅谷"><a class="header" href="#操作系统---尚硅谷">操作系统 - 尚硅谷</a></h1>
<p>[TOC]</p>
<h2 id="课程地址"><a class="header" href="#课程地址">课程地址</a></h2>
<p>https://www.bilibili.com/video/BV1b34y1H7YJ</p>
<h2 id="操作系统概述"><a class="header" href="#操作系统概述">操作系统概述</a></h2>
<h3 id="操作系统的演化"><a class="header" href="#操作系统的演化">操作系统的演化</a></h3>
<p>演化的目标：提高 CPU 利用率，提高人机交互体验。</p>
<ol>
<li>
<p>单道批处理系统：内存中只有一道作业</p>
</li>
<li>
<p>多道批处理系统：内存中有多道作业（磁带上有多个作业，一个进程IO时，CPU交给另一个进程）（对于没有 IO 的长作业，则会长期占用 CPU）</p>
</li>
<li>
<p>分时系统：大家一起用计算机，多用户，多终端，时间片，人机交互，共享主机</p>
</li>
</ol>
<p>其他名词：</p>
<ul>
<li>单工：信息单向传输（例如广播）</li>
<li>双工：信息可以双向传输（例如打电话）</li>
<li>荧光灯闪烁频率：50次/s</li>
</ul>
<table><thead><tr><th>多道批处理系统</th><th>分时系统架构</th></tr></thead><tbody>
<tr><td><img src="computer-science-notebook/technology-lecture/assets/image-20220718150101713.png" alt="image-20220718150101713" /></td><td><img src="computer-science-notebook/technology-lecture/assets/image-20220718145006824.png" alt="image-20220718145006824" /></td></tr>
</tbody></table>
<p>实时系统：</p>
<ul>
<li>硬实时任务 必须满足截止时间要求</li>
<li>软实时任务 偶尔错误截止时间也不会有太大影响</li>
</ul>
<h3 id="操作系统基本特性"><a class="header" href="#操作系统基本特性">操作系统基本特性</a></h3>
<ul>
<li>
<p>并发：宏观上的并行，微观上的串行（并发能够实现是因为引入了进程的概念）</p>
</li>
<li>
<p>共享</p>
<ul>
<li>互斥共享：互斥资源（临界资源），例如打印机，磁带机，同一段时间内，只允许一个进程访问。</li>
<li>同步共享：同步资源，例如磁盘，允许一段时间内多个进程同时访问。（宏观上是同时访问，微观上实际上还是交替访问！）</li>
</ul>
<p>数据库里面的数据，本身属于同步资源，只是数据库为了实现 ACID，在读数据的时候，增加了读锁（允许其他进程读取，不允许写，同步资源），在写数据的时候，增加了写锁（不允许其他进程读写，临界资源），写锁属于互斥资源，读锁属于同步资源。</p>
</li>
<li>
<p>虚拟</p>
<p>将一个物理实体，变为若干个逻辑上的对应物。</p>
<p>实现虚拟化的技术：</p>
<ul>
<li>时分复用：虚拟处理机，虚拟打印机，虚拟存储器</li>
<li>空分复用（频分复用）</li>
</ul>
</li>
<li>
<p>异步</p>
<p>也叫做不可预知性，不确定性。进程以不可预知的速度向前推进的特性，称为异步性。</p>
<p>只要 OS 中配置有完善的进程同步机制，且运行环境相同，则作业即使经过多次运行，也可以获得完全相同的结果，即 OS 的异步性不会影响到作业的运行结果。</p>
<p>同步就是确定的，可预知的，可再现的。</p>
</li>
</ul>
<h3 id="微内核特征"><a class="header" href="#微内核特征">微内核特征</a></h3>
<p>例如 Linux 内核</p>
<ul>
<li>
<p>提供基础核心功能 </p>
</li>
<li>
<p>基于 C/S 模式</p>
<p>客户进程和微内核外的服务进程之间的通信，IO，需要通过内核提供的系统调用来实现。（解耦）</p>
<p><img src="computer-science-notebook/technology-lecture/assets/image-20220718204153183.png" alt="image-20220718204153183" /></p>
</li>
<li>
<p><strong>机制与策略分离</strong>（设计模式）</p>
<p>机制：实现某一功能的具体执行机构（通常将机制放在微内核中）（有点类似于定义接口和部分实现，抽象类）</p>
<p>策略：在机制基础上借助某些参数和算法来实现对该功能的优化（通常将策略放在内核外的服务进程中）（类似于抽象类的子类，实现了接口）</p>
<p>例如进程调度，调度功能属于机制问题，而进程优先级算法就属于策略问题。</p>
</li>
</ul>
<p>Dubbo 中的微内核</p>
<p>SPI: Service Provider Interface 服务提供者接口，是一种服务发现机制。Dubbo 的微内核就是基于 SPI 实现的。</p>
<p>Dubbo 作为一款优秀的 RPC 框架，一个 Apache 顶级项目，其最大的亮点之一，就是其优秀的无限开放性设计：微内核 + 插件的架构设计思想，使得其几乎所有组件均可方便地进行扩展、增强、替换。内核只负责组装插件，Dubbo 的功能都是由插件实现的。</p>
<p>ZK、Nacos、Apollo 中的&quot;中断&quot;</p>
<p>中断处理的思想，反映到编程语言开发中，其实就是监听机制（回调）。反映到分布式开发中，其实就是发布/订阅模式。</p>
<h2 id="分布式算法"><a class="header" href="#分布式算法">分布式算法</a></h2>
<h3 id="一致性-hash"><a class="header" href="#一致性-hash">一致性 hash</a></h3>
<p>别名：hash 环。</p>
<p>使用场景：负载均衡，分布式缓存</p>
<p>介绍：<a href="https://blog.csdn.net/mo71105731/article/details/123364539">一致性hash算法</a></p>
<p>核心算法：hash 环，虚拟化</p>
<p>缓存 Demo</p>
<table><thead><tr><th>步骤</th><th>图示</th></tr></thead><tbody>
<tr><td>存储图片</td><td><img src="computer-science-notebook/technology-lecture/assets/image-20220718195414328.png" alt="image-20220718195414328" style="zoom:50%;" /></td></tr>
<tr><td>hash 倾斜</td><td><img src="computer-science-notebook/technology-lecture/assets/image-20220718195533682.png" alt="image-20220718195533682" style="zoom:50%;" /></td></tr>
<tr><td>引入虚拟节点</td><td><img src="computer-science-notebook/technology-lecture/assets/image-20220718195603941.png" alt="image-20220718195603941" style="zoom:50%;" /></td></tr>
</tbody></table>
<p>数据读写 -&gt; 虚拟节点 -&gt; 真实节点 -&gt; 读写</p>
<h3 id="master-选举"><a class="header" href="#master-选举">Master 选举</a></h3>
<p>MySQL 读写分离集群，master 负责写，slave 负责读。 </p>
<p>Kafka 集群，broker controller 负责各个分区 leader 的选举。</p>
<h3 id="分布式锁"><a class="header" href="#分布式锁">分布式锁</a></h3>
<p>zookeeper 分布式锁原理：读着写着模式</p>
<p><img src="computer-science-notebook/technology-lecture/assets/image-20220718203158625.png" alt="image-20220718203158625" /></p>
<h3 id="分布式发布与订阅"><a class="header" href="#分布式发布与订阅">分布式发布与订阅</a></h3>
<p>dubbo 中将 ZK 作为服务注册与订阅。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算的未来"><a class="header" href="#计算的未来">计算的未来</a></h1>
<p>[TOC]</p>
<p><a href="https://www.bilibili.com/video/BV1sh411R7JR">[Bilibili-计算的未来]</a></p>
<h2 id="吴翰清"><a class="header" href="#吴翰清">吴翰清</a></h2>
<p>阿里巴巴大牛，阿里云，西安交通大学，黑客</p>
<h2 id="技术问题--数学问题"><a class="header" href="#技术问题--数学问题">技术问题 —&gt; 数学问题</a></h2>
<p><strong>算法的可计算性</strong>：只要能在有限步内求出结果的问题</p>
<p><strong>技术问题归根结底还是数学问题</strong></p>
<ul>
<li>将一个实际问题抽象成数学问题的能力，然后用数学的做题思维来解决</li>
<li>没有什么代码是读不懂的，只要头脑清晰，一段代码一段代码地看下去，总能看懂的</li>
<li>没有什么开发问题(正常的开发问题)是解决不了的，因为其本质上还是一个数学的计算问题，无论多么庞大的需求，只要是可计算的，都可以抽象成一个一个小步骤，慢慢解决</li>
</ul>
<h2 id="算力的价值"><a class="header" href="#算力的价值">算力的价值</a></h2>
<p>算力与生产力。<strong>未来算力将和电力一样无处不在</strong>。计算在东部发达地区，已经无处不在了，几乎人手一部手机了。</p>
<h2 id="技术与商业"><a class="header" href="#技术与商业">技术与商业</a></h2>
<ul>
<li>资本的本质：技术</li>
<li>生产力，生产资料，规模</li>
</ul>
<p>在计算经济时代，算力就是生产力，数据就是生产资料，扩大规模的是互联网</p>
<h2 id="关于互联网"><a class="header" href="#关于互联网">关于互联网</a></h2>
<ul>
<li>互联网与电话网，电报网，铁路网有着相同的经济规模</li>
<li>网络连接不是计算，节点之间的互动会沉淀大量数据和计算需求</li>
<li>网的价值在于节点的互动：梅特卡夫定律 - 网络的价值 = kn^2 (k 为价值系数，n 为用户数量)</li>
</ul>
<p>网络是二维的，其价值大于双边一维价值，<strong>淘宝的价值</strong>是线性的，其价值为 O(n)，而<strong>腾讯的价值</strong>是二维的，其价值为 O(n^2)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="许式伟架构课"><a class="header" href="#许式伟架构课">许式伟架构课</a></h1>
<p>[TOC]</p>
<h2 id="我为什么要学习这门课"><a class="header" href="#我为什么要学习这门课">我为什么要学习这门课</a></h2>
<ul>
<li>
<p>看看从一个 IT 老兵的角度重新学习计算机的基础知识</p>
</li>
<li>
<p>希望能了解计算机领域的前沿技术，并把这些技术串起来</p>
</li>
<li>
<p>希望通过学习这门课，形成一种计算机思维，拥有透过现象看本质的能力，拥有将现实中的问题抽象到计算机体系架构的能力，例如：</p>
<p>当现在各个手机厂商都在推出各种黑科技时，你能冷静的意识到，这只是输入输出设备人机交互上的一些 trick，并没有革命性的创新</p>
</li>
<li>
<p>在学习这门课的同时，我们能发现自己知识薄弱的地方，然后去补课：《现代操作系统》，《深入理解计算机系统》</p>
</li>
</ul>
<h2 id="开篇词-怎样成长为优秀的软件架构师"><a class="header" href="#开篇词-怎样成长为优秀的软件架构师">开篇词 怎样成长为优秀的软件架构师</a></h2>
<ul>
<li>软件架构师和软件工程师最根本的差别在于四个字：<strong>掌握全局</strong>。掌握全局，并不是成为全栈，核心在于对知识脉络的体系化梳理，这是架构能力构建和全面提升的关键。</li>
<li>如何成为优秀的软件架构师？一靠匠心，二靠悟心。</li>
<li>架构能力的提升，本质上是对你的<strong>知识脉络（全身经络）的反复梳理与融会贯通</strong>的过程。</li>
</ul>
<h2 id="第一讲-架构设计的宏观视角"><a class="header" href="#第一讲-架构设计的宏观视角">第一讲 架构设计的宏观视角</a></h2>
<p>谈及架构，基础才是最重要的，有了坚实的基础，才能起高楼。</p>
<h3 id="google-赋予的浏览器的使命"><a class="header" href="#google-赋予的浏览器的使命">Google 赋予的浏览器的使命</a></h3>
<p>客户端软件面临的是多样性的挑战。操作系统有 N 种，我们不能针对每一个操作系统都编写一套客户端，于是 Google 赋予了浏览器一个使命：<strong>消除客户端的多样性，跨平台提供统一编程接口</strong>。Google 之所以发力浏览器，有两个原因：</p>
<ol>
<li>Google 已经丧失了桌面操作系统的控制权，所以其想把战场转到浏览器上，越来越多的开发人员在浏览器上做应用，从而导致底层操作系统管道化（操作系统成为数据流通的通道）。</li>
<li>一次开发，多平台运行是大势所趋，Google 除了发力 Chrome，也有其他的尝试，例如：Flutter</li>
</ol>
<h2 id="第二讲-无生有-有生万物"><a class="header" href="#第二讲-无生有-有生万物">第二讲 无生有 有生万物</a></h2>
<h3 id="冯诺依曼体系结构"><a class="header" href="#冯诺依曼体系结构">冯诺依曼体系结构</a></h3>
<p>冯的体系结构不仅是应用程序这座大厦的基石，同时也是整个信息科技的地基。冯诺依曼体系的三个基础零部件：</p>
<ol>
<li>
<p><strong>处理器</strong></p>
</li>
<li>
<p><strong>存储</strong></p>
<p>存储分为内存和外存。计算机存储的地位，如同人类发明了纸一样重要。</p>
</li>
<li>
<p><strong>输入输出设备</strong></p>
</li>
</ol>
<p><strong>注意：任何计算机系统，都离不开这三点：计算/存储/输入输出，思考问题要从这三点开始思考。</strong></p>
<p>CPU 与输入输出设备之间进行通信，本质上就是和 IO设备 进行数据的传输。</p>
<img src="computer-science-notebook/technology-lecture/assets/1556592435775.png" alt="冯诺依曼架构" style="zoom:80%;" />
<p><strong>处理器 + 存储 实现了无中生有，而 输入输出设备 实现了有生万物</strong>。</p>
<h3 id="输入输出设备的重要性"><a class="header" href="#输入输出设备的重要性">输入输出设备的重要性</a></h3>
<p><code>y = f(x)</code> x 存储到存储设备中，函数 f 则涉及到处理器的计算规则。然而，如果电脑只有 处理器 + 存储，那么就如同一个人只有头脑而没有四肢五官一样，尽管很聪明，但是这种聪明无法施展，因为其无法与现实世界进行交互。交互，抽象来看，就是输入和输出，对于人来说，输入就是听觉视觉触觉味觉嗅觉，输出就是人利用四肢五官做出的反应。</p>
<p>输入输出设备从根本上解决的问题是：计算机无限可能的扩展能力。另外，输入输出设备和电脑完全是异构的，他们之间只是通过制定好的协议进行通信，IO 设备对于电脑来说，只是实现了某个功能的黑匣子。输入输出设备，赋予了计算机计算一切的能力，如果没有输入输出设备，那么计算机就像坐在轮椅上的高智商人一样，没有用武之地。</p>
<h3 id="从-冯诺依曼体系-到-架构思维"><a class="header" href="#从-冯诺依曼体系-到-架构思维">从 冯诺依曼体系 到 架构思维</a></h3>
<p>架构的第一步是：需求分析。<strong>需求分析的关键在于抓住需求的稳定点和变化点</strong>。需求的稳定点，往往是系统的核心价值所在，而需求的变化点，则往往需要相应去做开放性设计。</p>
<p>对于计算机而言，其需求的稳定点就是其计算能力，需求的变化点在于用户 “计算需求” 的多样性。计算机的计算能力，最终体现为中央处理器的指令集，这是相对稳定的。而 “计算需求” 的多样性，则体现到应用程序的多样性。</p>
<h2 id="第三四讲-编程语言的诞生和进化"><a class="header" href="#第三四讲-编程语言的诞生和进化">第三/四讲 编程语言的诞生和进化</a></h2>
<h3 id="汇编语言的地位"><a class="header" href="#汇编语言的地位">汇编语言的地位</a></h3>
<p><strong>汇编语言的出现使得计算机的软件和硬件开始解耦</strong>，让写程序开始变成一个纯软件的行为，人们可以反复修改汇编程序，然后通过编译器将其翻译成机器语言。汇编语言在指令的能力上，与机器指令并无二致，只之不过将人们从物理硬件地址中解放了出来，以便专注于应用逻辑的表达。注意：变成语言的发展，其本质上是一个释放程序员生产力的过程。</p>
<p><strong>汇编语言实现了编程语言的从 0 到 1，C 语言实现了编程语言的从 1 到 N</strong>。</p>
<h3 id="软件是活的书籍"><a class="header" href="#软件是活的书籍">软件是活的书籍</a></h3>
<p>编程语言在信息科技发展中的地位，如同人类文明中语言的地位。而编程语言写出的软件，如同人类文明中不断被传承下来的书籍一般。</p>
<h2 id="第六七八讲-操作系统进程管理内存管理"><a class="header" href="#第六七八讲-操作系统进程管理内存管理">第六/七/八讲 操作系统/进程管理/内存管理</a></h2>
<h3 id="操作系统的启动过程"><a class="header" href="#操作系统的启动过程">操作系统的启动过程</a></h3>
<p>计算机操作系统由固化到 RAM 上的 BIOS 授权启动，BIOS 中的驱动程序激活必要的设备（磁盘/显示器/鼠标/键盘），然后跳转到<strong>磁盘的引导区</strong>，将执行权交给引导程序。引导程序用来引导开启操作系统，如果磁盘上装有多个操作系统，那么引导程序会引导我们进入相应的系统。引导程序引导结束后，会将控制权交给 OS引导程序，操作系统从这里开始干活了！</p>
<h3 id="unix-与-doswindows"><a class="header" href="#unix-与-doswindows">Unix 与 DOS/Windows</a></h3>
<p>Unix 针对的是企业用户，DOS/Windows 面向的是个人用户，两者定位不同，导致了截然不同的发展方向。</p>
<h3 id="操作系统的重要性"><a class="header" href="#操作系统的重要性">操作系统的重要性</a></h3>
<ul>
<li>
<p><strong>操作系统是所有流量的入口</strong></p>
<p>传统的互联网流量入口是 PC，微软凭借 WIndows 得以制霸整个市场。移动互联网流量的入口是 手机系统，Google 和 Apple 在争夺流量上，扳回一局。</p>
</li>
<li>
<p><strong>操作系统的其他作用</strong></p>
<p>进程管理/内存管理/文件管理/设备管理/网络管理/提供基础编程接口</p>
</li>
</ul>
<h3 id="现代操作系统分类"><a class="header" href="#现代操作系统分类">现代操作系统分类</a></h3>
<p><strong>本地操作系统</strong>：Windows / Linux / Android / IOS </p>
<p><strong>Web操作系统</strong>：微信小程序 / 百度小程序</p>
<h3 id="内存管理的重要性"><a class="header" href="#内存管理的重要性">内存管理的重要性</a></h3>
<p>内存实际上是计算机最宝贵的资源，实际工作中，我们面临的内存资源，往往是非常有限的，一个优秀的程序员，懂得用极少的内存资源，实现自己的需求。</p>
<h3 id="操作系统编程接口"><a class="header" href="#操作系统编程接口">操作系统编程接口</a></h3>
<p>操作系统使用 **软中断（系统调用）**来实现软件进程与操作系统的交互，系统调用是用户程序与操作系统之间的接口。</p>
<p><strong>操作系统的编程接口：</strong></p>
<ul>
<li>系统调用</li>
<li>动态库（二进制）
<ul>
<li>Windows ddl (Dynamic Link Library)</li>
<li>Linux/Android 的 so (Shared Library)</li>
</ul>
</li>
</ul>
<p><strong>动态库产生的原因：</strong></p>
<p>系统调用只能提供操作系统最原始/原子的功能。动态库可以根据业务需求，对代码进行封装，从而<strong>实现代码复用</strong>。</p>
<img src="computer-science-notebook/technology-lecture/assets/1557646023134.png" alt="用户态到内核态" style="zoom:67%;" />
<img src="computer-science-notebook/technology-lecture/assets/1557647654089.png" alt="基础架构" style="zoom:67%;" />
<h2 id="第九讲外存管理与文件系统"><a class="header" href="#第九讲外存管理与文件系统">第九讲：外存管理与文件系统</a></h2>
<ul>
<li>
<p><strong>内存和外存的根本区别</strong></p>
<p>内存是<strong>临时存储</strong>，为 CPU 计算服务</p>
<p>外存是<strong>持久存储</strong>，为存储服务</p>
</li>
<li>
<p><strong>文件系统的数据结构</strong></p>
<p>树：<strong>双亲节点</strong>存储目录(文件夹)，<strong>叶子节点</strong>存储文件</p>
</li>
<li>
<p><strong>文件系统的设计思路</strong></p>
<p>利用<strong>日志</strong>来改善文件系统的容灾能力，利用 <strong>B树/B+树</strong> 来组织元数据。</p>
</li>
<li>
<p><strong>分区</strong></p>
<p>分区本质上是将<strong>一块</strong>存储设备模拟成<strong>多块</strong>存储设备来使用，也是一种<strong>虚拟技术</strong>。</p>
</li>
<li>
<p><strong>磁盘的处理步骤</strong></p>
<ol>
<li>
<p>分区：虚拟分区</p>
</li>
<li>
<p>格式化：设置各分区的文件系统格式</p>
</li>
<li>
<p>挂载：将格式化后的分区挂载到操作系统文件系统下</p>
<p>Windows 系统：将分区依次挂载到 C/D/E 盘下</p>
<p>Linux 系统：将分区挂载在 /, /home, swap 下</p>
</li>
</ol>
</li>
<li>
<p><strong>Swap 空间（交换空间）</strong></p>
<p>Swap 空间是磁盘上的物理空间，用来实现虚拟内存，内存中的页块暂时存储到。</p>
<p>Linux 系统在对磁盘进行初始化时，会分配出一块空间，用作 swap</p>
<p>Windows 系统则通过隐藏的 <code>.swp</code> 文件来实现虚拟内存</p>
</li>
</ul>
<h2 id="第-11-讲多任务进程线程与协程"><a class="header" href="#第-11-讲多任务进程线程与协程">第 11 讲：多任务：进程，线程与协程</a></h2>
<p>现代的 CPU 大多是多核的 CPU，例如双核四线程，多核可以真正的实现进程的并行。</p>
<h3 id="任务的抽象"><a class="header" href="#任务的抽象">任务的抽象</a></h3>
<ul>
<li>
<p>进程</p>
<p>进程是操作系统最基本的隔离单元。</p>
</li>
<li>
<p>线程</p>
</li>
<li>
<p>协程</p>
</li>
</ul>
<h2 id="第-1415-讲-计算机网络"><a class="header" href="#第-1415-讲-计算机网络">第 14/15 讲: 计算机网络</a></h2>
<p>网络协议是计算机之间通信的数据格式。这些协议包含很多的信息，并且各司其职，有不同的职责。就像一张快递单一样。</p>
<p><img src="computer-science-notebook/technology-lecture/assets/1563777454889.png" alt="1563777454889" /></p>
<p>收件人和寄件人是应用层，其他信息包括物流订单号，信封袋，包装箱，这都不是寄件人要邮寄的内容，而是物流系统针对物流协议产生的需求，实际上是对原始信息的封装。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-9"><a class="header" href="#questions-9">Questions</a></h1>
<h2 id="architecture-questions"><a class="header" href="#architecture-questions">Architecture-Questions</a></h2>
<ul>
<li>Google 赋予的 Chrome 浏览器的使命</li>
<li>冯诺依曼体系架构组成及其各自的地位</li>
<li>汇编语言和C语言的地位</li>
<li>BIOS 的作用，操作系统的启动过程</li>
<li>Unix 和 Windows 系统的定位</li>
<li>现代操作系统分类，有哪些</li>
<li>动态链接库最本质的作用</li>
<li>内存和外存的根本区别</li>
<li>文件系统的数据结构</li>
<li>文件系统的设计思路</li>
<li>磁盘分区是什么，磁盘初始化的步骤是什么</li>
<li>格式化的本质是什么</li>
<li>Swap 空间是什么，作用是什么，Linux 和 Windows 是如何实现的</li>
<li>多核四线程指的是啥</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="week-27"><a class="header" href="#week-27">week-27</a></h1>
<h3 id="主题图片生成器"><a class="header" href="#主题图片生成器">主题图片生成器</a></h3>
<p>自媒体在互联网上创作，最头疼的是莫过于文章的配图了。每次我写完一篇文章，都不知道该找一张什么样的图片来契合文章的主题。</p>
<p>有时候我会配上自己平时拍的一些照片，虽然文不对题，但是总比没有好。</p>
<p>所以我干脆找了一批可以自定义生成图片的网站。</p>
<p><a href="https://agreeable-pond-087f7a90f.1.azurestaticapps.net/">Profile Header Generator</a> | <a href="https://github.com/leviarista/github-profile-header-generator">github</a> 自定义生成 profile 图片</p>
<p><img src="weekly/2022/assets/image-20220705084037108-6989534.png" alt="image-20220705084037108" /></p>
<p><a href="https://github.com/kyechan99/capsule-render">capsule-render</a> |<a href="https://github.com/kyechan99/capsule-render">github</a> 根据 url 参数自动生成 svg 图片链接</p>
<pre><code>https://capsule-render.vercel.app/api?color=gradient&amp;height=300&amp;section=header&amp;text=授人以鱼，也授人以渔&amp;fontSize=40&amp;type=waving
</code></pre>
<p><img src="weekly/2022/assets/image-20220705105537518.png" alt="image-20220705105537518" /></p>
<p><a href="https://www.bannerbear.com/demos/github-social-preview-generator-tool">github social</a> 输入 GitHub 仓库，自动生成图片</p>
<p><img src="weekly/2022/assets/image-20220705105342046.png" alt="image-20220705105342046" /></p>
<h3 id="rust-静态网站生成"><a class="header" href="#rust-静态网站生成">rust 静态网站生成</a></h3>
<p>分享一套 rust 静态网站生成的技术栈：</p>
<ul>
<li><a href="https://github.com/getzola/zola">Zola</a> A fast static site generator in a single binary with everything built-in.</li>
<li><a href="https://github.com/aaranxu/adidoks">adidoks</a> AdiDoks is a mordern documentation theme, which is a port of the Hugo theme Doks for Zola.</li>
</ul>
<h2 id="bug-的波粒二象性"><a class="header" href="#bug-的波粒二象性">bug 的波粒二象性</a></h2>
<p><img src="weekly/2022/assets/image-20220706072415271.png" alt="image-20220706072415271" /></p>
<h2 id="平原上的夏洛克"><a class="header" href="#平原上的夏洛克">平原上的夏洛克</a></h2>
<p>乡土浪漫</p>
<p><img src="weekly/2022/assets/image-20220706132516135.png" alt="image-20220706132516135" /></p>
<h2 id="jackson-反序列化"><a class="header" href="#jackson-反序列化">jackson 反序列化</a></h2>
<p>fastjson 和 jackson 是最常用的序列化和反序列化工具。</p>
<p>SpringBoot 自带的是 jackson，如果要切换成 fastjson，则需要单独配置。</p>
<p>jackson 有一个巨坑，就是无法反序列化第二个字母大写的字段，举例：</p>
<p>将下面的 json 反序列化成 bean 的时</p>
<pre><code class="language-json">{
  &quot;eMail&quot;: &quot;wanshojs@gmail.com&quot;
}
</code></pre>
<p>得到的 eMail 字段是 null。需要强制指定来进行反序列化：</p>
<pre><code class="language-java">@Data
public class User {

    private String name;

    @JsonProperty(&quot;eMail&quot;)
    private String eMail;
  
  	/***
     * 前端传过来的是 more-info，解析对应到 moreInfo 字段
     */
    @JsonProperty(&quot;more-info&quot;)
    private String moreInfo;

}
</code></pre>
<p>fastjson 不存在上述问题。</p>
<p>fastjson 中和 @JsonProperty 功能类似的注解是：<code>@JSONField(name=&quot;eMail&quot;)</code>。</p>
<h2 id="换手机-redmi-note9-pro---redmi-k50"><a class="header" href="#换手机-redmi-note9-pro---redmi-k50">换手机 Redmi Note9 Pro -&gt; Redmi K50</a></h2>
<p>这周我的 Redmi Note9 Pro 实在是卡得不行了，没办法换了 K50。</p>
<p>什么感觉呢，感觉就是直接起飞🛫！</p>
<p>Note9 Pro 才用了一年半，就拉垮了，看来买小米还是得买 K 系列！2000 的价格，3000 的体验！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-28"><a class="header" href="#week-28">week-28</a></h1>
<h2 id="快乐秘籍"><a class="header" href="#快乐秘籍">快乐秘籍</a></h2>
<ol>
<li>少关注别人的人生（少上网）</li>
<li>珍视自己（多投资自己，多关注自己）</li>
<li>多多搞钱</li>
</ol>
<h2 id="代码格式化并在前端高亮展示-1"><a class="header" href="#代码格式化并在前端高亮展示-1">代码格式化并在前端高亮展示</a></h2>
<p>代码格式化：<a href="https://github.com/sql-formatter-org/sql-formatter">sql-formatter</a></p>
<p>前端高亮展示：<a href="https://highlightjs.org/">highlight.js</a></p>
<p>在 react 中引入 highlight.js：<a href="https://juejin.cn/post/6969131238493782046">在各种环境中使用 hightlight.js</a></p>
<p>react 中使用 highlight.js 会有如下警告，目前尚未解决：</p>
<pre><code>One of your code blocks includes unescaped HTML. This is a potentially serious security risk.
</code></pre>
<h2 id="寒门学子"><a class="header" href="#寒门学子">寒门学子</a></h2>
<p>曾经的农村留守儿童，考研上岸国防科大，和种田的爷爷奶奶一起拆录取通知书。</p>
<p>泪目。</p>
<p>寒门出贵子，越来越难了。</p>
<p><img src="weekly/2022/assets/image-20220714074237959.png" alt="image-20220714074237959" /></p>
<h2 id="我看老师你是完全不懂哦"><a class="header" href="#我看老师你是完全不懂哦">我看老师你是完全不懂哦</a></h2>
<p><img src="weekly/2022/assets/FkcaCzh82nF8bZ4PKwwx6Cf5VIBnv3.png" alt="FkcaCzh82nF8bZ4PKwwx6Cf5VIBnv3.png" /></p>
<h2 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h2>
<p>尚硅谷刚发布的一个很接地气的操作系统教学系列，属实业界良心。</p>
<p><img src="weekly/2022/assets/image-20220715074655374.png" alt="image-20220715074655374" /></p>
<h2 id="3d-打印建筑"><a class="header" href="#3d-打印建筑">3D 打印建筑</a></h2>
<p>用 3D 打印，一两天就能打印出一栋楼，牛批。</p>
<p><img src="weekly/2022/assets/bg2022070401.webp" alt="img" /></p>
<h2 id="早起"><a class="header" href="#早起">早起</a></h2>
<p>上个月经常早上 6 点多就醒了，一开始我以为自己睡眠质量不好，醒的这么早。为了休息好，我醒来后就赖在床上，等 7 点的闹钟响了再起来。</p>
<p>但是从醒来到等闹钟的这段时间里，我觉得重新进入睡眠，反而有时候等得很煎熬，白天的效率也不高。</p>
<p>直到最近我才发现，我 6 点多醒来的时候，其实就是自然醒了，没必要赖床了。</p>
<p>然后感觉就打开了新世界。早起一个小时能干很多事情，跑步，写文章，学习，心情也好，而且效率特别高。</p>
<p>follow your heart.</p>
<h2 id="设计先行"><a class="header" href="#设计先行">设计先行</a></h2>
<p>最近接触到了 apifox 和 pdman，深刻意识到设计先行、文档先行、思考先行的重要性。</p>
<p>其实也就是，不管做什么事情，想好再做。</p>
<p>开发接口，那么先设计好接口，想好算法实现的步骤，再开发，别上来就 <code>new class ...</code>；</p>
<p>增加数据库表，那么先想好再创建，别上来就 <code>create table ...</code>；</p>
<p>写论文，那么先把框架打出来，想好每一章写什么，有哪几个创新点，别上来就 <code>摘要：...</code>；</p>
<p>考研复习专业课，先想好怎么复习，看看这一个章节都考过哪些知识点，别上来就 <code>王道...</code>；</p>
<p>事实上，现在已经有很多计算机领域的开发工具，只要设计好了，就可以自动帮我们按照设计做接下来的事情。</p>
<p>例如，</p>
<p>在 apifox 上设计好接口后，apifox 可以自动帮我们根据设计自动生成 Java 代码；</p>
<p>在 pdman 上设计好数据库表后，pdman 会帮我们自动生成其对应的建表语句（这也是设计先行带来的好处，进行抽象设计，工具会帮我们去实现具体的细节），甚至会帮我们自动生成 Bean。</p>
<p><img src="weekly/2022/assets/image-20220715104805962.png" alt="image-20220715104805962" /></p>
<p><img src="weekly/2022/assets/image-20220715104822225.png" alt="image-20220715104822225" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-29"><a class="header" href="#week-29">week-29</a></h1>
<p>[TOC]</p>
<h2 id="高考填志愿的趋势"><a class="header" href="#高考填志愿的趋势">高考填志愿的趋势</a></h2>
<p>今年家里的弟弟高考，我也花了很多的心思，在高考填报志愿上。</p>
<p>江苏省从 2021 年开始，使用全国卷，总分 750 分，并且改用专业组为单位进行录取，而不是以往的以高校为单位进行录取。</p>
<p>专业组，简单来说，就是将一个学校的专业，打包成多个组，每个组都是一个志愿。假设南京大学将所有专业分成 A，B，C 三个组，那么考生一志愿可以报南大 A 组，二志愿可以报南大 B 组，三志愿可以报南大 C 组。专业组强化了专业的重要性，弱化了学校的影响。</p>
<p>从江苏各大高校 2022 的专业组投档线可以看出以下几个趋势：</p>
<ul>
<li>双一流（非211）高校包含双一流专业的专业组，投档线都非常高</li>
<li>专业越来越重要</li>
<li>大家都想学好专业，导致包含好专业的专业组，竞争非常激烈</li>
</ul>
<p>投档线最高的专业组，南邮达到了 595，南信大达到了 603，南林达到了 568，均比去年要高很多。说明考生和家长越来越重视双一流这个品牌。但是南信大最高组的投档分是 603 我是没想到的，苏州大学最高的专业组投档线也才 608，南信大竟然直逼苏大，真是太疯狂了，南信大是不是今年宣传做得特别好？</p>
<p>这三所学校不同专业组投档分分差也很大，南信大投档线最高的专业组分数是 603，投档线最低的专业组分数是 543，差了整整 60 分！南邮还好，差了 35 分，南林差了 23 分。虽然国家重点发展双一流，以上三所都有双一流学科，但是很明显南信大的水分太大了。</p>
<p><img src="weekly/2022/assets/image-20220721133355921.png" alt="image-20220721133355921" /></p>
<p><img src="weekly/2022/assets/image-20220721133414018.png" alt="image-20220721133414018" /></p>
<p><img src="weekly/2022/assets/image-20220721133429754.png" alt="image-20220721133429754" /></p>
<h2 id="一个段子"><a class="header" href="#一个段子">一个段子</a></h2>
<p>经济，不是地上的卡车，而是天上的飞机。你踩一脚刹车，它不是停下来，是掉下来，你想重新起飞，不是踩一脚油门，而是需要跑道和很长的爬升。</p>
<h2 id="github-city"><a class="header" href="#github-city">github city</a></h2>
<p><a href="https://honzaap.github.io/GithubCity/">Create</a> a 3D city from your GitHub contributions.</p>
<p><img src="weekly/2022/assets/image-20220719203014105.png" alt="image-20220719203014105" /></p>
<h2 id="滴滴被罚-8026-亿"><a class="header" href="#滴滴被罚-8026-亿">滴滴被罚 80.26 亿</a></h2>
<p>干得漂亮！</p>
<p><img src="weekly/2022/assets/image-20220721133236080.png" alt="image-20220721133236080" /></p>
<h2 id="美团王兴观点"><a class="header" href="#美团王兴观点">美团王兴观点</a></h2>
<p><img src="weekly/2022/assets/image-20220721203748230.png" alt="image-20220721203748230" /></p>
<p><img src="weekly/2022/assets/image-20220721203819057.png" alt="image-20220721203819057" /></p>
<p><img src="weekly/2022/assets/image-20220721203855279.png" alt="image-20220721203855279" /></p>
<h2 id="世界地图"><a class="header" href="#世界地图">世界地图</a></h2>
<table><thead><tr><th>比例失调的世界地图</th><th>真实比例的世界地图</th></tr></thead><tbody>
<tr><td><img src="weekly/2022/assets/image-20220722074000799.png" alt="image-20220722074000799" /></td><td><img src="weekly/2022/assets/image-20220722074019719.png" alt="image-20220722074019719" style="zoom:67%;" /></td></tr>
</tbody></table>
<h2 id="两个段子"><a class="header" href="#两个段子">两个段子</a></h2>
<ol>
<li>跑步的多巴胺仅次于谈恋爱 三公里专治各种不爽，五公里专治各种内伤，十公里跑完内心全是坦荡和善良</li>
<li><img src="weekly/2022/assets/FnqUNciaRL8wQ2HKlX6ya4_6aT_sv3.jpg" alt="FnqUNciaRL8wQ2HKlX6ya4_6aT_sv3.jpg" /></li>
</ol>
<h2 id="一个免费的内网穿透工具"><a class="header" href="#一个免费的内网穿透工具">一个免费的内网穿透工具</a></h2>
<p><a href="https://github.com/ekzhang/bore">bore.pub</a> 一个命令行工具，将本地端口映射到远程服务器上的端口。很好用，但是速度很慢。</p>
<pre><code class="language-shell"># 将本地的 8000 端口暴露到公网，命令
bore local 8000 --to bore.pub

# 得到一个 bore.pub 指定的访问端口
# 2022-07-22T09:18:57.311562Z  INFO bore_cli::client: connected to server remote_port=38611
# 2022-07-22T09:18:57.311591Z  INFO bore_cli::client: listening at bore.pub:38611
# 访问 bore.pub:38611 即可访问本地 8000 端口
</code></pre>
<p>原理如下：</p>
<p><img src="weekly/2022/assets/image-20220723083245946.png" alt="image-20220723083245946" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week---30"><a class="header" href="#week---30">week - 30</a></h1>
<p>[TOC]</p>
<h2 id="一个观点"><a class="header" href="#一个观点">一个观点</a></h2>
<p>钱这个东西，对有些人是为糊口，对有些人是为了享乐，对有些人是为了证明价值。</p>
<p>如果用短短的一生，只为了钱活着，反而成了奴隶，这个东西，毕竟生不带来，死不带走。</p>
<h2 id="一部电影隐入尘烟"><a class="header" href="#一部电影隐入尘烟">一部电影「隐入尘烟」</a></h2>
<p>讲述西北农民的故事，全片除了女主海清，其他演员全是农民。</p>
<p>真实、残酷，又浪漫。</p>
<p>主流媒体对农村的态度，就像房间里的🐘：沉默，失声，选择性失明。</p>
<p><img src="weekly/2022/assets/image-20220724201905672.png" alt="image-20220724201905672" /></p>
<p><img src="weekly/2022/assets/image-20220724201855543.png" alt="image-20220724201855543" /></p>
<p><img src="weekly/2022/assets/image-20220724201914054.png" alt="image-20220724201914054" /></p>
<p><img src="weekly/2022/assets/image-20220724201919337.png" alt="image-20220724201919337" /></p>
<p><img src="weekly/2022/assets/image-20220724201927709.png" alt="image-20220724201927709" /></p>
<p><img src="weekly/2022/assets/image-20220724201933289.png" alt="image-20220724201933289" /></p>
<h2 id="相信未来不要离开"><a class="header" href="#相信未来不要离开">相信未来，不要离开</a></h2>
<p><img src="weekly/2022/assets/image-20220724202650416.png" alt="image-20220724202650416" /></p>
<h2 id="空笔芯"><a class="header" href="#空笔芯">空笔芯</a></h2>
<p>一支笔芯用了两年才写完，想起考研结束的时候，光是空笔芯，就攒了一盒。</p>
<p>你最近的一支笔芯用了多久？</p>
<p><img src="weekly/2022/assets/image-20220725111924125.png" alt="image-20220725111924125" /></p>
<h2 id="vscode-两个插件"><a class="header" href="#vscode-两个插件">vscode 两个插件</a></h2>
<ul>
<li>
<p><a href="https://marketplace.visualstudio.com/items?itemName=pomdtr.excalidraw-editor">excalidraw vscode</a></p>
<p>在 vscode 中画图，画图源文件还能保存到本地。完美解决了 excalidraw 需要付费的问题。</p>
<p><img src="weekly/2022/assets/image-20220725195940103.png" alt="image-20220725195940103" /></p>
</li>
<li>
<p><a href="https://marketplace.visualstudio.com/items?itemName=cweijan.vscode-typora">typora vscode</a></p>
<p>在 vscode 中集成 typora，markdown 所见即所得。也完美解决了 typora 的付费问题。</p>
<p><img src="weekly/2022/assets/image-20220725200548354.png" alt="image-20220725200548354" /></p>
</li>
</ul>
<p>我会使用一段时间 typora vscode，如果没有问题，那么 vscode 将覆盖我平时工作学习中几乎所有的使用场景。</p>
<h2 id="光荣在于平淡-艰巨在于漫长"><a class="header" href="#光荣在于平淡-艰巨在于漫长">光荣在于平淡 艰巨在于漫长</a></h2>
<p><img src="weekly/2022/assets/image-20220726133508382.png" alt="image-20220726133508382" /></p>
<h2 id="污水监测的一种应用"><a class="header" href="#污水监测的一种应用">污水监测的一种应用</a></h2>
<p>消费量越高的城市，夜生活也相对越丰富。</p>
<p><img src="weekly/2022/assets/image-20220726211526239.png" alt="image-20220726211526239" /></p>
<h2 id="人与自然"><a class="header" href="#人与自然">人与自然</a></h2>
<p><img src="weekly/2022/assets/image-20220726211611383.png" alt="image-20220726211611383" /></p>
<h2 id="只争朝夕"><a class="header" href="#只争朝夕">只争朝夕</a></h2>
<p>最近冲浪发现一个观点，人生不过短短几万天，当成一场旅途就行了。</p>
<p>才几万天，某乎人均年薪都百万了，人只能活短短几万天，真的太短了。</p>
<p>想起主席的一首词：</p>
<pre><code>满江红

小小寰球，有几个苍蝇碰壁。
嗡嗡叫，几声凄厉，几声抽泣。
蚂蚁缘槐夸大国，蚍蜉撼树谈何易。
正西风落叶下长安，飞鸣镝。
多少事，从来急；
天地转，光阴迫。
一万年太久，只争朝夕。
四海翻腾云水怒，五洲震荡风雷激。
要扫除一切害人虫，全无敌。
</code></pre>
<h2 id="二舅火了"><a class="header" href="#二舅火了">二舅火了</a></h2>
<p>我，二舅，打钱！</p>
<p><img src="weekly/2022/assets/image-20220729081436681.png" alt="image-20220729081436681" /></p>
<p>这是我这几天来看到的一个唯一正常的观点。大佐明白人。视频本就是传达一种积极向上的人生态度，知乎上却一边倒的从苦难着笔，非蠢即坏。</p>
<p><img src="weekly/2022/assets/image-20220729081544291.png" alt="image-20220729081544291" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-31"><a class="header" href="#week-31">week-31</a></h1>
<p>[TOC]</p>
<h2 id="凝望深渊"><a class="header" href="#凝望深渊">凝望深渊</a></h2>
<p><strong>唐山烧烤店打人事件对你内心的冲击有多大？</strong></p>
<p>过去十年系统性的互联网舆论审查，带来了一个连审查者自己都没想到的结果：</p>
<p><strong>民众心态的婴儿化和圣人化。</strong></p>
<p>从一些题材不能提及到连血液都要改成绿色，审查为几亿人构建了一个几乎完全洁白无瑕的世界。但他们大概没想到：**当他们用圣人标准要求民众时，民众也会反过来用圣人标准要求他们。**你的新闻里几乎没有恶性犯罪，那我就要你的治下连一起打架斗殴案都不能有；你的影视题材里警察都是好人，那我就相信你现实中的警察人人夏洛克人人任长霞。</p>
<p>这些在互联网时代成长起来的一代人，他们不知道 90 年代的车匪路霸打死有奖时代，他们没经历过广东部分交警持枪上街和飞车党真人 GTA，他们不知道下夜班女工被奸杀在那些年就值晚报上一个豆腐块意味着什么。</p>
<p>为什么？因为没人告诉他们，因为审查不高兴提过去那段历史；</p>
<p>好，你不提，那我就相信你说的太平盛世是自古以来就这样。</p>
<p>那现在，年轻女孩在大排档被混混打了，你怎么说？</p>
<p>当圣人的形象瞬间崩塌时，破防的小年轻们很自然就倒向另一个方向：</p>
<p>原来我们的治安没那么好——那我们的治安一定全球最烂；</p>
<p>别不信，那两天我真见过有小姑娘在朋友圈说准备润美国，美国治安差都是政治宣传 balabala……</p>
<p>审查希望一代人生活在一个他们营造出来的天国里；</p>
<p>但这个天国本来就是「不正常」的；</p>
<p>当「不正常」在现实面前暴露出一丁点「正常」时；</p>
<p>那些温室里的小年轻就集体破防了。</p>
<p>所以这其实是个好事。对双方都是。</p>
<p>审查应该趁早认识到打造地上天国是不可能的；</p>
<p>而小年轻也开始踏出真正了解这个国家的第一步了。</p>
<p>可喜可贺，可喜可贺。</p>
<p>作者：匿名用户
链接：https://www.zhihu.com/question/537174003/answer/2576392923
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="苏联笑话生成器"><a class="header" href="#苏联笑话生成器">苏联笑话生成器</a></h2>
<p><a href="https://disksing.com/sao-gen-gen/3">苏联笑话生成器</a></p>
<p>原来笑话也是有模板，可以批量生成的😎</p>
<p><img src="weekly/2022/assets/image-20220802081404027.png" alt="image-20220802081404027" /></p>
<h2 id="玻璃晴朗-橘子辉煌"><a class="header" href="#玻璃晴朗-橘子辉煌">玻璃晴朗 橘子辉煌</a></h2>
<p>北岛</p>
<p>毒蛇炫耀口中的钉子
大地有著毒蛇
吞吃鸟蛋的寂静
所有钟表
停止在无梦的时刻
丰收聚敛着
田野死后的笑容
从水银的镜子出发
影像成双的人们
乘家庭的轮子
去集市
一位本地英雄
在废弃的停车场上
唱歌
玻璃晴朗
桔子辉煌</p>
<h2 id="山东临沂大爷"><a class="header" href="#山东临沂大爷">山东临沂大爷</a></h2>
<p>熊二是连云港赣榆人，风俗习惯靠近山东，看到这道菜格外亲切。</p>
<p><img src="weekly/2022/assets/image-20220804073132870.png" alt="image-20220804073132870" /></p>
<h2 id="好代码的比喻"><a class="header" href="#好代码的比喻">好代码的比喻</a></h2>
<p>好的代码应该像一颗洋葱，外面看起来是一个整体，但是内部层次分明，每一层都能被轻轻剥离。</p>
<p>当你写一个类，一个方法，甚至是一段语句的时候，要时刻问自己，现在你在哪一层，自己即将新增的代码，是不是正好符合这一层的行为和特征，不多，不少。</p>
<h2 id="sqlite-背后的故事"><a class="header" href="#sqlite-背后的故事">SQLite 背后的故事</a></h2>
<p><a href="https://liyafu.com/2022-07-31-sqlite-untold-story/">SQLite 背后的故事</a></p>
<p>SQLite 诞生的契机就是典型的程序员开发的故事剧本。作者 Richard 最开始在一艘军舰上做 contractor（就是我们说的外包）。他们程序跑在军舰安装的电脑上，电脑上装的是 informix。Richard 的工作就是把 informix 的数据拿出来进行计算然后展示到电脑屏幕上（这和我们今天的 CRUD 工作类似）。比较令人恼火的是 informix 很不稳定，经常崩溃连不上。部队里的铁拳长官可不懂啥 TCP/IP 或者数据库系统知识。他们只看到软件的报错 dialog（对话框） 经常弹出来，而这个 dialog 又是 SQLite 的作者 Richard 写的软件画出来的，锅自然从天而降。于是 Richard 决定自己从头写一个无需外部连接的数据库来解决这个问题。</p>
<p>当时恰逢布什政府消减政府预算， Richard 作为外包商没法获得订单，不得不暂停在军舰上的开发。这让 Richard 有了几个月的时间去构思并从头实现 SQLite。那时时间是 2000 年初，软件开发没有现在这么多参考资料，没有维基百科，google 还没完全起来， 美国只有 1% 家庭有宽带。 而 Richard 也没有数据库开发经验，只有编译器开发经验。他最初的构想非常简单，把每条 sql 语句看成一个独立的执行程序。于是他首先实现了 bytecode 执行器，然后把 sql 语句转化成 bytecode 执行。一开始 SQLite 并没有替换掉他们在军舰上的 informix，尽管他们每个开发者都恨透了 informix，但客户指定要用又不得不继续使用（好熟悉的场景）。就这样 SQLite 一直做为 Richard 的 side project 在开发。</p>
<p>。。。</p>
<p>Richard 提到了他是如何在完全不懂数据库的情况下把 SQLite 做出来的。他提到这是第一性原理(first principle)的应用。简单来说就是按照事物本来的样子去设计。他说做数据库的人和组织非常多，但最后的结果大家都殊途同归。用不同的做事方式最后都达到同样的结果。还有些趣事是他也不懂 B 树，需要用到的时候还得去翻看 The Art of Computer Programming（计算机程序设计艺术）。并且 Knuth 的书连 B 树的 delete 删除的算法都没提供，被做为练习题让读者自己去实现。</p>
<h2 id="太阳能协议"><a class="header" href="#太阳能协议">太阳能协议</a></h2>
<p>摘自<a href="https://www.ruanyifeng.com/blog/2022/08/weekly-issue-217.html">科技爱好者周刊（第 217 期）</a></p>
<p><a href="http://solarprotocol.net/index.html">太阳能协议</a></p>
<p>数据中心的耗电巨大，很多国家正在设法采用太阳能为机房供电，但有一个难题：夜间的网络使用量最高，偏偏这个时候没有太阳能。</p>
<p>一组美国的研究人员提出了&quot;太阳能协议&quot;：网站同时部署在世界各地的服务器上，这些服务器都由太阳能供电，流量总是自动切换到白天时区的服务器，这样就能保证一天24小时的太阳能供电。</p>
<p>它的技术实现很简单，就是让 DNS 总返回一个太阳能供电的 IP 地址。</p>
<p><img src="weekly/2022/assets/bg2022062802.webp" alt="img" /></p>
<h2 id="中文互联网---粪坑"><a class="header" href="#中文互联网---粪坑">中文互联网 -&gt; 粪坑</a></h2>
<p>打开微博，知乎，微信群，满屏都是消极和负面消息，让我很焦虑。</p>
<p>最近开始尝试开始戒网了，不知道能不能成功。</p>
<p>有以下尝试：</p>
<ul>
<li>
<p>卸载微博，知乎，有猎奇心理，就上 Quora，需要看新闻，算了，现在也没啥值得看的新闻，前两天刚被耍猴</p>
<p>国外论坛的环境，还是相对比较和谐的，没那么焦虑</p>
<p><img src="weekly/2022/assets/image-20220806104233650.png" alt="image-20220806104233650" /></p>
</li>
<li>
<p>用 RSS + Inoreader 来订阅自己关注的大V和观点</p>
<p><img src="weekly/2022/assets/image-20220806104221236.png" alt="image-20220806104221236" /></p>
</li>
<li>
<p>关闭朋友圈，不看朋友圈，也不发朋友圈</p>
<p>专注自己的生活。</p>
</li>
</ul>
<p>不立太多 flag，先坚持这么多吧。</p>
<h2 id="哪些城市在裸泳"><a class="header" href="#哪些城市在裸泳">哪些城市在裸泳</a></h2>
<p><img src="weekly/2022/assets/v2-1a041f965c53085b540d90b722a625a5_r.jpg" alt="img" /></p>
<p><img src="weekly/2022/assets/108.jpg" alt="img" /></p>
<h2 id="关于社恐的一个观点"><a class="header" href="#关于社恐的一个观点">关于社恐的一个观点</a></h2>
<p>据我观察所谓社恐的人，个顶个都是脑子里只有人上人思维的家伙。</p>
<p>只要和他人接触，默认就是要比，比不过就难受。又因为这种思维方式是全方位占据大脑的，导致他们每次接触人都是输。</p>
<p>比如看到一个街溜子，刚来点自信，发现街溜子女朋友们非常好看，立刻就萎了。又比如看到一个纯撸瑟，正自信爆棚要嘲讽几句，却发现卢瑟比他开心一百倍，马上就怒不可遏。</p>
<p>别人有钱他羡慕，别人帅他嫉妒，别人开心他愤怒。</p>
<p>父母教育有很大关系，那些整天你看这个你比那个的家长只能教出这种扭曲的恶心怪胎，内卷严重的地区这种怪胎比例就大。</p>
<p>作者：手撕狗肉
链接：https://www.zhihu.com/question/359104641/answer/2617029360
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="三十年河东-三十年河西"><a class="header" href="#三十年河东-三十年河西">三十年河东 三十年河西</a></h2>
<p>以前软件吃香，现在硬件吃香，可惜软件能速成，硬件可速成不了。</p>
<p><img src="weekly/2022/assets/image-20220809141926780.png" alt="image-20220809141926780" /></p>
<h2 id="如何让自己变得开心起来"><a class="header" href="#如何让自己变得开心起来">如何让自己变得开心起来？</a></h2>
<p>如何让自己变得开心起来？ - nell nell的回答 - 知乎 </p>
<p>https://www.zhihu.com/question/20657503/answer/2554785917</p>
<p>想体验极致的快乐，就得体会极致的痛苦，没有痛苦做比较，哪来的快乐呢？想起来王德峰老师讲的一句话，如果这个世界上只有一种颜色红色，那么人们是不认识红色的？想要知道什么是红色，必须有其他颜色来和红色做比较，想要了解快乐，需要痛苦来比较。</p>
<h2 id="闻多素心人-乐与数晨夕"><a class="header" href="#闻多素心人-乐与数晨夕">闻多素心人 乐与数晨夕</a></h2>
<p><img src="weekly/2022/assets/image-20220811074110523.png" alt="image-20220811074110523" /></p>
<h2 id="5g-观点"><a class="header" href="#5g-观点">5G 观点</a></h2>
<p><a href="https://www.ithome.com/0/634/120.htm">专家：现在还没有真正的 5G 应用，运营商逼迫用户升级 5G 不是商业正路</a></p>
<p>8 月 9 日下午消息，在世界 5G 大会的元宇宙论坛上，北京航空航天大学软件学院创始院长、贵州盛华职业学院创始人及院长孙伟发表主题演讲。他指出，5G 目前面临着巨大挑战。5G 建设我国已经投入了上万亿元，全球第一；还要继续投入上万亿元，继续全球第一；华为等公司的 5G 技术和专利授权领先全球，全球第一。</p>
<p><strong>但现在完全没有 5G 应用</strong>，他认为，5G 应用应当定义为 4G 下无法平滑运营，必需 5G 带宽服务的应用。</p>
<p>5G仅有的两个受益者：菊厂和何同学。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-32"><a class="header" href="#week-32">week-32</a></h1>
<p>[Toc]</p>
<h2 id="蒸汽波图片在线制作"><a class="header" href="#蒸汽波图片在线制作">蒸汽波图片在线制作</a></h2>
<p><a href="https://magiconch.com/vaporwave/?from=github">蒸 気 機</a></p>
<p><img src="weekly/2022/assets/image-20220813090303947.png" alt="image-20220813090303947" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-33"><a class="header" href="#week-33">week-33</a></h1>
<p>[TOC]</p>
<h2 id="带逛知乎"><a class="header" href="#带逛知乎">带逛知乎</a></h2>
<h3 id="关于中金交易员被老婆坑"><a class="header" href="#关于中金交易员被老婆坑">关于中金交易员被老婆坑</a></h3>
<p>几十年来我最少认识上百对夫妻，即便有的夫妻表面看起来差异很大，比如相貌，比如年龄，比如学历，比如收入，比如家境，但有个深层次的东西差异不大，就是对欲望的认知和把控。 说个最极端的例子，一个漂亮女孩因为钱嫁给比她大的多的有钱男人，一个是对钱的欲望，一个是对色的欲望，这两个欲望是对等的，甚至量级都是一样的。 所以我从来不认为一个糟糕的老婆会有一个完美的老公，如果她老公以完美的姿态出现，那我一定会非常小心的防范，因为他身上一定笼罩着厚实的谎言。 因为这个原因，我特别喜欢认识夫妻两个人，认识一个后尽量认识他的伴侣，两个人同时保守一个谎言的难度很大，我就能更好的认清他们。 婚姻伊始的匹配非常重要，也非常有趣，它最后一定是鱼找鱼虾找虾，即便外人看上去有可能差异巨大。 </p>
<p><strong>找到一个好的伴侣，办法只有一个，就是自己也是个好的伴侣。</strong></p>
<p>中金交易员被老婆坑了 还会用什么样的心态面对他老婆呢？ - 请勿关注的回答 - 知乎 https://www.zhihu.com/question/546113007/answer/2602995471</p>
<h3 id="体制内与体制外"><a class="header" href="#体制内与体制外">体制内与体制外</a></h3>
<p>中国人民大学博士教授储殷直播表示年轻人想留在大城市体制内五六千就够，体制外起码得一万五，你怎么看？ - 老杨叔聊志愿填报的回答 - 知乎 https://www.zhihu.com/question/548217862/answer/2627496782</p>
<p>储殷汇率：1公务员币＝3牛马币。</p>
<h3 id="哪一刻你意识到阅读这件事依然无可替代"><a class="header" href="#哪一刻你意识到阅读这件事依然无可替代">哪一刻你意识到，阅读这件事依然无可替代？</a></h3>
<p>作者：吹面不寒
链接：https://www.zhihu.com/question/528045763/answer/2625076704
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>有太多时刻，都让我意识到，阅读依然无可替代。</p>
<p>比如说，填补想象力缺口这件事。</p>
<p>在这个世界上，我们绝大多数人的轨迹其实是相同的，然而阅读却能让普通人，拥有更多人生厚度的可能。</p>
<p>在阅读中，我们可以短暂地摆脱自己枯燥的生活，在作者为我们建构的宏大世界中，去探险，去体验，去感知一千种不一样的人生。</p>
<p>原来还有那么多的绝妙故事，有那么多的厚重历史。还存在着这样一种生活方式，如此风姿，如此洒脱。</p>
<p>那些你一辈子可能不曾踏足的场景，都能在文字中被一一呈现。</p>
<p>很多人说读完一本书或是一篇长文，总是很快就忘了。就像是拿着竹篮去打水，无论打多少次，都是空手而归。</p>
<p>因而，阅读是没有意义的。</p>
<p>但是我想告诉你的是，一个人长期阅读，即便可能不会记住什么，但在潜意识里总会明白什么是对，什么是错。</p>
<p>读书最重要的是，教会我们独立思考的能力，不会成为乌合之众。</p>
<p>即便不随从众人，也不会惴惴不安。</p>
<p>有时候，我们和文化层次低的人聊天十分困难，岁数越大越是。不是他们不知道对错，而是他们不愿意，变通熟知了几十年的观点。</p>
<p>在阅读中，你可以去体察人性，去感知世间的罪恶，去找寻心中的污秽，然后理清自身的情绪及种种关系的本质。</p>
<p>阅读给予我们的，不是鄙视他人的傲气，而是直面现实的勇气。</p>
<p>以前，读书对我而言，是件虚荣心的事。曾以为阅读的数量多了，自己就博学了，时光就不虚度了。</p>
<p>后来了解到，读书并不是为了炫耀什么，赢得别人的认同，而是与作者的思维碰撞，或是说情感共鸣。</p>
<p>其实，哪怕我们一年只读一本书，但只要这本书里，有能够影响到你的内容，就足够了。</p>
<p>读书，不会使你光鲜亮丽，也未必能让你取得成功，甚至无法在为你找工作时，提供任何便利。</p>
<p>但当你被生活打回原形，陷入泥潭时，文字总能给你一些内在的力量，让你消解自身的苦难。</p>
<p>即便深陷谷底，也能抬头仰望星空。</p>
<p>仰望星空，让你内心笃定，在寻常中丰满却不自满。</p>
<p>若你心境澄澈，你将永远热爱生活。</p>
<p>书读多了，思维开阔，自然有了一种隐然的气场，这是一种自信。</p>
<p>但这不是书本的作用，而是思考；又或者说不是思考的作用，而是主见。</p>
<p>胸中有丘壑的人，总是格外清楚知道，自己该做什么。</p>
<p>在如今这个浮躁的时代，充斥着短视频、自媒体情绪热文，能够静下心来在知乎，长文阅读已是十分难得。</p>
<p>那些喜爱阅读的人，往往都是耐心，富有同理心的人。他们有着清醒的认知，对世间万物保持着悲悯。</p>
<p>即便长期独处，也能够内心安宁详实。</p>
<p>年少的时候，我最渴望的事就是，能有许多的书。这个自小养成的习惯，即便在我最难以糊口的岁月，也没中断。</p>
<p>可悲的是现在，当我有了稳定而体面的生活之后，却难再有一次酣畅淋漓的阅读体验了。书多了，时间却没了。</p>
<p>长大后，我接触到了太多优秀的人，逐渐迷失了自我，变得容易浮躁、焦虑，感受到了许多说不清的压力。</p>
<p>于是，我的认知变成了，我要跟上他们的步伐，我不能浪费我的时间，我要挣很多的钱……</p>
<p>所以时至今日，我依旧羡慕那些，能够耐下心来纯粹阅读的人。我的读书岁月，早已随着我的成长渐行渐远了，而我也已没了当初的快乐。</p>
<p>我记得小时候，我总喜欢搬个小板凳，翘着二郎腿坐在巷子门前，手里捧着书，脚下睡着大黄狗。</p>
<p>风从远处稻田里吹来，带来成熟的谷物气息。红彤彤的太阳即将落山，在那一排排挤密的庄稼地里，我听见了林野里，各种鸟雀儿咕嘎咕嘎的叫。</p>
<p>文字能把人牵得很远，仿佛置身于广袤的原野。</p>
<p>后来，直到月亮升起，姥爷前来喊我，我还沉浸在文字的世界里……那种身心俱迷的情景尤在眼前，宛如那个不曾流转的夏天。</p>
<p>我拍了拍衣服上的尘土，屁股一扭一扭的回家了。</p>
<p>真他妈怀恋啊。</p>
<h3 id="计算机硕士"><a class="header" href="#计算机硕士">计算机硕士</a></h3>
<p>既然计算机硕士大部分都干开发那硕士白读了吗？工作比当科研奴隶收益大？ </p>
<p>The Alpha的回答 - 知乎 https://www.zhihu.com/question/520418301/answer/2598574802</p>
<p>哈哈哈有些人装什么外宾呢。去读研有多少人是真的想搞科研的？去读了又有什么真科研能给你个小瘪三做？还不是因为本科能干的活卷到不要本科生，倒逼学生去读研？你往前推7-10年，客户端点击就送，后端无八股，前端无框架。你就算是培训班手攥着PHP入行，撑到19年完整吃下整波红利也该是3w一个月了。那个时代你让大家去读研？读什么研，外面有金子有银子我不去捞你让我读书？你疯了还是我疯了。经济一下滑研究生就开始扩招，考研率开始蹭蹭涨，也不带这么凑巧的吧？我不否认大学学者的价值，但你要说每年招100w个研究生去搞科研，抱歉我觉得这太扯了。</p>
<h3 id="知道得越多距离真相越远"><a class="header" href="#知道得越多距离真相越远">知道得越多，距离真相越远</a></h3>
<p>因为我经常写一些三四十年前的事，六七十岁的人，写的时候没觉得怎样，但写的多了，得到的评论多了之后，我发现一个问题，或者说一个现象。</p>
<p>就是最近这四十年因为教育和信息获取的便捷，大量这四十年里出生的人知识非常丰富，知道的东西非常多。</p>
<p>但是可能有一些小问题，就是这四十年跟之前断层的过于严重，导致有相当一部分人，因为知识丰富反而导致了认知局限。</p>
<p>我觉得是两个问题，一是以现在的认知理解以前的人和事，以自己的经验去揣摩以前的人和事。</p>
<p>二是用被总结的或被归总的知识去解读问题，判断情况。</p>
<p>这里还包括地域上的认知局限，比如一说北京的房价绝大多数人知道的都是商品房的价格，而不知道商品房只是北京众多产权类型中的一种，因为产权清晰才被广泛认知，而数量庞大的其他产权形式的房没人知道价值和可交易情况，北京有太多房子是无法正常交易或无法用商品房价格交易的房子。</p>
<p>知乎上和很多平台上都有大量回到以前会怎么样的问题，把太多人的认知扭曲了，变成了所谓的爽文，很少有回答是考虑当时人的认知水平和环境的，这对真正了解当时的历史是很大的伤害。</p>
<p>所以远离爽文，不要用爽文的视角认知过去的人和事，才能真正了解历史，当然更不用爽文的角度去生活，那是对自己的伤害。</p>
<p>来自知乎答主：请勿关注</p>
<h3 id="认清现实放弃幻想"><a class="header" href="#认清现实放弃幻想">认清现实，放弃幻想</a></h3>
<p>今晚散步的时候，跟我儿子探讨了一个问题，就是中国在古代世界的地理位置，中国人自己的看法，还有其他文明的看法。</p>
<p>其实这是个没有标准答案的问题，中国人从古至今都是坚定的认为中国是居世界之中的，甚至名字都叫中央之国的中国，但在我看来，中国一直都在古代文明大陆的边缘，中心应该是土耳其到中东一代。</p>
<p>因为海洋和高山，荒漠，我们跟其他文明之间是很疏远的，相互很陌生的，最多就是互相有一些使节，离全面了解差的很远。</p>
<p>要命的是中国自古以来的生存压力不大，跟其他文明相比都小的多，没有任何进步的压力，也没有探索更大时间的迫切。</p>
<p>相比来说欧洲及周边才是修罗场，毁灭级别的碰撞太多了，生存压力太大了，逼的他们不得不进步，不得不产生工业革命。</p>
<p>我们去过很多博物馆都看到过一个大事的记录，就是马戛尔尼见乾隆，我们对这个事既重视又不太重视，因为在我看来那是世界在几千年来第一次认清中国，是可以从世界史角度给中国历史分期的标志，那一刻，中国真正成为了世界的一员，即便我们不愿意，也不自知。</p>
<p>之所以今天说这些，就是之前看过大量博物馆实物，但串不到一起，还是要多去，多讲。</p>
<p>作者：请勿关注
链接：
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="穷极一生追求的是什么"><a class="header" href="#穷极一生追求的是什么">穷极一生追求的是什么</a></h3>
<p>许三多：好好活就是做有意义的事，有意义的事就是好好活。</p>
<p>我们穷极一生，究竟追寻的是什么？ - 知乎 https://www.zhihu.com/question/384441334/answer/2596104794</p>
<h2 id="马斯克早晨醒来就看手机是个坏习惯"><a class="header" href="#马斯克早晨醒来就看手机是个坏习惯">马斯克：早晨醒来就看手机是个坏习惯</a></h2>
<p><a href="https://www.ithome.com/0/634/991.htm">早晨醒来就看手机是个坏习惯，我希望先去锻炼</a></p>
<p>马一龙终于说了一句实话。</p>
<h2 id="能力被动型人才"><a class="header" href="#能力被动型人才">能力被动型人才</a></h2>
<p>有些人一切以“<strong>我当前所掌握技术和能力为标准</strong>“来判断事情难度。 我管这类人叫“能力被动型员工“。被动型人水平也有高有低。较高水平的这类人很可能在之前某个人生阶段（比如聪明，大学被逼，年轻心态开放情况下）习得的知识和技术。但因为是被动型，非发展性人格，所以到了30之后会逐步走下坡路。</p>
<p>合格技术管理者和员工针对一个技术问题的沟通中，很容易发现“能力被动型员工”。这时候管理者心里会默默给你一个标签。以后只会选择你能力之内的工作给你。合理的使用你，只让你辛苦，不让你那么痛苦。由于你一直困在“当前这一秒我会的东西是最高难度“，也接触不到更多更新更难的事情。接触了也无心无力奋争解决。 能力也不会提高。 所以你和一个原地拉磨的驴子很像。体力耗光，也就卸磨杀驴了。</p>
<p>技术人都有发展自身能力和技术的倾向。主观上，如果你不是做一天和尚撞天钟，你肯定不认可自己是能力被动型。 但有种学习的障碍，自己被自己知道的东西困住了。你认为的极限真的就是你自己的极限，和这个技术问题的极限吗？据我十几年的观察，多数情况下并不是。 另外，工程实际是解决问题，不是用完美或者自认为满意的方法解决问题。这需要特别灵活的头脑。工程思维，和钻研理论与技术，用的是不同的思路。这种思维转换对很多技术人员有困难。久而久之，自己被自己耽误了。丧失了很多机会去突破自己的极限。</p>
<p>这种思维习惯不限于技术人员。一切靠一项技能吃饭的人，都会存在。如果这类人目光还短，只盯着眼前鸡毛蒜皮的小利，想不到5年到15年以后自己长期利益。那下场就更惨。这个和看工资待遇不矛盾。你既要看现在的待遇，也要看当前其他公司的更好待遇机会。更要去想5年或者15年以后的工资待遇。</p>
<p>软件技术人员的瓶颈，为35岁之后做准备 - 姚勇的文章 - 知乎 https://zhuanlan.zhihu.com/p/498762187</p>
<h2 id="今日长缨在手何时缚住苍龙"><a class="header" href="#今日长缨在手何时缚住苍龙">今日长缨在手，何时缚住苍龙？</a></h2>
<p>清平乐·六盘山</p>
<p>天高云淡，
望断南飞雁。
不到长城非好汉，
屈指行程二万。
六盘山上高峰，
红旗漫卷西风。
今日长缨在手，
何时缚住苍龙？</p>
<p>— 毛泽东</p>
<h2 id="强大的哔哩哔哩增强脚本"><a class="header" href="#强大的哔哩哔哩增强脚本">强大的哔哩哔哩增强脚本</a></h2>
<p><a href="https://github.com/the1812/Bilibili-Evolved">Bilibili-Evolved</a></p>
<p><img src="weekly/2022/assets/about-panel.jpg" alt="about-panel" /></p>
<h2 id="股票的一个观点"><a class="header" href="#股票的一个观点">股票的一个观点</a></h2>
<p>回看一下股票账户，如果波动过大，即盈利或者亏损以月为单位统计震动幅度比较大，一定意义上来说 还是在靠运气参与投资，和赌博的性质差不多。</p>
<p>目标是要减少账户的大范围波动，一定程度上来说大幅波动比稳定亏钱更严重，而后者对于自己复盘，形成交易逻辑是非常有帮助的。</p>
<h2 id="凝望深渊-1"><a class="header" href="#凝望深渊-1">凝望深渊</a></h2>
<p>最近对「你在凝望深渊时，深渊也在凝视你」有了更深的体会。</p>
<p>社会越来越割裂，网络充斥着戾气。通过鄙视链获得优越感的人，也终将在被人瞧不起时，体会到痛苦。</p>
<h2 id="不说话的嘉陵江"><a class="header" href="#不说话的嘉陵江">不说话的嘉陵江</a></h2>
<p>这里没有大海，只有一条不说话的嘉陵江。</p>
<p><img src="weekly/2022/assets/21a4462309f790529f6262245b2618c07acbd58e.jpeg" alt="img" /></p>
<h2 id="根据名字判定性别"><a class="header" href="#根据名字判定性别">根据名字判定性别</a></h2>
<p>github: <a href="https://github.com/observerss/ngender">NGender</a> 用朴素贝叶斯公式解决问题的一个很有趣的例子。</p>
<pre><code class="language-shell">$ ng 赵本山 宋丹丹
name: 赵本山 =&gt; gender: male, probability: 0.9836229687547046
name: 宋丹丹 =&gt; gender: female, probability: 0.9759486128949907
</code></pre>
<p>贝叶斯公式: <code>P(Y|X) = P(X|Y) * P(Y) / P(X)</code></p>
<p>当X条件独立时, <code>P(X|Y) = P(X1|Y) * P(X2|Y) * ...</code></p>
<p>应用到猜名字上</p>
<pre><code>P(gender=男|name=本山) 
= P(name=本山|gender=男) * P(gender=男) / P(name=本山)
= P(name has 本|gender=男) * P(name has 山|gender=男) * P(gender=男) / P(name=本山)
</code></pre>
<h2 id="vimium-像-vim-一样操作浏览器"><a class="header" href="#vimium-像-vim-一样操作浏览器">Vimium 像 vim 一样操作浏览器</a></h2>
<p><a href="https://github.com/philc/vimium">Vimium</a>，一款 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">download</a>，用 vim 的方式操控浏览器（不用鼠标）。</p>
<p><a href="https://sspai.com/post/27723">让你用 Chrome 上网快到想哭：Vimium</a></p>
<h2 id="高温表情包"><a class="header" href="#高温表情包">高温表情包</a></h2>
<p><img src="weekly/2022/assets/image-20220819132634929.png" alt="image-20220819132634929" /></p>
<p><img src="weekly/2022/assets/image-20220819132641932.png" alt="image-20220819132641932" /></p>
<h2 id="一位-up-的考研生活"><a class="header" href="#一位-up-的考研生活">一位 up 的考研生活</a></h2>
<p><img src="weekly/2022/assets/image-20220819132703958.png" alt="image-20220819132703958" /></p>
<h2 id="雷军-2022-年度演讲"><a class="header" href="#雷军-2022-年度演讲">雷军 2022 年度演讲</a></h2>
<p><a href="https://www.sohu.com/a/576060273_358836">雷军2022年度最新演讲：熬过绝望低谷，你便无人能敌 </a></p>
<blockquote>
<p>那一年，我26岁。我是北京金山的总经理，第一次面临这样的情况，有点束手无策，尤其是每个月发工资的那几天，都觉得特别难熬。</p>
<p>最惨的一个月，账上只有十几万人民币。连发下个月的工资都非常困难，那段时间我经常失眠，经常一宿一宿的睡不着。</p>
<p>我还记得有好多个晚上，我独自坐在沙发上，看着对面的楼里的灯光，一盏一盏的熄灭，再看到天色一点一点的亮起来，其实这种痛苦只有经历过的人才能很深的明白吧。</p>
</blockquote>
<blockquote>
<p>我觉得自己懂技术，特别想把技术给客户讲清楚，如果人家有不同意见，我还跟人家抬杠，总之“我一定要说服你，不买产品都没关系，这道理咱们一定得给说明白了”，就特别较真。</p>
<p>我后来在想，我看他卖的时候不是这么做的，他拿一个软件的包装，拿一张宣传页，几句话就把用户说明白了，实在不行，还有电脑给你演示一下就搞定了。</p>
<p>其实，我们做销售的目的，不是为了给用户把道理讲明白，关键要让用户能够很舒服地的接受。 这个金牌销售，他跟用户交流就特别轻松自如。</p>
</blockquote>
<blockquote>
<p>1996年，电脑刚刚开始普及。我在店里的时候， 每天都有几个用户来问我，有没有电脑入门的软件。</p>
<p>我就想不通了，学电脑买本书就学了，为什么还要买个软件来教？我总是不厌其烦的劝阻用户，说真的没有这样的软件，要不你出门左转有个书店，你去买一本书照着学就行了。我还 非常耐心地告诉他们。</p>
<p>直到被问了无数次以后，我突然恍然大悟： 做一个（教程软件）不就得了吗？</p>
<p>说实话，这一类的软件跟盘古比起来，没啥技术含量。于是，我就立刻组织团队马上开发了一个软件，就叫《电脑入门》，快速推向市场，连广告都没做。</p>
<p>一推出以后马上就畅销，立刻上了畅销软件排行榜。</p>
<p>这个故事给这个过程真的给了我巨大的震撼，再让我重新思考，并重新理解了一个非常浅显的道理：</p>
<p>做产品，一定要做用户需要的产品，不要做那些看起来高大上的产品。只要这个产品是用户哭着喊着要的，销售就不是问题，特别容易卖。好的产品，它会自己长脚的。</p>
<p>有了这样的理解以后，不瞒大家说，再做产品就不难了。</p>
<p>后来我们出了一系列的爆品，有金山词霸、金山毒霸等等 （一二十个），所以很快金山找到了活下去的路。</p>
<p>我们再回顾看盘古的问题，其实很简单，就是脱离群众，闭门造车，就这么一个问题。</p>
</blockquote>
<blockquote>
<p>我当时就跟同学们分享了我的观点。我说我是一个程序员，在软件过程里学到的最重要的道理是什么呢？</p>
<ol>
<li>软件工程没有银弹</li>
<li>可能出错的地方，一定会出错</li>
</ol>
</blockquote>
<blockquote>
<p>最后用一句话来总结我今天的演讲，<strong>你经历的所有的挫折和失败，甚至那些看似毫无意义消磨时间的事情，都将成为你最重要的、最宝贵的财富。</strong></p>
<p>人生很长，无论如何，让我们保持信念：永远相信美好的事情即将发生。</p>
</blockquote>
<p><img src="weekly/2022/assets/image-20220813083008006.png" alt="image-20220813083008006" /></p>
<h2 id="音视频重构"><a class="header" href="#音视频重构">音视频重构</a></h2>
<p>一个有趣的观点：<strong>未来几乎所有行业都需要用音视频的方式重构一遍</strong></p>
<p>这是知乎的一个回答：</p>
<p>说法很高端，但事就是那么个事。制造业里都推广很多年了，很多产业，尤其是重体力，重危险，重精度的产业都在转向视频反馈，机械操作，流水线生产。我一哥们是在汽车厂生产大货车配件的，每天的工作就是在视频上看着一堆机器人（其实叫机械臂更贴切）操作，而他则根据不同的需求对设备进行调试，这就是去所谓的音视频构建呗，他现在做的工作跟十几年前零件生产线上的师傅，虽然都出同一种产品，但是干的工作完全不一样。</p>
<p>现在，这种趋势在向其他领域蔓延，以前人工还有成本优势，疫情时代则增加了封闭的风险，大大促进了无人少人操作的发展吧感觉。</p>
<p>作者：红护
链接：https://www.zhihu.com/question/548076856/answer/2622918348
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="一剪梅红藕香残玉簟秋"><a class="header" href="#一剪梅红藕香残玉簟秋">一剪梅·红藕香残玉簟秋</a></h2>
<p>红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。</p>
<p>花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</p>
<p><img src="weekly/2022/assets/image-20220813083204758.png" alt="image-20220813083204758" /></p>
<h2 id="高手在民间逃"><a class="header" href="#高手在民间逃">高手在民间（逃</a></h2>
<p><img src="weekly/2022/assets/image-20220813084522372.png" alt="image-20220813084522372" /></p>
<h2 id="你和谁在一起最轻松"><a class="header" href="#你和谁在一起最轻松">你和谁在一起最轻松</a></h2>
<p><img src="weekly/2022/assets/image-20220813084622509.png" alt="image-20220813084622509" /></p>
<h2 id="github-贡献墙-svg-动画"><a class="header" href="#github-贡献墙-svg-动画">github 贡献墙 svg 动画</a></h2>
<p><a href="https://contribution.catsjuice.com/">在线生成</a></p>
<p><img src="https://contribution.catsjuice.com/_/wansho?chart=3dbar&amp;gap=0.6&amp;scale=2&amp;flatten=1&amp;animation=wave&amp;animation_duration=3&amp;animation_delay=0.03&amp;animation_amplitude=24&amp;animation_frequency=0.1&amp;animation_wave_center=19_3&amp;format=svg&amp;weeks=40" alt="wansho github contributions" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-34"><a class="header" href="#week-34">week-34</a></h1>
<p>[TOC]</p>
<h2 id="为何许多男士痴迷于练肌肉"><a class="header" href="#为何许多男士痴迷于练肌肉">为何许多男士痴迷于练肌肉</a></h2>
<p>因为身体是你能掌控的唯一东西，也是你练就能给你正向回馈的东西。<a href="https://www.zhihu.com/question/23850556/answer/2633571157">为何许多男士痴迷于练肌肉？ - 谭四瞳的回答 - 知乎</a></p>
<p>器械再冷也比人心要暖。 <a href="https://www.zhihu.com/question/23850556/answer/581229935">为何许多男士痴迷于练肌肉？ - vermouthsa的回答 - 知乎</a></p>
<h2 id="火爆全网的-eviljs-源码解读"><a class="header" href="#火爆全网的-eviljs-源码解读">火爆全网的 Evil.js 源码解读</a></h2>
<p><a href="https://juejin.cn/post/7133134875426553886">火爆全网的 Evil.js 源码解读</a></p>
<pre><code>什么？黑心996公司要让你提桶跑路了？
想在离开前给你们的项目留点小 礼物 ？
偷偷地把本项目引入你们的项目吧，你们的项目会有但不仅限于如下的神奇效果：

当数组长度可以被7整除时，Array.includes 永远返回false。
当周日时，Array.map 方法的结果总是会丢失最后一个元素。
Array.filter 的结果有2%的概率丢失最后一个元素。
setTimeout 总是会比预期时间慢1秒才触发。
Promise.then 在周日时有10%不会注册。
JSON.stringify 会把I(大写字母I)变成l(小写字母L)。
Date.getTime() 的结果总是会慢一个小时。
localStorage.getItem 有5%几率返回空字符串。
</code></pre>
<h2 id="一个好的产品经理"><a class="header" href="#一个好的产品经理">一个好的产品经理</a></h2>
<p>一个好的领导（或者产品经理），应该具备五项技能：SQL、Excel、简洁写作、讲故事、区分优先级。<a href="https://www.craigkerstiens.com/2021/04/27/top-5-product-and-management-skills-sql-excel-clear-communication-story-prioritization/">《前5位的产品和管理技能》</a></p>
<h2 id="五彩斑斓的蓝"><a class="header" href="#五彩斑斓的蓝">五彩斑斓的蓝</a></h2>
<p>冲浪遇到两种颜色，群青和克莱因蓝，很安静，很喜欢的颜色。</p>
<h3 id="群青"><a class="header" href="#群青">群青</a></h3>
<p><img src="weekly/2022/assets/image-20220821093022499.png" alt="image-20220821093022499" /></p>
<h3 id="克莱因蓝"><a class="header" href="#克莱因蓝">克莱因蓝</a></h3>
<p>rgb(0, 47, 167)：</p>
<p><img src="weekly/2022/assets/image-20220821093327915.png" alt="image-20220821093327915" /></p>
<h2 id="关于原生家庭"><a class="header" href="#关于原生家庭">关于原生家庭</a></h2>
<p>不管你原生家庭好，还是不好，其实都会有缺失。如果你原生家庭不好，那么你就缺少爱。如果你原生家庭好，你就缺少历练。你在原生家庭里没有上到的课，终究还是要出去上。</p>
<p>——杨幂</p>
<h2 id="凤凰架构"><a class="header" href="#凤凰架构">凤凰架构</a></h2>
<p>一本好书</p>
<p><a href="https://icyfenix.cn/">凤凰架构，构建可靠的大型分布式系统</a>   <a href="https://raw.githubusercontent.com/fenixsoft/awesome-fenix/gh-pages/pdf/the-fenix-project.pdf">pdf download</a></p>
<p><img src="weekly/2022/assets/image-20220822112053995.png" alt="image-20220822112053995" /></p>
<h2 id="为技术文章在线生成海报"><a class="header" href="#为技术文章在线生成海报">为技术文章在线生成海报</a></h2>
<p><a href="https://coverview.vercel.app/editor">CoverView</a> </p>
<p><img src="weekly/2022/assets/image-20220822132659891.png" alt="image-20220822132659891" /></p>
<h2 id="庄稼地旁写代码"><a class="header" href="#庄稼地旁写代码">庄稼地旁写代码</a></h2>
<p><img src="weekly/2022/assets/3000000@.jpeg" alt="img" /></p>
<h2 id="济你太美"><a class="header" href="#济你太美">济你太美</a></h2>
<p>同济大学军训 2021,2022 表演节目。</p>
<p><img src="weekly/2022/assets/image-20220823182644099.png" alt="image-20220823182644099" /></p>
<p><img src="weekly/2022/assets/image-20220823182637209.png" alt="image-20220823182637209" /></p>
<h2 id="软件本地优先"><a class="header" href="#软件本地优先">软件本地优先</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/557353347">本地优先软件 Local-first software</a></p>
<p>翻译了 Local-first software。原文是深度好文，一作是 DDIA 的作者，文中指出了目前云应用普遍存在的问题「用户不再拥有自己的数据的控制权」，并指出了如何在不损失用户体验的情况下重新「让用户掌握自己数据所属权」的可行路线。</p>
<h2 id="跨平台框架-electron-和-tauri-比较"><a class="header" href="#跨平台框架-electron-和-tauri-比较">跨平台框架 Electron 和 Tauri 比较</a></h2>
<p><a href="https://www.levminer.com/blog/tauri-vs-electron">Tauri VS. Electron - Real world application</a></p>
<p>结论：</p>
<p>Electron is being replaced? Yes, Tauri is way better, but it still misses a lot. In a couple of years I'm sure the Tauri team will catch app to Electron. The things I'm excited for: Deno as the backend, better auto update and iOS/Android support.</p>
<h2 id="据意查句"><a class="header" href="#据意查句">据意查句</a></h2>
<p>清华大学出的一款垂直搜索引擎，可以据意查句，很有意思，前端设计也很有美感。</p>
<p><img src="weekly/2022/assets/image-20220826213105362.png" alt="image-20220826213105362" /></p>
<p><img src="weekly/2022/assets/image-20220826213842871.png" alt="image-20220826213842871" /></p>
<h2 id="重庆山火"><a class="header" href="#重庆山火">重庆山火</a></h2>
<p><img src="weekly/2022/assets/Fkzyx9FKpxjg9uOpLDIR3llFzxbav3.jpg" alt="Fkzyx9FKpxjg9uOpLDIR3llFzxbav3.jpg" /></p>
<p><img src="weekly/2022/assets/Fr7bsYtIq30F3RQzMgrffDRauzpUv3.jpg" alt="Fr7bsYtIq30F3RQzMgrffDRauzpUv3.jpg" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-35"><a class="header" href="#week-35">week-35</a></h1>
<p>[TOC]</p>
<h2 id="paper2gui"><a class="header" href="#paper2gui">Paper2GUI</a></h2>
<p><a href="https://github.com/Baiyuetribe/paper2gui">paper2gui</a></p>
<p>Paper2GUI: 一款面向普通人的AI桌面APP工具箱，免安装即开即用，已支持18+AI模型，内容涵盖语音合成、视频补帧、视频超分、目标检测、图片风格化、OCR识别等领域。支持Windows、Mac、Linux系统，未来还将适配安卓和苹果设备，另外还有小程序。</p>
<p>下载地址：<a href="https://download.fastgit.org/Baiyuetribe/paper2gui/releases/download/Published/XiaoBaituAI_windows.zip">Download</a></p>
<h2 id="明日风回更好今宵露宿何妨"><a class="header" href="#明日风回更好今宵露宿何妨">明日风回更好，今宵露宿何妨</a></h2>
<p>西江月·阻风山峰下</p>
<p><a href="https://hanyu.baidu.com/s?wd=%E5%BC%A0%E5%AD%9D%E7%A5%A5">张孝祥 </a></p>
<p>满载一船秋色，平铺十里湖光。波神留我看斜阳。放起鳞鳞细浪。
明日风回更好，今宵露宿何妨。水晶宫里奏霓裳。准拟岳阳楼上。</p>
<h2 id="带逛知乎-1"><a class="header" href="#带逛知乎-1">带逛知乎</a></h2>
<h3 id="上山下乡"><a class="header" href="#上山下乡">上山下乡</a></h3>
<p><a href="https://www.zhihu.com/pin/1547634029448564736">请勿关注的想法 - 知乎</a></p>
<p>刚才送孩子去打羽毛球，路上跟他讨论了北京。</p>
<p>我说北京其实是座奇怪的城市，它是一座城市，但又不属于任何一个省，而且除了北京以外还叫首都。</p>
<p>这个城市巨大无比，人口众多，在全世界来说都是超级城市。这个城市里的人口大多数都不是世代住在这里的，真正的老居民占比并不多，不断的有新移民来。</p>
<p>所以在这个出生长大的孩子有个先天的缺陷，就是不了解真正的中国。</p>
<p>就像了解一座楼，最好的办法就是从一楼一层一层的走到顶层，可是一出生就在顶层的人如果不刻意到一楼走一遍，是无法了解这栋楼的。</p>
<p>有些北京和老家两地住的孩子就比只在北京常住的孩子更了解中国，所以最闭塞的一定是不流动的土著，而真正的精英一定是流动的，一旦精英变成土著，那优势就会消失，这就是北京土著大多沉沦的根本原因。</p>
<p>我跟我儿子说，以后一定要多走，多看，多听，多参与，走出去，到各地扎实的走，远远的走，那样才能真正看清中国，看清世界。</p>
<h3 id="关于电动车的观点"><a class="header" href="#关于电动车的观点">关于电动车的观点</a></h3>
<p><a href="https://www.zhihu.com/pin/1547409818713010176">关于电动车的观点</a></p>
<p>我发现电动车吹最恶心的一点。
他们畅想未来的时候，不去讲“将来电池技术突破，零下三十度也能一秒启动，比油车方便”。
不去讲“将来换电站大规模推广，没电了随便找一个开进去两分钟换完，可以和油车一样无限续航”。
他们讲啥呢，讲“将来给汽油课重税，让油车的成本你们承受不了”，讲“将来把加油站修配厂都取缔了让你们加不上油修不起车”。
所以技术进步的意义是什么？是为了让你的使用者生活更美好，还是强迫不使用你的人生活变得更差？</p>
<h3 id="对希特勒的评价"><a class="header" href="#对希特勒的评价">对希特勒的评价</a></h3>
<p><a href="https://www.zhihu.com/question/528090588/answer/2550683112">在中国，喜欢希特勒的人，脑子是不是有问题啊？ - 大熊喵的回答 - 知乎 </a></p>
<p>喜欢希特勒的确实脑子有点问题，但是对他深恶痛绝那也大可不必。</p>
<p>在我看来，希特勒最大的罪恶是 他居然把过去几百年来欧洲白人在亚非拉世界对付其它民族的手段，拿来对付其他欧洲人！</p>
<p>欧洲人恨他是合理的，但是亚非拉各民族大可不必自作多情。 毕竟现在西方人提起南京大屠杀一样无动于衷。 你说你上赶着贴什么脸呢？</p>
<h3 id="这短暂的一生有何意义"><a class="header" href="#这短暂的一生有何意义">这短暂的一生有何意义</a></h3>
<p><a href="https://www.zhihu.com/question/306468598/answer/2635293262">这短暂的一生如何算有意义呢？ - 易水寒的回答 - 知乎</a></p>
<p>找个狗屁的人生意义。</p>
<p>我们传统文化里本来就有理性过度的弊病，过多的克己，修身，礼教。剩下这点可怜的感性精神，还要断绝它，扬弃它。</p>
<p>你翻遍所有的哲学典籍，都告诉你这花是假的，这树是假的，这山也是假的，这美女是红粉骷髅，这一切有形之物都是速朽的梦幻泡影，所以，让我们去追寻这虚幻之后的本质吧，去追寻那恒长不变的唯一真理。</p>
<p>咄！</p>
<p>还是去找个女朋友吧，去爱她，不要用你的思想去爱她，用你的肉身去爱她，去拥抱她，触碰她，去感受异性青春的肉体毫不合乎理性的炽热，鲜活，颤栗。</p>
<p>像拥抱女人一样去拥抱生活，拥抱她，融入她，不要做生活的冷眼旁观者，不要老是想我我我我我，没有我，这活的一切，人生的一切，都是我。</p>
<p>未经反省的人生是不值得过的，而过度反省的人生是活不下去的。</p>
<p>你去追问人生的终极意义，走过虚无主义，走过存在主义，走过尼采，走过康德，翻山越岭登舟渡河，追寻生活意义的人，在行色匆匆中错过真实的生活。</p>
<p>几万年前我们的老祖宗从树林子里窜出来，摘野果，撵兔子，饿了吃，困了睡，看见漂亮的女裸猿就心生欢喜，晚上手拉着手围着火堆跳舞，他要什么人生意义？</p>
<p>意义才是人造的虚幻之物，高悬天外的海市蜃楼——意义是为了让人更好的活着，人活着绝不仅仅是为了追求一个什么意义。</p>
<p>看见花开，你就微笑，这花就得到了尊重，人的生命也得到了尊重。</p>
<h2 id="柴门闻犬吠-风雪夜归人"><a class="header" href="#柴门闻犬吠-风雪夜归人">柴门闻犬吠, 风雪夜归人</a></h2>
<p><img src="weekly/2022/assets/image-20220829205857645.png" alt="image-20220829205857645" /></p>
<h2 id="写一个开源的-macos-项目可以赚多少钱"><a class="header" href="#写一个开源的-macos-项目可以赚多少钱">写一个开源的 macOS 项目可以赚多少钱</a></h2>
<p><a href="https://zihua.li/2020/04/open-source-app-earn">写一个开源的 macOS 项目可以赚多少钱</a></p>
<p>作者在 2015 年国庆节写的一个开源项目，挂在 MacOS 苹果商店上，可以免费下载，也可以花 30 元支持。短短不到五年，净收入超过 20W。</p>
<p>相当于每天赚 160 元！</p>
<p>好 羡 慕</p>
<h2 id="月薪-36000-日均写-7-行代码被开除"><a class="header" href="#月薪-36000-日均写-7-行代码被开除">月薪 36000 日均写 7 行代码被开除</a></h2>
<p>中科尚易健康科技（北京）有限公司与李彦昌劳动争议二审民事判决书公布。</p>
<p>中科尚易指出，自聘用合同生效后，李某某并未按照合同中约定的内容以及公司安排完成相应的工作事项。李某某作为视觉算法工程师，在职 72 天，只完成了深度学习识别算法 422 行代码的编写，3D 点云算法和多摄像头联合算法代码编写均为 0 行，其间除去约 9 天的样本训练和拍摄，也就是 63 天里每天只写 7 行代码。而作为该职位相同工资水平的员工，同行业同级别每天的正常代码工作量 100-200 行。</p>
<h2 id="五菱宏光-miniev-敞篷版"><a class="header" href="#五菱宏光-miniev-敞篷版">五菱宏光 MINIEV 敞篷版</a></h2>
<p>9 月 1 日开抢。cute</p>
<p><img src="weekly/2022/assets/803f14ef-008d-489b-a5f2-185dc9d5563e.png" alt="img" /></p>
<h2 id="阳澄湖大闸蟹"><a class="header" href="#阳澄湖大闸蟹">阳澄湖大闸蟹</a></h2>
<p><img src="weekly/2022/assets/image-20220831095349902.png" alt="image-20220831095349902" /></p>
<h2 id="找工作-app-比较"><a class="header" href="#找工作-app-比较">找工作 app 比较</a></h2>
<p><img src="weekly/2022/assets/image-20220831095429855.png" alt="image-20220831095429855" /></p>
<h2 id="静态语言和动态语言的区别-逃"><a class="header" href="#静态语言和动态语言的区别-逃">静态语言和动态语言的区别 (逃</a></h2>
<p><img src="weekly/2022/assets/FvIDcvS3nvQG6Ge_pgaKaDx6YH8gv3.jpg" alt="FvIDcvS3nvQG6Ge_pgaKaDx6YH8gv3.jpg" /></p>
<h2 id="diffusion-ai-作画"><a class="header" href="#diffusion-ai-作画">Diffusion AI 作画</a></h2>
<p>百度发布了一款 AI 作画产品，<a href="https://yige.baidu.com/#/">文心</a></p>
<p>AI 作画已经相当成熟了。下面是文心绘制的作品：</p>
<p>凤凰涅槃</p>
<p><img src="weekly/2022/assets/image-20220831163607962.png" alt="image-20220831163607962" /></p>
<p>枯藤老树昏鸦</p>
<p><img src="weekly/2022/assets/image-20220831164236104.png" alt="image-20220831164236104" /></p>
<p>小桥流水人家</p>
<p><img src="weekly/2022/assets/image-20220831164926715.png" alt="image-20220831164926715" /></p>
<p><img src="weekly/2022/assets/image-20220831164947607.png" alt="image-20220831164947607" /></p>
<p>一蓑烟雨任平生</p>
<p><img src="weekly/2022/assets/image-20220831165649959.png" alt="image-20220831165649959" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week---36"><a class="header" href="#week---36">week - 36</a></h1>
<p>[TOC]</p>
<h2 id="带逛知乎-2"><a class="header" href="#带逛知乎-2">带逛知乎</a></h2>
<h3 id="关于户籍的观点"><a class="header" href="#关于户籍的观点">关于户籍的观点</a></h3>
<p><a href="https://www.zhihu.com/question/522158678/answer/2421593405">美国堪萨斯的一个农民能不能在纽约定居成为市民？ - 倚阑看日暮的回答 - 知乎</a></p>
<p>户籍这玩意儿，不就是变相的国籍吗？</p>
<p>户籍制度把国内分成了大大小小的王国，安徽人可以免签到上海打工，但是不被视作当地人，不能买房安家，孩子上不了好的学校，老了也不能享受上海的养老待遇。学历高工资高的工作几年可以拿到上海户口，这不就是技术移民吗？</p>
<p>欧盟内的西班牙人要移民到柏林生活，移民难度不一定比一个安徽人要定居上海大吧？所以对个人来说，这个户籍政策，不就相当于国籍么。</p>
<h3 id="关于美国分裂的观点"><a class="header" href="#关于美国分裂的观点">关于美国分裂的观点</a></h3>
<p><a href="https://www.zhihu.com/question/551938613/answer/2662105345">如何看待《经济学人》最新封面标语「美国成了『美利坚，分众国』」？美国在哪些问题上存在分裂？ - 飞跃本屯的回答 - 知乎</a></p>
<p>一个山寨只要能持续不断的抢夺财货，花都花不完，那所有的分裂都不是大事，因为抢下面村子要比和同伙火并安全的多。 如果山寨发现下面的村子不是修了炮楼就是穷的光屁股，那坏了，就算是大寨主与二寨主养的狗子互咬，都可能引发山寨的解体。 所以对美国而言，问题不是内部分裂，而是外部的抢劫环境如何了。 目前看还能抢劫到东西，但原来拿出枪晃悠下就能抢到，现在需要扫射一梭子才行。可山寨不产子弹，打一发少一发呀。</p>
<h3 id="关于自信"><a class="header" href="#关于自信">关于自信</a></h3>
<p><a href="https://www.zhihu.com/question/491729132/answer/2665738056">一个人的自信从根本上来说靠的是什么？ - 请勿关注的回答 - 知乎</a></p>
<p>靠的是在自己的能力圈，甚至是舒适圈里，出圈的话不可能自信，不要信看得开，不在乎的理论，那最多是表面装样子。</p>
<p>所以想保持真正的自信要么不离开舒适圈，要么扩大能力圈，还有就是不出圈。</p>
<p>自信是好事，不自信也不是坏事，能一直冲出舒适圈，一直拓展能力圈的人才是真正的勇士。</p>
<p>勇士不是无畏的，能感到恐惧，又能面对恐惧才是有厉害的人，并不一定要战胜恐惧。</p>
<p>自信很容易盲目，保持恐惧，敬畏未知，可能比自信活的更真实一点。</p>
<h3 id="过去心不可得现在心不可得未来心不可得"><a class="header" href="#过去心不可得现在心不可得未来心不可得">过去心不可得，现在心不可得，未来心不可得</a></h3>
<p><a href="https://www.zhihu.com/question/19919957/answer/2652516536">金刚经中的「过去心不可得，现在心不可得，未来心不可得」是什么意思？ - 陈昱达的回答 - 知乎 </a></p>
<p>我的老婆在还是我女友的时候，曾经问过我：“我感觉你对我很好，但是又感觉你不在乎我，这是为什么？”。 我回答：“可能是因为我其实很在乎你的感受，但是我不在乎分手这件事，分手了我立刻再找一个”。 她生气地说：“你想得美！”。 果然她从这以后，没和我提过分手。 过去心不可得，现在心不可得，未来心不可得。 和前面的“应无所住而生其心”联系到一起，就能好理解一些。 无所住，是很高的修养。 容易搞混淆的地方是：把“无所住”当作“不在乎”。其实这两者差别非常大。 打个比方： 我对情爱很在乎，但我对情爱无所住，情爱就不是我的挂碍。 我对名利很在乎，但我对名利无所住，名利就不是我的挂碍。 我对知识很在乎，但我对知识无所住，知识就不是我的挂碍。 有啥表现，拿“名利”举例子。一个人做生意为了挣钱，利润越高越好，他很喜欢钱，很重视钱，挣到钱了就很开心。但是他不害怕亏钱，做生意有风险，害怕亏钱他岂不是事事裹足不前，怎么去挣更多的钱。这就叫于钱无所住。 害怕亏钱，就是住在钱上面了。 同样的道理，我热爱生命可以，但是脑子里总是怕死，就住在上面了。反而无法享受生命。 喜欢某个女人很好，但是害怕分手，就住在上面了。反而无法享受男欢女爱。 喜欢它的正面效果，不在乎它的负面效果。于是无所住，而生其心。 缘起缘灭，无心可住。既然已经无所住了，自然不会住在过去，现在，将来。于是验证了，过去心不可得，现在心不可得，未来心不可得。</p>
<h2 id="沙雕海报"><a class="header" href="#沙雕海报">沙雕海报</a></h2>
<p><img src="weekly/2022/assets/image-20220905184504390.png" alt="image-20220905184504390" /></p>
<p>一曲肝肠断，天涯何处觅知音</p>
<p><img src="weekly/2022/assets/image-20220905184510897.png" alt="image-20220905184510897" /></p>
<p><img src="weekly/2022/assets/image-20220905184524137.png" alt="image-20220905184524137" /></p>
<h2 id="一篇散文"><a class="header" href="#一篇散文">一篇散文</a></h2>
<p>作者：吹面不寒
链接：https://www.zhihu.com/question/538335062/answer/2661195589
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>前几天，有个好久不联系的朋友问我，“这些年，你过得还好吗？”</p>
<p>哈哈哈，当然过得很好呀。</p>
<p>因为在绝大多数情况下，我过得不好，也没有勇气说出来。</p>
<p>上个月一个平常的日子，我像往年一样，潦草的过完了自己今年的生日。</p>
<p>可能是我没有过生日的习惯吧，从小到大，都没有一个人记得过我的生日。</p>
<p>那天，我只是像往常一样，出去逛了逛，但给自己买了一推平时舍不得吃的零食。</p>
<p>晚上一个人漫步在晚风里，月光落在身前，夜幕下的路灯和飞虫都显得落寞。</p>
<p>过了生日，我今年就已经二十五岁了。</p>
<p>这个年纪，身边的人好像都在往前走。毕业工作，买车买房，甚至是结婚生子，似乎只有自己留在了原地。</p>
<p>我以为二十五岁的我，会像个大人一样，在风里雨里奔跑，却没想到喜怒哀乐仍在脸上。</p>
<p>走在路上被小朋友叫叔叔了，会不开心。妈妈没有给我买答应的东西，还会闹小情绪。</p>
<p>常常在路边和偶遇的猫咪对叫，看见漂亮的大胸妹子就想回头。望着天空漂浮的云朵，发呆、思考，想着一些不切实际的事情。</p>
<p>只是有时候，想找人出去散散步时，却发现好像已经没了，可以约出来的朋友了。</p>
<p>恍惚间发现，原来自己真的不是个孩子了。尤其是看着身边的同学、朋友陆续结婚生子，会莫名地感到心慌。</p>
<p>爸妈，好像也已没了当初的活力，自己却还不能好好地照顾自己。时间只是让我成长了年岁，却还没让我成为一个合格的大人。</p>
<p>以前，我不能理解年轻人的丧。在我的认知里，从小到大的教育就在告诉我，要用自己热爱的方式过这一生。</p>
<p>后来，我才明白，这只是一个理想的状态。</p>
<p>我们绝大多数的人，最终都会回到世俗的生活里，为家长里短，为柴米油盐烦恼着。</p>
<p>不知从哪一天开始，只是简单熬一下夜，第二天起来做事，就会浑身没劲。我知道那个曾经炙热的少年，就已经与我渐行渐远了。</p>
<p>可能成长，就是在不断地放下着东西。</p>
<p>后来，我渐渐学会了收起自己的锋芒，把委屈藏在心中，说话做事都有所顾虑。在处理问题时，早没了当初初生牛犊不怕虎的干劲……</p>
<p>隐忍妥协，但有时候又会庆幸自己，依旧有着世俗无法改变的东西。</p>
<p>比如说学不会抽烟喝酒，学不会逢迎欺骗，也有着自己的清高与小傲娇，还是那样喜欢沉浸在自己的世界里。</p>
<p>还是会有孩子的心性，比如说贪玩懒惰。</p>
<p>看着别人事业有成的时候，又会陷入焦虑，觉得自己这个样子不思进取，但却没了耐心和心思去学习。</p>
<p>其实，自己并不是个不喜欢分享的人。只是在大多数情况下，没人愿意聆听我的琐碎。</p>
<p>所以，我很沉默，一直都沉默。</p>
<p>就像是前几天，在微博上看见的热搜，朋友圈已经没了生活的痕迹。</p>
<p>是啊，看了看，自己好像已有大半年，没发过朋友圈了。</p>
<p>身边的绝大多数人，好像都选择了三天可见。</p>
<p>我觉得挺好的，因为现实里很少有人会真正关心你。大部分的人，根本不会多看一眼你的动态。</p>
<p>我们这一生，注定会被很多人路过，也会路过很多人。</p>
<p>可能只有等到哪天，真正遇见同频共振的那个人，才会像只刺猬样敞开心扉，让彼此看看内心深处，不为人知的优雅。</p>
<p>或许相遇的那天，我会因为历经孤独，而格外懂得珍惜。</p>
<p>以前我总以为，人生最美好的是相遇。后来才明白，其实最美好的可能是重逢。</p>
<p>因为人生里的很多告别，都是毫无征兆的。那些悄无声息的离开，或许是永久的沉默和不回头。</p>
<p>后来的我们，不再去追问心知肚明的答案，也不再轻易地将自己的情绪表露出来，开始尝试去做一个不动声色的大人。</p>
<p>那些曾以为生命之不能承受的事，就像是散落在风中的银杏叶，随着成长亦被岁月带走。</p>
<p>那些曾以为刻骨铭心的经历，或是痛苦难捱的日子。后来提及，两个字就足以概括。</p>
<p>从前，从前。</p>
<p>其实，自己这些年来，也并不是过得一点都不快乐。</p>
<p>比如说在路上遇见的快乐小狗，久违的文章动态还有人给我点赞，这些就足够让我快乐。</p>
<p>但又好像不算是真的快乐，只是在一阵短暂的欢愉后，就没了动静。再也没了那种小时候，可以为一件事期待好久好久，就算是得到了还会一直回味的感觉。</p>
<p>小时候的我无忧无虑，却总想着长大。长大后，却又开始怀恋小时候，或许是我还未做好准备，接纳成年人这个身份罢了。</p>
<p>我记得小时候，姥姥家的院子里，种着一颗大银杏树。每年春夏，枝头总是挂着一片绿意。等秋天一到，金灿灿的叶子就在风中招摇。</p>
<p>风将落叶带去远方，天空飘着的云很是明亮。</p>
<p>我只是安静地看着，邻居家那只爱趴在我家屋檐上，呼呼大睡的肥猫，就能虚度一下午的时光。</p>
<p>不知那时候，我们在树下一起追逐玩闹的孩子们。现在，你们怎么样了？这些年来，过得还好吗？</p>
<p>当我在写这篇文章时，正在为生活上的一地鸡毛而烦恼着。不知你们会不会也像我一样，在过去或未来的某个时刻，也在怀念着那个无忧的年代。</p>
<p>落叶随着风一阵摆动，家乡的银杏树一直都在，可是我已经回不去了。</p>
<h2 id="一段旋律"><a class="header" href="#一段旋律">一段旋律</a></h2>
<p><img src="weekly/2022/assets/image-20220906145817401.png" alt="image-20220906145817401" /></p>
<h2 id="一眼-ikun"><a class="header" href="#一眼-ikun">一眼 ikun</a></h2>
<p><img src="weekly/2022/assets/image-20220908133905364.png" alt="image-20220908133905364" /></p>
<p><img src="weekly/2022/assets/image-20220908133921711.png" alt="image-20220908133921711" /></p>
<p><img src="weekly/2022/assets/image-20220908133928526.png" alt="image-20220908133928526" /></p>
<p><img src="weekly/2022/assets/image-20220908133940161.png" alt="image-20220908133940161" /></p>
<p><img src="weekly/2022/assets/image-20220908133947440.png" alt="image-20220908133947440" /></p>
<p><img src="weekly/2022/assets/image-20220908133953768.png" alt="image-20220908133953768" /></p>
<h2 id="科目三宇宙"><a class="header" href="#科目三宇宙">科目三宇宙</a></h2>
<p><img src="weekly/2022/assets/image-20220912145329857.png" alt="image-20220912145329857" /></p>
<p><img src="weekly/2022/assets/image-20220912145337906.png" alt="image-20220912145337906" /></p>
<p><img src="weekly/2022/assets/image-20220912145342429.png" alt="image-20220912145342429" /></p>
<p><img src="weekly/2022/assets/image-20220912145347826.png" alt="image-20220912145347826" /></p>
<p><img src="weekly/2022/assets/image-20220912145352754.png" alt="image-20220912145352754" /></p>
<p><img src="weekly/2022/assets/image-20220912145357717.png" alt="image-20220912145357717" /></p>
<h2 id="赤壁赋"><a class="header" href="#赤壁赋">赤壁赋</a></h2>
<p>壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p>
<p>于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p>
<p>苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</p>
<p>苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。”</p>
<p>客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-37"><a class="header" href="#week-37">week-37</a></h1>
<p>[TOC]</p>
<h2 id="带逛知乎--贴吧"><a class="header" href="#带逛知乎--贴吧">带逛知乎 &amp; 贴吧</a></h2>
<h3 id="成年人的心动"><a class="header" href="#成年人的心动">成年人的心动</a></h3>
<p><a href="https://www.zhihu.com/question/393800893/answer/2480735977">成年人的心动是什么样的？ - lalala的回答 - 知乎 </a></p>
<p><img src="weekly/2022/assets/v2-6bd5d0e2637de2376b657cc8fc43cec2_1440w.jpg" alt="v2-6bd5d0e2637de2376b657cc8fc43cec2_1440" /></p>
<h2 id="盲水印"><a class="header" href="#盲水印">盲水印</a></h2>
<p><a href="https://mp.weixin.qq.com/s/EykLVZA6MQ3kgKvZFKfR9g">知乎水印事件</a></p>
<p>知乎页面的截图，竟然会注入盲水印，用来追踪截图的用户，真是用心险恶。</p>
<p><img src="weekly/2022/assets/640.png" alt="图片" /></p>
<h2 id="乔布斯档案"><a class="header" href="#乔布斯档案">乔布斯档案</a></h2>
<p><a href="https://stevejobsarchive.com/">乔布斯档案</a>，乔布斯家人建立的网站。</p>
<p>又想起了乔布斯在斯坦福大学的演讲。</p>
<p>You can't connect the dots looking forword, you can only connect them looking backwards, wo you have to trust the dots will somehow connect in your future. You have to trust in something, you gut, destiny, life, karma, whatever. Because believing the dots will connect down the road will give you the confidence to follow your heart, even when it lead you off the well-worn path.</p>
<p>The heaviness of being successful was replaced by the lightness of being a beginner again. It free me to enter one of the most creative periods of my life.</p>
<p>It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don't lose faith, I'm convinced that the only thing that kept me going was that I loved what I did. You've got to find what you love, and that is as ture for your work as it is for your lovers.</p>
<p>Remembering that you are going to die, is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p>
<p>Keep looking, don't settle.</p>
<p>跟随好奇心和直觉所做的事情，后来都被证明是无价之宝。</p>
<p>走过的每一步都算数。</p>
<p><img src="weekly/2022/assets/image-20220915194318866.png" alt="image-20220915194318866" /></p>
<h2 id="green-wall"><a class="header" href="#green-wall">green-wall</a></h2>
<p><a href="https://green-wall.vercel.app">green-wall</a> 一个可以在线制作 GitHub 历年贡献图表的网站。</p>
<p><img src="weekly/2022/assets/image-20220915202708737.png" alt="image-20220915202708737" /></p>
<h2 id="图书馆占座"><a class="header" href="#图书馆占座">图书馆占座</a></h2>
<p><img src="weekly/2022/assets/v2-452f96d39589c5337cc2ac4b3735c97d_1440w.jpg" alt="v2-452f96d39589c5337cc2ac4b3735c97d_1440" /></p>
<h2 id="孙笑川吧"><a class="header" href="#孙笑川吧">孙笑川吧</a></h2>
<p>最近发现网络净土：<a href="https://tieba.baidu.com/f?kw=%E5%AD%99%E7%AC%91%E5%B7%9D&amp;ie=utf-8">孙笑川吧</a>，以后可能要转战贴吧了。</p>
<p>不开玩笑，真的贼解压。</p>
<p><img src="weekly/2022/assets/v2-830a48d1c67a048fd7e594d6eb1d9e07_r.jpg" alt="img" /></p>
<h2 id="马上相逢无纸笔凭君传语报平安"><a class="header" href="#马上相逢无纸笔凭君传语报平安">马上相逢无纸笔，凭君传语报平安</a></h2>
<p><img src="weekly/2022/assets/image-20220916074302799.png" alt="image-20220916074302799" /></p>
<h2 id="内卷裁员"><a class="header" href="#内卷裁员">内卷，裁员</a></h2>
<p>在<a href="https://www.ruanyifeng.com/blog/2022/09/weekly-issue-223.html">科技爱好者周刊（第 223 期）：程序员需要担心裁员吗？</a> 看到一个观点：</p>
<p>&quot;与其担心宏观经济，不如关注自己。<strong>你对自己生活的影响，往往比宏观经济对你的影响大得多。</strong>&quot;</p>
<p>&quot;如果你忧心忡忡，那是不必要的；如果你毫不担心，那么你需要担心。&quot;</p>
<h2 id="htap-数据库-1"><a class="header" href="#htap-数据库-1">HTAP 数据库</a></h2>
<p><em>HTAP</em>（Hybrid Transaction Analytical Processing）</p>
<p><em>HTAP</em>= OLTP +OLAP</p>
<p>HTAP 数据库代表：TiDB 全能数据库</p>
<p><a href="https://ossinsight.io/blog/why-we-choose-tidb-to-support-ossinsight/">why-we-choose-tidb-to-support-ossinsight</a></p>
<p><img src="weekly/2022/assets/how-different-db-handle-github-data-097746b55085a93fa36a6bfb7af4cb0b.png" alt="Simplified architecture after we use TiDB" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-38"><a class="header" href="#week-38">week-38</a></h1>
<p>[TOC]</p>
<h2 id="git-ui-in-cmd"><a class="header" href="#git-ui-in-cmd">git ui in cmd</a></h2>
<p>命令行中的 git ui <a href="https://github.com/extrawurst/gitui">gitui</a>，只需要在终端中输入 gitui，即可打开图形化界面。</p>
<p><img src="weekly/2022/assets/demo.gif" alt="img" /></p>
<h2 id="全球各大洲制造业生产总值地图"><a class="header" href="#全球各大洲制造业生产总值地图">全球各大洲制造业生产总值地图</a></h2>
<p><img src="weekly/2022/assets/Fi5_EgvW7f5-8RQUEppWEIHSKydgv3.png" alt="Fi5_EgvW7f5-8RQUEppWEIHSKydgv3.png" /></p>
<h2 id="通勤"><a class="header" href="#通勤">通勤</a></h2>
<p><img src="weekly/2022/assets/643f1480-95eb-4443-90e8-3b29a1efa828.jpeg" alt="img" /></p>
<p><img src="weekly/2022/assets/618bf02d-39ae-45f5-a084-ad21a6230c6b.jpeg" alt="img" /></p>
<h2 id="笑傲江湖"><a class="header" href="#笑傲江湖">笑傲江湖</a></h2>
<p>上个星期看完了 2001 李亚鹏版本的笑傲江湖，有几句台词我挺喜欢的。</p>
<p><img src="weekly/2022/assets/image-20220919191905140.png" alt="image-20220919191905140" /></p>
<h2 id="元宇宙工程系"><a class="header" href="#元宇宙工程系">元宇宙工程系</a></h2>
<p><img src="weekly/2022/assets/image-20220924153944880.png" alt="image-20220924153944880" /></p>
<h2 id="北京的环境"><a class="header" href="#北京的环境">北京的环境</a></h2>
<p>最近在北京出差，住在离天安门不到两公里的地方。</p>
<p>虽然现在北京的空气好多了，但是街道卫生还是差太多了，天安门附近的胡同里还是太脏了，得低着头时刻提防着踩到狗屎。</p>
<h2 id="人生统计"><a class="header" href="#人生统计">人生统计</a></h2>
<p><a href="https://neal.fun/life-stats/">人生统计</a></p>
<p>输入出生年月日，这个网站会告诉我们已经活了多少天了。</p>
<p>时间不等人，对于我来说，一万天已经过去了。</p>
<p><img src="weekly/2022/assets/image-20220924212941846.png" alt="image-20220924212941846" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week---39"><a class="header" href="#week---39">week - 39</a></h1>
<p>[TOC]</p>
<h2 id="隐入尘烟全网下架"><a class="header" href="#隐入尘烟全网下架">《隐入尘烟》全网下架</a></h2>
<p>这样一部描述农村的写实影片，硬是被全网下架了…… 果真老爷心善，见不得穷人。</p>
<p><img src="weekly/2022/assets/640-4188772.png" alt="图片" /></p>
<h2 id="马拉松世界纪录保持者"><a class="header" href="#马拉松世界纪录保持者">马拉松世界纪录保持者</a></h2>
<p><a href="https://www.bilibili.com/video/BV1yV4y1T7eY/?vd_source=a353c03d59050e32df0db7cd77b16f6e">再破世界纪录！总台独家专访马拉松名将基普乔格</a></p>
<p>每天跑两次，每天跑 30 公里，一周跑 200 到 220 公里。</p>
<p>太强了……我一年也就跑 300 公里，还在沾沾自喜……</p>
<p>而且基普乔格已经 37 岁了……</p>
<p><img src="weekly/2022/assets/image-20220926185218211.png" alt="image-20220926185218211" /></p>
<p><img src="weekly/2022/assets/image-20220926185310462.png" alt="image-20220926185310462" /></p>
<p><img src="weekly/2022/assets/image-20220926185326185.png" alt="image-20220926185326185" /></p>
<h2 id="5g-带来的最大改变"><a class="header" href="#5g-带来的最大改变">5G 带来的最大改变</a></h2>
<p>看到一个段子：5G 迄今为止带来的最大改变，就是 4G 变慢了……</p>
<p>最近在北京出差，深有体会。按说京城的 4G 应该是全覆盖的，结果办公地点 4G 卡成了 3G，必须打开 5G，才能勉强达到 4G 的速度。</p>
<h2 id="一汽大众汽车导航时弹出广告"><a class="header" href="#一汽大众汽车导航时弹出广告">一汽大众汽车导航时弹出广告</a></h2>
<p>现在的电动车都是用做手机的思维做出来了……</p>
<p><img src="weekly/2022/assets/d5a301ed-634c-4e88-ba75-4cf37a213f5d.png" alt="img" /></p>
<h2 id="北京-27-环的新房房价"><a class="header" href="#北京-27-环的新房房价">北京 2.7 环的新房房价</a></h2>
<p>在北京二环看到的广告牌，一直对大城市的房价没有切身的体会，今天看到的这个新盘，单价 11 万，总价 1500 万。</p>
<p>北上广核心地段的新盘，一般都是限价倒挂的，说明这个端礼著一套市场价应该不止 1500 万……</p>
<p><img src="weekly/2022/assets/image-20220927140802874.png" alt="image-20220927140802874" /></p>
<p><img src="weekly/2022/assets/image-20220927141032803.png" alt="image-20220927141032803" /></p>
<p><img src="weekly/2022/assets/image-20220927140913754.png" alt="image-20220927140913754" /></p>
<h2 id="山东大集"><a class="header" href="#山东大集">山东大集</a></h2>
<p>俺也算半个山东人了，小时候也赶过集，看到这样的视频，格外亲切。</p>
<p>另外我注意到，这个视频的播放量有 100 多万，说明大家还是喜欢看接地气的素材的，毕竟 B 站后浪只是少数，大多数人还是出身农村或者小县城的。</p>
<p>这也解释了为什么《二舅》能火起来，因为农村出来的娃，都能从二舅上看到自己熟悉人的影子。</p>
<p><img src="weekly/2022/assets/image-20220927141629650.png" alt="image-20220927141629650" /></p>
<p><img src="weekly/2022/assets/image-20220927141412999.png" alt="image-20220927141412999" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-40"><a class="header" href="#week-40">week-40</a></h1>
<p>[TOC]</p>
<h2 id="技术管理者的要求"><a class="header" href="#技术管理者的要求">技术管理者的要求</a></h2>
<p>我以前要求自己做到的是，我手下两层以下的人，他们每个人的工作我都能做。这样整个公司里，没有人敢欺骗你、忽悠你。这个非常重要，大部分企业中层都在忽悠高层，资源其实是浪费掉的。</p>
<p>—— 陆奇</p>
<h2 id="逛知乎"><a class="header" href="#逛知乎">逛知乎</a></h2>
<h3 id="无题"><a class="header" href="#无题">无题</a></h3>
<p>穷人孩子的耳朵边很少听到“自由、艺术、快乐、幸福、享受、平等、爱”这种字眼。从小到大听到的都是“平安，看得起，看不起，努力，听话，老实，忍耐，吃得苦中苦方为人上人”。</p>
<h3 id="你们是怎么察觉一个人喜不喜欢你"><a class="header" href="#你们是怎么察觉一个人喜不喜欢你">你们是怎么察觉一个人喜不喜欢你？</a></h3>
<p>你就观察你和对方在一起的时候，你喜不喜欢自己，如果对方总能激发出你乐观自信开朗善良的一面，并让你经常觉得对未来有希望，你的情绪总是稳定在一个舒服安全的状态，大概率，对方是喜欢你的。相反． 如果一个人总是能让你怀疑自己，让你时常有嫉妒伤心痛苦不堪忍受的心理体验，即使他也会有让你快乐的体验，但那些消极的影响就像潮涨潮落样，永不会缺席，喜欢你的人怎么可能对你做道事呢？人的身体比灵魂诚实的多。</p>
<h3 id="你是什么时候释怀的"><a class="header" href="#你是什么时候释怀的">你是什么时候释怀的</a></h3>
<p>有一天偶然读到了庆山作者的一段话：如果足够勇敢，应该继续扛起问题往前走。直到因果成熟自动脱落，人对问题的解决方式。不是试图找到答案，而是背负到可以解决的那一天突然有种幡然醒悟的释怀之感，如果一直想着怎么摆脱它，会陷入纠结无限里，不如带着如影随行的它一起上路，历尽干帆之后，也许所有的问题都不再是问题了。</p>
<h2 id="陕不列颠"><a class="header" href="#陕不列颠">陕不列颠</a></h2>
<p><img src="weekly/2022/assets/image-20221010091005892.png" alt="image-20221010091005892" /></p>
<h2 id="送东阳马生序"><a class="header" href="#送东阳马生序">送东阳马生序</a></h2>
<p>融入不了上海的小资生活，应该怎么办？ - 知乎 https://www.zhihu.com/question/552899106/answer/2686353153</p>
<p>在知乎上看到这篇文章，评论区有人说是现代版的「送东阳马生序」，中学的时候看到这篇文章没什么感觉，工作后打拼几年，才体会到个中滋味。以中有足乐者，不知口体之奉不若人也。</p>
<p>余幼时即嗜学。家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。录毕，走送之，不敢稍逾约。以是人多以书假余，余因得遍观群书。既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。先达德隆望尊，门人弟子填其室，未尝稍降辞色。余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。<em>以中有足乐者，不知口体之奉不若人也</em>。盖余之勤且艰若此。今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！东阳马生君则，在太学已二年，流辈甚称其贤。余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。自谓少时用心于学甚劳，是可谓善学者矣！其将归见其亲也，余故道为学之难以告之。谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？</p>
<h2 id="两首曲子"><a class="header" href="#两首曲子">两首曲子</a></h2>
<h3 id="小茉莉"><a class="header" href="#小茉莉">小茉莉</a></h3>
<p><img src="weekly/2022/assets/image-20221010163325926.png" alt="image-20221010163325926" /></p>
<h3 id="武林外传---茉莉花"><a class="header" href="#武林外传---茉莉花">武林外传 - 茉莉花</a></h3>
<p><img src="weekly/2022/assets/image-20221010163343137.png" alt="image-20221010163343137" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-examination"><a class="header" href="#self-examination">Self-Examination</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-a-job"><a class="header" href="#for-a-job">For-a-Job</a></h1>
<p>[TOC]</p>
<p>从七月中旬到十月中旬，我找了三个月的工作。这是读研期间，最痛苦的三个月，究其原因，还是因为自己太菜，什么技术都不精。心态也慢慢发生了变化，从一开始不去北上广深，非阿里不去，到后来试试上海的美团，然后试试家里的研究所，直到华为一面挂掉之后，我彻底不想去互联网公司了，好在最后运气足够好，找到了一家的国企。这期间，我收获最大的是，知道了自己想要的究竟是什么。</p>
<h2 id="早点准备"><a class="header" href="#早点准备">早点准备</a></h2>
<p>我是从 7 月下旬开始准备秋招的，当时的状态，基本上就是只记得本科时候的一些基本概念，Leetcode 一题没刷，但是大厂的校招在 8 月已经全面开启了。我本人在整个秋招的面试都不太理想，特别是在基础知识层面，原因有二：第一是准备晚了，很多人在研二下学期就已经开始刷题准备了，但是我到了七月底才正式开始；第二是我喜欢知识的长期基类，非常反感临时抱拂脚。所以我的 Offer，基本上靠的是大厂实习的经历吹牛，还有长久以来积累的知识和项目经历。如果问到了我不会的基础知识和算法，那基本上就完蛋了。所以，早点系统的开始准备，是很重要的。个人建议，在研二上个学期（或者更早），就开始系统的复习计算机专业课，刷 Leetcode，并且最好准备一个拿得出手的项目。我的感觉是，只要是学校过关，基础知识非常扎实，那么拿大厂的 Offer 也没有那么难，项目经历是锦上添花的东西。</p>
<h2 id="算法-or-其他岗"><a class="header" href="#算法-or-其他岗">算法 or 其他岗</a></h2>
<p>这个问题，还是对自己定位的问题，我个人还是觉得，一名算法工程师，首先是工程师，然后才是算法工程师。如果单纯拼接刷 Leetcode 拿到算法的 Offer，没有工程能力，没有解决问题的能力，那么也很有局限。不过算法岗的薪资是真的高，有能力的算法同学也是非常的多，尤其是牛客，知乎，OfferShow 上，30W白读。有能力的同学，还是要准备算法岗，我两个室友，一个去了字节的算法岗，一个去了网易游戏，都很厉害，他俩算法都很强。</p>
<h2 id="到底是互联网还是非互联网"><a class="header" href="#到底是互联网还是非互联网">到底是互联网还是非互联网</a></h2>
<p>我建议，大家最好找个实习，体验体验，看看自己能不能吃得了那个苦，适不适应互联网的工作。南京的华为，尽量争取去实习，体验体验。如果能拿到大厂的30W+ 的 Offer，也是很好的。 人各有志，追求不同，同样精彩。</p>
<h2 id="明确目标"><a class="header" href="#明确目标">明确目标</a></h2>
<p>据我观察，大多数人找工作，是对自己没有一个明确的认知的。大家都知道互联网公司高薪，北上广深 30W 起步，但是那真的是自己想要的生活吗？自己真的受得了 996（大多数一线互联网公司平时没有 996 那么严重，但是忙的时候可能不止 996） 吗？大多数人，在校读研的时候，都是 8，9点起床，晚上 10 点以后回宿舍，都已经蛮累的了，自己能够适应互联网的高压吗？</p>
<p>当然，作为一名计算机科班出身的学生，有机会去一线的互联网公司工作，还是要试试的，不去可能后悔一辈子，要是我拿到了 BAT 的 Offer，我也会去大城市溜达一圈，毕竟年轻，有资本去浪。但是，并不是所有人都适合互联网这个行业的，至少我觉得身边搞计算机的同学，有一半的同学，不具有去互联网公司的特质。我之所以这么说，因为我幸运地在秋招之前在北京的某厂实习过，我体验过大厂的高压，体验到组里老员工的中年危机，体验过 24h on call，体验过在北京生活的难处。从我进厂实习，到现在离职在学校写总结，已经有一年多了，这一年多的时间里，部门里面的人员已经经历了一次大换血，一半的人都跑路了，要么逃离北京，要么换了一个轻松的工作。互联网的高薪，也伴随着高成本，只有工作没有生活，最可怕的是，对身体健康慢性摧残（写代码很多时候是体力活）。</p>
<p>互联网，是穷人家孩子阶级跃迁最后的几个途径，同时也是一条异常辛苦的道路。实习过后，我回到学校想了想，给自己秋招定下了一个过滤条件，不考虑北上广深的工作。很多人，是不适合互联网公司的，大多数人只是抱着试一试的心态，最后受不了了，工作了一两年就逃离了互联网公司，逃离了大城市。只有少数人能坚持下来，这对精神和身体素质，都是一个很大的考验。</p>
<p>其实秋招整个过程中，我一直在考虑一个问题，我辛辛苦苦读了这么多年书，考了那么多年的试，最后能够从一个名校研究生毕业。但是找工作的时候，还要去刷题，去学习，做各种性格测评，搞得和考研时候那么辛苦，图的是什么，我读的研究生到底有什么用？我这么努力的读书学习，无非是想以后的生活能够过得轻松一点，工资能高一点。现在找工作都这么辛苦了，以后进了互联网公司，岂不是被压榨的更辛苦？</p>
<p>所以，能提前去大厂实习，就尽量去实习，早点确定，自己想要的到底是什么。</p>
<p>当然，大厂也有大厂的好处，工资贼高，可以快速积累财富，上限也贼高，适合大佬。</p>
<h2 id="其他-6"><a class="header" href="#其他-6">其他</a></h2>
<p>现在互联网的形势越来越不乐观了，大环境下经济不景气，互联网红利慢慢褪去，用户增长放缓逐步饱和，而且现在工科人均计算机，计算机又人均机器学习，入行门槛低，我本人对这个行业不是很乐观，主要还是因为本人太菜，进入这个行业，拼不过其他人。</p>
<p>文章有点消极，也很主观，只希望能给大家带来不一样的思考，大家求同存异。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何学习"><a class="header" href="#如何学习">如何学习</a></h1>
<p>Inspired by <a href="https://github.com/dwmkerr/hacker-laws">hacker-laws</a>，summed up by <a href="https://gitbook.wansho.cn/about/about">wansho</a></p>
<h2 id="学习的过程"><a class="header" href="#学习的过程">学习的过程</a></h2>
<p><img src="life-and-thinking/blog/assets/1559225913350.png" alt="如何学习" /></p>
<p><img src="life-and-thinking/blog/assets/1559224390536.png" alt="学习曲线" /></p>
<h2 id="study-laws"><a class="header" href="#study-laws">Study-Laws</a></h2>
<ul>
<li>
<p><strong>DRY 法则</strong></p>
<p>不在同一个地方跌倒两次；一个题型不再错第二遍；一块代码逻辑，不再进行第二次重复；……</p>
</li>
<li>
<p>**种瓜得瓜，种豆得豆 **</p>
<p>学习从长期来看，没有捷径，也绝对没有速成，但可以利用科学的学习方法提高效率。</p>
</li>
<li>
<p><strong>思考决定学习效率</strong></p>
<p>学习结果的衡量尺度不是时间的多少，而是思考的深度和广度。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应试教育经验总结"><a class="header" href="#应试教育经验总结">应试教育经验总结</a></h1>
<p>作为一名普通得不能再普通的学生，在成长的过程中一定有数不清的考试经历。在经历了大大小小的那么多考试后，我觉得我应该总结点什么。</p>
<p>原因有二：</p>
<ul>
<li>
<p>希望万*鑫看到这篇文章后，能有所收获，掌握正确的学习方法，少走弯路</p>
</li>
<li>
<p>明年研究生毕业后，我可能再也不会经历比较大型的考试了，这个总结是对我学生生涯应试教育的一个交代</p>
</li>
</ul>
<p>该篇总结分为如下几个部分：</p>
<ul>
<li>为什么要学习：应试教育的重要性</li>
<li>如何学习：学习方法总结</li>
<li>关于中考：战略上藐视，战术上重视</li>
</ul>
<h2 id="应试教育的重要性为什么要学习"><a class="header" href="#应试教育的重要性为什么要学习">应试教育的重要性：为什么要学习</a></h2>
<p>首先抛结论：<strong>应试教育是基于当下国情的最公平的选拔人才的手段，也是寒门学子改变命运的快速通道。</strong></p>
<p>之所以说是快速通道，是因为对懂得学习方法的人来说，学习是一件最容易的事情。只要掌握了学习的诀窍，就可以利用应试教育改变命运。所以，古人说，<strong>书中自有黄金屋，书中自有颜如玉</strong>。</p>
<h3 id="我们学的知识背的课文到底有没有用"><a class="header" href="#我们学的知识背的课文到底有没有用">我们学的知识，背的课文，到底有没有用？</a></h3>
<p>很多学生讨厌应试教育，讨厌背古诗，讨厌背英语，背历史，背政治，觉得这些知识一点用处都没有。首先这种观点就是有问题的。我能理解大多数中学生为什么觉得鲁迅的文章是枯燥无味的，因为他们还没有很深的阅历。当你随着年龄的增长，经历过人情冷暖，悲欢离合，你再回头看一看鲁迅的文章，才能发现他的话是多么的一阵见血。这里引用知乎上的一个问题和回答：<strong>小孩子不懂古诗，为什么还要背古诗</strong>？</p>
<blockquote>
<p>为了在他长大后，有一天看到黄昏美景时脱口而出的是“落霞与孤鹜齐飞，秋水共长天一色”，而不只是“我X，好牛X”；</p>
<p>看到明月时脱口而出的是“举杯邀明月，对影成三人”，而不只是“哇，这月亮好美”；</p>
<p>遇到下雨脱口而出的是“落花人独立，微雨燕双飞”，而不只是“我去，下雨了”；</p>
<p>与朋友喝酒时脱口而出的是“人生得意须尽欢，莫使金樽空对月”，而不只是“满上满上”“干”“别养鱼”“老子喝死你”；</p>
<p>看到美女时自然浮想出的是：“清水出芙蓉，天然去雕饰”、“肌肤若冰雪，淖约若处子”，而不只是满脑子的“小姐姐，颜值舔屏”。</p>
</blockquote>
<h3 id="应试教育是一个改变命运的捷径"><a class="header" href="#应试教育是一个改变命运的捷径">应试教育是一个改变命运的捷径</a></h3>
<p>退一万步讲，就算你现在不懂得这些道理，但是有一个道理你应该很清楚，如果你想出人头地，你想改变自己的命运，你想实现自己的梦想，那么应试教育就是你的工具，而且是捷径！</p>
<p>人并不是生而公平的。从出生的那一刻起，就是不公平的。你可能会羡慕，为什么别人家的父母这么有钱，为什么别人可以用这么好的手机，这虽然不公平，但是确是事实。我们不能选择自己的出身，但是可以自己走出自己的未来。未来你也会组建家庭，你也会为人父母，你不想给自己的孩子一个更好的起点吗？</p>
<p>学生时代，你可能发现，你和同学之间的差距，并不是很明显。你身边的同学都是每天穿着和你一样的校服，每天和你一样上下课，上学放学。但是到了你工作的时候，你可能会发现，这个社会上，有各种各样的不公平。例如，你中学时候成绩倒数的同桌，毕业后凭借关系进入了某个大型国企，父母还给他在大城市买车买房，而你却只能在大城市靠租房。如果你不能在学生时代和大多数人拉开差距，那么等你毕业工作的时候，你会发现，你和被人的差距会越来越大。</p>
<p>人生也是相对公平的。大多数人出生下来后，身体都是健全的，智力发育都是没有问题的，都是两个肩膀抗一个脑袋。这就是你奋斗的资本。有钱人家的孩子再有钱，也不可能有两个脑袋四条腿。父母只会陪你走人生的一小段路，剩下大部分的路，需要自己去走。与其羡慕别人的父母，不如去用自己健全的身体，靠自己的奋斗，去实现自己人生的价值（奋斗并不是为了和别人攀比，而是让人生活的有价值）。虽然你的父母不能在大城市给你买车买房，但是你可以通过努力学习，考进一所国内顶尖的 985 高校，大学毕业后年薪 30 万，虽然你可能需要自己暂时租房子，但是你可以凭借自己的努力，几年赚到一栋房子的首付，在大城市通过自己的努力扎根，等你有了下一代，你可以自豪和他们说，你老子当年自己只身一人来到大城市，白手起家，在大城市扎了根。</p>
<p>这一切的一切，都可以通过学习，通过应试教育的捷径来实现，也就是说，你梦想的未来，是应试教育给你带来的，是你自己努力学习，努力奋斗带来的。</p>
<p>所以，退一万步说，就算当前的你，觉得应试教育再枯燥，再没有意义，你都应该利用好这个途径，实现自己人生的价值。况且，应试教育，也并不是无用的知识，所有的科目，所有的知识，都是有价值的，只是你还没有体会到。</p>
<h2 id="如何学习学习方法总结"><a class="header" href="#如何学习学习方法总结">如何学习：学习方法总结</a></h2>
<p>最重要的能力：<strong>在老师的引导下，独立思考，主动学习的能力</strong>。</p>
<p>我觉得当下中国应试教育最大的弊端，就是没有教会学生如何<strong>独立的思考</strong>，大多数老师都是在进行填鸭式教育，当然这并不是老师的问题，这是教育体制的问题。每一个老师，不管授课能力如何，都是值得尊敬的老师。我们不能因为一个老师上课讲的不好，或者一个老师不喜欢我，就对一门科目产生厌恶的情绪。老师讲的不好是老师的事情，但是分数是自己的啊。</p>
<p>独立思考的能力是非常重要的。什么是独立思考的能力，独立思考的能力，体现在你们学生身上，就是总结错题的能力，是举一反三地能力，是主动学习地能力。我们知道，一个题目，其要考察的知识点，本质上就是书本上地那些知识点，再难的题目，也只是书上的知识点的组合考察。只要把书本上的知识点吃透了，遇到题目就能看清这个题目的。</p>
<p>学习是有章法的，有很多道理是显而易见而且十分有效的。有效的学习方法，是成功的一半。我们的班级里面，肯定有一些同学，学习比谁都勤奋，但是分数就是考不高，这是学习方法出现了问题。同样的道理，为什么很多知识点我都忘记了，当时当我拿到一个数学题的时候，我还是会做，答案很简单：我有自己的一套学习经验。</p>
<h3 id="主动学习预习的重要性"><a class="header" href="#主动学习预习的重要性">主动学习：预习的重要性</a></h3>
<p>一件事情，你主动想做，和被动地去做，有本质地区别。学习也是如此，被老师进行填鸭式教学，和自己预习完后，带着问题听讲，有本质的区别。你应该能有所体会，提前对书本的知识点进行预习，做老师发下来的预习题，在做题的过程中，遇到不懂的问题，第二天你肯定会认真听老师如何解答，然后你脑子里就会留下很深的影响。</p>
<p>很多道理，都是老师反复强调过的，例如上课前要认真预习课本，下课后要认真复习，这都是真理，只是大多数人都把这些道理当作耳旁风。</p>
<p>再提一下复习，复习和预习同样重要。艾兵浩斯遗忘曲线告诉我们，人的记忆，在经过 20min 后就会衰减 50%，也就是说，你上课听到的知识，如果不及时复习，那么就会遗忘的特别快。这个反复被人验证过的道理，却被大多数人忽视。</p>
<p><img src="life-and-thinking/blog/assets/1559031388865.png" alt="1559031388865" /></p>
<h3 id="课堂认真听讲的重要性"><a class="header" href="#课堂认真听讲的重要性">课堂认真听讲的重要性</a></h3>
<p>首先抛一个结论：<strong>上课不认真听讲，课后花再多的时间也补不回来</strong>。</p>
<p>我们的班级里面，肯定有过这样的人：学习很努力，比谁都努力，但是就是成绩上不去。这些人并不是笨，实际上大多数人的智商都是差不多的，只是他们的学习方法出了问题。老师每一次讲课，都是认真备课的，老师们的所有时间，基本上都花在了备课上，因为这是面向所有同学的授课。如果上课不认真听讲，企图通过课后补课的方式，来弥补，那只是亡羊补牢，老师们在补课的时候讲的课，以及大家听课后的效果，是绝对比不上课堂上的结果的。</p>
<h3 id="总结的重要性"><a class="header" href="#总结的重要性">总结的重要性</a></h3>
<p>前面我说过，学习最重要的就是不断地总结，先总结核心知识，然后从核心知识延申出枝叶。需要总结的东西很多，数学的错题，英语的错题，英语的优秀句型，政治的答题模板，很多东西，自己总结出来了印象就会非常深刻，而如果是被动的接受老师灌进来的东西，那么效果肯定不如自己总结的好。特别是数学的错题，总结的多了，就知道某个类型的题目，坑在什么地方，有几种解法。注意：<strong>自己总结出来的知识，自己主动学习出来的知识，才是自己的</strong>，老师交给你的知识，你不吸收，那还是老师的。</p>
<p><img src="life-and-thinking/blog/assets/1559046833725.png" alt="考研总结" /></p>
<p>上图是我考研期间总结的各种错题，以及各种经验的积累，这都是我思考的结果，只属于我的思考的结果，思考的时间决定了你的复习效率，而不是你的复习时间。自己<strong>主动思考</strong>、总结出来的知识，才是最好的，别人的就算总结的再好，替代不了你<strong>思考的过程</strong>。<strong>别人思考出来了再告诉你，就像嚼好了饭再喂给你一样，营养肯定不如自己总结来的多。</strong></p>
<p>你现在距离考试还有半个月的时间，这半个月，你应该把绝大部分的时间，花在总结上（一定要总结出属于自己的感悟），尤其是总结理工科目的错题。当然，还要做一些新的题型，保持做题的手感。不要小看这半个月，半个月的时间，只要学习方法得到，那么效果会突飞猛进，因为总结会带来进一步的提升，这段时间可以是量变引起质量的时间。</p>
<h2 id="关于中考战略上藐视战术上重视"><a class="header" href="#关于中考战略上藐视战术上重视">关于中考：战略上藐视，战术上重视</a></h2>
<h3 id="战略上藐视"><a class="header" href="#战略上藐视">战略上藐视</a></h3>
<p>关于中考，我想说的是，没有人去逼你一定要去考上省赣中，我也不想你这么年轻，就那么累。对于这场考试，你要从战略上藐视他，因为他是一次很好的机会（一个捷径），让你离你的梦想更进一步。进了省赣中，你将接触一流的老师，与全市一流的学生做同学。省赣中三年的磨练，让我受益一生。</p>
<p>我觉得最好的心态，是你主动的想去考进赣中（主动思考），而不是被人逼着去做这件事情。</p>
<p>当然，你也不要有太大的压力。优秀的人，去哪里都是优秀的。即使你考不进赣中，只要你一直严格要求自己，也总能实现自己的梦想，但是这条路明显比考上省赣中更加曲折。这也是我为什么反复强调：应试教育、应试考试是一个成功的捷径，你不应该反感他，而应该感谢这个捷径给了你一个证明自己的机会。所以，你已经知道了应试教育的本质，你应该从战略上藐视他，应试教育不过如此。当然，每个人都有失败的时候，胜败乃兵家常事，所以你也不必要有什么压力，我中考高考都失利了，后来的情况你可知道了，我在大学里，付出了太多的努力，去追赶别人，最后才勉强和其他优秀的人，站在同一个舞台上，未来还有很长的路要做，一次失败没什么，能爬起来，总结经验，就是好样的。</p>
<h3 id="战术上重视"><a class="header" href="#战术上重视">战术上重视</a></h3>
<p>虽然我说应该在战略上藐视这场考试，但是我们应该在战术上重视这场应试教育，他给了你一个极好的机会，让你走上一条更好的道路。我们要重视自己的学习方法，重视自己的备考策略，不能在这个时候骄傲自满，觉得自己能考上了，就放松了。考试，最忌骄傲自满，大意失荆州。考试最可惜的，就是会做的题目做错了，我之前说过，只要会做的题目全部做对，就一定是高分。</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>最后这段时间，你应该戒骄戒躁，认真总结做题经验，抓复习重点，然后平稳的走完这次考试，我不期待你有什么超常的发挥，我只希望你能够正常发挥出自己的实力即可。</p>
<p>祝万*鑫好运！</p>
<h2 id="参考文献-4"><a class="header" href="#参考文献-4">参考文献</a></h2>
<ol>
<li><a href="https://www.zhihu.com/question/54231137/answer/575502749">鲁迅的文字有多一针见血</a></li>
<li><a href="https://www.zhihu.com/question/22913650/answer/57037751">人生为什么要努力</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络精神鸦片"><a class="header" href="#网络精神鸦片">网络精神鸦片</a></h1>
<p>[TOC]</p>
<h2 id="现状"><a class="header" href="#现状">现状</a></h2>
<p>我通常会在两个视频网站看视频：Bilibili 和 Youtube。最近我隐约发现，我在两个平台看视频的体验是不一样的，每当我打开 B 站，看到网站右上角的动态数字时，我都会迫不及待地点开每一个视频，然后狼吞虎咽地看完每一个视频，看完后还不过瘾，再看看 B 站的排行榜，看看 B 站的推荐，再看看 #$*&amp;^!@。等看视频看累了，回过神的时候，才发现时间都悄悄流逝了，该睡觉没有睡觉，该学习也没有学习，再想想刚才看了啥，有收获没有，结果脑子一片空白。看视频如此，有时候过日子也是如此，匆匆忙忙，慌慌张张，晚上躺床上想想自己一天干了啥，脑子里又是一片空白，身体还出奇的累。一个鲜活的人活成了一具行尸走肉。</p>
<h2 id="网络精神鸦片-1"><a class="header" href="#网络精神鸦片-1">网络精神鸦片</a></h2>
<p>我隐约感觉这种行尸走肉的状态和我每天上网脱不了干系，因为我每天除了吃饭睡觉，其他时间都和网络分不开。凡事都有外因和内因，我抵制不了这些诱惑，说明我本身修为不够。但是，这一次，我只想揭露导致我焦虑的外部因素：<strong>网络精神鸦片</strong>。</p>
<blockquote>
<p>网络上任何能让人上瘾，产生依赖，并引起焦虑的内容。</p>
</blockquote>
<p>网络精神鸦片无处不在，手段也越来越高明。从直截了当地让人上瘾的网络游戏，到利用人性的各种网络营销。手机上形形色色的 APP 是利用人性弱点进行精神鸦片倾销的重灾区，尤其是淘宝和拼多多这种电商 APP，是利用人性弱点的集大成者。举几个简单的例子：</p>
<ul>
<li>
<p>Feed 流</p>
<p>新闻 APP 和视频 APP 的惯用技俩，今日头条，抖音，只要用户手指不断地往下滑，就会有无穷无尽地新闻和视频，而且是基于用户的兴趣进行推荐的新闻和视频；在淘宝主页上只要不断往下滑，就会有无穷的你感兴趣的商品推荐给你，直到你满意为止。</p>
</li>
<li>
<p>未读信息</p>
<p>微信朋友圈的小红点，B 站上未看的订阅内容，无时无刻地不在培养用户的习惯，让你看到这些内容时而感到欣喜，慢慢地上瘾，然后离不开他们。</p>
</li>
<li>
<p>复杂的网页设计</p>
<p>拿 Youtube 和 Bilibili 来比较，B 站的网页设计眼花缭乱，给人的感觉，就像巴不得用户进站后就住在站里，而 Youtube 则相对冷静克制。</p>
</li>
</ul>
<p><img src="life-and-thinking/blog/assets/1575525966004.png" alt="Bilibili Vs Youtube" /></p>
<p>这些高明的向用户倾销精神鸦片的行为，其背后的目的很明确：<strong>压榨掉用户的碎片化时间，培养用户习惯和粘性，最后变现。</strong></p>
<h2 id="危害独立人格的丧失"><a class="header" href="#危害独立人格的丧失">危害：独立人格的丧失</a></h2>
<p>网络是一把双刃剑，你凝望深渊，深渊也在凝视你，任何生命中美好的馈赠，实际上都暗中标注了价格，天下没有免费的午餐。</p>
<ul>
<li>看似是你在看新闻，实际上是想向你灌输价值观；</li>
<li>看似是你在薅羊毛，实际上是电商平台在培养你的用户习惯；</li>
<li>看似是你在购物，实际上电商平台恨不得挖空心思掏空你的钱包；</li>
<li>看似是你在看视频，实际上你看到的视频都是平台想让你看到的；</li>
<li>看似是你在微博吃瓜，实际上热搜是想利用你扩大事件的影响力；</li>
<li><strong>看似是你玩手机，实际上是手机在玩你</strong>。</li>
<li><strong>看似是你玩电脑，实际上是电脑在玩你。</strong></li>
<li><strong>看似是你在思考，实际上是大脑在控制你</strong>。</li>
</ul>
<p>很多人认为自己有独立的人格。但是大多数人，实际上都是被其自己的大脑所控制，被自己的习惯所控制，而不是在控制自己的大脑。看似自己把握了自己的命运，实际上沦为习惯的奴隶，成为了行尸走肉。</p>
<h2 id="如何抵御洪水猛兽"><a class="header" href="#如何抵御洪水猛兽">如何抵御洪水猛兽</a></h2>
<p>浮躁、焦虑、消费主义，…… 是互联网的现状，不仅国内如此，国外也是如此，天下熙熙攘攘，皆为利来利往。用户长期浸淫在这种环境下，稍不留神，就会被网络绑架，受到精神鸦片的腐蚀。那么如何抵御这些洪水猛兽，向精神鸦片说不？</p>
<p>作为一个普通人，多看书多动脑多思考多实践，这都是最朴实不过的道理，但也是更古不变的真理；</p>
<p>而作为一个技术人，我想从技术方面给出如何抵御这些洪水猛兽的两个建议：</p>
<ul>
<li>日常使用手机时，将手机屏幕颜色调整成灰色调</li>
</ul>
<p><img src="life-and-thinking/blog/assets/1575535284618.png" alt="彩色的 B 站和灰色的 B 站" /></p>
<ul>
<li>用浏览器插件将任何网页的主题调整成黑色的背景，这里推荐 Chrome 浏览器的 <a href="https://chrome.google.com/webstore/detail/dark-theme-for-chrome/geooakdjiamlhpechokegobmhdmlgidk?utm_source=chrome-ntp-icon">Black Theme for Chrome</a> 插件</li>
</ul>
<p><img src="life-and-thinking/blog/assets/1575535575023.png" alt="彩色的 B 站和灰色的 B 站" /></p>
<h2 id="我的计划"><a class="header" href="#我的计划">我的计划</a></h2>
<p>作为一个技术人，我深知许多网站设计的『良苦用心』，和臃肿的淘宝、支付宝 APP 一样，为了吸引用户的注意力，让用户花更多的时间浏览，他们将网站颜色搞得五彩斑斓，增加了数不清的功能入口。</p>
<p>我希望我所浏览的网站，是一个简约的一目了然的网站，能够获得沉浸式的体验，而不是扑面而来的焦虑。所以我想做一个类似 <a href="https://www.tampermonkey.net/">油猴插件</a> 的开放平台，平台的名称暂时叫作 <strong>Web-lite</strong>，平台可以执行针对各个网站进行瘦身的脚本，脚本则来源于其他技术人的用爱发电。平台还会提供一个衡量网页复杂度的标准（颜色，文字数量，），进而提醒用户。</p>
<p><img src="life-and-thinking/blog/assets/Web-lite.png" alt="Web-lite 架构" /></p>
<p><strong>是的，我想发起一场净化网页设计的运动。</strong> </p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://www.lieyunwang.com/archives/445794">抖音设局</a></li>
<li><a href="https://mp.weixin.qq.com/s/NKY0CqVfsXntyePRmzx9tg">拼多多是怎么骗你的？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/40388558">套路：想戒手机？试试把屏幕变灰</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-perfect"><a class="header" href="#why-perfect">Why-Perfect</a></h1>
<h2 id="完美主义"><a class="header" href="#完美主义">完美主义？</a></h2>
<p>完美主义，是一把双刃剑。我们在追求完美，提升自我的同时，也会被完美反噬。反噬的原因在于，我们太看重结果，而忽略了成长；我们想一口吃个胖子，而忽略了种瓜得瓜种豆得豆；我们期待一劳永逸，</p>
<p>现实中，我们往往因为会如下原因，放弃自己：</p>
<pre><code>昨晚没睡好，今天不学习了，明天重新来过
中午没休息好，今天不学习了
这本书很久没看了，不想再看了
晚上吃的太饱犯困，晚上看剧吧
中午才起床，没状态，今天不学习了
昨晚梦到前女友了，今天心情不好
今天没状态，就是没法进入状态
计划没有完成，怎么办，很焦虑
今天心情不好，不想学习
</code></pre>
<p>事实上，我们缺乏解决问题的勇气，当问题来临时，我们选择了大脑的舒适区，选择了逃避。我们并没有认真思考如何解决问题，并没有将生命视为自己的责任。如果我们认真的进行了思考，那么以上的问题都可以解决：</p>
<pre><code>昨晚没睡好，今天不学习了，明天重新来过 ——&gt; 没睡好回去补觉然后再学习啊
中午没休息好，今天不学习了 ——&gt; 中午没休息好，就再多睡会啊
这本书很久没看了，不想再看了 ——&gt; 书本很久没动了，就不看了？花钱买的就不看了？
晚上吃的太饱犯困，晚上看剧吧 ——&gt; 犯困就休息一会啊
中午才起床，没状态，今天不学习了 ——&gt; 没状态就调整呀，没睡醒就继续睡啊
昨晚梦到前女友了，今天心情不好 ——&gt; 都他妈两年前的事了，你是心情不好，还是懒？
今天没状态，就是没法进入状态 ——&gt; 进入不了状态，只是拖延的借口
计划没有完成，怎么办，很焦虑 ——&gt; 计划写完了并不是一劳永逸了，计划是需要随时修改的
今天心情不好，不想学习 ——&gt; 心情不好就不想学习？这只是懒惰的理由吧
</code></pre>
<p>大多数我们面临问题的时候，都因为思维的懒惰而不假思索的选择了逃避。把问题丢到明天，美其名曰追求完美，实际上就是懒惰导致的惯性思维。只有面对问题，正视现实，认真思考，才能摆脱困境，才不会重蹈覆辙。</p>
<h2 id="真正的完美主义者"><a class="header" href="#真正的完美主义者">真正的完美主义者</a></h2>
<p>真正的完美主义者，应该意识到，这世界上没有 100 分，我们能做到的，是不断逼近这 100 分，我们永远也达到不了终点，我们永远都在路上，我们永远都在成长，我们永远都在学习。</p>
<p>真正的完美主义者，知道人生不如意十之八九，人生的每一天都充满了挑战，他们认清了生活的真相，却依然热爱生活。</p>
<p>想一想，最坏又能怎样，考不上研就考不上呗，找不到好工作可以慢慢找，也不能一口吃个胖子，慢慢来吧，少年。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-love"><a class="header" href="#about-love">About-Love</a></h1>
<p>我理想中的另一半，应该是张宇<a href="https://music.163.com/song?id=190499&amp;userid=64569149">《给你们》</a>中唱的那样，两个人相互理解，相互扶持，相互成长，亲亲爱爱的一家人。虽然这样的另一半已经很难找了，但我不会放低要求，不会将就，三观不合的人，在一起也是痛苦一辈子。</p>
<p>世界上最美好的青春莫过于奋斗的青春，最好的爱情莫过于一起奋斗中的爱情</p>
<p>我越来越清楚我想找一个什么样的女生了，我想找一个天真开朗，能让我重拾快乐的女孩子~</p>
<hr />
<p>美貌总会褪去，</p>
<p>喜好也会改变，</p>
<p>唯一不变的只有闪光的灵魂。</p>
<hr />
<p>Nathaniel Branden 教授指出， 我们之所以会持久的爱上一个人（短暂的不算，因为短暂的可能是因为一些错误的原因），本质上是因为他提出的“心理可见性原则”。就像一面镜子一样，如果你的灵魂真正的被一个人看见，你就会爱上这个人。当你发现，如果别人看我们的眼光跟我们内心深处最真实的自己对自己的看法是一致的，并且他们通过他们对我们的言行，表现出对我们的这种理解，我们就会有一种深深的被“看见”的感觉。</p>
<hr />
<p>与君初相识，犹如旧人归</p>
<hr />
<p>未曾相逢先一笑 初会便已许平生</p>
<hr />
<p>闻多素心人，乐与数晨夕</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="细数在拼多多开店遇到的坑"><a class="header" href="#细数在拼多多开店遇到的坑">细数在拼多多开店遇到的坑</a></h1>
<p>作为一个在拼多多一个半月的小本商家，从 2 月 7 日开店以来，我已经在拼多多平台卖出了近 7000 块钱的货，发起提现四次，三次失败，目前只提现出了 800 块的现金，导致我急着用钱却提不出钱。我承认这有我提现操作粗心的因素，但我觉得拼多多各种阻拦商家提现的骚操作才是最主要的原因。这期间，我对拼多多的体验就是一句话：恶心！各种阴招来坑商家，让人说不出来的那种恶心。</p>
<p><img src="life-and-thinking/blog/assets/1585209988189.png" alt="恶心" /></p>
<p>我知道天下没有免费的午餐，我也知道我利用拼多多赚钱需要缴纳一定的平台费用，我就是单纯觉得拼多多这些逼迫商家的手段不够光明真大，数据不透明，真的恶心，让人说不出得难受。</p>
<p>拼多多这些手段的目标只有一个，就是将商家在平台上的资金流转进行模糊化，企图在商家不知不觉的情况下，扣除尽可能多的交易费，并且尽可能地阻拦商家提现，进而保证自己的现金流。</p>
<h2 id="阻拦商家提现的手段"><a class="header" href="#阻拦商家提现的手段">阻拦商家提现的手段</a></h2>
<p><img src="life-and-thinking/blog/assets/1585208842608.png" alt="提现记录" /></p>
<p>拼多多不止在营销方面是一把好手，在阻拦商家提现的手段上，也是不遗余力。</p>
<p>我第一次 800 块钱提现失败，就是因为填错了网点。商家的第一次提现，在填写银行卡信息，输入银行卡号，确认验证码后，<strong>竟然需要填写开户的银行网点</strong>，只有选择正确的银行网点，才能提现成功。我转账了这么多年，头一次遇到提现转账时需要填写银行网点的，有谁能记得清楚当初办理银行卡时的开户网点？这种给商家提现故意制造困难的骚操作，真的恶心！</p>
<p><img src="life-and-thinking/blog/assets/1585209988189.png" alt="恶心" /></p>
<p>第二次提现失败，拼多多给出的原因是：</p>
<p><img src="life-and-thinking/blog/assets/1585210201265.png" alt="第二次提现失败" /></p>
<p>我就搞不懂了，为什么我发起提现的时候，你们拼多多不审核好了到底能不能提现，我急着用钱等了快一天了，然后告诉我提现失败？Execuse me？</p>
<p>第二次提现失败后，我惊奇的发现，我不能提现了，因为没有缴纳保证金 2000 块钱。我了解没有缴纳保证金只能提现三次的政策，但是我没想到<strong>提现失败的两次也算提现</strong>，现在好了，5000 块钱的现金卡在了拼多多里面，如果想要把现金提出来，方法有两个：</p>
<ol>
<li>缴纳 2000 块钱保证金</li>
<li>退店，需要等待 20 天左右的时间</li>
</ol>
<p>为了继续使用拼多多的平台，我只好缴纳 2000 块钱的保证金，然后发起第三次提现。</p>
<p>第三次提现，我申请把缴纳保证金后剩余的 3111 全部提了出来，结果就是这个第三次提现失败！</p>
<p><img src="life-and-thinking/blog/assets/1585210863735.png" alt="第三次提现失败" /></p>
<p>我仔细查了一下后台的账单，发现不知道什么原因导致<strong>开店保证金低于 2000，也会提现失败</strong>。我忍无可忍，缴纳了两毛四分钱的保证金后，我发起了第五次提现，希望这一次拼多多不要再作妖了。</p>
<p><img src="life-and-thinking/blog/assets/1585211394401.png" alt="1585211394401" /></p>
<p>除了上面这些妖魔鬼怪，拼多多还设立了一天只能提现一次的规定，就算交了店铺保证金，也是一天只能提现一次。还有提现时间审核太长的问题，但从我的提现记录看的话，提现到账大概需要一天的时间。微信和支付宝提现需要一天的时间吗？提现的技术问题需要花费一天的时间吗？这不就是在卡商家的现金流吗？疫情期间，中小商家的现金流都很紧张，淘宝发起活动，号召消费者确认收货，而拼多多呢？呵呵，想方设法阻止商家提现。当然，这些妖魔鬼怪的目的只有一个嘛，卡商家的现金流，这样自己账上就有了更多的钱。</p>
<h2 id="逼迫商家缴纳-2000-保证金的手段"><a class="header" href="#逼迫商家缴纳-2000-保证金的手段">逼迫商家缴纳 2000 保证金的手段</a></h2>
<ul>
<li>不缴纳保证金，只能提现三次，提现失败也算一次</li>
<li>不缴纳保证金，那么用户确认收货 15 天后资金才能到账，加上消费者往往没有收货后确认收货的习惯，导致资金滞留拼多多平台长达半个多月</li>
<li>如果坚决不缴纳保证金，资金提不出来，退店也需要等待 20 天左右的时间</li>
</ul>
<h2 id="技术服务费"><a class="header" href="#技术服务费">技术服务费</a></h2>
<p>一笔交易200 块钱，需要缴纳 1.2 的技术服务费，这个我可以理解。但是请拼多多告诉我，用户购买商品后退货退款 200，商家也需要缴纳技术服务费 1.2，这个怎么解释？？？</p>
<p><img src="life-and-thinking/blog/assets/1585207707744.png" alt="技术服务费" /></p>
<h2 id="拼多多的客服"><a class="header" href="#拼多多的客服">拼多多的客服</a></h2>
<p>当我抱着一堆的问号，打开客服的时候，得到的却是机器人的秒回。讽刺的是，输入框里面竟然提示这个机器人是人工客服，公开侮辱商家的智商……</p>
<p><img src="life-and-thinking/blog/assets/1585215136698.png" alt="机器人客服" /></p>
<h2 id="拼多多重新定义收入"><a class="header" href="#拼多多重新定义收入">拼多多重新定义收入</a></h2>
<p><img src="life-and-thinking/blog/assets/1586063838238.jpg" alt="商家收入" /></p>
<p>拼多多商家收入 = <strong>提现失败返还</strong> + 交易收入 + 其他</p>
<p>提现失败也算作商家的收入，这 TM 简直是在侮辱商家的智商！</p>
<p><img src="life-and-thinking/blog/assets/1585209988189.png" alt="恶心" /></p>
<h2 id="新冠疫情期间-自动收货时间默认为-30-天"><a class="header" href="#新冠疫情期间-自动收货时间默认为-30-天">新冠疫情期间-自动收货时间默认为 30 天</a></h2>
<p><img src="life-and-thinking/blog/assets/1586169894530.png" alt="自动确认收货时间" /></p>
<p>新冠肺炎期间，损失最大的是各大中小商家，其他平台都在呼吁消费者尽快确认收货，确保商家的现金流。拼多多呢，非但不帮助商家，反而将自动确认收货的时间从 15 天扩大了一倍，调整到了一个月！也就是说，如果消费者不确认收货，那么商家需要隔一个月的时间才能收到付款的现金。消费者的钱都暂时进到了拼多多的口袋里，被拼多多拿去利用了，要等一个月后才能吐出来还给商家。</p>
<p><img src="life-and-thinking/blog/assets/1585209988189.png" alt="恶心" /></p>
<h2 id="最后"><a class="header" href="#最后">最后</a></h2>
<p>我写这篇文章的目的，是为了揭露拼多多的丑恶行径，为自己出一口气。我不反对缴纳保证金，我也不反对缴纳技术服务费，毕竟我使用了拼多多的平台，就需要按规定缴纳一定的费用，我只是一个大学生，急着用钱，所以才会推迟缴纳保证金。我享受了拼多多给我带来的平台，就需要付出一定的代价。但是我没想到的是，竟然因为我没有缴纳保证金，拼多多给我整出这么多恶心的骚操作。</p>
<p>这一个多月里，我一共卖出了将近 7000 块钱的货款，发起提现四次，但是三次失败，目前只提现出了 800 块的现金。但凡拼多多能够让我舒服一点，我也不至于花两个小时的时间，来细数这些在拼多多遇到的坑！</p>
<p><img src="life-and-thinking/blog/assets/1585209988189.png" alt="恶心" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="商品营销经验"><a class="header" href="#商品营销经验">商品营销经验</a></h1>
<p>记录总结我的专业课资料营销经验。</p>
<h2 id="赚钱的前提"><a class="header" href="#赚钱的前提">赚钱的前提</a></h2>
<ul>
<li>资料扎实的质量</li>
<li>寻找更多的流量</li>
</ul>
<p>两者缺一不可</p>
<h2 id="流量来源"><a class="header" href="#流量来源">流量来源</a></h2>
<p>营销的目标：寻找考研的同学，然后和他们宣传，将他们引入自己的 QQ 群。</p>
<p>考研同学经常出没的地方：</p>
<ul>
<li>
<p>王道论坛 / 天勤论坛</p>
</li>
<li>
<p>Bilibili </p>
</li>
<li>
<p>知乎</p>
</li>
<li>
<p>各大考研 QQ 群（等他们来宣传，再反击回去，互相伤害，互相曝光，反正我的质量比其他人高）</p>
</li>
</ul>
<h2 id="长期有效的措施"><a class="header" href="#长期有效的措施">长期有效的措施</a></h2>
<ul>
<li>坚持写作，坚持写经验贴</li>
<li>在群里和大家互动答疑</li>
</ul>
<h2 id="短期见效的措施"><a class="header" href="#短期见效的措施">短期见效的措施</a></h2>
<ul>
<li>直播带货</li>
<li>商品促销</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="买房经验总结"><a class="header" href="#买房经验总结">买房经验总结</a></h1>
<h2 id="微惊群-言论与思考"><a class="header" href="#微惊群-言论与思考">微惊群-言论与思考</a></h2>
<ul>
<li>
<p>一个软件大道，可以撑起整个雨花台的房价，这就是产业的力量，科研用地，大学啊研究所啊，能算作支撑房价的因素么</p>
<p>所以，支撑上秦淮房价的，是什么产业？有多少科技和金融公司会过来呢？</p>
</li>
<li>
<p>江山大境、江山荟、锦绣樾江山、中交锦度、龙潭、禄口等坑盘，接盘侠优惠团购群</p>
</li>
<li>
<p>要是在江宁，没有太多的选择，除九龙湖百家湖，只能是上秦淮。因为江宁发展的比较早，以前土地粗放式利用，所以整个江宁主城单位内基本上没有储备住宅用地。你可以看到，整个江宁除了商业和工业，没有像样的商务中心，也就是我们俗称的CBD。那么江宁扩张或者建立新产业的唯一途径就是蔓延式发展，比如正方新城、上秦淮等。所以，你在江宁发展居住，唯一的新房选择的机会可能就是上秦淮。整个南京发展的趋势，还是沿长江两侧形成拥江发展的城市格局。所以，整个江宁大概率涨幅会落后于江北新区和建邺区。但是上秦淮作为江宁外溢唯一还可以的板块，中长期看，保值没有太大问题，江宁没有太多靠近主城还可以大规模成片开发的新区。江宁目前的一些高新产业也在往上秦淮倾斜。从自住角度来看，可以入手。周边荒地过几年填满没有太大问题，跑赢南京市平均涨幅问题不大。</p>
<p>上秦淮的发展预期要强于大学城，我个人不太看好大学城，建议上秦淮。不建议买百家湖和托乐嘉二手。除非你直接入手小龙湾的次新房，其他不建议考虑，还是选上秦淮。 不要怕荒，要看懂城市的发展方向，就不会慌，上秦淮问题不大。</p>
</li>
<li>
<p>今年一季度后250万以内三成首付没有选择权，只有上车权。</p>
<p>确实，真的没得选，只能先上车，没办法十全十美。</p>
</li>
<li>
<p>南京就是苏北人心中的耶路撒冷！</p>
<p>精辟</p>
</li>
<li>
<p>新城重要是是自成一体，和主城无缝对接不就是主城了</p>
</li>
<li>
<p>碧桂园是县城韭菜收割机，高逼格的售楼处，让小县城的“土豪”一眼爱不释手</p>
</li>
<li>
<p>现在除了连云港宿迁，苏北其他市的学区房已经全面破3</p>
<p>南京的房价还会继续涨，直到和苏北县市拉开差距	</p>
</li>
</ul>
<h2 id="我的思考-2"><a class="header" href="#我的思考-2">我的思考</a></h2>
<ul>
<li>
<p>集全省之力开发江北，其实是让全省的人都来江北买房，然后拿大家买房的钱建设江北。2019年，政府的收入来源，有 1/3 来自房地产，这还只是平均数，有的地方更夸张。卖地来钱快，才有钱开发城市</p>
</li>
<li>
<p>所有中介和销售，都是不靠谱的，说话都有三分假，同样，所有中介和销售朋友圈推荐的楼盘，都是卖不出去才来打广告的</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="中医"><a class="header" href="#中医">中医</a></h1>
<h2 id="王德峰讲中医"><a class="header" href="#王德峰讲中医">王德峰讲中医</a></h2>
<p>https://www.bilibili.com/video/BV1Jy4y137B9</p>
<p>中医依赖师徒传承，依赖直觉，不可能像西医那样容易习得。</p>
<p>老中医一定会看八字。看八字就是看药性。治得了病，治不了命。</p>
<p>两本书：《中医诊断学》，《中药学概论》</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="健康"><a class="header" href="#健康">健康</a></h1>
<p>[TOC]</p>
<h2 id="生理健康"><a class="header" href="#生理健康">生理健康</a></h2>
<h3 id="饮食"><a class="header" href="#饮食">饮食</a></h3>
<ul>
<li>过于油腻的饮食会影响饭后的状态，<strong>吃饭之前要三思</strong></li>
<li>多吃膳食纤维，膳食纤维是人体无法吸收的多糖，例如<strong>蔬菜</strong>中的<strong>纤维</strong>素，<strong>水果</strong>中的果胶，多吃膳食纤维能够增加果腹感，减少肠道对于糖的吸收。一句话：<strong>多吃水果、蔬菜和粗粮</strong>。多吃玉米 / 红薯等粗粮。</li>
</ul>
<h2 id="心理健康"><a class="header" href="#心理健康">心理健康</a></h2>
<h3 id="好的心态"><a class="header" href="#好的心态">好的心态</a></h3>
<p>心理健康可以促进生理健康，心态可以影响一个人的身体</p>
<h3 id="如何保持好的心态"><a class="header" href="#如何保持好的心态">如何保持好的心态</a></h3>
<p>三省吾身；行有不得，反求诸己；</p>
<h2 id="健身"><a class="header" href="#健身">健身</a></h2>
<p>一句话，多健身，有助身心健康。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keep-learning-1"><a class="header" href="#keep-learning-1">Keep-learning</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何保持学习激情"><a class="header" href="#如何保持学习激情">如何保持学习激情</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="周刊"><a class="header" href="#周刊">周刊</a></h1>
<p>记录每一周的所见所闻。学习阮老师。</p>
<p>每周都对 gitbook 提交记录进行整理，把有趣的，有价值的知识，分享到周报。</p>
<p>[TOC]</p>
<h2 id="2021-week-52"><a class="header" href="#2021-week-52">2021-week-52</a></h2>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/446947298?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=744285080762990592">聊聊我关于 Web 未来发展趋势的看法</a> <a href="https://modernjs.dev/">modernjs</a></p>
<p>计算机领域的发展方向：不断向上抽象，屏蔽更多的底层细节，让计算机的使用者/开发者能够花更多的时间在创造和享受上。</p>
<p>抽象层级的排序：语言 -&gt; 库 -&gt; 框架 -&gt; 引擎</p>
<p>操作系统屏蔽了硬件的细节，k8s 屏蔽了物理机的细节，而 Serverless 则更进一步，直接把集群的细节也屏蔽了。</p>
<p>一切能通过明晰的路径做到的事情，都具备替代性，要想提升自己的不可替代性，最重要的是抓住机会，在关键的产品中，担任关键的位置，取得关键的成果。</p>
<p>抽象层级的改变，会带来范式的转移，什么是范式？当从原子角度看，桌子，电脑，甚至是芯片都没有意义，因为都是一个一个的原子。</p>
<p>UGC（User Generate Content）用户生产内容。B 站，油管，抖音都是 UGC 平台，爱优腾如果不变革，早晚要没落的。</p>
<p>元宇宙游戏，其实就是游戏平台的 UGC 化，游戏提供非常简易，门槛极低的低代码工具，让很多有创造力的用户，可以创造各种各样的小游戏。</p>
<p>在 2021 年即将结束的这个时间点，它处于，框架逐渐成熟收敛，低代码工具市场开始爆发的前夜。</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1rY411p7Tg">虚幻5引擎：黑客帝国觉醒</a></p>
<p>当我们打造出的世界和我们自己的世界同等真实时，那现实到底意味着什么？</p>
</li>
<li>
<p><a href="http://news.66wz.com/system/2021/12/06/105422662.shtml">鄱阳湖明代千眼古桥</a></p>
<img align="left" src="life-and-thinking/keep-learning/assets/00300838605_a1159d5e.jpg" alt="img" style="zoom:40%;" />
<p>明代修的桥现在还能用，质量真的扎实。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/327986995/answer/1711259480">为什么输电损耗2000公里只有6%，还要修运煤铁路，直接输电多好?</a></p>
<p>不要低估一辆运输着硬盘的卡车的带宽，也不要低估一辆运载煤炭的火车的输电量。把煤慢慢运到目的地再发电产生的电量远高于通过特高压输电线输送的电量。如果要完全要用特高压输电线路替代送煤铁路，要建设的特高压线路要多很多。</p>
<p>如果我国所有的火力发电厂都在山西，在山西发电以后再通过长距离运输到用电负荷中心。如果一旦山西出了问题，那么就相当于整个中国70%的电力受到影响。所以要异地发电。</p>
</li>
</ul>
<h2 id="2022-week-01"><a class="header" href="#2022-week-01">2022-week-01</a></h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/EYzaqpW_h-ouL5WLGbQk-w">分化，是楼市未来的趋势</a></p>
<p>南京楼市在过去20年时间里，基本只在05、08、12、16年经历过4次普涨。观察一下就可以发现，基本每3-4年就发生一次普涨。所谓普涨，就是说不管是骡子是马，一平米至少涨个几千。</p>
<p>但是16年到现在，已经5年多了，普涨没有再发生了。如果不进行强货币刺激，那么往年的普涨很难再现。这时候全市的平均涨幅指标会出现失真。一二线板块持续上升，三四线板块增长乏力。这时候买房的选择会变得极其重要。新房一旦套住，就是5年起步。假如你买的房子价格没动，而好的板块已经翻倍有余了，那你的置换计划就没戏了。买错了比错过行情更加可怕。</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1fr4y1e7VG">黄昏与月光 | 唐诗导读 第十二讲</a></p>
<p>黄昏意味着生命的流逝，月光蕴含着联系</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/mdBook">mdbook</a> </p>
<p>rust 语言编写的，兼容 gitbook 的电子书生成服务。Create book from markdown files. Like Gitbook but implemented in Rust。</p>
<p>mdbook 对中文不友好，不支持中文搜索。</p>
<p>Rust 正在成为 Linux 官方的第二大开发语言。</p>
</li>
<li>
<p><a href="https://github.com/LingDong-/shan-shui-inf">shan-shui-inf</a></p>
<p>用 JavaScript 绘制山水画</p>
</li>
<li>
<p>https://eja.tv/ </p>
<p>可以看国外的电视频道</p>
</li>
</ul>
<h2 id="2022-week-02"><a class="header" href="#2022-week-02">2022-week-02</a></h2>
<ul>
<li>
<p><a href="https://www.ithome.com/0/597/842.htm">2021 B 站百大 Up 主公布</a></p>
<p>记录一下我关注的 B 站百大 Up 主：</p>
<ul>
<li>电影最 Top（我入站关注的第一位 Up 主，有真情实感，真性情，不搞花里胡哨）</li>
<li>极速拍档（他们是真的热爱汽车）</li>
</ul>
<p>啊这，我还以为我能找到很多，结果 2021 百大 up 主中我只关注了两位🤦🏻‍♀️</p>
<p>2020 年疫情的时候，我还没毕业，在家无聊萌生了做 Up 的想法，到现在已经两年了，积累了 620 个粉丝，啥时候能破 1k 粉丝呀😂</p>
</li>
<li>
<p><a href="https://sspai.com/post/70602">PlayCover</a></p>
<p>在 MacOS 上装 IOS 应用打原神</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1uZ4y1D787">复旦大学教授王德峰解读《坛经》横屏4K精修</a></p>
<p>考研坚持不下去的时候，遇到困难的时候，可以看一看</p>
</li>
<li>
<p><a href="https://github.com/wansho/altar-sutra-wdf">王德峰坛经十品-录音稿-markdown版本</a></p>
<p>整理的录音稿</p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/6u_QydMIdFaT78RumdMJRA">infoQ 解读编程语言的 2021</a></p>
<p>Java 即将支持协程(虚拟线程)。协程可以更有效地利用可用的硬件，并大大降低成本。最主流的编程语言已经全部支持或正在支持协程，包括 C++、Python、C#、Go（原生） 。</p>
<p>在 InfoQ 2021 编程语言榜单 中，Rust 无论是关注度还是期望值，都紧随 Go 语言之后。Rust 最重要的优势在于以媲美 C/C++ 的性能表现，解决了编程过程中的内存安全问题。Rust 的出现不是为了重写这个世界已经存在的一切，而是为了让未来更加美好。</p>
<p>C++ 问世四十年，相关方法技巧已经成熟，催生了编程大神无数，但在 2021 年的今天，我们仍然在寻找其替代品。其根本原因在于，人们逐渐明了，性能并非系统级编程语言的全部，随着软件逐渐接管 IoT 设备（尤其是自动驾驶车辆），内存溢出 / 指针悬垂类的内存安全问题，已经不只会造成经济损失，更会威胁人身安全。与其面向结果，出了问题再改 Bug，不如面向过程从一开始就把控好内存安全。</p>
<p>在移动端开发，Kotlin 独树一帜；在数据科学领域，Python 和 R 语言应用甚广；在 Web 端，有越来越多的人开始尝试使用 TypeScript。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/pin/1465267871517904897">北理工 2022 计算机考研试卷比往年多了 4000 份</a></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220114195248285.png" alt="image-20220114195248285" /></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2022/01/weekly-issue-192.html">最大的机会来自新技术</a> </p>
<p>所有的机会都是新技术带来的，你想抓住最大的机会，只能去追踪那些新产品、新技术。</p>
</li>
<li>
<p><a href="https://www.theregister.com/2022/01/06/acura_honda_cars_software_bug/">本田汽车的 2022 Bug</a></p>
<p>一辆老款丰田车，车机在 2022 年 1 月 1 日出现 Bug，这还只是一个很简单的嵌入式系统。很难想象现在的很多搭载复杂的安卓系统的新能源汽车，在几年后，会出现什么离奇的 Bug。</p>
<p>现在汽车，尤其是新能源汽车，越来越像电子快消品了。汽车电子化，造车门槛越来越低，电子快消品卷不动了，开始卷汽车了，想要再拉动一波消费。</p>
<p>汽车应该回归其本来的价值和作用，就是驾驶出行。加入那么多花里胡哨的东西，又是自动驾驶，又是操作大屏，其实都是噱头。很难想象这些智能化的东西，在 N 年不更新系统后，会出现什么离奇的 Bug。</p>
</li>
</ul>
<h2 id="2022-week-03"><a class="header" href="#2022-week-03">2022-week-03</a></h2>
<ul>
<li>
<p>这一脚，踢出了整个盛夏</p>
<p>出自‌‌‌‌‌‌‌B站up主“请你喝好果汁”的视频《<a href="https://www.bilibili.com/video/BV1BM4y1G7S7">因为你我会记住那一分钟</a>》，里面有虎哥与赵三金名场面的画面，搭配王家卫的台词，接着是虎哥鬼步舞搭配bgm夏日漱石，本身是整活视频，但是整个视频颇具文艺气息，使得评论区有很多人讲述他们自己的故事，代入其中仿佛回到了整活年代的那个盛夏。
狠活儿是杀不死的，但那个盛夏已经回不去了。</p>
</li>
<li>
<p><a href="https://course.rs/">rust 语言圣经</a></p>
<p>rust 学习教程（中文），GitHub 2.6K 星</p>
</li>
<li>
<p><a href="https://github.com/andersontr15/clean-code-javascript-es">clean-code-javascript-es</a></p>
<p>如何编写简洁的 JavaScript</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1Q44y1B7xw">《致谢》作者黄国平博士在西南大学本科生毕业典礼上的演讲</a></p>
<p>这短短的一生，我们最终都将失去（出世），不妨大胆一些，爱一个人，攀一座山，追一个梦（入世）。</p>
<p>学弟学妹们，在梦想的道路上，一定会遇到各种困难，到今天，我依然坚持相信，努力终有所成。因为人生不能没有梦想。</p>
<p>致谢原文</p>
<pre><code>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。

出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七 岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。

人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的力。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交， 黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。

人后的苦尚旦还能克服，人前的尊严却无比脆弱。上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。

身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。

我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开 了个头。在未来，希望能有机会弥补这段遗憾。

从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。

最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■■■■■■■■■■■■■■■■■重塑了我的人生。

感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不认大学将来在休息，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。

感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。

最后，对参加论文评审、答辩的各位老师表示衷心的感谢！
</code></pre>
</li>
</ul>
<h2 id="2022-week-04"><a class="header" href="#2022-week-04">2022-week-04</a></h2>
<ul>
<li>
<p><a href="https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available">SpringBoot3.0 M1版本正式发布</a></p>
<p>抛弃 Java8，最低兼容 Java17</p>
</li>
<li>
<p><a href="https://www.baeldung.com/java-liskov-substitution-principle">Liskov Substitution Principle in Java</a></p>
<p>讲里式替换原则，讲得非常好，非常透彻的文章</p>
</li>
<li>
<p>一种在 Markdown 中居左插入图片的新方式：图片超链接</p>
<p>图片超链接，超链接的内容是图片（不再是文字），链接是点击图片后跳转的</p>
<p>图片超链接可以天然地实现图片的居左插入，GitHub badge 的原理既如此。下图为 Barbara Liskov。</p>
<p><a href="https://en.wikipedia.org/wiki/Barbara_Liskov"><img src="life-and-thinking/keep-learning/assets/220px-Barbara_Liskov_MIT_computer_scientist_2010-20220127204454834.jpg" alt="Portrait of Barbara Liskov" /></a></p>
<p>图片超链接的源码为：</p>
<pre><code>[![Portrait of Barbara Liskov](assets/220px-Barbara_Liskov_MIT_computer_scientist_2010-20220127204454834.jpg)](https://en.wikipedia.org/wiki/Barbara_Liskov)
</code></pre>
</li>
<li>
<p><a href="https://www.zhihu.com/question/511927934/answer/2318929238">高速上车机系统死机或黑屏了要怎么办？</a></p>
<p>上周提到新能源汽车车机系统的一个 bug，今天逛知乎的时候，又看到一个更离谱的，车企竟然在车机系统上推送广告，而且还是走高端新能源车路线的蔚来车机系统：</p>
<p><a href="life-and-thinking/keep-learning/"><img src="life-and-thinking/keep-learning/assets/v2-358ce1ab62aca53dda33d0004e018040_r.jpg" alt="img" /></a><a href="life-and-thinking/keep-learning/"><img src="life-and-thinking/keep-learning/assets/v2-60adf202a4f0a98d496fdcd1769236d4_r.jpg" alt="img" /></a></p>
<p>我再列举一下这些带有大屏车机的新能源车的弊端吧：</p>
<ul>
<li>车机系统越智能，安装的软件越多，越有崩溃的风险，而车机系统的首要功能，就是稳定性，车机的智能化与车的安全稳定性是背道而驰的</li>
<li>大屏车机会分散驾驶员的注意力</li>
<li>车机系统和手机系统一样，过几年就不会更新了，系统一堆漏洞，相像一下现在用 Windows XP 系统是什么感觉，用 Android4.0 系统是什么感觉</li>
<li>自动驾驶短期内是不可能实现的，谁会把自己的性命，交给一个花里胡哨不成熟的东西呢</li>
<li>新能源车刚刚起步没几年，目前的产品仍然是不成熟的，成熟的产品是不会在性命攸关的产品上推送广告的</li>
</ul>
<p>综上，把做手机的那一套方法论带到做机车上，是不行的，手机可以崩溃，可以死机，但是汽车不能崩溃（要出故障也只能是机械故障）。汽车应该回归它本来应有的功能，汽车就是一个安全的代步工具，第一要求是稳定性。越智能的东西，不稳定因素越大，增加各种花里胡哨的大多数情况下用不到的功能，只会给自己的驾驶带来安全隐患。</p>
</li>
</ul>
<h2 id="2022-week-06--08"><a class="header" href="#2022-week-06--08">2022-week-06 — 08</a></h2>
<ul>
<li>
<p><a href="https://book.douban.com/subject/35272352/">悲观者往往正确，乐观者往往成功</a></p>
<p>虽然内卷越来越严重，考研越来越难，但是宏观是我们必须接受的,微观才是我们可以有所作为的，停止抱怨，开始行动。</p>
</li>
<li>
<p><a href="https://movie.douban.com/subject/2210241/">贫嘴张大民的幸福生活</a></p>
<p>最近在追电影最 top 讲解的 <a href="https://www.bilibili.com/video/BV1oS4y1G7rU">贫嘴张大民的幸福生活</a>，堪称平民史诗。讲的老北京的普通老百姓的生活，很温馨接地气，看完心情久久不能平复，尤其是霍思燕和潘粤明的 cp，太好磕了，呜呜呜( Ĭ ^ Ĭ )</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220212093926271.png" alt="image-20220212093926271" style="zoom:50%;" />
</li>
<li>
<p><a href="https://book.douban.com/subject/1929725/">程序开发原理</a></p>
<p>推荐一本好书，也是我最近在看的一本书。现在太多书在讲怎么做，而很少有书讲为什么要这么做，这本书会告诉我们，为什么 Java 要引入异常机制，为什么成员变量要私有并通过 get set 访问，什么是里式替换原则。（里式替换原则的作者编写）</p>
</li>
<li>
<p>如何快速查找电子书</p>
<p>最近发现一个快速找到电子书的方法，不管什么电子书书，只需要去淘宝，花 3 块钱，就可以买到。专业的事找专业的人，省去了找书的麻烦。上面的《程序开发原理》电子书，就是直接淘宝买到的。</p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2022/02/weekly-issue-195.html">科技爱好者周刊</a> - <a href="https://www.inverse.com/science/black-hole-merger-2022">黑洞合并</a></p>
<p>天文学家观测到距离地球 12亿光年 的黑洞合并，经过阮老师的提醒，我突然意识到，这件事情 12亿 年前就已经发生了，只是经过 12 亿光年后光到达地球，我们才知道……</p>
</li>
</ul>
<h2 id="2022-week-09"><a class="header" href="#2022-week-09">2022-week-09</a></h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/VGL9t2TJpTNLVyfrNclhdw">在微软工作是怎样一种体验</a></p>
<p>真的好羡慕，大家看看微软的福利待遇：</p>
<p>1、全员持股，共同富裕的典范。另外还有股票内购福利，员工最多可以拿每个月工资的15%九折购买公司股票。</p>
<p>2、入职就有15天年假，不论工作年限长短。长达6周的男性陪产假。</p>
<p>3、覆盖配偶和子女的补充医疗保险。</p>
<p>4、水果、饮料、零食、咖啡近乎无限供应。</p>
<p>办公装备：</p>
<p>1、一个小型工作站，32G内存，i9处理器，运行起来相当丝滑。</p>
<p>2、两个显示器，如果觉得不够可以去IT领取，不需要审批。</p>
<p>3、两个笔记本电脑。</p>
<p>4、随时可以申请可升降办公桌。</p>
<p>5、网速超级快，整套装备使用体验相当好。</p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/WwlWCa5LV-bzWXaKn67TRg">如果你有以下10种症状，说明你压力过大，这4招帮你走出困境</a></p>
<p>命中了好多症状，忙得有点麻木了，很多时候都忽视了自己的压力</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/519615042/answer/2371272939">房价还会涨🐴</a> </p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220303103326514.png" alt="image-20220303103326514" style="zoom: 33%;" />
<p>太形象了，土地财政绑架了 zf，再吸一口，哈哈哈哈，只是扭转了三阶导数</p>
</li>
<li>
<p>低代码</p>
<p>最近在调研低代码，和大家分享一些我看过的文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/225987562">百度吴多益：低代码，要怎么低？和低代码有关的 10 个问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/419475396">知乎：聊聊我对 GraphQL 的一些认知</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/370436576">美团：GraphQL及元数据驱动架构在后端BFF中的实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/348950745">爱奇艺：减少重复开发，GraphQL在低代码平台如何落地？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/421426635">dataway 10 minutes</a></li>
<li><a href="https://www.graphql-java.com/tutorials/getting-started-with-spring-boot">graphql-springboot 10 minutes</a></li>
</ul>
</li>
</ul>
<h2 id="2022---week-10"><a class="header" href="#2022---week-10">2022 - week 10</a></h2>
<h3 id="一部电影大佛普拉斯"><a class="header" href="#一部电影大佛普拉斯">一部电影<a href="https://movie.douban.com/subject/27059130/">《大佛普拉斯》</a></a></h3>
<p>「我们已经可以依靠科技进入外太空，却依然无法走进一个人内心的宇宙」</p>
<p>「富人造佛，穷人拜佛」</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220305110320548.png" alt="image-20220305110320548" style="zoom: 25%;" />
<h3 id="一首诗词"><a class="header" href="#一首诗词">一首诗词</a></h3>
<p>西江月·世事短如春梦</p>
<p>世事短如春梦，人情薄似秋云。不须计较苦劳心。万事原来有命。</p>
<p>幸遇三杯酒好，况逢一朵花新。片时欢笑且相亲。明日阴晴未定。</p>
<h3 id="一句话"><a class="header" href="#一句话">一句话</a></h3>
<p>你喜欢吃草莓，你会毫不犹豫的买下它，如果你不喜欢吃香蕉，但考虑到香蕉助消化，你还是会买它。</p>
<p>所以，喜欢是单纯的，不喜欢，才会权衡利弊，在你犹豫的一瞬间，其实已经做出了选择。</p>
<p>— 杨绛</p>
<h3 id="快速入门-haproxy-和-keepalived"><a class="header" href="#快速入门-haproxy-和-keepalived">快速入门 HAProxy 和 keepalived</a></h3>
<p>https://www.bilibili.com/video/BV1Fh411Y7hc</p>
<p>HAProxy 用来做负载均衡，keepalived 用来做高可用</p>
<h3 id="在线图表绘制工具手绘风格excalidraw"><a class="header" href="#在线图表绘制工具手绘风格excalidraw">在线图表绘制工具（手绘风格）excalidraw</a></h3>
<p>https://excalidraw.com/</p>
<p>优点：手绘风格 缺点：云同步功能得付费</p>
<h3 id="java-中-getter-和-setter-的作用"><a class="header" href="#java-中-getter-和-setter-的作用">java 中 getter 和 setter 的作用</a></h3>
<p>知其然，也知其所以然，习以为常的编码方式，我们知道为什么要这样吗</p>
<p><a href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors">Why use getters and setters/accessors?</a></p>
<p><a href="https://www.baeldung.com/java-why-getters-setters">Significance of Getters and Setters in Java</a></p>
<h3 id="计算机领域的重要思想"><a class="header" href="#计算机领域的重要思想">计算机领域的重要思想</a></h3>
<p>计科：<em>abstraction</em> </p>
<p>数学：<em>formalization</em> </p>
<p>设计：<em>design is how it works</em> </p>
<p>软工：<em>indirection - &quot;All problems in computer science can be solved by another level of indirection&quot;</em></p>
<p>作者：黄玄 来源：知乎
链接：https://www.zhihu.com/question/32025746/answer/916476904</p>
<h3 id="soap-vs-rest-1"><a class="header" href="#soap-vs-rest-1">SOAP vs Rest</a></h3>
<p>基于 HTTP 的通信有两种常见方式：SOAP 和 Rest，最近因为工作原因接触到 SOAP，发现 SOAP 实际上就是 HTTP + XML</p>
<p>SOAP：HTTP + XML</p>
<p>Rest：HTTP + JSON</p>
<h2 id="2022---week---11"><a class="header" href="#2022---week---11">2022 - week - 11</a></h2>
<h3 id="一个视频"><a class="header" href="#一个视频">一个视频</a></h3>
<p>【范 大 神 仙 怒 斥 天 兵 天 将-哔哩哔哩】 https://b23.tv/pHHfBGg</p>
<p>迄今为止，我看到的范志毅宇宙，最离谱的一个视频。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220313165915522.png" alt="image-20220313165915522" style="zoom: 25%;" />
<h3 id="一个-up-主"><a class="header" href="#一个-up-主">一个 up 主</a></h3>
<p>马刀刻森 https://space.bilibili.com/14048220</p>
<p>代表作：<a href="https://www.bilibili.com/video/BV1GZ4y1d7yP?spm_id_from=333.999.0.0">张无忌！！！你就是歌姬吧？！！</a></p>
<p>百万 up 主预定。</p>
<h3 id="一句话-1"><a class="header" href="#一句话-1">一句话</a></h3>
<p>你没有做错什么，甚至大概率比10年前的你做得更好。但最可悲的事实是这个时代结束了，而这个时代中的我们还活着。</p>
<h3 id="一首诗"><a class="header" href="#一首诗">一首诗</a></h3>
<p>西江月·世事短如春梦</p>
<p>世事短如春梦，人情薄似秋云。不须计较苦劳心。万事原来有命。</p>
<p>幸遇三杯酒好，况逢一朵花新。片时欢笑且相亲。明日阴晴未定。</p>
<p>人生无常，波音 737 坠毁，想起了这首诗。这个月刚飞了两次四川，看到这件事，很压抑。</p>
<h3 id="廖雪峰-web-开发教程"><a class="header" href="#廖雪峰-web-开发教程">廖雪峰 Web 开发教程</a></h3>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400">廖雪峰 Web 开发教程</a></p>
<p>推荐廖大神的 web 开发教程，从 servlet 讲起，一直到 mvc 框架的由来，授人以鱼，也授人以渔。</p>
<p>很多人学习 web 开发，是从 Springboot 开始学起，但实际应该从最基础的 HTTP 和 Servlet 开始学起。</p>
<h2 id="2022---week--12"><a class="header" href="#2022---week--12">2022 - week -12</a></h2>
<h3 id="一句话-2"><a class="header" href="#一句话-2">一句话</a></h3>
<p>缓慢的、持久的、有纪律的努力，最终会导致令人难以置信的结果。</p>
<p>每当我无法忍受日常生活时，我就提醒自己，没有什么比每天坚持做下去更重要了。虽然我很难看到未来会怎样，但我知道持久性具有强大的威力，就像一句古老格言说的&quot;继续去做&quot;（keep doing）。</p>
<p>-- <a href="https://www.collaborativefund.com/blog/lessons-from-the-sea/">《大海教给我的》</a></p>
<h3 id="一个观点-1"><a class="header" href="#一个观点-1">一个观点</a></h3>
<p>房价真的到顶了吗</p>
<p>https://www.zhihu.com/question/340712338/answer/2387456275</p>
<h3 id="一个项目"><a class="header" href="#一个项目">一个项目</a></h3>
<p><a href="https://github.com/txperl/Story-for-Typecho">Story-for-Typecho</a> 一个博客模板，设计感很好</p>
<p><img src="life-and-thinking/keep-learning/assets/screenshot.png" alt="screenshot" /></p>
<h2 id="2022-week-13"><a class="header" href="#2022-week-13">2022-week-13</a></h2>
<h3 id="9000-个人一起看同一个视频"><a class="header" href="#9000-个人一起看同一个视频">9000 个人一起看同一个视频</a></h3>
<p>9000 个人看同一个视频，看到这个数字，我惊呆了。</p>
<p>难怪现在有很多人权值搞自媒体，就想鸟哥说的一样，如果你把在城市的努力程度放到农村，你的生活也可以过的很好。</p>
<p>如果我们把一部分的经历，放在我们热爱的事情身上，去做自媒体，也许也可以做的很好。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220327162324800.png" alt="image-20220327162324800" /></p>
<h3 id="计算机研究生就业"><a class="header" href="#计算机研究生就业">计算机研究生就业</a></h3>
<p>最近开了一个腾讯会议，和群里的同学，聊了聊计算机研究生的就业。</p>
<p>核心思想就是，趁着读研有时间，去考公务员试试，找工作别跟风都去互联网，多听听自己内心深处的想法。</p>
<p>然后，去互联网公司的话，北京上海深圳至少得开 35W+，不然还不如在南京等新一线，不要只看钱，还要看工作城市的房价。有好的平台，例如阿里，腾讯，字节，美团，华为，百度这种公司，不管在哪个城市，都是值得去的。对于二三流的公司，例如滴滴、OPPO、vivo，就要多掂量掂量了，可能高薪，但是不太稳定。</p>
<p>我老家在连云港，连云港的公务员，一年总包 15w，我感觉真的太香了，比我在南京打工强多了。</p>
<p>这是临时准备的思维导图，仅供参考，不接受批评。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220327163752133.png" alt="image-20220327163752133" style="zoom:67%;" />
<h3 id="一个观点-2"><a class="header" href="#一个观点-2">一个观点</a></h3>
<p>疫情这几年，中国人已经人困马乏了。或许还有进一步折腾的空间，但过去的平稳肯定是一去不复返了。空难这件事不是孤立的，社会上还有各行各业，国家只是个机器，变不出钱来，大户的钱就那点，越杀越少，杀了也只有一小部分惠及百姓，没有稳定的市场主体就没有百姓的富裕生活。</p>
<p>这是个防控的张力的问题，究竟应该怎么平衡防治和放开？南孟买已经公然在对抗中央了，一副要做哥谭第二的架势。只要把全国都带崩，由不得组织不从。发生这种事，也不是偶然。</p>
<p>但带崩后如何，谁敢断言呢？是真的没有多大风浪，还是掀起一波巨大的浪潮？或者持续高压下去，还持续得住吗？</p>
<p>党和人民面临的这场考验，十分凶险。</p>
<p>作者：黑涩土狗蓝孩
链接：
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="关于裁员"><a class="header" href="#关于裁员">关于裁员</a></h3>
<p>大环境下，各行各业的冷热情暖都是相互影响的，房地产从业人员几百万，教辅从业人员上百万，旅游行业从业人员几百万，餐饮从业人员上千万……他们的收入降低了，必然收缩消费，服装、美容、电子、娱乐……都会受影响，互联网涉及到电商、娱乐等各种消费，必然受影响。</p>
<p>所以互联网裁员是大环境变差的必然结果，各行各业都在不同程度裁员，受影响，只不过互联网话题热度最高容易洽流量，所以你觉得互联网裁员好像最严重而已，互联网依然是大多数年轻人最想去的地方，裁起员来才更有底气。</p>
<p>作者：老杨叔聊志愿填报 - 知乎</p>
<h3 id="一部电影"><a class="header" href="#一部电影">一部电影</a></h3>
<p><a href="https://movie.douban.com/subject/1947089/">投名状</a> 豆瓣 7.5 分（低了）</p>
<p>看过，这周在发条张那里又看了一遍：<a href="https://b23.tv/OuOozmU">【细读经典：被严重低估的华语杰作！现在上映票房至少10亿起-哔哩哔哩】</a> https://b23.tv/OuOozmU</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220331190514767.png" alt="image-20220331190514767" style="zoom: 33%;" />
<h3 id="一句台词"><a class="header" href="#一句台词">一句台词</a></h3>
<p>那天我们都喝醉了，也都哭了，说了很多肝胆相照的话，真是难忘的一夜。 几天后，我和北雁儿正式举行了婚礼，她父母单独找我谈了一次话，问我是不是隐瞒了年龄？ 我跟老人家说，我从出生就显得比别的孩子老。</p>
<p>1997年过去了，我很怀念它。</p>
<p>——「甲方乙方」</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220331185150046.png" alt="image-20220331185150046" style="zoom: 33%;" />
<h3 id="一个教程"><a class="header" href="#一个教程">一个教程</a></h3>
<p>这一周把廖雪峰的 jdbc 编程又过了一遍，循序渐进。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943820274272">廖雪峰 jdbc 编程</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282383540125729">廖雪峰 spring 开发 访问数据库</a></p>
<h3 id="一首诗-1"><a class="header" href="#一首诗-1">一首诗</a></h3>
<p>神童诗</p>
<p>天子重英豪，文章教尔曹；
万般皆下品，惟有读书高。
少小须勤学，文章可立身；
满朝朱紫贵，尽是读书人。
学问勤中得，萤窗万卷书；
三冬今足用，谁笑腹空虚。
自小多才学，平生志气高；
别人怀宝剑，我有笔如刀。
朝为田舍郎，暮登天子堂；
将相本无种，男儿当自强。
学乃身之宝，儒为席上珍；
君看为宰相，必用读书人。
莫道儒冠误，诗书不负人；
达而相天下，穷则善其身。
遗子满赢金，何如教一经；
姓名书锦轴，朱紫佐朝廷。
古有千文义，须知学后通；
圣贤俱间出，以此发蒙童。
神童衫子短，袖大惹春风；
未去朝天子，先来谒相公。
年纪虽然小，文章日渐多；
待看十五六，一举便登科。
大比因时举，乡书以类升；
名题仙桂籍，天府快先登。
喜中青钱选，才高压俊英；
萤窗新脱迹，雁塔早题名。
年小初登第，皇都得意回；
禹门三级浪，平地一声雷。
一举登科目，双亲未老时；
锦衣归故里，端的是男儿。
玉殿传金榜，君恩赐状头；
英雄三百辈，附我步瀛洲。
慷慨丈夫志，生当忠孝门；
为官须作相，及第必争先。
宫殿召绕耸，街衢竞物华；
风云今际会，千古帝王家。
日月光天德，山河壮帝居；
太平无以报，愿上万年书。
久旱逢甘雨，他乡遇故知；
洞房花烛夜，金榜挂名时。
土脉阳和动，韶华满眼新；
一支梅破腊，万象渐回春。
柳色浸衣绿，桃花映酒红；
长安游冶子，日日醉春风。
淑景余三月，莺花已半稀；
浴沂谁氏子，三叹咏而归。
数点雨余雨，一番寒食寒；
杜鹃花发处，血泪染成丹。
春到清明好，晴天锦绣纹；
年年当此节，底事雨纷纷。
风阁黄昏夜，开轩内晚凉；
月华在户白，何处递荷香？
一雨初收霁，金风特送凉；
书窗应自爽，灯火夜偏长。
庭下陈瓜果，云端闻彩车；
争如郝隆子，只晒腹中书。
九日龙山饮，黄花笑逐臣；
醉看风落帽，舞爱月留人。
昨日登高罢，今朝再举觞；
菊荷何太苦，遭此两重阳。
北帝方行令，天晴爱日和；
农工新筑土，天庆纳嘉禾。
檐外三竿日，新添一线长；
登台观气象，云物喜呈祥。
冬天更筹尽，春附斗柄回；
寒暄一夜隔，客鬓两年催。
解落三秋叶，能开二月花；
过江千尺浪，入竹万竿斜。
人在艳阳中，桃花映面红；
年年二三月，底事笑春风。
院落沉沉晓，花开白雪香；
一枝轻带雨，泪湿贵妃妆。
枝缀霜葩白，无言笑晓凤；
清芳谁是侣，色间小桃红。
倾国姿容别，多开富贵家；
临轩一赏后，轻薄万千花。
墙角一枝梅，凌寒独自开；
遥知不是雪，为有暗香来。
柯干如金石，心坚耐岁寒；
平生谁结友，宜共竹松看。
居可无君子，交情耐岁寒；
春风频动处，日日报平安。
春水满泗泽，夏云多奇峰；
秋月扬明辉，冬岭秀孤松。
诗酒琴棋客，风花雪月天；
有名闲富贵，无事散神仙。
道院迎仙客，书道隐相儒；
庭裁栖凤竹，池养化龙鱼。
春游芳草地，夏赏绿荷池；
秋饮黄花酒，冬吟白雪诗。</p>
<h3 id="显卡价格暴跌"><a class="header" href="#显卡价格暴跌">显卡价格暴跌</a></h3>
<p>显卡价格暴跌的原因，是以太坊即将切换区块链的共识机制，共识机制将从工作量证明（PoW）切换到权益证明（PoS）。切换后，新的节点不通过计算哈希产生，这意味着显卡挖矿没用了。</p>
<h2 id="2022-week-14"><a class="header" href="#2022-week-14">2022-week-14</a></h2>
<h3 id="一首诗-致橡树"><a class="header" href="#一首诗-致橡树">一首诗 致橡树</a></h3>
<p>我如果爱你——
绝不像攀援的凌霄花，
借你的高枝炫耀自己；
我如果爱你——
绝不学痴情的鸟儿，
为绿荫重复单调的歌曲；
也不止像泉源，
常年送来清凉的慰藉；
也不止像险峰，
增加你的高度，衬托你的威仪。
甚至日光，
甚至春雨。</p>
<p>不，这些都还不够！
我必须是你近旁的一株木棉，
作为树的形象和你站在一起。
根，紧握在地下；
叶，相触在云里。
每一阵风过，
我们都互相致意，
但没有人，
听懂我们的言语。
你有你的铜枝铁干，
像刀，像剑，也像戟；
我有我红硕的花朵，
像沉重的叹息，
又像英勇的火炬。</p>
<p>我们分担寒潮、风雷、霹雳；
我们共享雾霭、流岚、虹霓。
仿佛永远分离，
却又终身相依。
这才是伟大的爱情，
坚贞就在这里：
爱——
不仅爱你伟岸的身躯，
也爱你坚持的位置，
足下的土地。</p>
<h3 id="一个短视频"><a class="header" href="#一个短视频">一个短视频</a></h3>
<p>【【亮剑版毒液】龙 液 （李云龙大战楚云飞！）-哔哩哔哩】 https://b23.tv/H6MSif5</p>
<h3 id="github-copilot"><a class="header" href="#github-copilot">GitHub Copilot</a></h3>
<p>早就听说过 GitHub 副驾驶的大名，最近试用了一下，确实爽。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220402090658079.png" alt="image-20220402090658079" style="zoom:50%;" />
<h3 id="deepl"><a class="header" href="#deepl">DeepL</a></h3>
<p>比 Google 翻译，百度翻译都好用的翻译。</p>
<h3 id="一个-up-主-爱吃粑蛋的人"><a class="header" href="#一个-up-主-爱吃粑蛋的人">一个 up 主 爱吃粑蛋的人</a></h3>
<p>https://space.bilibili.com/70757306</p>
<p>最近又发现了一个宝藏 up 主：爱吃粑蛋的人</p>
<p>顶尖大学的顶尖演技。</p>
<p>https://www.bilibili.com/video/BV1vr4y1p7KA</p>
<h2 id="2022-week-15"><a class="header" href="#2022-week-15">2022-week-15</a></h2>
<h3 id="民间互助"><a class="header" href="#民间互助">民间互助</a></h3>
<p>上海疫情，各个微信群里，扑面而来的负面消息，看得让人揪心，我也分不清真假。今天看到一个暖心的小故事，虽然故事可能发生在高档小区，虽然故事可能是一场营销，但看到这个还是蛮治愈的。但行直心。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220415155826292.png" alt="image-20220415155826292" style="zoom:33%;" />
<h3 id="这里是中国---如何架设一个石油钻井平台"><a class="header" href="#这里是中国---如何架设一个石油钻井平台">这里是中国 - 如何架设一个石油钻井平台</a></h3>
<p>很久没看到这种硬核的，配图专业的科普文章了</p>
<p>https://mp.weixin.qq.com/s/atAiSpkNyWte0MSoJ6TFzw</p>
<p><img src="life-and-thinking/keep-learning/assets/bg2022040903-20220415164323803.webp" alt="img" /></p>
<h2 id="2022-week-16"><a class="header" href="#2022-week-16">2022-week-16</a></h2>
<h3 id="一门公开课-中科大---计算机网络"><a class="header" href="#一门公开课-中科大---计算机网络">一门公开课 中科大 - 《计算机网络》</a></h3>
<p>工作中频繁会接触到计算机网络的知识，但是我自己对计算机网络，仅仅是知其然而不知其所以然。最近决定补一补这方面的知识。看了几节课后，有一个感悟。</p>
<p>我们大学时候学习的计算机相关的专业课，在工作中是需要再去温习一遍的，有了实战经验，再回归到书本，我在上课的过程中，经常会感叹，哇，原来是这样，工作中模模糊糊的一个知识，竟然是这个道理，实践结合理论，常常心生喜悦。</p>
<p><a href="https://www.bilibili.com/video/BV1JV411t7ow">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</a></p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220422080218116.png" alt="image-20220422080218116" style="zoom:33%;" />
<h3 id="如何度过疫情裁员还有战争"><a class="header" href="#如何度过疫情裁员还有战争">如何度过疫情、裁员、还有战争</a></h3>
<p>推荐阮一峰的 <a href="https://www.ruanyifeng.com/blog/2022/04/weekly-issue-204.html">科技爱好者周刊（第 204 期）：如何度过疫情、裁员、还有战争</a>，宏观是我们必须接受的，微观是我们有所作为的。</p>
<p>疫情当下，少上网接触负面的消息，少看微博，少上知乎，少打开微信群，多看书充实自己。</p>
<h3 id="一首歌-生如夏花-朴树"><a class="header" href="#一首歌-生如夏花-朴树">一首歌 生如夏花 朴树</a></h3>
<p>https://www.bilibili.com/video/BV1sq4y1w7Dx</p>
<h3 id="一个仓库"><a class="header" href="#一个仓库">一个仓库</a></h3>
<p>一个 GitHub 仓库，免费分享各种英文杂志，方便大家学习英文。（带着批判的立场去读）</p>
<p><a href="https://github.com/hehonghui/the-economist-ebooks">经济学人(含音频)、纽约客、自然、新科学人、卫报、科学美国人、连线、大西洋月刊、国家地理等英语杂志免费下载</a></p>
<h2 id="2022-week-17"><a class="header" href="#2022-week-17">2022-week-17</a></h2>
<h3 id="对最近很火的一个视频的看法"><a class="header" href="#对最近很火的一个视频的看法">对最近很火的一个视频的看法</a></h3>
<p>最近和朋友聊天，聊到了这个话题，我忍不住发发牢骚，最近的各种负面新闻，我也是受够了。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220425132753972.png" alt="image-20220425132753972" style="zoom:50%;" />
<h3 id="一个观点-3"><a class="header" href="#一个观点-3">一个观点</a></h3>
<p>北京市教师轮岗成效低，改为信息化手段流转，您怎么看？ - 谢流远的回答 - 知乎 https://www.zhihu.com/question/520747377/answer/2455865997</p>
<blockquote>
<p>现在就是独生子女太多了，但凡家里多几个孩子对比一下，也不至于认为老师水平能对孩子有啥决定性影响。</p>
<p>80，90自己是独生子女，不少还只生一个，没见过组内对照实验，所以喜欢把一切都归因到老师家长的不同上。</p>
<p>建议回家和自己的60后父母聊聊，60后普遍都是一家n个，一样的父母，一个村里上学，长大了命运天差地别。</p>
<p>真要是望子成龙与其鸡娃不如咣咣生，自己基因别太差，大概生七八个能生个成器的出来，稍微提携一下不成器的就好。</p>
<p>一命二运三风水，四积阴德五读书。人的命运第一靠基因变异，第二靠运气，老师家长排在八九十往后了。</p>
</blockquote>
<h3 id="json-3"><a class="header" href="#json-3">JSON</a></h3>
<p>天天用 json，但是 json 到底是啥？JavaScript Object Notation.</p>
<p>JSON 是 JavaScript 序列化的标准。JSON 是字符串。</p>
<p>JSON 的语法超级简单，只有几种数据类型：</p>
<pre><code>number：和JavaScript的number完全一致；
boolean：就是JavaScript的true或false；
string：就是JavaScript的string；
null：就是JavaScript的null；
array：就是JavaScript的Array表示方式——[]；
object：就是JavaScript的{ ... }表示方式。
</code></pre>
<p>以及上面的任意组合。</p>
<p>并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code>。</p>
<p>一个 json 示例：</p>
<pre><code class="language-json">{
  &quot;firstName&quot;: &quot;John&quot;,
  &quot;lastName&quot;: &quot;Smith&quot;,
  &quot;isAlive&quot;: true,
  &quot;age&quot;: 27,
  &quot;address&quot;: {
    &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
    &quot;city&quot;: &quot;New York&quot;,
    &quot;state&quot;: &quot;NY&quot;,
    &quot;postalCode&quot;: &quot;10021-3100&quot;
  },
  &quot;phoneNumbers&quot;: [
    {
      &quot;type&quot;: &quot;home&quot;,
      &quot;number&quot;: &quot;212 555-1234&quot;
    },
    {
      &quot;type&quot;: &quot;office&quot;,
      &quot;number&quot;: &quot;646 555-4567&quot;
    }
  ],
  &quot;children&quot;: [],
  &quot;spouse&quot;: null
}
</code></pre>
<p>参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023021554858080</p>
<h3 id="微博评论和微信公众号加入地址"><a class="header" href="#微博评论和微信公众号加入地址">微博评论和微信公众号加入地址</a></h3>
<p>微博评论开始显示地址了，互联网确实不是法外之地，自由是有代价的。支持。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220430111628543.png" alt="image-20220430111628543" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220430112132296.png" alt="image-20220430112132296" /></p>
<h2 id="2022-week-18"><a class="header" href="#2022-week-18">2022-week-18</a></h2>
<p>五一劳动节 五天假</p>
<h3 id="滴滴司机-困在系统里"><a class="header" href="#滴滴司机-困在系统里">滴滴司机 困在系统里</a></h3>
<p>前几天出门打了一辆滴滴，整个路上，司机就和我说了两句话，「你好，你好 63xx」，「谢谢，不客气」。全程不到 5 公里的路上，滴滴 APP 提醒了两遍：「请不要主动和乘客攀谈，不要询问乘客隐私」。</p>
<p>想起了《外卖骑手 困在系统里》这篇文章。网约车司机，和外卖骑手一样，被困在了系统里的。资本将人与人之间的天然的连接剥离掉，将人异化成工具，异化成螺丝钉。我总觉得缺了点什么，也许是缺了点人情味，烟火气。</p>
<p>18 年在北京实习的时候，我经常打车上下班，北京的司机比较健谈。从他们的口中得知，滴滴打车刚兴起的那几年，很多早加盟的网约车司机，一个月都能赚两万多。但是随着烧钱大战的结束，滴滴一家独大，网约车的生意也越来越难做了。货拉拉事件发生后，网约车司机的日子应该更难过了。</p>
<p>我遇到过很多热心肠的师傅。南京疫情最严重的时候，打 T3 的网约车，上车后需要扫码，我上车后小哥请问扫码，我自然就拿出手机，扫码登记。出乎我意料的是，扫完码后，司机小哥竟然很感谢我，他说情愿配合扫码登记的乘客，很少，小哥说他家在江苏宿迁的农村，离刘强东东哥家的村子不远。他说强东功成名就，衣锦还乡的时候，给村里的老人发钱，后来停止发放了，村里很多人还埋怨强东。小哥是觉得，东哥发钱是情分，不发是本分。</p>
<p>还遇到过一位网约车师傅，那次我酒喝多了，一身酒气，呼吸也比较急促。我坐在前排，上车后就开始打盹，师傅闻到了酒味，问我，要不要把座椅往后调一调，方便我腿伸开好休息。突然而来的陌生人的关系，让我很感动。</p>
<p>想起来一首诗</p>
<blockquote>
<p>西江月</p>
<p>世事短如春梦，人情薄似秋云。不须计较苦劳心。万事原来有命。</p>
<p>幸遇三杯酒好，况逢一朵花新。片时欢笑且相亲。明日阴晴未定。</p>
</blockquote>
<p>不说了，明天要上班了。</p>
<h3 id="一个观点-4"><a class="header" href="#一个观点-4">一个观点</a></h3>
<p>练道修心都是扯淡，真正能让人大幅度降低物欲的大概就三种，权力的支配欲、知识的探索欲以及创造积累的成就感。</p>
<h3 id="红山动物园的一只獐子去世"><a class="header" href="#红山动物园的一只獐子去世">红山动物园的一只獐子去世</a></h3>
<p><img src="life-and-thinking/keep-learning/assets/bg2022042707.webp" alt="img" /></p>
<h3 id="虹猫蓝兔七侠传"><a class="header" href="#虹猫蓝兔七侠传">虹猫蓝兔七侠传</a></h3>
<p>小时候很喜欢看的一部动画片，最近又在 B 站看了看，惊奇地发现，文学顾问竟然是余华。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220508212223669.png" alt="image-20220508212223669" /></p>
<p>还有歌词，朴素中充满了力量，小时候没听懂，现在懂了。</p>
<p>能在小时候看到这么多优秀的动画片，我觉得很幸运。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220508213454608.png" alt="image-20220508213454608" /></p>
<h3 id="南京红山森林动物园"><a class="header" href="#南京红山森林动物园">南京红山森林动物园</a></h3>
<p>周末去红山森林动物园转了一圈，第一次看到大熊猫，第一次看到孔雀求偶，第一次看到考拉，第一次看到熊瞎子……</p>
<table><thead><tr><th><img src="life-and-thinking/keep-learning/assets/image-20220508213848530.png" alt="image-20220508213848530" /></th><th><img src="life-and-thinking/keep-learning/assets/image-20220508213856061.png" alt="image-20220508213856061" /></th></tr></thead><tbody>
<tr><td><img src="life-and-thinking/keep-learning/assets/image-20220508214004300.png" alt="image-20220508214004300" /></td><td><img src="life-and-thinking/keep-learning/assets/image-20220508213911674.png" alt="image-20220508213911674" /></td></tr>
</tbody></table>
<h2 id="2022-week-20"><a class="header" href="#2022-week-20">2022-week-20</a></h2>
<h3 id="百年孤独"><a class="header" href="#百年孤独">百年孤独</a></h3>
<p>生命中曾经有过的所有喧嚣，都将用寂寞来偿还。</p>
<h3 id="一句话-3"><a class="header" href="#一句话-3">一句话</a></h3>
<p>I am a pessimist by nature. Many people can only keep on fighting when they expect to win. I'm not like that, I always expect to lose. I fight anyway, and sometimes I win. </p>
<p>—— Richard Stallman 自由软件之父</p>
<h2 id="2022-week-21"><a class="header" href="#2022-week-21">2022-week-21</a></h2>
<h3 id="一首诗-2"><a class="header" href="#一首诗-2">一首诗</a></h3>
<p>临江仙·夜饮东坡醒复醉</p>
<p>苏轼</p>
<p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p>
<p>长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1Z7xE">我们在这个世界上可以拥有多少自由？（解读苏轼《临江仙》）</a></p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220522095419452.png" alt="image-20220522095419452" style="zoom:50%;" />
<h3 id="仿生阅读"><a class="header" href="#仿生阅读">仿生阅读</a></h3>
<p>一种快速阅读英文文献的方式，亲测有用。大致原理是，在英语文本里，给每个单词的前几个字母加粗，就可以引导人眼迅速识别出单词。</p>
<p>Demo:</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220523194104582.png" alt="image-20220523194104582" style="zoom:50%;" />
<p>这是一个 Chrome 插件实现：https://github.com/ansh/bionic-reading</p>
<h3 id="王心凌能出圈的客观原因"><a class="header" href="#王心凌能出圈的客观原因">王心凌能出圈的客观原因</a></h3>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220525132124060.png" alt="image-20220525132124060" style="zoom:50%;" />
<h3 id="一部电影-一一"><a class="header" href="#一部电影-一一">一部电影 《一一》</a></h3>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20220529164025428.png" alt="image-20220529164025428" style="zoom:13%;" />
<h3 id="缓解腰肌劳损的方法"><a class="header" href="#缓解腰肌劳损的方法">缓解腰肌劳损的方法</a></h3>
<p>绝大多数人忽略了一个关键环节：睡觉。</p>
<p>一个 trick: 睡觉时，把脚放在一个枕头上面</p>
<p>https://www.zhihu.com/question/453312421/answer/2333888047</p>
<h2 id="week-23"><a class="header" href="#week-23">week-23</a></h2>
<h3 id="关于唐山恶性事件的看法"><a class="header" href="#关于唐山恶性事件的看法">关于唐山恶性事件的看法</a></h3>
<p>最近只要一上网，就铺天盖地的恶性新闻，还有官媒发声，明星发声。</p>
<p>我想，如果受害者是一位男性，恐怕不会在互联网上掀起什么大浪。</p>
<p>还有官媒，毒教材刚发酵的时候，怎么没挺身而出去狠狠批判的呢？</p>
<p>出现这样的恶性事件，在社会上引起这么大的动荡，有其深刻的背景原因。</p>
<p>经济持续低迷，疫情结束遥遥无期，大家都很焦虑，都需要一个宣泄情绪的渠道，所以网络上的戾气，越来越重。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220612085346697.png" alt="image-20220612085346697" /></p>
<p>我又想起了阮老师的这篇文章，分享给大家。</p>
<h2 id="week-24"><a class="header" href="#week-24">week-24</a></h2>
<h3 id="分享几个最近看到的视频"><a class="header" href="#分享几个最近看到的视频">分享几个最近看到的视频</a></h3>
<p>看看普通人的生活。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220617090554214.png" alt="image-20220617090554214" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220617090602661.png" alt="image-20220617090602661" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220617090615973.png" alt="image-20220617090615973" /></p>
<h3 id="一个开源项目"><a class="header" href="#一个开源项目">一个开源项目</a></h3>
<p><a href="https://github.com/hangbale/photography-blog">photography blog generator</a> 一个摄影类的博客生成器。</p>
<p>挺有设计感的，我在云上部署了一个版本，把最近几年的照片 po 了上去。</p>
<p><a href="http://gallery.wansho.top/">wansho gallery</a></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220618162232453.png" alt="image-20220618162232453" /></p>
<h3 id="旅途"><a class="header" href="#旅途">旅途</a></h3>
<p><img src="life-and-thinking/keep-learning/assets/image-20220619183649444.png" alt="image-20220619183649444" /></p>
<h2 id="week-25"><a class="header" href="#week-25">week-25</a></h2>
<h3 id="一个开源项目-pyscript"><a class="header" href="#一个开源项目-pyscript">一个开源项目 PyScript</a></h3>
<p><a href="https://pyscript.net/">PyScript 官网</a></p>
<p>只需要引入一个样式文件，和一个 js 库，就可以在前端运行 Python 脚本！</p>
<p>给大家看一下，一个简单的 html + python，能实现的效果：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weekly"><a class="header" href="#weekly">weekly</a></h1>
<p>[TOC]</p>
<h2 id="week-25-1"><a class="header" href="#week-25-1">week-25</a></h2>
<h3 id="江宁九龙湖"><a class="header" href="#江宁九龙湖">江宁九龙湖</a></h3>
<p><img src="life-and-thinking/keep-learning/assets/image-20220625064405022.png" alt="image-20220625064405022" /></p>
<h3 id="一个开源项目-pyscript-1"><a class="header" href="#一个开源项目-pyscript-1">一个开源项目 PyScript</a></h3>
<p><a href="https://pyscript.net/">PyScript 官网</a></p>
<p>只需要引入一个样式文件，和一个 js 库，就可以在前端运行 Python 脚本！</p>
<p>给大家看一下，一个简单的 html + python，能实现的效果：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Matplotlib&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;./favicon.png&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt;
    &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt;
    &lt;py-env&gt;
      - matplotlib
    &lt;/py-env&gt;
    &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div id=&quot;mpl&quot;&gt;&lt;/div&gt;
      &lt;py-script output=&quot;mpl&quot;&gt;
      import matplotlib.pyplot as plt
      import matplotlib.tri as tri
      import numpy as np

      # First create the x and y coordinates of the points.
      n_angles = 36
      n_radii = 8
      min_radius = 0.25
      radii = np.linspace(min_radius, 0.95, n_radii)

      angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)
      angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
      angles[:, 1::2] += np.pi / n_angles

      x = (radii * np.cos(angles)).flatten()
      y = (radii * np.sin(angles)).flatten()
      z = (np.cos(radii) * np.cos(3 * angles)).flatten()

      # Create the Triangulation; no triangles so Delaunay triangulation created.
      triang = tri.Triangulation(x, y)

      # Mask off unwanted triangles.
      triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
                              y[triang.triangles].mean(axis=1))
                      &lt; min_radius)

      fig1, ax1 = plt.subplots()
      ax1.set_aspect('equal')
      tpc = ax1.tripcolor(triang, z, shading='flat')
      fig1.colorbar(tpc)
      ax1.set_title('tripcolor of Delaunay triangulation, flat shading')

      fig1
      &lt;/py-script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="life-and-thinking/keep-learning/assets/image-20220620141155388.png" alt="image-20220620141155388" /></p>
<h3 id="wasm-1"><a class="header" href="#wasm-1">wasm</a></h3>
<p>看到上面 pyscript 项目，我很好奇，pyscript 是用的什么技术，实现的在 html 中写 Python 代码。</p>
<p>经过一番调研，发现其使用的就是大名鼎鼎的 web assembly（wasm） 技术。通过 wasm，可以将其他编程语言（例如 C++，Rust，Python）的代码，编译成 wasm，然后由浏览器执行 wasm 文件。</p>
<p>wasm 是 web 端一种偏底层的技术，其执行效率，要高于 JavaScript。</p>
<p>这里是我查到的一些资料：</p>
<ul>
<li><a href="https://webassembly.org/getting-started/developers-guide/">wasm org</a></li>
<li>python -&gt; wasm: <a href="https://pyodide.org/en/stable/">Pyodide</a>, a Python distribution for the browser and Node.js based on WebAssembly.</li>
<li>python -&gt; wasm: <a href="https://pyscript.net/">PyScript</a> Run Python in Your HTML </li>
<li>C++ -&gt; wasm 的在线工具：https://mbebenita.github.io/WasmExplorer/</li>
<li>Bilibili 视频介绍：https://www.bilibili.com/video/BV13i4y1n74s</li>
</ul>
<h3 id="新概念英语"><a class="header" href="#新概念英语">新概念英语</a></h3>
<p>逛知乎看到有人评价《新概念英语》英语这本书是学习英语的最好教材。</p>
<p>不明觉厉。</p>
<h3 id="中国消费者信心指数"><a class="header" href="#中国消费者信心指数">中国消费者信心指数</a></h3>
<p>冲浪看到的一个指数，好像是非官方的，在统计局上查不到。</p>
<p><img src="life-and-thinking/keep-learning/assets/FgxQBAMbeXSb5EUaCF_NPw6mIuUiv3.jpg" alt="img" /></p>
<h3 id="致谢---黄国平"><a class="header" href="#致谢---黄国平">致谢 - 黄国平</a></h3>
<p>毕业季，又想起了黄国平博士的毕业发言，泪目</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220622152832373.png" alt="image-20220622152832373" /></p>
<h3 id="蔚来汽车事故"><a class="header" href="#蔚来汽车事故">蔚来汽车事故</a></h3>
<p>电动汽车圈，最近发生的好多事情，太魔幻了。</p>
<pre><code>李x：理想 L9 是 500W 以内最好的 SUV
余x嘴：现在买燃油车，就像智能手机时代买功能手机
</code></pre>
<p>电动汽车一如既往的不靠谱。现在电动汽车已经剑走偏锋了，开始搞手机圈的那一套了，叠各种黑科技，叠算力，叠智能，叠屏幕，叠百米加速，而汽车的基本属性，安全，去鲜有厂商去强调。</p>
<p>百米加速，蔚来 ES7 的百米加速已经达到 3.9 秒，那么猛的劲，一脚油门下去，司机能控制得住吗？我有一次，骑着自行车好好的，路边的一辆蔚来突然启动斜窜出来，吓我一大跳。</p>
<p>实在搞不清楚，那么高的算力，有什么用，难道不费电吗，智能驾驶难道真能代替司机吗？</p>
<p>程序是不靠谱的，那么复杂的系统，是肯定有 bug 的，现在什么按钮都做到屏幕里面，万一哪天系统死机了呢？难以置信有那么多人买电动智能车。</p>
<h3 id="高考"><a class="header" href="#高考">高考</a></h3>
<p>6 月 24 日，江苏高考放榜了。</p>
<p>现在是 3 + 1 + 2 的模式，一共考 6 门。我有一个亲戚，考了 570 分，高不高低不低的。</p>
<p>想起一位老师说过的话，只要每一门科目，细心一点，多努力一点，哪怕多考 5 分，各科加在一起，就是 30 分，570 + 30 = 600 分，就能上一个不错的 211。</p>
<p>我觉得挺可惜的。</p>
<h2 id="week-26"><a class="header" href="#week-26">week-26</a></h2>
<h3 id="一个画板开源项目"><a class="header" href="#一个画板开源项目">一个画板开源项目</a></h3>
<p><a href="https://github.com/tldraw/tldraw">tldraw</a> 一个在线画板工具，开源。</p>
<p><img src="life-and-thinking/keep-learning/assets/screenshot-6308734.png" alt="A screenshot of the tldraw web app" /></p>
<h3 id="qq-安全事故"><a class="header" href="#qq-安全事故">QQ 安全事故</a></h3>
<p>2022 年 6 月 27 日，一觉醒来，打开 QQ，看到了很多同学给我发了激情小图片，各大 QQ 群也沦陷了。</p>
<p>这次安全事故规模还是很大的，虽然没有什么新闻报道，但是感觉是近几年影响范围最广的一次 QQ 安全事故了。</p>
<p>很奇怪这次事故竟然没有上知乎热搜，应该被企鹅公关了。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220627135449874.png" alt="image-20220627135449874" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220627135525784.png" alt="image-20220627135525784" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220627135432745.png" alt="image-20220627135432745" /></p>
<h3 id="避孕套指数"><a class="header" href="#避孕套指数">避孕套指数？</a></h3>
<p><img src="life-and-thinking/keep-learning/assets/FlbEw_pLi47TLkEsfnHjDCf_pN1hv3.png" alt="FlbEw_pLi47TLkEsfnHjDCf_pN1hv3.png" /></p>
<h3 id="蓝猫淘气三千问"><a class="header" href="#蓝猫淘气三千问">蓝猫淘气三千问</a></h3>
<p>午休醒来，脑海里突然回想起一段旋律：星星眨着眼，月亮画问号~</p>
<p>原来是蓝猫淘气三千问！</p>
<p>感慨小时候的儿歌，歌词朴素，旋律优美，不知道现在的孩子们，都是听什么儿歌长大的。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220629133000219.png" alt="image-20220629133000219" /></p>
<p>那是一个创作者和广大群众都眼里有光的年代：</p>
<p><img src="life-and-thinking/keep-learning/assets/v2-deacf793d405b9ca8da0c453efe6ab97_r.jpg" alt="img" /></p>
<h3 id="tkinter-helper"><a class="header" href="#tkinter-helper">Tkinter Helper</a></h3>
<p><a href="https://github.com/iamxcd/tkinter-helper">Tkinter Helper</a> 一个低代码创建 GUI 的平台。</p>
<p>TkinterHelper（Tkinter布局助手）是一款为Tkinter打造，仅需拖拽组件进行布局，所见即所得，非常方便就能做出一个GUI界面，再配合 pyinstall 库将程序打包成exe，简直是开发小工具的利器。</p>
<p><img src="life-and-thinking/keep-learning/assets/img1.png" alt="img" /></p>
<h3 id="reborn-1"><a class="header" href="#reborn-1">reborn</a></h3>
<p>种一棵树最好的时间是十年前，其次是现在。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220701135759005.png" alt="image-20220701135759005" /></p>
<h3 id="在线画图工具"><a class="header" href="#在线画图工具">在线画图工具</a></h3>
<p><a href="https://jspaint.app/">jspaint</a></p>
<p>windows 画图的在线版本</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702133551224.png" alt="image-20220702133551224" /></p>
<h3 id="三体---水滴"><a class="header" href="#三体---水滴">三体 - 水滴</a></h3>
<p>一个关于三体水滴的开源项目 <a href="https://github.com/javaLuo/water">water</a>，用 jQuery 和 three.js 构建的水滴穿梭。</p>
<p>制作太精良了，每一帧截图都可以当壁纸。</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702133847235.png" alt="image-20220702133847235" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702134012507.png" alt="image-20220702134012507" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702134037947.png" alt="image-20220702134037947" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702134058362.png" alt="image-20220702134058362" /></p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220702134123786.png" alt="image-20220702134123786" /></p>
<h2 id="week-27-1"><a class="header" href="#week-27-1">week-27</a></h2>
<h3 id="主题图片生成器-1"><a class="header" href="#主题图片生成器-1">主题图片生成器</a></h3>
<p>自媒体在互联网上创作，最头疼的是莫过于文章的配图了。每次我写完一篇文章，都不知道该找一张什么样的图片来契合文章的主题。</p>
<p>有时候我会配上自己平时拍的一些照片，虽然文不对题，但是总比没有好。</p>
<p>所以我干脆找了一批可以自定义生成图片的网站。</p>
<p><a href="https://agreeable-pond-087f7a90f.1.azurestaticapps.net/">Profile Header Generator</a> | <a href="https://github.com/leviarista/github-profile-header-generator">github</a> 自定义生成 profile 图片</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220705084037108.png" alt="image-20220705084037108" /></p>
<p><a href="https://github.com/kyechan99/capsule-render">capsule-render</a> |<a href="https://github.com/kyechan99/capsule-render">github</a> 根据 url 参数自动生成 svg 图片链接</p>
<pre><code>https://capsule-render.vercel.app/api?color=gradient&amp;height=300&amp;section=header&amp;text=授人以鱼，也授人以渔&amp;fontSize=40&amp;type=waving
</code></pre>
<p><img src="https://capsule-render.vercel.app/api?color=gradient&amp;height=300&amp;section=header&amp;text=%E6%8E%88%E4%BA%BA%E4%BB%A5%E9%B1%BC%EF%BC%8C%E4%B9%9F%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94&amp;fontSize=40&amp;type=waving" alt="header" /></p>
<p><a href="https://www.bannerbear.com/demos/github-social-preview-generator-tool">github social</a> 输入 GitHub 仓库，自动生成图片</p>
<p><img src="life-and-thinking/keep-learning/assets/image-20220705084453406.png" alt="image-20220705084453406" /></p>
<h3 id="rust-静态网站生成-1"><a class="header" href="#rust-静态网站生成-1">rust 静态网站生成</a></h3>
<p>分享一套 rust 静态网站生成的技术栈：</p>
<ul>
<li><a href="https://github.com/getzola/zola">Zola</a> A fast static site generator in a single binary with everything built-in.</li>
<li><a href="https://github.com/aaranxu/adidoks">adidoks</a> AdiDoks is a mordern documentation theme, which is a port of the Hugo theme Doks for Zola.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentic-expression"><a class="header" href="#authentic-expression">Authentic-Expression</a></h1>
<h2 id="authentic-english"><a class="header" href="#authentic-english">Authentic English</a></h2>
<table><thead><tr><th style="text-align: left">Word</th><th style="text-align: left">汉语</th><th style="text-align: left">Demos</th></tr></thead><tbody>
<tr><td style="text-align: left">awesome</td><td style="text-align: left">绝妙的</td><td style="text-align: left">awesome list for windows；awesome Python frameworks</td></tr>
<tr><td style="text-align: left">terminology</td><td style="text-align: left">术语</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">syntax</td><td style="text-align: left">语法</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">checksum</td><td style="text-align: left">校验</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lite</td><td style="text-align: left">精简版</td><td style="text-align: left">SQLite</td></tr>
<tr><td style="text-align: left">amend</td><td style="text-align: left">修改</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">wildcard</td><td style="text-align: left">通配符</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">diverge</td><td style="text-align: left">分叉</td><td style="text-align: left">git 分叉</td></tr>
<tr><td style="text-align: left">case study</td><td style="text-align: left">复盘</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">propagate</td><td style="text-align: left">传播</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cascade</td><td style="text-align: left">级联</td><td style="text-align: left"><code>pd_data.drop_duplicates().rename()[[&quot;name&quot;, &quot;age&quot;]]</code></td></tr>
<tr><td style="text-align: left">foo/bar</td><td style="text-align: left">无</td><td style="text-align: left">常用于定义一个临时的无意义的函数</td></tr>
<tr><td style="text-align: left">cheatsheet</td><td style="text-align: left">备忘录</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">daemon</td><td style="text-align: left">守护进程</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">introspection</td><td style="text-align: left">自省</td><td style="text-align: left">self-examination</td></tr>
<tr><td style="text-align: left">Imperative programming</td><td style="text-align: left">命令式编程</td><td style="text-align: left">command line interface CLI</td></tr>
<tr><td style="text-align: left">refactor</td><td style="text-align: left">重构</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">flyweight</td><td style="text-align: left">轻量级</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">thornier</td><td style="text-align: left">棘手的</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">instance</td><td style="text-align: left">实例</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Macro</td><td style="text-align: left">宏</td><td style="text-align: left">宏类似于批处理，MacroCommand == Batch Command，MacroKernal 宏内核</td></tr>
<tr><td style="text-align: left">Soapbox</td><td style="text-align: left">即兴发挥</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">boilerplate code</td><td style="text-align: left">模板代码</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Agile</td><td style="text-align: left">敏捷</td><td style="text-align: left">敏捷开发</td></tr>
<tr><td style="text-align: left">Recursive</td><td style="text-align: left">递归</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Prev / Post</td><td style="text-align: left">前/后</td><td style="text-align: left">链表前驱/后驱节点</td></tr>
<tr><td style="text-align: left">nested</td><td style="text-align: left">嵌套的</td><td style="text-align: left">function inside function</td></tr>
<tr><td style="text-align: left">nonglobal</td><td style="text-align: left">非全局</td><td style="text-align: left">nonglobal variable</td></tr>
<tr><td style="text-align: left">elapsed</td><td style="text-align: left">耗时</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">generic</td><td style="text-align: left">泛型</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">dispatch</td><td style="text-align: left">调度</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">overload</td><td style="text-align: left">重载</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">master</td><td style="text-align: left">研究生</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">undergraduate / bachelor degree</td><td style="text-align: left">本科生 / 学士学历</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">postgraduate / master degree</td><td style="text-align: left">研究生 / 硕士学历</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">doctor</td><td style="text-align: left">博士</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Explicit</td><td style="text-align: left">清晰的，明显的</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">CVE</td><td style="text-align: left">公共漏洞与报录</td><td style="text-align: left">Common Vulnerabilities and Expousures(漏洞库 )</td></tr>
<tr><td style="text-align: left">Hex</td><td style="text-align: left">16 进制</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Mandarin</td><td style="text-align: left">普通话</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Freelancing</td><td style="text-align: left">自由职业者</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">stride</td><td style="text-align: left">步频</td><td style="text-align: left">step 常用于 Python 的 slice [start: end: stride]</td></tr>
<tr><td style="text-align: left">complex</td><td style="text-align: left">复数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">wizard</td><td style="text-align: left">向导</td><td style="text-align: left">installation wizard 软件安装向导</td></tr>
<tr><td style="text-align: left">The Forbidden City</td><td style="text-align: left">紫禁城</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">truncate</td><td style="text-align: left">截短</td><td style="text-align: left">将长字符串，变成 xxx...</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">占位符</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">redux</td><td style="text-align: left">以新的方式重现</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">compelling</td><td style="text-align: left">漂亮的</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">redex</td><td style="text-align: left">重新学习(ruai dex)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">persistence</td><td style="text-align: left">持久化</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">boilerplate</td><td style="text-align: left">样板代码</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cascade</td><td style="text-align: left">级联</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">suppress</td><td style="text-align: left">抑制，镇压</td><td style="text-align: left">@SuppressWarnings 关闭警告</td></tr>
<tr><td style="text-align: left">retention</td><td style="text-align: left">保留</td><td style="text-align: left">@Retention</td></tr>
</tbody></table>
<h2 id="authentic-chinese"><a class="header" href="#authentic-chinese">Authentic Chinese</a></h2>
<table><thead><tr><th style="text-align: left">Word</th><th style="text-align: left">释义</th></tr></thead><tbody>
<tr><td style="text-align: left">复盘</td><td style="text-align: left">事后经验总结和学习</td></tr>
<tr><td style="text-align: left">同比</td><td style="text-align: left">历史<strong>同</strong>一时期比较</td></tr>
<tr><td style="text-align: left">环比</td><td style="text-align: left">相邻时期比较</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knowledge-summary"><a class="header" href="#knowledge-summary">Knowledge Summary</a></h1>
<p>希望自己每天上网都能有所收获。</p>
<p>[TOC]</p>
<h2 id="政治"><a class="header" href="#政治">政治</a></h2>
<h3 id="国情"><a class="header" href="#国情">国情</a></h3>
<ul>
<li>
<p>我国只有3%的人拥有本科学历</p>
</li>
<li>
<p>我国的<strong>有线电视用户</strong>在 2020 年第一季度已经下降到了 <strong>2.06 亿</strong>户</p>
</li>
<li>
<p>航天行业的人才流失已经很严重了，中国孕育航天人才的土壤已经很贫瘠了，高端人才，在校招的时候，就已经流失了</p>
</li>
<li>
<p>2020-06 最新的<strong>超算排行</strong>，<strong>日本</strong>的基于 ARM 架构的 Fugaku <strong>排第一</strong>，第二和第三位是美国的计算机，第四和第五才是中国的</p>
</li>
<li>
<p><strong>中国为什么要搞上山下乡？</strong></p>
<ul>
<li><strong>马克思主义发展阶段论</strong>：封建主义 —&gt; 资本主义（过渡）—&gt; 共产主义（苏联也支持先发展资本主义）</li>
<li><strong>一个国家和地区的发展经验，不能完全照搬到另一个国家</strong>：中国特色社会主义</li>
<li>新中国成立：所有剥削者的资产，全部剥夺，归国有，这触动了外国列强的利益</li>
<li>中国是个<strong>海绵型社会</strong>，<strong>城乡二元结构</strong>，农村最大的海绵作用：<strong>劳动力蓄水池</strong>，每当城市发生危机，大量劳动力失业的时候，西方就转变为街头政治、暴动和社会动乱，在中国转变为下乡</li>
<li><strong>60 年代的上山下乡的原因：1960 苏联撤资，城里的大量劳动力失业，必须下乡，而且是下乡到集体户（个人不好接纳）</strong></li>
<li><strong>集体化的原因</strong>：个体化的农户是不能充当蓄水池的，是送给张三家，还是李四家？</li>
</ul>
</li>
<li>
<p>中国经济开启内循环，扎根基层，外循环的路开始走不通了</p>
</li>
<li>
<p><strong>深圳人均收入</strong></p>
<p>中位数不到 6K</p>
<img align='left' src="life-and-thinking/keep-learning/assets/image-20201011110701167.png" alt="image-20201011110701167" style="zoom:70%;" />
</li>
<li>
<p>中国 GDP：11.2 万亿 美元，是印度的 4 倍，江浙沪的 GDP 比印度还高</p>
</li>
<li>
<p>北京市政府在 2019 年迁往了<strong>通州</strong>，也就是杨利银的老家，将北京市政府从首都赶出去，是为了划清北京市政府和中央政府的职权界限，<strong>降格北京市</strong></p>
</li>
<li>
<p>李总理说，<strong>中国有 6 亿人，平均月收入 1000 元</strong>。我觉得这是中国的最大国情</p>
</li>
<li>
<p>种<strong>一亩麦子</strong>，农民的纯收入也就<strong>三四百元</strong>，靠种地，农民必然赤贫</p>
</li>
<li>
<p><strong>公务员级别</strong>：</p>
<p>办事员，科员，副科级，<strong>正科级</strong>（<strong>局长</strong>），副处级，<strong>正处级</strong>（<strong>县委书记</strong>），厅级（江苏省教育厅），省级，国家级</p>
</li>
</ul>
<h4 id="经济"><a class="header" href="#经济">经济</a></h4>
<ul>
<li>
<p>政府收入来源（2019 年）</p>
<ul>
<li>税收（16 万亿）</li>
<li>卖地（7 万亿，约占 30%）</li>
<li>国企收入（只占 1%）
<ul>
<li>烟草行业 417 亿</li>
<li>投资服务企业 244 亿</li>
<li>电力企业 200 亿</li>
<li>石油石化 188 亿</li>
<li>电信行业 174 亿</li>
</ul>
</li>
</ul>
</li>
<li>
<p>2019年上海金融业占GDP比重高达17%，跨境人民币收支规模占全国50%，上海当之无愧我国的金融中心</p>
</li>
</ul>
<h4 id="国企"><a class="header" href="#国企">国企</a></h4>
<ul>
<li>
<p>国企做的，很多都是亏本的买卖，航空航天，农化，军工，石油。<strong>资本是逐利</strong>的，想要发展<strong>芯片</strong>，还得看国家支持，国企支持</p>
</li>
<li>
<p><strong>军工领域</strong></p>
<ul>
<li>军工是<strong>高科技</strong>、<strong>高利润</strong>行业</li>
<li>日本从美国军购 F35 150 架，加上 110 台发动机，<strong>总价 230 亿美元</strong>，<strong>和中兴市值差不多</strong></li>
<li>中国的军火销售巨头：<strong>中国兵器工业集团</strong>（北方工业公司）99A 坦克，还做油田开采，矿产开发</li>
<li>第二位军火巨头：<strong>中国兵器装备集团</strong>（南方工业公司）子公司：<strong>长安汽车</strong>、<strong>江铃汽车</strong>，中国最大的输变电设备制造商：<strong>天威保变电气</strong></li>
<li>航空领域：<strong>中航工业公司</strong>，2018 年营收 655 亿美元，子公司：<strong>成飞</strong>、<strong>沈飞</strong>（除欧美国家外，唯一能研究出喷气式舰载机和四代机的制造商），也是中国<strong>商飞</strong>的三大股东之一</li>
<li>海洋领域：<strong>中船重工</strong>、<strong>中国船舶</strong>：<strong>江南造船厂</strong>： 055 国产驱逐舰（2020-01 服役），同时在建国产航母，<strong>大连造船厂</strong>：辽宁舰、山东舰，2019 年 11 月，<strong>南北船合并</strong>为<strong>中国船舶集团</strong></li>
<li>航天领域：<strong>航天科工</strong>、<strong>航天科技</strong>：航天和导弹</li>
</ul>
</li>
<li>
<p><strong>中国农业现状 农化领域</strong></p>
<ul>
<li>农业化学产品和种子行业在 2015 年之前，由 6 大公司主导：美国孟山都、瑞士先正达（全球第一大农药，第三大种子巨头）、德国拜尔（拜尔后来 660 亿美元收购孟山都）、美国杜邦、美国陶氏化学（前两者后来合并）、德国巴斯夫，第七是以色列安道麦</li>
<li><strong>中国化工集团</strong>，收购<strong>以色列安道麦</strong>和<strong>瑞士先正达</strong>（430 亿美元）</li>
<li>四巨头变成六巨头：<strong>中国化工集团</strong>、德国拜尔、美国陶氏杜邦、德国巴斯夫</li>
<li>中国化工集团在 2015 年以 70 亿欧元收购意大利<strong>倍耐力</strong>轮胎（高端轮胎）</li>
<li>2019年，中国制造业产值几乎等于<strong>美日德之和</strong>，中国制造业规模，如果再增加一倍，将会达到整个发达国家之和</li>
<li>国企虽然利润低，运营效率底，垄断，但是国企承担着更多的国家和社会责任，如果没有国企，那么<strong>军工、农化和种子</strong>领域，都不会有和欧美巨头比肩的中国公司存在</li>
</ul>
</li>
<li>
<p><strong>国企和华为，石油化工领域</strong></p>
<ul>
<li>华为的研发支出在中国企业中排第一</li>
<li><strong>中国公司的科技研发活动，绝大部分都是由国企完成的；中国的制造，相当大的一部分，由国企来完成</strong>，很多不赚钱、保民生的脏活累活都是国企来干的</li>
<li>石油化工领域：<strong>中石油、中石化、中海油</strong>
<ul>
<li>2019 年上市公司研发投入排行榜，中石油排第二，中石化排第五</li>
<li>石油天然气的开采是高科技行业，一直由欧美垄断，中石油等国企实现了技术的国产化，并向外输出技术（和南瑞继保类似）</li>
<li><strong>科威特</strong>是石油大国，国土面积和北京差不多大，但是供给了全球 10% 的石油，中石化已经打入中东市场，在 2014 年拿到科威特 11.5 亿美元的钻井合同，成为科威特最大的钻井承包商</li>
<li>中海油：海上石油开采难度，远高于陆地石油开采（<strong>贪吃蛇技术</strong>），中海油从 08 年开始研发</li>
<li>欧美的霸权行业：石油天然气、军工、航空、农化产品</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内卷"><a class="header" href="#内卷">内卷</a></h4>
<ul>
<li>定义：资源有限，人口增长</li>
<li>最大的内卷：高考（所以有钱人把孩子送出国）</li>
<li>怎么做：跳出内卷赛道，找到其他赛道，自己开心就好</li>
<li>国情：每年有 80 万的硕士生，10 万的博士</li>
</ul>
<h4 id="城市地区"><a class="header" href="#城市地区">城市地区</a></h4>
<ul>
<li>
<p>天津的实体经济，已经停滞；天津的外卖繁荣程度，还不如四川绵阳</p>
</li>
<li>
<p>中国城市高校数量排行榜</p>
<p>北京-武汉-广州（南京是个小弟，但是其学校质量高，211学校也很多）</p>
</li>
<li>
<p>澳门每年<strong>八成</strong>的财政收入来源于赌博，结构单一</p>
</li>
<li>
<p>四川攀枝花是高海拔盆地，冬暖夏凉</p>
</li>
</ul>
<h3 id="美国"><a class="header" href="#美国">美国</a></h3>
<ul>
<li>
<p>美联储的一份报告披露，<strong>40%</strong> 的美国成年人，紧急情况下，拿不出 <strong>400</strong> 美元现金</p>
</li>
<li>
<p>美国黑人，占美国总人口的 <strong>13%</strong>，白人占比 65%，白人人口是黑人的 <strong>5</strong> 倍</p>
</li>
<li>
<p>产业空心化</p>
<p>美国计算机产业外流（产业空心化），目前只有 Intel 的芯片是在美国生产，高通，Navida 和 AMD 的芯片生产全在台积电（市值最大半导体公司），中国有一套完整的供应链</p>
</li>
<li>
<p><strong>特朗普能走多远</strong>（特朗普赢得选举之前的预测）</p>
<ul>
<li>我们看到的世界，是媒体塑造出来的，独立思考！</li>
<li>特朗普为什么能够胜出？因为人民支持他啊！</li>
<li>思考政治问题的正确方式：从实际出发，实事求是，<strong>经济基础</strong>决定上层建筑，<strong>生产力</strong>决定生产关系，<strong>客观存在</strong>决定主观认识</li>
<li>特朗普（共和党），<strong>人民民主</strong>（战胜） vs <strong>精英民主</strong>（少数人的统治）</li>
<li>希拉里 <strong>邮件门</strong>：在任国务卿期间的 5700 页的邮件已经被公开下载</li>
<li>美国的<strong>政治正确</strong>在华盛顿产生了一种虚伪的氛围，特朗普则戳破了这张窗户纸，在墨西哥边境修墙</li>
<li>美国国民最关注的话题：<strong>经济</strong>、<strong>移民</strong>、<strong>国家安全（911）</strong>、<strong>政府失能</strong>，特朗普触及了这些美国民众最真实的需求</li>
<li>特朗普的兴起源于民众对<strong>政府失能</strong>的厌恶，特朗普是一个政治投机客</li>
<li>特朗普的<strong>人设</strong>是精心设计过的：<strong>有行动力</strong>的传统的美国白种盎克鲁撒克逊上等贵族，给<strong>政府赋能</strong>，无视华盛顿一切繁文缛节</li>
<li>让民众不关注政治，准入门槛高，从而变成少数人的游戏</li>
<li>特兰普发一个 Twitter，一分钱不花，就能做宣传，收割平民选票，搞<strong>民粹主义</strong></li>
<li><strong>GDP 重要吗</strong>？1980 年，西德和日本的 GDP 超过苏联，30 年的发展赶上了苏联 70 年的发展，说明资本主义比苏联的社会主义优越，苏联开始不自信了，所以戈尔巴乔夫才着急改革开放。中国的 GDP 超过日本后，GDP 这个指标已经不重要了，中国已经有自信了，有了道路和制度自信</li>
<li>政治为经济服务。<strong>美国人民为什么失业</strong>？美国企业，为了追求利润，将产业搬到了中国。而美国却宣传，是中国人抢走了美国人的工作</li>
<li><strong>媒体的作用</strong>，就是让你<strong>离开问题的本质</strong>，就像操作系统将用户与硬件隔离一样</li>
<li>美国国情：2008 年金融危机后，美国出现了<strong>中产阶层</strong>的<strong>塌陷</strong></li>
<li>你为什么要买手机？虚荣心！</li>
<li>美国过去十几年，将太多的精力放在了<strong>中东</strong>，中国得以<strong>韬光养晦</strong>（希拉里的功劳 - 保护人权，花里胡哨）</li>
<li>沈逸预测：特朗普上台后，美国快速进入孤立时期，全球收缩，<strong>长期来看，美国会熬过最艰难的时期，然后触底反弹</strong>（都预测对了）</li>
</ul>
</li>
<li>
<p><strong>TikTok事件背后，我们来品品“懂王”的剧本</strong></p>
<ul>
<li><strong>懂王</strong>：特朗普</li>
<li>美国已经因为新冠死了 16W 人了，比越南战争死的人都多，新冠砸穿了美国治理体系隐藏起来的所有问题</li>
<li>TikTok 会成为特朗普竞选时候炫耀的筹码，这是从中国那里薅下的一块肉，简单粗暴</li>
<li>特朗普擅长极限施压</li>
</ul>
</li>
<li>
<p>美国禁枪</p>
<p>美国为什么不🈲枪拿枪捍卫自己的权力和自由，自由从来不是别人恩赐的，要靠自己争取。片面之词，只说了不禁枪的坏处，没说持枪的坏处</p>
</li>
<li>
<p>美国的四大法宝：高科技 / 美军 / 美元 / 好莱坞</p>
</li>
<li>
<p>美国的三大股指：纳斯达克(高科技股)，道琼斯指数，标准普尔指数</p>
</li>
<li>
<p>美国从全世界吸血，美国人民过得越好，第三世界人民越水深火热</p>
</li>
</ul>
<h3 id="日本"><a class="header" href="#日本">日本</a></h3>
<p>日本本土市值最高的企业：任天堂（2020-08-28）</p>
<p>东京城市圈好玩的地方：新宿，秋叶原</p>
<p>自我介绍：瓦大喜哇 墨鱼仔 黛丝 （我是墨鱼仔)</p>
<h3 id="印度"><a class="header" href="#印度">印度</a></h3>
<ul>
<li>
<p><strong>老子世界第一</strong></p>
<ul>
<li>反抗，是贱民的事情，不能反抗，不然就出格成为了贱民</li>
<li>婆罗门的任务，就是祭祀和传道，说白了就是负责打嘴炮：印度比中国强，敏于言而不能行</li>
<li>贵族阶级通过各种<strong>迷惑行为</strong>，塑造阶级认同</li>
<li>印度人均是精神上的婆罗门，自欺欺人，和儒家的入世截然相反</li>
</ul>
</li>
<li>
<p><strong>1962 年对印作战</strong></p>
<ul>
<li>战争起因：1959 年西藏叛乱，达赖喇嘛叛逃印度，其实是印度从中作梗（美国支持），支持藏独</li>
<li>印度华裔的伤害最大，4 万华裔 —&gt; 4 千华裔，逮捕 4000 华侨换战俘，并把华侨的财富全部没收</li>
<li>印度大国地位，迅速下跌，开始埋头发展军事</li>
<li>印度国内各宗教和各派，因为有了共同的敌人：中巴，反而变得团结起来</li>
</ul>
</li>
<li>
<p><strong>印度制造业的野心</strong></p>
<ul>
<li>
<p>全球<strong>经济第五</strong>大国，2019 年，其经济总量已经超过英法，仅次于美中日德</p>
</li>
<li>
<p>中国制造业产业链往印度转移的规模比到越南的规模更大，2019 年，印度是仅次于中国的第二大手机生产国</p>
</li>
<li>
<p>提高各种关税，迫使外企在当地建厂：OPPO，VIVO，小米，三星，苹果；这些举措，受伤最大的是：中国</p>
</li>
<li>
<p>印度是当前全球第五，未来全球前三的<strong>巨型经济体</strong></p>
</li>
<li>
<p>United States	21,439.45	
China	        14,140.16	
Japan	        5,154.48	
Germany	        3,863.34	
India	        2,935.57</p>
<p>印度的经济体量，是中国的 <strong>1/5</strong>，不容小觑</p>
</li>
</ul>
</li>
<li>
<p>印度也有核武器，1974 年在印巴边境试爆；巴基斯坦于 1998 年成功试爆核武器，成为第七个有核国家，并且也是伊斯兰国家中第一个有核国家；</p>
</li>
<li>
<p>世界上的有核国家：五常 + 印度 + 巴基斯坦 + 朝鲜，八个国家</p>
</li>
</ul>
<h3 id="台湾"><a class="header" href="#台湾">台湾</a></h3>
<p><strong>现状</strong></p>
<ul>
<li>台湾省人口：2300万，是中国第一强省，大陆的人均 GDP 是台湾的 40%，人均 GDP 比江苏高 60%，比上海高 10%，医疗器械，电子信息产业发达；50年代，麦克阿瑟称台湾为<strong>永不沉没的航空母舰</strong></li>
<li>中国大陆的人均 GDP 仅为台湾的 40%</li>
<li>截至 2020 年，中国大陆，仍然没有任何一个省级行政区，其人均 GDP 超过台湾，<strong>经济基础决定上层建筑</strong></li>
<li>台湾有两种人（两条路政策）：亲日台独分子，中国人（坚持一个中国）</li>
<li>收复台湾的方法：先穷台，再统一</li>
</ul>
<p><strong>李敖</strong></p>
<p>台湾无党派人士，代表作：《北京法源寺》</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=OWgX8wo6kDI">Youtube</a></li>
<li>樽前做剧莫相笑，我死诸君思我狂</li>
<li>100年前的中国，四千个人里面才有一个中学生，其他都是文盲</li>
</ul>
<p><strong>台积电</strong></p>
<ul>
<li>台积电是目前市值最大的半导体公司（2020-07）</li>
<li>台积电已经上马了 3nm 工艺制程</li>
</ul>
<h3 id="韩国"><a class="header" href="#韩国">韩国</a></h3>
<ul>
<li>
<p><strong>政治</strong></p>
<p>韩国政治中心：<strong>青瓦台</strong></p>
<p>韩国总统任期：<strong>五年</strong></p>
<ul>
<li>
<p><strong>李承晚</strong>：第一任总统</p>
</li>
<li>
<p><strong>卢武铉</strong>：第十六任韩国总统，<strong>文在寅挚友</strong>，<strong>理想主义者</strong>，08 年任期结束，2009-05-23 跳崖自杀，以死明志</p>
<ul>
<li>对美国，收回自主权</li>
<li>对日本，要求正视历史</li>
<li>对财阀，对大企业进行改组</li>
<li>对朝鲜，提出和平繁荣政策</li>
</ul>
</li>
<li>
<p><strong>李明博</strong>：第十七任韩国总统，<strong>现代集团总裁</strong>，财阀，清算卢武铉，被查出受贿 4000 万美元</p>
</li>
<li>
<p><strong>朴槿惠</strong>：第十八任韩国总统，父亲朴正熙，遭卢武铉清算，2016 年闺蜜们爆发，被国会弹劾，2017年称为韩国历史上首个被弹劾下台的总统</p>
</li>
<li>
<p><strong>文在寅</strong>：第十九任韩国总统，出身寒微，考上庆熙大学，被退学，律师，为平民打官司，卢武铉之影，2017-05-23 朴槿惠出庭受审，2018-05-23 李明博出庭受审，对抗韩国财阀</p>
</li>
</ul>
</li>
<li>
<p><strong>寄生虫</strong></p>
<p>奉俊昊-寄生虫-奥斯卡-韩国财阀</p>
<ul>
<li>《寄生虫》是奥斯卡历史上，第一个获得最佳电影奖的外语片，奥斯卡奖的评委团体是一群老大爷，奥斯卡奖是西方的自嗨</li>
<li>奉俊昊-艺二代-延世大学-《寄生虫》-《杀人回忆》-《汉江怪物》</li>
<li>一个人的成功，<strong>个人努力很重要</strong>，<strong>时运也很重要</strong></li>
<li>韩国财阀：三星-现代-LG</li>
<li>寄生虫：穷人看了感动不已，富人赚得盆满钵满，通过理解穷人来赚钱，富豪的钱加倍奉还，百姓的钱三七分成</li>
</ul>
</li>
<li>
<p>三星集团虽然有一半的股份被华尔街持有，但是其<strong>控制权</strong>还是牢牢掌握在李氏家族的手中，目前李氏家族的所有资产，还是掌握在<strong>李在镕</strong>的手里，李健熙的长女是一个边缘人物</p>
</li>
<li>
<p>韩国现任总统文在寅是和三星财团唱反调的，反对李在镕继位，完全不为自己下台后的境地考虑（文在寅的复仇）</p>
</li>
</ul>
<h3 id="香港"><a class="header" href="#香港">香港</a></h3>
<ul>
<li>
<p>香港九龙城寨在 1993 年已被全部拆除</p>
<img align="left" src="life-and-thinking/keep-learning/assets/1585394594416.png" alt="九龙城寨" style="zoom:50%;" />
</li>
<li>
<p>李嘉诚</p>
<p><a href="https://www.zhihu.com/question/268907527/answer/799831066">link</a></p>
<p>不做实业，靠房地产，金融圈钱，卖地不开发，哄抬房价，使得年轻人买不起房，香港的年轻人恨错了人，他们恨的应该是这些吸人血的资本家。</p>
<p>李嘉诚的所作所为，已经影响到国计民生了，政府早晚要制裁他，所以他开始将资产转移到英国</p>
</li>
</ul>
<h3 id="欧洲"><a class="header" href="#欧洲">欧洲</a></h3>
<ul>
<li>
<p><strong>五月花号</strong>：1620 年，<strong>第一批英国移民</strong>乘坐五月花号来到北美</p>
</li>
<li>
<p>我刚当德国总理的时候（2005年），中国的 GDP 是2.3万亿美元，略低于德国（2.8万亿美元）。今天我要离职了，中国的 GDP 是14.7万亿，而我们的GDP是3.8万亿。</p>
<p>尽管我们仍是一个相对富裕的国家，但我们在世界上的作用越来越小， 因为世界的平衡完全改变了。</p>
<p>-- 德国总理<a href="https://p.dw.com/p/42CbD">默克尔</a>回答记者提问，为什么她任内每年都去中国。</p>
</li>
</ul>
<h3 id="俄罗斯"><a class="header" href="#俄罗斯">俄罗斯</a></h3>
<ul>
<li>
<p>土耳其和俄罗斯的主要矛盾：俄罗斯的从黑海到地中海的海上贸易通道<strong>土耳其海峡</strong>由土耳其掌控（土耳其首都伊斯坦布尔就在土耳其海峡），土耳其海峡是黑海到地中海的唯一通道，土耳其海峡被卡住，那么俄罗斯的黑海舰队就成了湖军</p>
</li>
<li>
<p><strong>贝加尔湖</strong>：最大的天然淡水湖，最深的湖</p>
</li>
</ul>
<h3 id="东南亚"><a class="header" href="#东南亚">东南亚</a></h3>
<ul>
<li>2019年，越南的 GDP，只有中国的 2%</li>
</ul>
<h3 id="其他国家地区"><a class="header" href="#其他国家地区">其他国家地区</a></h3>
<ul>
<li>
<p>20世纪下半叶，<strong>犹太人</strong>获得了22％的诺贝尔化学奖，32％的医学奖和32％的物理奖，尽管他们不到世界人口的1％</p>
</li>
<li>
<p><strong>印度尼西</strong>亚有 17508 个岛屿</p>
</li>
<li>
<p><a href="https://my.matterport.com/show/?m=NeiMEZa9d93&amp;mls=1">拉美西斯六世陵墓的 3D 模拟</a></p>
</li>
<li>
<p><strong>阿联酋</strong>平均每年只有 <strong>12</strong> 天降雨</p>
</li>
<li>
<p><strong>黎巴嫩</strong>首都贝鲁特港口爆炸的<strong>硝酸铵</strong>，是 <strong>2013</strong> 年被黎巴嫩海关从一艘非洲船只查获</p>
</li>
<li>
<p>西努哈克港，简称西港，柬埔寨第二大城市，<strong>柬埔寨</strong>的深圳</p>
</li>
<li>
<p><strong>摩纳哥</strong>，世界第二小的国家，寄生在法国海岸，法国也不想吞并了，因为这是一种内耗，欧洲应该团结起来，一致对外，两次世界大战，将世界中心送给了美国</p>
</li>
<li>
<p>阿富汗-帝国坟场</p>
</li>
<li>
<p><strong>孟加拉国</strong></p>
<p>首都：达卡（<strong>达卡大学</strong>），<strong>印度、孟加拉、巴基斯坦</strong>曾经合起来是一块英国殖民地，中国支持孟加拉和巴基斯坦的发展，支持两国的基建，用来<strong>牵制印度</strong>。</p>
<p>孟加拉位于<strong>恒河下游</strong>，交通被恒河分割严重，最大的港口：吉大港，孟加拉的目标：让上亿的年轻人有资格进<strong>血汗工厂</strong></p>
</li>
<li>
<p><strong>巴基斯坦</strong>：</p>
<ul>
<li>供电极不可靠，最大的经济中心：<strong>卡拉奇</strong></li>
<li>一半的国土是荒漠和戈壁，缺乏水资源，人口超过 2.1 亿</li>
<li>需要修建水电站，在夏季蓄水，需要 140 亿美元来修建，修建风险也非常高，已和中国达成协议，中国出资金和技术来修建</li>
</ul>
</li>
<li>
<p>荷兰是美洲和拉丁美洲的毒品进入欧洲的门户，荷兰年轻人有 17.5% 吸食过大麻；</p>
<p>德国和荷兰卖淫合法化，所以欧洲人口贩卖猖獗；</p>
<p>美国是世界第一大毒品消费国，每年花 1500 亿美元购买毒品</p>
</li>
<li>
<p>丘吉尔，是一个腐朽的种族主义者，帝国主义者，并不是一个值得称道的英雄；温斯顿家族在英国是一个贵族</p>
</li>
<li>
<p>印度也有核武器，1974 年在印巴边境试爆；巴基斯坦于 1998 年成功试爆核武器，成为第七个有核国家，并且也是伊斯兰国家中第一个有核国家；</p>
</li>
<li>
<p>世界上的有核国家：五常 + 印度 + 巴基斯坦 + 朝鲜，八个国家</p>
</li>
</ul>
<h3 id="我的家乡"><a class="header" href="#我的家乡">我的家乡</a></h3>
<ul>
<li>
<p><strong>人口</strong></p>
<p>赣榆有 120 万人口，其中青口镇 21.6 万，柘汪镇 5.7 万，海头镇 8.7 万</p>
</li>
<li>
<p><strong>教育</strong></p>
<p>县中目前最大的矛盾，是学生较先进的意识，和落后师资之间的矛盾</p>
</li>
</ul>
<h2 id="经济--财经"><a class="header" href="#经济--财经">经济 / 财经</a></h2>
<h3 id="知识点-2"><a class="header" href="#知识点-2">知识点</a></h3>
<ul>
<li>
<p><strong>开曼群岛合法避税</strong></p>
<p>X 公司在<strong>开曼群岛</strong>，注册了一家 Y 公司。<strong>开曼群岛不对公司收税，只收取注册费</strong>。然后，它把所有的知识产权，比如商标和特许技术都转移到 Y 公司。</p>
<p>X 公司每年需要向 Y 公司支付很大一笔知识产权许可费用，导致它的利润为零，所以就不用缴税了。而 Y 公司由于注册在开曼群岛，即使有很大一笔利润，也不用缴税</p>
</li>
<li>
<p><strong>数字人民币</strong></p>
<p>数字人民币就是人民币的数字形式，主要用户网上支付，只有指定的银行才能提供该公共服务，<strong>数字人民币就是商业银行的网上支付服务</strong>。</p>
</li>
<li>
<p><strong>固定利率和 LPR 利率</strong></p>
<ul>
<li>
<p>利率 = 基准利率 * (1 + 浮动)</p>
<p>基准利率由央行来决定，浮动利率由央行、政策、<strong>银行</strong>和个人的情况所决定，浮动的部分，在和银行签订协议后，就不会再变化</p>
<p>央行投入市场的钱，通过 MLF 借给各大银行，各大银行也需要还给央行一定的利率，也就是说，央行通过 MLF 调控各大银行</p>
</li>
<li>
<p>LPR 贷款基础利率</p>
<p>LPR = MLF + 加点</p>
<p>MLF 由央行决定，加点主要由<strong>商业银行</strong>决定，LPR 的定价给了商业银行更多的自主权</p>
<p>签订 LPR 的缺点：钱让银行挣去了，媒体宣传什么，反着来就行了</p>
</li>
</ul>
</li>
<li>
<p>有史以来发行的所有美元，几乎有四分之一是在2020年发行的。</p>
</li>
</ul>
<h3 id="资本轶事"><a class="header" href="#资本轶事">资本轶事</a></h3>
<ul>
<li>
<p><strong>起底瑞幸咖啡资本大骗局</strong>（18个月上市的神话）</p>
<ul>
<li><strong>陆正耀</strong>（董事长，也是神州优车和<strong>神州租车</strong>的老大）
<ul>
<li>钱治亚（CEO，草根出身）</li>
<li>杨飞（CMO，首席营销官，入过狱，收钱写黑稿）</li>
<li>刘剑（COO，首席运营官，中央财大毕业）</li>
</ul>
</li>
<li>两个资本：<strong>黎辉</strong>的大钲资本，<strong>刘二海</strong>的愉悦资本</li>
<li>神州租车和瑞幸是一个老板，一个尿性，不靠谱</li>
<li>瑞幸的第一家测试店铺开在了北京二环的银河soho，当年我和王凯去天安门的时候，从那里路过</li>
<li>瑞幸咖啡走的是神州租车的路子，险中求胜，不上市，就崩盘</li>
<li>截至 2019-12-31，瑞幸咖啡共开设了 4507 家门店，称为国内最大的咖啡连锁店，而星巴克只有 3600 多家</li>
<li>浑水做空瑞幸，实锤了瑞幸</li>
<li>会计事务所安永因为浑水做空瑞幸的压力，拒绝在瑞幸的 Q4 报告上签字，直接导致了瑞幸自爆， COO 刘剑做假账 22 亿美元，替死鬼要进局子了，最多判 25 年</li>
<li>既得利益者：<strong>陆正耀</strong>系通过股权质押套现 25 亿美元，<strong>黎辉</strong>甩卖股票跑路套现 100 亿人民币</li>
<li>损失方：瑞幸 COO 刘剑被当作替死鬼；刘二海被坑了，没有来得及套现，股价雪崩；美国银行损失 7400 万美元；瑞银损失 6000 万美元；瑞信损失 4600 万美元；全球资本研究投资者基金损失 16 亿美元；孤松资本亏损 12 亿美元；</li>
<li>陆正耀就是个骗子！朱啸虎也在朋友圈踩了瑞幸一脚</li>
<li>新冠疫情也是瑞幸垮掉的又一个因素，其神州租车和瑞幸的现金流出现了问题</li>
</ul>
</li>
<li>
<p><strong>浑水公司</strong></p>
<p>核心成员 10 人左右，由美国人创立，专门做空中概股，曾经做空过新东方、好未来、瑞幸咖啡等公司，俞敏洪评价：<strong>苍蝇不叮无缝的蛋</strong></p>
</li>
<li>
<p><strong>付宁：网红与 Up 主</strong></p>
<ul>
<li>
<p><strong>商业模式分两种</strong>：To B 和 To C</p>
</li>
<li>
<p><strong>网红与明星的区别</strong>：<strong>明星 To B</strong>，<strong>网红 To C</strong>，C 的基数更大</p>
</li>
<li>
<p>B 站涨粉是非常难的，一粉顶十粉</p>
</li>
<li>
<p>敬汉卿的投资人：高樟资本-范卫锋</p>
</li>
<li>
<p>B 站 Up 主，年收入千万的大有人在</p>
<img align="left" src="life-and-thinking/keep-learning/assets/image-20200625144140600.png" alt="image-20200625144140600" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p><strong>冲浪 Plus：影院经济账（电影院复工）</strong></p>
<ul>
<li>
<p>影院怎么赚钱？</p>
<p>一张 100 元的电影票，电影院可以分到一半的钱。利润率最高的，是影院衍生的餐饮服务；</p>
<p>开一家中型电影院（5—7个场子）的成本：1000 万，大型电影院：3000 万；</p>
<p>拍电影不赚钱，钱都让影院赚去了；影院也不赚钱，钱都拿去交房租了；商业地产也不赚钱，是为了吸引客流，转别的店的租金；收租金也不赚钱，主要为了形成商业圈，拉动地段升值，赚周边住宅地产的钱。总结来说：**电影院就是为房地产打工的弟弟。**只有房地产商（例如万达）做电影院，才不会亏钱。</p>
<p>实际上，交了各种钱后，影院的最后收入，只剩票房的 10% 左右，通常<strong>五年才能回本</strong></p>
<p>一年不开张，开张吃半年</p>
<p>一场电影，得至少有 12 人观影，才能回本</p>
</li>
<li>
<p>2017 年，中国银幕数量，超过北美</p>
</li>
<li>
<p>电影院盲目扩张，电影票价格上涨导致的上座率下跌，影院租金、运营成本的上涨，加上新冠疫情，导致了电影院的全面崩盘</p>
</li>
<li>
<p>影院为什么不复工？因为看电影的人少，<strong>影院的开工成本，比停工成本还高</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>冲浪 Plus：长租公寓</strong></p>
<ul>
<li>链家 2017 年发布的报告显示，<strong>中国租赁人口，已经达到 1.9 亿人</strong></li>
<li>北京有 35% 的人在租房，北京每三个人中，就有一个人在租房</li>
<li>长租公寓的内核：<strong>二房东</strong></li>
</ul>
</li>
<li>
<p><strong>付宁：腾讯收购搜狗</strong></p>
<ul>
<li>搜狗现状：输入法市场占有率：70%，搜索份额：10%；大股东：腾讯，老东家搜狐；工具性公司</li>
<li>收购完后，搜狗将成为腾讯的全资子公司，并退市</li>
<li>腾讯已收购公司近 800 家</li>
<li>腾讯是垄断吗？互联网发展的终点就是垄断（数据垄断），技术的终点就是垄断，腾讯收购搜狗，更看重的是它积攒的数据，数据就是公司的护城河（小米手环的数据为什么不能导出？电力行业为什么找不到好的技术文档？）</li>
<li>中国在 2020 年会制定个人信息保护法、数据安全法</li>
</ul>
</li>
<li>
<p><strong>冲浪普拉斯：滴滴与程维</strong></p>
<ul>
<li>
<p>程维，高考失算，行政管理专业，第一份体面的工作：阿里销售，最年轻的主管，<strong>阿里</strong> B2B 部门最年轻的大区经理，支付宝 B2C 事业部副总经理</p>
<p>好友：美团 CEO 王兴，王刚（天使投资人）</p>
</li>
<li>
<p>滴滴：天使投资 - 阿里王刚 70 万，2012 年A 轮投资 - 朱啸虎 300 万，2013 年 3 月B 轮融资 - 腾讯注资 1500 万美金（成为腾讯系），2013 年底 C 轮融资 - 中信产业基金 6000 万美元 </p>
</li>
<li>
<p>滴滴 vs 快滴（烧钱大战），导火索：微信支付 vs 支付宝，微信提供资金和技术支持（几个月两家公司一共烧了 20 亿），滴滴用户从 2000 万涨到 1 亿</p>
</li>
<li>
<p>Uber 入华，引入私家车参与商业运营，动了出租车市场的蛋糕，百度投资 Uber 6 亿美元，成为 Uber 中国股东</p>
</li>
<li>
<p>2015 年情人节，滴滴，快滴 6：4 合并，程维管理</p>
</li>
<li>
<p>滴滴 vs Uber（网约车烧钱大战），Uber 遇到微信封杀，刷单</p>
</li>
<li>
<p>2016 年，苹果注资滴滴 10 亿美元，烧钱大战没有结果，滴滴出行收购 Uber 中国，Uber 卡兰尼克进入滴滴董事会，程维进入 Uber 董事会，百度成为滴滴股东</p>
</li>
<li>
<p>好兄弟王兴，做起了打车生意（王兴总是在市场成熟的时候入局，美团打车）</p>
</li>
<li>
<p>滴滴在不断破坏规则中成长，也注定要付出代价</p>
</li>
</ul>
</li>
<li>
<p><strong>冲浪普拉斯：选秀（平台，马太效应）</strong></p>
<ul>
<li>选秀最早起源于<strong>日本</strong>，经<strong>韩国</strong>发扬光大，后传入<strong>中国</strong></li>
<li>2004 年，湖南卫视，<strong>超级女声</strong>；2016 年<strong>限韩令</strong>；2018 年，偶像练习生-<strong>蔡徐坤</strong>，创造 101-<strong>杨超越</strong>；</li>
<li>成本：培养一个团，至少需要 <strong>4000W</strong></li>
<li>在综艺平台唱歌，需要<strong>歌曲版权费</strong>，冷门歌曲 <strong>8W</strong> 一首，热门歌曲 <strong>30W</strong> 一首</li>
<li>微博<strong>热搜</strong>，前五名，<strong>4.5W / h</strong></li>
<li><strong>爱优腾</strong>已经基本上垄断了偶像艺能变现的所有渠道，行业内的<strong>利润大头</strong>，都被这<strong>三大平台</strong>吃了，<strong>马太效应</strong>已经形成</li>
<li>偶像经济，正在被<strong>直播短视频网红</strong>一步一步蚕食</li>
</ul>
</li>
<li>
<p><strong>冲浪普拉斯：非洲手机之王-传音（农村包围城市，孙正义-时间机器理论）</strong></p>
<ul>
<li><strong>波导</strong>是<strong>国产手机鼻祖</strong>，传音手机起源于波导</li>
<li><strong>非洲有三个世</strong>界：<strong>欧洲世界</strong>-南非，<strong>阿拉伯世界</strong>-撒哈拉以北，<strong>黑非洲</strong>-撒哈拉以南</li>
<li>传音在黑非洲，走<strong>农村包围城市</strong>的道路（拼多多，oppo，Vivo 也都是这条道路）</li>
<li>非洲市场分散，<strong>销售</strong>是重点（走的 oppo，vivo 的路子，线下大量开店，线上大量打广告），两个品牌：Tecno，Itel（低端功能机），Infinix（智能机）</li>
<li><strong>文化</strong>：非洲民间的硬通货：家禽 —&gt; 买机送鸡；<strong>三亿美颜算法</strong>；<strong>去中国化</strong>，在埃塞俄比亚创建手机厂，是第一家帮埃塞尔比亚赚取外汇的公司</li>
<li><strong>时间机器</strong>理论：<strong>所有美国兴起的东西，在未来几年后都会在日本兴起，从发达国家到相对不那么发达的国家</strong></li>
<li><strong>软件护城河</strong>：
<ul>
<li>非洲版网抑云：BoomPlay（传音和网易云合资）</li>
<li>非洲版抖音：Vskit</li>
<li>即时聊天工具：PalmChat</li>
</ul>
</li>
<li>创始人竺兆江（波导海外市场负责人）预言：2022 年传音就会完蛋</li>
<li>东南亚、印度市场已经成为<strong>红海</strong>了，最后一个<strong>蓝海</strong>，就是非洲！</li>
</ul>
</li>
<li>
<p><strong>618 马云刘强东对线</strong></p>
<ul>
<li>马云和丁磊，因为拆分支付宝时，丁磊踩了一脚，留下过节</li>
<li>朋友有四层交情：一起喝过酒，一起同过窗，一起扛过枪，一起嫖过娼</li>
<li><strong>黄铮</strong>，浙大毕业，国外读研，Google 工作，后调入 Google 中国，受到<strong>丁磊</strong>和<strong>段永平</strong>提拔，和段永平、<strong>巴菲特</strong>吃过饭（巴菲特开过光）</li>
</ul>
</li>
</ul>
<h2 id="文化--历史"><a class="header" href="#文化--历史">文化 / 历史</a></h2>
<h3 id="朝鲜战争"><a class="header" href="#朝鲜战争">朝鲜战争</a></h3>
<ul>
<li>
<p><strong>毛主席对朝鲜战争的评价</strong></p>
<ul>
<li>提升士气，打破美军神话</li>
<li>军队获得锻炼</li>
<li>获得苏联支持</li>
<li>防止东北成为冷战前线</li>
</ul>
</li>
<li>
<p>因为<strong>朝鲜战争</strong>，所以美国才会向日本注资 148 亿美元，作为其朝鲜战场的后线；苏联才会向中国东北注资 54 亿美元</p>
</li>
</ul>
<h3 id="历史小知识"><a class="header" href="#历史小知识">历史小知识</a></h3>
<ul>
<li>清朝采用选贤制，所以每一个皇子都有当太子的机会，清朝的王爷，除了铁帽子王爷(开国元勋)，其他王爷每世袭一届，爵位降一级</li>
</ul>
<h2 id="互联网--科技"><a class="header" href="#互联网--科技">互联网 / 科技</a></h2>
<h3 id="华为"><a class="header" href="#华为">华为</a></h3>
<ul>
<li>
<p>华为的收入组成：6：3：1</p>
<p>6：强芯片业务，手机，笔记本，平板电脑，服务器，存储</p>
<p>3：弱芯片业务，基站，逆变器</p>
<p>1：软件业务，专利</p>
</li>
<li>
<p>一个 5G 室外基站平均功耗 3.8KW 左右，是 4G 基站的3倍以上，电费约2.3－3万元/年。</p>
<p>估计到2026年，5G 基站耗电量将上升至全社会用电量的2.1%，略高于数据中心（约2%）的耗电量水平。</p>
</li>
</ul>
<h3 id="苹果"><a class="header" href="#苹果">苹果</a></h3>
<ul>
<li>从 iPad 的升级路线来看，苹果在构建基于 arm 芯片的操作系统。苹果已发布基于 arm 芯片的 Mac，尝试摆脱对 Intel 的依赖，自主研发 PC 芯片，掌握主动权</li>
<li>2020-06-22，苹果在开发者大会上，宣布放弃 Intel 的 CPU，改用自己设计的 ARM 架构芯片；为了不让 Mac 电脑抢走桌面市场份额，微软一定会奋起反击，继续适配 ARM 架构，<strong>最终实现 Windows 可以同时支持 x86 和 ARM 两种架构</strong></li>
<li>苹果换芯，会削弱美国的重要性，增强台湾的重要性，台湾有 CPU！</li>
<li>iPhone 是 iPod 下的蛋，先有的 iPod，再有的 iPhone</li>
<li>苹果公司不允许<strong>恶棍</strong>在<strong>电影</strong>中使用 iPhone。因此，如果您正在看一部新电影并且角色拥有 iPhone，那么他们就不是坏人，这算是剧透吗？</li>
<li>Mac OS 的桌面占有率不到 5%（2020-11-02）</li>
</ul>
<h3 id="intelamd--navida-arm--台积电"><a class="header" href="#intelamd--navida-arm--台积电">Intel/AMD / Navida /ARM / 台积电</a></h3>
<p><strong>Intel 与 Arm 的战争</strong></p>
<ul>
<li>Intel 的 Atom 系列芯片，是 X86 架构的面向移动设备的 CPU</li>
<li>Intel 在 10 年到 20 年这十年间，陷入了停滞。2010年是2核的 2.66 GHz 的 i7，2020年是8核的 2.6 GHz 的 i9，过去10年基本上只是改进了工艺，增加了核心数量，没有实质的重大突破。除了性能以外，苹果最在意的两点----功率和散热---- Intel 也没有解决</li>
<li>2010 年的 iPhone4 采用的是苹果设计的第一款基于 Arm 架构的 CPU，名叫 Apple A4 处理器，直到现在最新的 iPhone11 的 A13 芯片</li>
</ul>
<p><strong>Navida</strong></p>
<ul>
<li>Nvidia RTX（Ray Tracing Platform 光线追踪平台），RTX 版本都是带有光追功能的</li>
<li>Navida 的市值在 2020 年是超过 Intel 的</li>
</ul>
<p><strong>台积电</strong></p>
<p>市值最大的芯片公司。</p>
<p>2021-05-07 最近，台积电宣布，扩大南京厂28纳米生产线。</p>
<h3 id="epic-games"><a class="header" href="#epic-games">Epic Games</a></h3>
<ul>
<li>
<p>Epic 公司放出 <strong>unreal 5 engine</strong> 预告片，宣称可以让游戏实现<strong>电影级别的画面</strong></p>
</li>
<li>
<p>Epic Games 公司分析，三大法宝：<strong>Unreal Engine，堡垒之夜跨平台，Epic 游戏平台</strong>，<strong>三位一体</strong></p>
<ul>
<li>代表作：堡垒之夜，Unreal engine(最流行的 3D 游戏开发引擎之一，另一个是 Unity)</li>
<li>2012 年，腾讯以 3.3 亿美元收购了 Epic Games 40% 的股份</li>
<li>曼达洛人，就是用虚幻引擎制作的</li>
<li>Epic 一开始专注于 PC 和主机游戏，但是这些游戏无法带来持续的现金流，所以转而和腾讯合作，开发网络游戏：GaaS（Game as a Service）</li>
<li>堡垒之夜是 Epic 开发的第一款网络游戏，也是历史上第一款跨平台游戏：手机、PC、Xbox、Switch</li>
<li>Steam 是 Windows 上一个游戏商店，但是要收取 30% 的交易费；后来 Epic 自创了一个游戏商店，只收取 12% 的交易费</li>
<li>Epic 将游戏跨平台的服务，提供给了其他游戏开发者，浏览器解决了软件的跨平台问题，Epic 解决了游戏的跨平台问题</li>
</ul>
</li>
<li>
<p>Epic 定义下一代互联网：Metaverse（元宇宙），共享虚拟社区，例如在线游戏-堡垒之夜（虚拟宇宙）</p>
</li>
</ul>
<h3 id="美国巨头轶事"><a class="header" href="#美国巨头轶事">美国巨头轶事</a></h3>
<ul>
<li>西雅图是微软和亚马逊的总部</li>
</ul>
<h3 id="芯片"><a class="header" href="#芯片">芯片</a></h3>
<ul>
<li><strong>芯片公司分成三类</strong>：
<ul>
<li>同时设计和生产：三星和 Intel（落后台积电两代，14nm）</li>
<li>只设计不生产：苹果，高通，华为，Navida(超过 Intel 成为美国最大的半导体公司)，联发科，AMD</li>
<li>只生产不设计：台积电（7nm，5nm 量产），中芯国际</li>
</ul>
</li>
</ul>
<h3 id="生物科技"><a class="header" href="#生物科技">生物科技</a></h3>
<ul>
<li>Moderna 公司利用 mRNA 技术研发的新冠疫苗是2020年1月11日开始研发，两天后的1月13日就完成了……太快了吧</li>
</ul>
<h3 id="互联网的优点"><a class="header" href="#互联网的优点">互联网的优点</a></h3>
<ul>
<li>互联网赋予了沉默的大多数说话的途径，尽管一开始说的不好（自媒体，网红，短视频）</li>
</ul>
<h3 id="互联网的陷阱"><a class="header" href="#互联网的陷阱">互联网的陷阱</a></h3>
<ul>
<li>
<p>智能家居的陷阱</p>
<p>操作系统是会过时的，就和手机一样，会很快报废掉，但是我们的电器是要用很久的，自带操作系统的智能家电，都不值得买，汽车也是如此</p>
</li>
<li>
<p>技术进步并不会解放生产力，相反的，会导致越来越多的人失业</p>
</li>
<li>
<p>互联网公司的高估值</p>
<ul>
<li><strong>贝壳找房</strong>在美国上市，其市值就超过了<strong>中国最大的房地产开发商</strong>-<strong>万科</strong></li>
<li>即将上市的支付宝，其市值肯定会超过<strong>宇宙第一大行：工商银行</strong></li>
<li>高估值的思考
<ul>
<li>公司层面：高估值必须要有高市场占有率</li>
<li>个人层面：高估值意味着一部分人，一夜暴富</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.zdnet.com/article/mozilla-research-browsing-histories-are-unique-enough-to-reliably-identify-users/">Mozilla 的员工</a>发现，只要根据某个人的50条～150条的浏览历史，就足以识别一个人</p>
</li>
<li>
<p>手机 / 社交网络 / 微信的本质：麻药</p>
</li>
<li>
<p>媒体开始走向垄断，开始出现寡头，互联网的传媒也开始走向垄断，但是，从另一个角度来看，每一个人都可以做传媒，万众发声的时代，我也可以做传媒，做考研辅导</p>
</li>
<li>
<p>电动车无法普及：丰田汽车的社长丰田章男公开表示，电动车是过度炒作，如果居民晚上下班回家，同时在小区里为自己的电动车充电，电网确实可能无法负荷</p>
</li>
</ul>
<h3 id="墓碑二维码"><a class="header" href="#墓碑二维码">墓碑二维码</a></h3>
<p><a href="https://www.phnompenhpost.com/lifestyle/salvadoran-resident-replaces-epitaphs-qr-codes">墓碑二维码</a> </p>
<p>people die，but long live internet?</p>
<p>一个人一生的数据，和区块链结合，会怎么样</p>
<h3 id="web30-2"><a class="header" href="#web30-2">web3.0</a></h3>
<p>Web 2.0 的范式是：用户创造、平台所有、平台控制、平台分配。</p>
<p>Web 3.0 的范式是：用户创造、用户所有、用户控制、协议分配。</p>
<h3 id="元宇宙-1"><a class="header" href="#元宇宙-1">元宇宙</a></h3>
<p>扎克伯格对元宇宙的观点：</p>
<ul>
<li>大多数美国成年人每天看电视（包括流媒体）或者玩电子游戏的时间，长达几个小时。电视节目或电子游戏，<strong>本质</strong>上都是提供了一个虚拟世界，让观众和玩家脱离现实，感受到快乐</li>
<li>疫情期间，许多人都在家办公。以前，上班的目的地是办公室，现在变成了键盘和显示器。这表明，人们可以在计算机前面工作8小时。如果能够提供更好的虚拟办公条件，这8小时完全可以在虚拟空间里面度过</li>
</ul>
<p>西游记是元宇宙。星球大战是元宇宙。哈利波特是元宇宙。漫威超级英雄是元宇宙。</p>
<h2 id="计算机"><a class="header" href="#计算机">计算机</a></h2>
<h3 id="编程"><a class="header" href="#编程">编程</a></h3>
<ul>
<li><strong>影响编程效率最大的因素</strong>是：昨晚的睡眠情况。其实不止编程，其他生活情形都如此</li>
<li>框架和库的区别：一个项目只能用一个框架，但是库能导多个；多用库，少用框架</li>
<li>Rust 语言连续五年排名程序员最喜欢的语言</li>
<li>根据研究，一个 JavaScript 项目平均有 377 个依赖关系，而 Java 项目有43个，Python 项目只有16个。你使用的依赖项越多，就隐含着必须信任的外部开发者也越多</li>
<li>企业选择不知名的 JS 框架是有风险的，可以预言，最终赢的还是 React。它是<strong>世界排名第一的前端框架</strong>，背后有 Facebook 的支持，所以&quot;没人因为选择 React 而被开除&quot;</li>
</ul>
<h3 id="算法-1"><a class="header" href="#算法-1">算法</a></h3>
<ul>
<li>算法现在是商品，由专业公司提供，99% 的程序员都不会直接和算法打交道</li>
</ul>
<h2 id="理财"><a class="header" href="#理财">理财</a></h2>
<h3 id="保险"><a class="header" href="#保险">保险</a></h3>
<ul>
<li>重点关注：<strong>低频高损</strong>的风险（例如一场大病）</li>
<li>保险不是理财产品，保险应该是应对风险的产品，越没用的保险，越有用，越频繁用的保险，越没用</li>
<li>保险的支出金额，应该不超过收入的 10%</li>
<li>两种主要风险（四大险）：
<ul>
<li>没钱治病：重疾险，医疗险，意外险</li>
<li>英年早逝：寿险</li>
</ul>
</li>
<li>重疾险：保额为年收入的两到三倍</li>
<li>意外险：保额是年收入的5倍（有点离谱）</li>
<li><strong>投保的大头应该以家里经济支柱为主</strong></li>
<li><strong>百万医疗险必买，每一个家人都要买</strong>（几百块钱，保百万，高杠杆），要继续观察观察</li>
<li>没有互联网保险的说法，互联网保险只是保险行业的一个销售渠道</li>
<li>保险都有同一个爸爸：<strong>银保监会</strong></li>
<li>保险公司想要破产倒闭很难，我国还没出现过破产倒闭的保险公司</li>
<li>相互保是互助计划，不是保险，不受银保监会监管，年轻人加入的少，老年人加入的多，迟早会入不敷出的</li>
</ul>
<h3 id="买房"><a class="header" href="#买房">买房</a></h3>
<ul>
<li>有一个朋友总在说，你<strong>最应该做的事情就是买房</strong>，而且是贷款买房，最近他又开始说了。理由是现在一个月还贷一万元，好像很多钱的样子；但过了20年，你还是每月还贷一万元，那时由于货币贬值，这点钱已经不足挂齿了。只要货币一直在贬值，而房子不贬值（通常如此），那么银行贷款就是对你的补助</li>
<li>贷款不要紧，会通货膨胀(<strong>货币会不断贬值</strong>的)，而通胀的一个坏处，就是老年人的<strong>养老金贬值</strong>了</li>
</ul>
<h3 id="创造财富"><a class="header" href="#创造财富">创造财富</a></h3>
<p><a href="https://new.qq.com/omn/20200413/20200413A0U72C00.html"><strong>如何不靠运气致富</strong></a>：<strong>准确定位 + 杠杆放大自己的长处</strong></p>
<ul>
<li>财富就是你<strong>拥有资产</strong>，而<strong>资产在你睡觉的时候都还在为你赚钱</strong></li>
<li><strong>互联网</strong>极大拓展了一个人职业生涯的可能性。绝大多数人对此毫无认知</li>
<li><strong>出卖时间不会变得富有</strong>，必须拥有产权，也就是生意的一部分，才能财务自由</li>
<li><strong>复利与积累</strong></li>
<li>拥有<strong>独到的知识和经验</strong>，形成<strong>不可替代性</strong>，<strong>核心竞争力</strong></li>
<li>财富增长需要使用<strong>杠杆</strong>。商业杠杆有三个来源：1、资本；2、人力；3、复制起来<strong>边际成本为零</strong>的产品（如：互联网和媒体）（我的专业课资料，边际成本就很低）</li>
<li><strong>互联网就是一个很大的杠杆，放大我们的价值</strong></li>
<li><strong>阅读</strong>，比看视频更有效</li>
<li>努力把事情<strong>做到最好</strong></li>
<li>安排好自己的时间</li>
<li>运用你的<strong>独到知识</strong>，<strong>配合上杠杆</strong>，最终你会得到你应该得到的东西（考研辅导）</li>
</ul>
<h2 id="战争--军事"><a class="header" href="#战争--军事">战争 / 军事</a></h2>
<ul>
<li>
<p>传统的潜艇都采用电池供电，<strong>柴油机</strong>供电会消耗大量的氧气，<strong>铅酸电池</strong>供电效率不高，2020-03-05，日本首艘<strong>锂电池</strong>供电的潜艇下水</p>
</li>
<li>
<p>理论上，一块宽30厘米、长6.1米、<strong>重量达数吨</strong>的钨、钛或铀金属棒状弹体可穿过大气层燃烧阶段，从距离地面1000千米的太空落下的时速可达15000千米以上，相当于11.5 吨 TNT 炸药，产生的动能撞击可以<strong>比拟小型战术核武器</strong></p>
</li>
<li>
<p><strong>核平衡的通俗解释</strong></p>
<p>传统的战争就像两个人用拳头打架，虽然会受伤，但是通常不会伤及性命。</p>
<p>核战争就像两个人用枪对峙，由于开枪都可能毙命，所以谁都不敢开枪。</p>
</li>
<li>
<p><strong>古巴导弹危机</strong></p>
<p>肯尼迪（后遇刺身亡） vs 赫鲁晓夫</p>
</li>
<li>
<p><strong>张伯伦与绥靖政策</strong></p>
<p>政治世家</p>
<p>英国在 1820s，经济体量占全球的 50%，一百年后，变成了 10%</p>
<p>绥靖政策最根本的原因，是英国的衰落</p>
<p>绥靖政策的巅峰：《慕尼黑协定》（德意英法），瓜分了捷克斯洛伐克的部分领土，签订了互不侵犯条约</p>
<p>苏德两国签定《苏德互不侵犯条约》，互不侵犯，共同瓜分波兰</p>
<p>张伯伦请辞，并推荐由丘吉尔担任首相</p>
</li>
<li>
<p>现在很多局部地区冲突成了大国新式武器的练兵场（无人机）</p>
</li>
<li>
<p>印度也有核武器，1974 年在印巴边境试爆；巴基斯坦于 1998 年成功试爆核武器，成为第七个有核国家，并且也是伊斯兰国家中第一个有核国家；</p>
</li>
<li>
<p>世界上的有核国家：五常 + 印度 + 巴基斯坦 + 朝鲜，八个国家</p>
</li>
</ul>
<h2 id="观点"><a class="header" href="#观点">观点</a></h2>
<ul>
<li>
<p>毕志飞的发家实际上一路顺风顺水，人家和我们根本不在一个跑道上</p>
</li>
<li>
<p><strong>你怎么看待知乎，你就是一个怎么样的人</strong>，从今天开始，我要在知乎和哔哩哔哩上同步创作计算机考研的内容</p>
</li>
<li>
<p>互联网赋予了每一个人的创作能力，每个人都可以在互联网上拥有自己的舞台，创造价值，要利用好这些新生事物</p>
</li>
<li>
<p>很多公司的基本工资非常低，美其名曰，给员工避税，其实是为了躲避给员工缴纳高额的社保，要多给员工缴纳近 40% 的社保</p>
</li>
<li>
<p>稀缺的东西才是最珍贵的，从这次疫情来看，互联网并不是一个非常稀缺的资源，人们缺的是实体的资源</p>
</li>
<li>
<p><strong>信息的半衰期</strong>，做有深度的，有价值的事情，这样才能保存得更加久远；学习知识也是如此，多学习不变的知识；简单可依赖；</p>
</li>
<li>
<p><strong>杠杆</strong>，顾名思义，就是以小博大，放大器</p>
</li>
<li>
<p><strong>开会</strong>对性格外向的人更有利，性格内向的人，可以通过<strong>写作</strong>来弥补自己的不足</p>
</li>
<li>
<p>越来越多的年轻人，会依靠打零工、在网上接 Uber-job 为生，成为斜杠青年，被迫 <strong>U 盘化生存</strong></p>
</li>
<li>
<p>创建一家大型互联网公司的最佳方法，就是<strong>帮助人们去做他们想做的事情</strong>，并<strong>使事情变得容易10倍</strong></p>
</li>
<li>
<p><strong>What I cannot create, I do not understand.</strong> - 费曼   其实就是：<strong>实践是检验真理的唯一标准</strong></p>
</li>
<li>
<p>在变化的时代，<strong>保持长跑的姿态</strong>，更有价值（流水不争先，争的是滔滔不绝）</p>
</li>
<li>
<p>要<strong>关注不变的东西</strong>，而不是变的东西，计算机领域也是如此</p>
</li>
<li>
<p>现在这个时代，聪明人太多了，<strong>能坚持的傻子太少了</strong></p>
</li>
<li>
<p>父母至少承担了孩子 51% 的责任控股权，出了问题，不要想着责怪他人，而是想想自己的问题出在哪里</p>
</li>
<li>
<p><strong>寒门再难出贵子</strong>，影视圈再难出草根明星，现在是资本的时代，青春有你背后，是各大资本公司力量的角逐</p>
</li>
<li>
<p>心理学对于内向和外向的定义并非一个人对外展现出来的样子，而是看他获取能量的方式，<strong>外向的人靠与他人交际获得能量，内向的人靠独处获得能量</strong></p>
</li>
<li>
<p>国外的硕士，分为研究型硕士和<strong>课程硕士</strong>，课程硕士，贼水</p>
</li>
<li>
<p>波伏娃 - 《第二性》</p>
<p>男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。</p>
</li>
<li>
<p><strong>免税贸易</strong>，本质上就是<strong>走私</strong></p>
</li>
<li>
<p>二值逻辑 ——&gt; 三值逻辑，这个世界不是非黑即白的，中庸</p>
</li>
<li>
<p><strong>快能力 vs 慢能力</strong></p>
<p>水暖工不需要冲刺，你只要持之以恒，水平自然就会提升。20年以后，你肯定是一个优秀的水暖工。</p>
<p>换句话说，体育竞争力是一种&quot;快能力&quot;，强调快速形成；水暖工是一种&quot;慢能力&quot;，有可能通过积累而获得。</p>
<p>&quot;快能力&quot;更多地取决于天赋或外部条件，所以普通人不容易成功；&quot;慢能力&quot;则是取决于后天的努力，可以用时间来换。芒格建议，如果没有天赋，就尽量选择&quot;慢能力&quot;的行业，这样你才有机会通过日复一日的积累做到优秀。</p>
<p>我就想到了一个问题：程序员属于&quot;快能力&quot;，还是&quot;慢能力&quot;？</p>
<p>别的不敢说，前端开发大概是属于&quot;快能力&quot;。因为这个行业要求你快速形成生产力，根本没有时间积累，而且积累的效果不明显，因为开发工具变得太快。相比之下，C / C++ 语言应该属于&quot;慢能力&quot;，坚持写20年，会越写越好，但是前端不是这样，几年就换一套技术栈，代码的生命周期非常短。</p>
<p>所以，想要进入前端的同学，要有清醒的认识。优秀的前端程序员，其实比的是&quot;冲刺能力&quot;，你想一直在这个行业，就要一直在冲刺。&quot;快能力&quot;的行业都是如此，一段时间出不了成绩，就会被淘汰。如果你不适应这种生活，可能就需要做一些准备，想想能不能换到&quot;慢能力&quot;的行业。</p>
</li>
<li>
<p>大公司想尽办法引诱人们多消费，真正的解决方案通常恰恰相反：你应该少消费。</p>
<p>大多数情况下，我们的问题主要是由过度消费引起的。如果你超重，不是要购买健身鞋和蛋白质粉，而是要少吃东西。如果你头痛和感到巨大压力，不是要购买头痛药和抗抑郁药，而要更多地睡觉和走路，并且不在深夜浏览社交媒体。</p>
</li>
<li>
<p><strong>两分钟规则</strong></p>
<p><a href="https://hoanhan.co/2-minute-rule">2分钟规则</a></p>
<p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p>
<ul>
<li>看一本书 → 看一页书</li>
<li>写一篇文章 → 写一句话</li>
<li>跑10公里 → 穿上跑鞋</li>
<li>做100次俯卧撑 → 做1次俯卧撑</li>
<li>多吃蔬菜水果 → 吃一个水果</li>
<li>编写一个程序 → 编写一个函数 → 编写一行代码</li>
</ul>
<p>这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。</p>
<ul>
<li>阅读一页 → 阅读10页 → 读完第一章</li>
<li>写一个句子 → 写文章的开头 → 写出正文</li>
<li>穿上跑鞋 → 步行5分钟 → 跑步5分钟</li>
</ul>
<p>一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。</p>
</li>
<li>
<p>大部分人在网上看视频、听音乐、玩游戏，都没花钱。 互联网娱乐，实际上，是人类有史以来第一种（接近）免费的大众娱乐方式**。**所有互联网娱乐里面，潜力最大的就是网络游戏。</p>
</li>
<li>
<p><strong>幸运公式</strong>：你的幸运 = X 乘以 Y，X 是你所做的准备，Y 是你遇到的机会</p>
</li>
<li>
<p>喜马拉雅山脉造就了巨大的河网，在整个亚洲广阔的土地上留下了惊人的丰富土壤。山脉的两边是世界上人口最多的两个国家，这绝非偶然。如果算上巴基斯坦、孟加拉国和尼泊尔，所有这些国家也都严重依赖喜马拉雅山脉发源的河流，那么地球上将近一半的人类与这个山脉有关。</p>
</li>
<li>
<p>一个人如果将他自己描述得很好的话，他十有八九是在撒谎，因为任何生命从内部审视都只不过是一系列的失败。——英国著名作家<a href="http://www.ruanyifeng.com/blog/2004/12/post_94.html">奥威尔</a> （人生不如意，十之八九）</p>
<p>很多人建议，寻找人生方向时，你应该听从自己的内心，寻找真正热爱的事情。我现在觉得，更现实的建议应该是，寻找你愿意忍受的痛苦。 <strong>你在哪一个方向上，愿意心甘情愿地、经年累月地吃苦，具有最大的忍耐，&quot;虽九死其尤未悔&quot;，那就是你应该选择的方向。</strong></p>
<p>你能在某件事上赢过别人，原因很可能不是你比他强，也不是你比他更热爱这个事业，而是你比他更抗打击。生活虐你千百遍，等到别人都放弃的时候，你还没有放弃。</p>
</li>
<li>
<p>如果你只看大众媒体和算法推荐给你的文章，你最终将罹患智力糖尿病</p>
</li>
<li>
<p>亲不亲，阶级分，而不是用性别去分</p>
</li>
<li>
<p>自从网约车平台出现，出租车司机就成为了大数据算法下的平台工具人。</p>
</li>
<li>
<p>凯文凯利</p>
<ul>
<li>小时候，让你与其它同学格格不入的东西，长大后会帮助你成功，如果你不失去它的话</li>
<li>成功的秘诀：少承诺，多交付</li>
</ul>
</li>
<li>
<p>我总是努力写零外部依赖的代码，多年以后依然可以运行。这是人类对抗熵的战争中，我所做出的一点贡献</p>
</li>
<li>
<p>伟大的精力来自伟大的目的，follow excellence，success will follow you</p>
</li>
</ul>
<h2 id="冷知识"><a class="header" href="#冷知识">冷知识</a></h2>
<ul>
<li>
<p>难抵极</p>
<p>地球最难到达的地方，南极距离海洋最远的地点</p>
</li>
<li>
<p>An-225</p>
<p>载重量最大的飞机，头可以打开装货</p>
</li>
<li>
<p>地球与火星之间的通讯时间</p>
<p>大约需要40分钟，发出一条指令，40分钟以后才能收到，这意味着火星登陆器必须高度自动化，具有自主决策的能力</p>
</li>
<li>
<p>美国肉鸡生产</p>
<p>1.8: 1**，**1.8 公斤的玉米饲料，可以产出 1 公斤的鸡，而且生产周期只需要 6 周</p>
</li>
<li>
<p>生产一吨大豆需要约1500吨水，所以中国的大豆可能永远都会生产不足</p>
</li>
<li>
<p>个人网站</p>
<p>是一种有点神秘的动物，大部分隐身在互联网的丛林中，很少有人观察到。</p>
<p>那些完全生活在 Facebook 和 Google 的美丽花园中的互联网用户，甚至可能都不知道该物种的存在。其他没有经验的用户可能会认为，个人网站已经像恐龙那样灭绝。事实是野外还存在许多标本，只有了解该物种习性的猎人才能发现它们。</p>
</li>
<li>
<p>火星有冰</p>
</li>
<li>
<p>金星大气压</p>
<p>金星的大气压是地球的 96 倍，压强极大，人到了金星会被瞬间压扁，威力类似于二向箔</p>
</li>
<li>
<p>民粹主义</p>
<p>说白了，就是<strong>民怨</strong>，就像夫妻吵架最后离婚一样，绝对不是因为最新的一次吵架而离婚的，而是日积月累的不满导致的。香港问题也是如此，反送中事件本身不足以导致香港大游行，反送中事件只是压垮骆驼的最后一根稻草，是一个导火索。（美国暴乱也是如此）</p>
</li>
<li>
<p>维密创始人最初的想法，是向男性售卖女性内衣</p>
</li>
<li>
<p>中国收视率第二的节目</p>
<p>天气预报，彩云天气通过人工智能预测降雨，实现分钟级别的预测</p>
</li>
<li>
<p>1989 年 64 事件后，清华大学的学生被<strong>军训了一年</strong></p>
</li>
<li>
<p><strong>阿拉伯</strong>国家，实行<strong>一夫多妻</strong>制</p>
</li>
<li>
<p>物理上控制变量法在医学上的应用：<strong>安慰剂</strong></p>
</li>
<li>
<p>普京的全称：<strong>弗拉基米尔-普京</strong></p>
</li>
<li>
<p>蚊子品种</p>
<p>分为伊蚊、库蚊和按蚊，库蚊是我们生活中最常见的蚊子，花蚊子是伊蚊</p>
</li>
<li>
<p><strong>理中客</strong>：理性，中立，客观</p>
</li>
<li>
<p><strong>CDC</strong>：美国疾控中心</p>
</li>
<li>
<p><strong>NSFW</strong>：Not Safe For Work</p>
</li>
<li>
<p><strong>国际空间站</strong></p>
<p>截至到 2020-11-02 国际空间站已启用 20 年。苏联解体后，俄罗斯和美国共建空间站，后来加拿大，日本，欧盟加入。</p>
<p>长约 109 米，速度是 8公里/s，建造费用超过1000亿美元，每年的维护和补给费用约40亿美元，其中大部分由美国支付。</p>
</li>
<li>
<p><strong>世界最大的潜艇</strong></p>
<p>前苏联的941型核潜艇（北约称为台风级核潜艇）是世界最大的潜艇，长175米。</p>
</li>
<li>
<p><strong>标普 500</strong></p>
<p>标准普尔500指数包括500支股票。过去5年，脸书、亚马逊(Amazon)、苹果、微软、谷歌这五家公司的市值增长了2.5倍，而剩下的495支股票的市值，加在一起几乎没有变化。</p>
</li>
<li>
<p><strong>谁死谁有理</strong></p>
<p>停车在路边，有人撞上死了，车主也得赔钱</p>
</li>
<li>
<p>4G 上网的二氧化碳排放比 WIFI 上网高4～7倍</p>
</li>
<li>
<p><a href="https://www.antipodesmap.com/">Antipodes Map</a> 上显示，南京在地球的另外一边的国家是阿根廷，并不是美国</p>
</li>
<li>
<p>台积电南京圆晶厂，是台积电唯一不在南京的工厂</p>
</li>
<li>
<p>国外的 Uber 是给其网约车司机缴纳五险一金的</p>
</li>
<li>
<p>三星堆，任何史书都没有记载，四千年前四川存在过一个高度发达的人类文明。这个文明是哪里来的，又为何消失，留下了太多的未解之谜。</p>
</li>
<li>
<p><a href="https://robbreport.com/lifestyle/news/rare-psyche-asteroid-worth-way-more-than-the-global-economy-1234577976/">哈勃望远镜</a>在火星和木星之间，发现了一颗稀有的小行星，上面包含的铁镍合金，按照现在的价格，价值1000亿亿美元，比全球 GDP 总和高出70000倍，分给全球75亿人，每人可以分到13亿美元。太空采矿也许会大发展了。</p>
</li>
<li>
<p>民航飞机通常飞到 1 万米的高空，八万米是大气层的边界</p>
</li>
<li>
<p>空气湿度对人体的影响非常大，比如气温为31度时，如果湿度达到78%，人体实际感受到的温度相当于40度。本文介绍什么是湿度，以及如何除湿或加湿</p>
</li>
<li>
<p>自由职业者如何开发票：https://mp.weixin.qq.com/s/uBGg3QuqD_Nl2W-uIJ4Feg</p>
</li>
<li>
<p>地壳所有元素中，含量最高的竟然是氧 46%，其次是硅 28%，其次是铝 8%</p>
</li>
</ul>
<h2 id="生活--健康"><a class="header" href="#生活--健康">生活 / 健康</a></h2>
<ul>
<li>
<p>喝水太多也会中毒，一个 150 斤的人，一口气喝 6 升的水，就会有死亡的危险，因为体内的钠被稀释，电解质失衡</p>
</li>
<li>
<p>在上半周做手术比在下半周做手术安全</p>
</li>
<li>
<p><strong>睡前玩手机影响睡眠的解释</strong>：手机屏幕发出的蓝色频率的波长和日光类似，蓝光会抑制褪黑素的分泌，进而影响睡眠</p>
</li>
<li>
<p>体温低的原因：新陈代谢变慢；</p>
<p>婴幼儿的新陈代谢快，所以体温比成人高，不超过 37.5 就没问题；</p>
<p>温度最高的器官：肝脏，在 38 度的环境下，过着 007 的生活，肝脏是人体最大的消化腺，最忙的一个器官，不要熬夜，好好保护它</p>
</li>
<li>
<p>勃起受脊髓控制</p>
</li>
<li>
<p>人是怎么散热的</p>
<p>人能在比自己体温高的环境 下生存，靠的是通过流汗蒸发散热的能力，有足够的水分补给，就 ok</p>
</li>
<li>
<p><strong>喝牛奶的重要性</strong></p>
<ul>
<li>钙元素是人体的第五大元素，也是人体需要的<strong>常量元素</strong>（不是微量元素），人体对钙的需求量是非常高，要多喝牛奶多补钙，每天要达到 <strong>300ml</strong> 的牛奶摄入量。人体能够通过<strong>晒太阳</strong>合成维生素D，<strong>维生素D可以促进钙的吸收</strong>，所以晒太阳会影响长个子。</li>
<li>喝牛奶会出现乳糖不耐受的情况，酸奶会利用乳酸菌将乳糖分解为乳酸，从而方便人体吸收</li>
<li>牛奶是否含有防腐剂？没有。牛奶变质是因为外界细菌的入侵。杀菌的方法：1. 巴斯德的<strong>巴氏杀菌法</strong>（<strong>高温杀菌</strong>，部分杀菌，<strong>有益菌</strong>没有被杀死，巴氏杀菌法的保质期可以达到 15 天，冷链运输；巴斯德证明了事物变质不是因为自身原因导致的，而是因为细菌） 2. 高温灭菌奶（UHT奶，完全杀菌，利乐枕包装，保质期 180 天，但是没有益生菌了，营养和口感不如巴氏杀菌奶）</li>
</ul>
</li>
<li>
<p>天津中医药大学校长-<strong>中国工程院院士</strong>-<strong>张伯礼</strong>，开始<strong>用大数据和超算来分析中</strong>药，彻底抛弃了阴阳五行学说，构建中药数据库，研究中药的有效成分，对中药的药性定性定量，进而为中医正名</p>
</li>
<li>
<p>很多三甲医院有营养科，备孕的时候，可以去咨询</p>
</li>
</ul>
<h2 id="人物"><a class="header" href="#人物">人物</a></h2>
<ul>
<li>
<p>阮一峰</p>
<p>卡辛斯基的推崇者，对技术进步持悲观态度，目前就职阿里</p>
</li>
<li>
<p>魔鬼投资人：付宁</p>
<p>后浪，伦敦大学毕业，一站到底冠军</p>
<blockquote>
<p>付宁这样形容自己：“每个人有很多面，认识我的人99%都不相信我不是外向的人，但是事实上<strong>我特别喜欢通过独处获取能量，一个人撸撸猫看看书，安静地做做研究，然后再对外释放出我的正面能量给大家。</strong>”</p>
<p><strong>在独处时积蓄能量，在人前散发光芒</strong>。</p>
</blockquote>
</li>
<li>
<p>胡锡进</p>
<p>环球时报总编辑，中立骑墙派，外宣风向标</p>
</li>
<li>
<p>宁南山</p>
<p>中国人民大学对外战略研究中心助理研究员，用数据说话，宏观经济视角</p>
</li>
<li>
<p>曹丰泽 寒冰射手草草草</p>
<p>2012 高考黑龙江省理科第七名，应该比我大一岁</p>
</li>
<li>
<p>李永乐</p>
<p>人大附中物理老师，屁股歪，后浪，不识人间疾苦</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="知乎"><a class="header" href="#知乎">知乎</a></h1>
<p>[TOC]</p>
<h2 id="知识总结"><a class="header" href="#知识总结">知识总结</a></h2>
<ul>
<li>
<p><strong>坐车的位置</strong></p>
<p>坐熟人的车，如果是朋友的车，要坐前排，如果坐后排，就是不尊重对方，把对方当司机了。</p>
</li>
<li>
<p>新冠时期美国失业率达到 <strong>14%</strong></p>
</li>
<li>
<p>通用电气的创始人：<strong>爱迪生</strong></p>
</li>
<li>
<p>老百姓买了一个城市的<strong>房子</strong>，就相当于买了这个城市的<strong>股票</strong></p>
</li>
<li>
<p><strong>凡有所学，皆成性格</strong>。—— 培根</p>
</li>
<li>
<p><strong>知乎治校</strong>：学生通过知乎吐槽创造舆论压力来倒逼学校有所作为。典型案例：疫情期间，南大和天大的学生吐槽学校封闭管理，而教职工及其子女可以随便进出</p>
</li>
<li>
<p>同床却不入身，这个话，很有意思，有古风，哈哈哈哈</p>
</li>
</ul>
<h2 id="观点-1"><a class="header" href="#观点-1">观点</a></h2>
<ul>
<li>你必须承认，30岁以后，你的基本形象就是靠人民币和自律来维持。这不是鸡汤，是现实。</li>
</ul>
<h3 id="丁蟹--李北方"><a class="header" href="#丁蟹--李北方">丁蟹 / 李北方</a></h3>
<ul>
<li>人民上了网，民意就上了网。在各种各样流行的言论背后，隐藏着社会的种种现实矛盾的发展情况。知乎上大多是高学历中产小年轻，这个群体的意识就是摇摆不定，犹豫不决，尿尿唧唧，哭哭啼啼。</li>
</ul>
<h2 id="话题"><a class="header" href="#话题">话题</a></h2>
<ul>
<li>
<p><a href="https://www.zhihu.com/question/422738321/answer/1492612749">[如何看待前财政部长楼继伟提出「现有 5G 技术很不成熟，数千亿级 5G 投资找不到应用场景」这一观点?]</a></p>
<p>5G 在商业上其实不是很成熟，很多场景 4G 完全能够满足，发展 5G 性价比不高，这也是很多国家不发展 5G 的原因。成本太高了，三大运营商都是在倒贴钱。</p>
<p>5G 大跃进和电动汽车一样，都是某些利益集团利用国家在技术方面想要急于摆脱和超越国外的心态，而忽悠政府的决策和投入。但是，虚假的东西就是虚假的。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/422641856/answer/1490864751">[如何看待罗永浩表示 6 亿债务已还了 4 亿？他是如何做到的？6 亿债务具体如何欠下的？]</a></p>
<p>当你欠银行100块钱的时候焦虑的是你自己，当你欠银行一个亿的时候焦虑的是银行。—— 罗永浩</p>
<p><strong>企业家合理借款1个亿，因经营不善导致无法偿还债务的这种情况对社会的恶劣影响＜＜＜毛贼入室抢劫1000块钱</strong>。</p>
<p>从国家的角度来看，如果一个企业家欠了一个亿，因为经营不善而破产，那么<strong>这一个亿是流入社会了</strong>，对国家来说没什么社会的不良影响反而增大了就业拉动了 gdp。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/61093061/answer/1337251489">[和女生聊天如何把握尺度？]</a></p>
<p>懂分寸，不要给女生压力！在和女生聊天中，分寸就是你要摆清自己的位置！还没有确立关系之前，你和女生的关系永远就是普通朋友。所以就不要去为她做错过普通朋友界限的事情！</p>
<p>比如：天天早安，晚安（这是她男朋友干的事情），天天问吃了吗，吃什么（这是她爸妈干的事情），天热提醒她小心中暑，天冷提醒她多穿衣服（这是天气预报干的事情）</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/408039874/answer/1498018990">[为什么中国的科研人才总是留不住，作为普通人我们能做什么？]</a></p>
<p>现实情况是，中国人才哪怕不是被动外流，而是主动朝外输出，都能把世界上<strong>所有主要工业化国家的相关岗位全部填满</strong>。内卷！</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/399148081/answer/1483785143">[程序员的悲哀是什么]</a></p>
<p>程序员、网络工程师、数据库管理员这类人构成了 IT 共和国的主体，这个阶层是十九世纪的产业大军在二十一世纪的再现，只不过劳作的部分由肢体变成大脑，繁重程度却有增无减。在渺如烟海的程序代码和迷宫般的网络软硬件中，他们如二百多年前的码头搬运工般背起重负，如妓女般彻夜赶工。信息技术的发展一日千里，除了部分爬到管理层的幸运儿，其他人的知识和技能很快过时，新的 IT 专业毕业生如饥饿的白蚁般成群涌来，老的人（其实不老，大多三十出头）被挤到一边，被代替和抛弃，但新来者没有丝毫得意，这也是他们中大多数人不算遥远的前景…… 这个阶层被称做技术无产阶级。 — 刘慈欣</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/425735108/answer/1543709331">[你可以继续不喜欢你不喜欢的事物，但请允许它存在]</a></p>
<p>虚空对虚空的辩经没有任何的意义，“我牛逼是因为我牛逼”的循环论证没有任何的意义。网线一拔，你的喜欢或者不喜欢没有任何的意义。世界是物质的，你的精神要想发挥作用，就要作用在物质上，否则你就是那张桌子。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/427198616/answer/1541702862">[如何评价山高县的第十期视频：别说城里人不生，农村生了儿子，也要哇的哭出声？]</a></p>
<p>对于中国社会来说，提高生育率实际上没有任何捷径可走。因为中国语境下的“阶层跌落”本身在生物学上是无法避免的，就算是两个大学教授生出的孩子，大概率不论你如何教育他，他仍然是能把车修明白就很不错了。你指望他们也当大学教授，那在生物学上就是一件很荒唐的事情。</p>
<p>唯一的办法，就是把修车工的生活质量提高到并不比大学教授低很多的水平上，**让大学教授并不恐惧自己的孩子会成为一个修车工。**如果你永远只是在阶级流动这种五饼二鱼的事情上做文章，那你的阶级流动做得越好，人们就越是对生育充满恐惧，越是会把生育的成本主动地推到极高的水平上，就越是会断子绝孙。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/426308484/answer/1543519412">[郑永年说现在年轻人啃老是正确的，因为前人把几百年的机会都抢光了，你怎么看]</a></p>
<p>一个我国从08年以来的事实：资本收益和劳动收益逐渐拉开差距，也就是一个活生生的年轻人靠着自己的双手劳动竟然不能有基本的生活条件，形成的资本能更快速的分配得到社会的资源，占据资源配置的倾斜一端。</p>
<p>醉翁之意不在酒，在乎韭菜之根也。抢着割韭菜，把韭菜割的不像样了。这时候突然想起来，不能这么割，再割韭菜就烂根了。想建立割韭菜长效机制，得施肥。一群人扭扭捏捏，都不愿意掏化肥钱。这时候，一个人跳了出来。“看见那堆咱爸妈割剩的老韭菜茬子了没，把他们烧了不就是肥吗？”</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/418623419/answer/1482699029">[如何看待“好！很有精神”这种旧日本军队梗的流行？]</a></p>
<p>基本上当代的年轻人已经无法从宏大叙事中获得任何参与感。说人话就是，主流叙事已经抛弃年轻人很久了。所以越来越多的肉食者开始发觉，根本搞不懂年轻人在想什么。为什么上一代惯用的宣传策略，官方的文化产品，这一代人根本不买账，然后搞出一堆宣传事故。</p>
<p>幽默是带着笑的反抗。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/266767649/answer/1509973899">[中国教育最大的成功在哪里？]</a></p>
<p>中国教育最大的成功在于：它以最小的成本，把极其昂贵的，中国古典文化的士大夫精英们的思想精华都保留了下来，用没有门槛的方式，传递给了所有接受基础教育的中国人。你会发现只要你踏踏实实学完中学语文，你会得到非常夯实的审美、认知、方法、策略；甚至是政治格局和家国责任的培养和训练。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/311635956/answer/625631723">为什么很多男生在相亲时，听到女生「喜欢旅行」「爱好旅游」会很抵触？</a></p>
<p>这叫加完杠杆却发现找不到人接盘。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/280272233/answer/673024647">当一对情侣无话可说的时候，该怎么做？</a></p>
<p>曾经看到过一个问题，问的是你听过最可爱的告白是什么，有个姑娘说“那天我在路上看到一棵形状奇怪的树，第一反应竟是拍下来给你看…那时候我就知道 要出大事了…”</p>
<p>你是什么时候下定决心分手的，有个答主和我说了同样的话。“那天我在路上看到一棵奇怪的树，却没想要告诉他。”</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/67091864/answer/543836164">女生真实的一面是怎样的？</a></p>
<p>女子本弱，为母则刚。</p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/437063741">新编解人颐 序</a></p>
<p>一个人追求宁静，那么他永远不会宁静，认真把眼前的事情做好，宁静自然来了。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/359906573/answer/1711178341">为什么中国出了这么多厉害的互联网公司，但没有自己设计过编程语言？</a></p>
<p>java语言之父：詹姆斯·高斯林，40岁左右做出了初代java；go语言之父Rob Pike，约50岁时开发了go；go语言的另一位爸爸：Ken Thompson，也是Unix操作系统的创始人，去谷歌造go的时候已经60多了；go语言的另一位爸爸：Ken Thompson，也是Unix操作系统的创始人，去谷歌造go的时候已经60多了；ruby语言之父：松本行弘，30岁发布了初代ruby。</p>
<p>而我，今年才 27 岁，却没了激情，没了梦想，真的惭愧</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="story"><a class="header" href="#story">Story</a></h1>
<p>[TOC]</p>
<h2 id="最神秘的蠕虫病毒---震网病毒"><a class="header" href="#最神秘的蠕虫病毒---震网病毒">最神秘的蠕虫病毒 - 震网病毒</a></h2>
<p>我们不知道 Stuxnet 的作者是谁，只知道大概是在2005年至2010年间编写的。</p>
<p>这种病毒藏在 U 盘上。当 U 盘插入 PC，它会自动运行，将自已复制到该 PC。它至少有三种自动运行的方法。如果某种方法行不通，就尝试另一种。其中的两种运行方法是全新的，使用了 Windows 的两个无人知晓的秘密 Bug。</p>
<p>一旦蠕虫进入 PC ，它会尝试获得该 PC 的管理员权限，使用的也是前面提到的那两个无人知道的秘密 Bug。然后，它把自己留下的痕迹全部清除，不让防病毒软件检测到它的存在，用户不会看到任何东西。这种蠕虫隐藏得很好，出现后一年多，没有任何一家安全公司发现它的存在。</p>
<p>它会秘密访问 <a href="http://www.mypremierfutbol.com/">http://www.mypremierfutbol.com</a> 或 <a href="http://www.todaysfutbol.com/">http://www.todaysfutbol.com</a> 这两个网站，告诉服务器已经成功侵入了一台新的 PC，然后从网站下载最新版本自行更新。</p>
<p>它会将自身复制到任何插入该 PC 的 U 盘。使用的 U 盘驱动程序由 Realtek 公司进行了数字签名，但是 Realtek 公司并不知道有这个签名。这意味着，蠕虫作者能够获取 Realtek 公司的最高密钥。</p>
<p>它利用两个 Windows 的 Bug ----一个涉及网络打印机，另一个涉及网络文件----将自己传播到局域网里面的其他计算机上。</p>
<p>直到这一步，它的真正任务还没有开始。</p>
<p>它在每一台计算机上寻找一种由西门子设计的用于大型工业机械自动化的控制软件。一旦发现这种软件，它会使用另<em>一个</em>以前未知的 Bug，将自身复制到工业控制器的驱动程序。然后，它会检查两家特定公司的工业电机，其中一家公司在伊朗，另一家在芬兰。它要搜索的特定电机称为变频驱动器，主要用于运行工业离心机，提纯多种化学品，比如铀。</p>
<p>由于蠕虫完全控制了离心机，因此它可以做任何事情，可以将离心机全部关闭，也可以将它们全部摧毁：只需设定以最大速度旋转离心机，直到它们全都像炸弹一样爆炸，杀死任何恰好站在附近的人。</p>
<p>但它没有这么做，一旦它控制了每台离心机......它就进入潜伏。一旦达到设定的时间，它就会悄悄地唤醒自己，锁住离心机，使得人类无法关闭这些机器。然后悄悄地，蠕虫开始旋转这些离心机，修改了安全参数，增加了一些气体压力......</p>
<p>此外，它还会在离心机正常运转的时候，偷录一段21秒的数据记录。当它控制离心机运行的时候，会一遍又一遍地播放这段数据记录。管理人员会看到，计算机屏幕上的所有离心机运行数据都很正常，但这其实是蠕虫让他们看的。</p>
<p>现在让我们想象一下，有一家工厂正在用离心机净化铀。电脑上的所有数字都表明离心机运行正常。但是，离心机正在悄悄地出问题，一个接一个地倒下，这使得铀产量一直下降。铀必须是纯净的。你的铀不够纯净，无法做任何有用的事情。</p>
<p>工厂的管理者根本找不到原因，离心机的数据是正常的。你永远不会知道，所有这些问题都是由一种计算机蠕虫引起的。这是一种历史上最狡猾和最聪明的计算机蠕虫，它由一些拥有无限资金和无限资源的令人难以置信的秘密团队编写，并且设计时只考虑一个目的：偷偷摧毁某个国家的核弹计划，并且不被发现。</p>
<h2 id="外卖骑手困在系统里"><a class="header" href="#外卖骑手困在系统里">外卖骑手，困在系统里</a></h2>
<p><a href="https://mp.weixin.qq.com/s/Mes1RqIOdp48CMw4pXTwXw">[外卖骑手，困在系统里]</a> 深度好文</p>
<h2 id="五只猴子的故事"><a class="header" href="#五只猴子的故事">五只猴子的故事</a></h2>
<p>科学家在笼子里放了五只猴子。笼子中间有一架梯子，梯子上面放着香蕉。</p>
<p>每当一只猴子爬上梯子，科学家就用冷水泼洒其余的猴子。过了一阵子，只要一只猴子爬上梯子，其他猴子就会殴打它。一段时间后，所有猴子都不敢爬上梯子。</p>
<p>然后，科学家用一只新猴子，替换了原来的一只猴子，并且停止用冷水泼洒猴子。这只新猴子立即爬楼梯去拿香蕉，但随即遭到其他猴子的殴打。经过几次殴打，新猴子学会了不爬梯子，即使它从来不知道为什么。</p>
<p>接着，替换了第二只猴子，也发生了同样的事情。刚才放进笼子的那只猴子，同样殴打了新来的猴子。替换了第三只猴子，也是如此。就这样，第四只、第五只猴子也接连被替换了。</p>
<p>最终，笼子里面的五只猴子，尽管从未被泼冷水，仍然继续殴打任何试图爬上梯子的猴子。如果可以问猴子，为什么要殴打所有试图爬上梯子的成员，答案可能是：</p>
<p>&quot;这就是我们在这里做事的方式。&quot;</p>
<p>这个故事告诉我们，如果前人觉得某件事情不能做，阻力就会流传下来，阻止后来的人去做。</p>
<p>但是，大多数人没有意识到，有时候情况会改变。二十年前不可能的事情今天也许并非不可能。比如，电动汽车以前是不可能的，现在随着电池技术的进步，才有可能。</p>
<p>年轻人不知道为什么某事不能做，如果他们不怕阻力，就会去尝试那些不能做的事情。这就是为什么重大创新往往是年轻人做出来的原因。</p>
<p>老年人通常看不到新的机会，因为他们相信有些事情是不可能的。年轻人在无知和热情推动下，愿意尝试那些不可能的事情。大多数年轻人会失败，但少数会成功。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="经济学原理"><a class="header" href="#经济学原理">经济学原理</a></h1>
<p>[TOC]</p>
<h2 id="授课老师--经典著作"><a class="header" href="#授课老师--经典著作">授课老师 / 经典著作</a></h2>
<ul>
<li>清华大学经管学院院长：钱颖一，02 年来到经管学院</li>
<li>经管学院副院长、党委副书记：钟笑寒</li>
<li>亚当斯密-《国富论》</li>
<li>大卫李嘉图-《政治经济学与赋税原理》</li>
</ul>
<h2 id="1-什么是经济学"><a class="header" href="#1-什么是经济学">1. 什么是经济学</a></h2>
<ul>
<li>经济学界的诺贝尔奖：<strong>克拉克奖章</strong></li>
<li>经济学，是一门研究<strong>选择</strong>的<strong>社会科学</strong>。</li>
<li><strong>经济学三类问题，十大原理</strong>
<ul>
<li>人们怎么做决策（微观经济学）
<ul>
<li>人们面临得失交换（<strong>权衡取舍</strong>） People face <strong>tradeoff</strong>.</li>
<li>某物的成本是为此所放弃的东西（<strong>机会成本</strong>） The <strong>cost</strong> of something is what you give up to get it. </li>
<li>理性人思考边际量（<strong>边际成本</strong>） Rational people think at the <strong>margin</strong>.</li>
<li>人们会对激励做出反应（<strong>激励</strong>） People respond to <strong>incentives</strong>.</li>
</ul>
</li>
<li>人们如何相互作用（微观经济学）
<ul>
<li>贸易能使人人受益（<strong>交换</strong>） <strong>Trade</strong> can make everyone better off.</li>
<li>市场通常是组织经济活动的好方式（<strong>市场</strong>） <strong>Markets</strong> are usually a good way to organize economic activity.</li>
<li>政府有时候可以改进市场结果（<strong>政府</strong>） <strong>Governments</strong> can sometimes improve market outcomes.</li>
</ul>
</li>
<li>整体经济如何运行（宏观经济学）
<ul>
<li>一国的生活水平取决于它的生产（<strong>生产力</strong>） The standard of living depends on a country's <strong>production</strong>.</li>
<li>当政府发行了过多的货币时，物价上涨（<strong>货币</strong>） Prices rise when the government prints too much <strong>money</strong>. </li>
<li>社会面临通货膨胀和失业之间的短期得失交换（<strong>通胀与失业</strong>） Society faces a short-run tradeoff between <strong>inflation</strong> and <strong>unemployment</strong>. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="权衡取舍-tradeoff"><a class="header" href="#权衡取舍-tradeoff">权衡取舍 tradeoff</a></h3>
<p>天下没有免费的午餐，有得就有失。时间成本。</p>
<h3 id="机会成本-opportunity-cost"><a class="header" href="#机会成本-opportunity-cost">机会成本 opportunity cost</a></h3>
<p><strong>机会成本</strong>是指在面临多方案择一决策时，被舍弃的选项中的最高价值者是本次决策的<strong>机会成本</strong>。 简单来说，某物的机会成本是为了得到它而放弃的东西。</p>
<p>每当我们做了一个选择，我们就放弃了其他的选择。</p>
<p>权衡利弊得失，时间成本，选择了国企，那么我的机会成本是什么？如果选择另一个方案，会不会有更好的收益？比尔盖茨为什么退学？是因为上学的机会成本太高了。民工荒：打工的机会成本变高。</p>
<p>我为了考上研，放弃了太多的东西。</p>
<h3 id="边际成本-marginal-cost"><a class="header" href="#边际成本-marginal-cost">边际成本 marginal cost</a></h3>
<p>边际成本是对已有行动计划的小的、增量微调。</p>
<p>动态的思维，谁都要吃饭的，边际成本是多吃一口，少吃一口的问题。航空公司在乘客上完之后，允许员工的家属免费搭乘飞机。</p>
<p>李老师所作的那些“施舍”和虚伪的“关心”，实际上都是成本很低的边际成本。</p>
<h3 id="激励机制-incentive"><a class="header" href="#激励机制-incentive">激励机制 incentive</a></h3>
<p>激励机制无处不在：消费券，奖学金，拼多多拼团优惠等。还有例如安全带激励司机开车不注意安全，使得受伤的行人增多；保险机制可能带来更多的风险，增加杠杆。</p>
<h3 id="交换可以使得人人受益"><a class="header" href="#交换可以使得人人受益">交换可以使得人人受益</a></h3>
<p>交换也可以理解成交易，交流。交易可以使得人人受益；在交易中竞争也可以得到受益；交易可以促进人们的专业分工。</p>
<h3 id="市场经济-market-economic"><a class="header" href="#市场经济-market-economic">市场经济 market economic</a></h3>
<p>看不见的手（invisible hand），<strong>价格</strong>，使得企业自己决定雇佣谁和生产什么，人们自己决定买什么和为谁工作。</p>
<h3 id="政府的作用"><a class="header" href="#政府的作用">政府的作用</a></h3>
<p>罗斯福新政，金融危机。促进公平，税收，福利，医疗。</p>
<h3 id="通货膨胀-inflation"><a class="header" href="#通货膨胀-inflation">通货膨胀 inflation</a></h3>
<p><strong>整体</strong>物价水平的上升。注意，是<strong>整体</strong>！猪肉价格，水果价格上涨，都不是通货膨胀。长期的通货膨胀，大概率是货币货币导致的。</p>
<p>通货膨胀和失业率，政府向市场注入大量现金 ——&gt; 人们手里有了更多的钱开始<strong>消费</strong> ——&gt; 企业招聘更多的工人生产 ——&gt;  失业率下降。（<strong>四万亿的作用</strong>） </p>
<h2 id="编外经济学名词"><a class="header" href="#编外经济学名词">编外：经济学名词</a></h2>
<h3 id="我的思考-3"><a class="header" href="#我的思考-3">我的思考</a></h3>
<p>这门课用的是曼昆的经济学教材，学习的是西方的经济学，很多情况下，并不能解释国内的一些现状，国内更讲政治。</p>
<h3 id="基准利率"><a class="header" href="#基准利率">基准利率</a></h3>
<p>基准利率就是一个市场上利率水平的风向标。各个金融机构，都根据这个标准来确定自己的贷款和存款利率。央行提高或者降低基准利率，就意味着提高或者降低整个社会的利率水平。</p>
<p>美国在疫情期间的基准利率已经降到了 0%。</p>
<p>利率是资金的成本。利率低就说明资金便宜，你可以用非常低的价格借到钱。反过来，它也反映了社会的平均利润率。如果各种项目的利润率很高，而利率又很低，就会有更多的人去借钱，从而促使利率回升。</p>
<p><strong>利率一降再降，恰恰说明了社会的平均利润率在不断下降。</strong> 通俗地说，就是可以赚钱的好项目，越来越难找了。</p>
<p>下面就是这件事对每个人的影响： <strong>高回报项目的消失、利率的下降、经济增长的放缓，使得你很难有办法攒钱了。</strong> 你好不容易积攒了一点工资，却发现根本找不到高回报的投资途径，不管是银行存款、证券投资、项目投资，回报率都很低。</p>
<h3 id="做空和做多"><a class="header" href="#做空和做多">做空和做多</a></h3>
<p>做空：不看好未来的业绩，高价卖股票，等股价跌了再买回来，著名的做空机构：浑水。</p>
<p>做多：看好未来的业绩，低价买股票，等股价高了再卖出去。</p>
<h3 id="年报和季报"><a class="header" href="#年报和季报">年报和季报</a></h3>
<p>季报：所有的上市公司每一个季度都要交一份报告，Q1，Q2，Q3，Q4</p>
<h3 id="四大会计事务所"><a class="header" href="#四大会计事务所">四大会计事务所</a></h3>
<ul>
<li>普华永道（PwC）</li>
<li>德勤（DTT）</li>
<li>毕马威（KPMG）</li>
<li>安永（EY）</li>
</ul>
<p>其中安永帮过瑞幸做过一次假账，在瑞幸被浑水做空实锤之后，不敢再为瑞幸背书了。</p>
<h2 id="2-像经济学家一样思考"><a class="header" href="#2-像经济学家一样思考">2. 像经济学家一样思考</a></h2>
<ul>
<li>经济学是一门<strong>社会科学</strong>，也是一门<strong>经验科学</strong>，有一套科学的研究方法，<strong>观察</strong>，获取数据，提出理论，验证</li>
<li>经济学的难点：很难获取数据，很难实证，例如 90 年代<strong>经济特区</strong>的实验，通常是做一个<strong>小样测试</strong>，或者做出<strong>假设</strong>，我的研究生毕业论文，就是假设一条微博的情感只有正负，<strong>假设越少越好，越简单越好，越抽象简单的理论，其解释的范围越广</strong>，便于理解。</li>
<li>冷门的、<strong>general</strong> 的问题，更值得去探索，<strong>不要盲目跟风</strong></li>
<li>学会三种表达方式：<strong>说话、图形和数学</strong>，这不止是经济学的表达方式，任何严谨的表达都应该如此</li>
<li><strong>生产要素</strong>：<strong>土地、劳动力和资本</strong></li>
</ul>
<h3 id="生产可能性边界--边际收益递减-diminishing-marginal-returns"><a class="header" href="#生产可能性边界--边际收益递减-diminishing-marginal-returns">生产可能性边界 / 边际收益递减 diminishing marginal returns</a></h3>
<p>The Production Possibilities Frontier</p>
<p>生产可能性边界，表示的是经济能够生产出的产品组合。</p>
<p><img src="life-and-thinking/keep-learning/assets/1585294857578.png" alt="汽车和电脑的生产可能性边界" /></p>
<p><strong>假设</strong>，假设一个公司只生产汽车和电脑，并且只有有限的生产要素。（<strong>一个简单的假设</strong>）</p>
<p>那么该公司的生产组合只能是<strong>边界</strong>（边界效率最高）或者边界内部的组合。<strong>汽车和电脑互为彼此的机会成本</strong>。如果公司想要多生产几辆汽车，就要少生产几台电脑。关键在于，如果调配生产组合，形成生产利益的最大化。</p>
<p>假设所有的生产资源都用来生产汽车，那么最多能生产 1000 量汽车，但是这并不一定能<strong>最大化地利用资源</strong>，此处曲线的斜率越大，x 轴汽车生产数量的一点减少，能够带来 y 轴电脑生产数量的快速增长。这就是<strong>边际效益递减</strong>。同样的道理，一门科目，在及格线处想要提高一分很容易，但是如果 90 分再多考一份，就可能需要耗费比 60 分多得多的精力，这也是边际效益递减。考研也是如此，我们的精力是有限的，面对那么多的科目需要复习，没有必要在单科上追求完美，而是应该<strong>追求总分的最大化</strong>。</p>
<p>当制造电脑的<strong>技术进步</strong>后，曲线变成了：</p>
<p><img src="life-and-thinking/keep-learning/assets/1585297596733.png" alt="技术进步" /></p>
<p>我们可以看到，在制造电脑的数量不变的情况下，电脑的技术进步使得汽车的制造数量增加了。这也很好解释，制造电脑的技术在引入流水线后，原来需要 10 个人在生产线，现在可能只需要 5 个人就可以操作整个生产线，剩下的五个人则可以去制造汽车，从而使得汽车的制造数量增加，所以汽车和电脑的价格是<strong>相互影响</strong>的。同样的现象可以解释理发行业的价格，理发的技术进步较慢，但是其他行业的技术进步较快，从事理发的机会成本就变得越高，所以理发的价格也随之增加。</p>
<h3 id="经济模型中的因果关系"><a class="header" href="#经济模型中的因果关系">经济模型中的因果关系</a></h3>
<p>最简单的因果关系：$y=f(x)$</p>
<p>x：<strong>外生变量</strong>，因，输入</p>
<p>y：<strong>内生变量</strong>，果，输出</p>
<p>被忽视的变量：x 增长，y 也增长，可能都是由 z 导致的。例如，打火机和癌症，都是由吸烟引起的。</p>
<p>反向因果关系：夫妇购买旅行车先于小孩的出生，小孩才是因。</p>
<p><strong>计量经济学的精髓：从一堆数据中，寻找因果关系。</strong></p>
<h3 id="经济分析方法"><a class="header" href="#经济分析方法">经济分析方法</a></h3>
<h4 id="考虑个人行为时"><a class="header" href="#考虑个人行为时">考虑个人行为时</a></h4>
<p><strong>稀缺性 Scarcity ——&gt; 机会成本 Opportunity cost ——&gt; 得失交换 Tradeoff</strong></p>
<p>例如，价格上升引起需求下降，价格上升，稀缺性变高，机会成本就上升</p>
<h4 id="考虑多人决策相互作用时"><a class="header" href="#考虑多人决策相互作用时">考虑多人决策相互作用时</a></h4>
<p>均衡 ——&gt; 效率？——&gt; 双赢。最大熵算法。</p>
<h4 id="应用于其他学科"><a class="header" href="#应用于其他学科">应用于其他学科</a></h4>
<p><strong>出发点</strong>：资源的<strong>稀缺性</strong>和<strong>人的行为</strong>动机的<strong>自利性</strong></p>
<p><strong>着眼点</strong>：经济人相互作用的<strong>效率</strong>结果</p>
<p><strong>政府中的经济学家</strong></p>
<p>中国：党中央-中央财经领导小组办公室，各部委，国务院政策研究室，国务院发展研究中心，中国社科院</p>
<p>美国：国家经济事务顾问，总统经济顾问委员会，美联储</p>
<h2 id="3-经济的相互依存性和贸易的好处"><a class="header" href="#3-经济的相互依存性和贸易的好处">3. 经济的相互依存性和贸易的好处</a></h2>
<h3 id="为什么要进行交易"><a class="header" href="#为什么要进行交易">为什么要进行交易</a></h3>
<p><strong>经济学源于生活。</strong></p>
<p><strong>为什么要进行交易</strong>？一个具体的例子：张顺和李逵</p>
<p>李逵擅长砍柴，张顺擅长捕鱼，以前两个人都是半天捕鱼，半天砍柴，自给自足，每天张顺获得 5 斤鱼，12.5 斤柴，李逵获得 2.5 斤鱼，25 斤柴。</p>
<p><img src="life-and-thinking/keep-learning/assets/1585708193682.png" alt="初始的生产可能性边界" /></p>
<p>后来两人合作，一人负责打鱼，一人负责砍柴，然后分别拿半天的收益相互交换：</p>
<p><img src="life-and-thinking/keep-learning/assets/1585708426738.png" alt="交易后的结果" /></p>
<p>最后每个人获取到的结果是：张顺获得的鱼没变，柴翻倍，李逵获得的柴没变，鱼翻倍。两个人都过上了更幸福的生活。</p>
<p><strong>每个人都生产自己最擅长的产品，然后进行交易，就会共赢。</strong></p>
<p><strong>人与人交往也是如此，多和人交流，多交易，才能共赢。</strong></p>
<h3 id="比较优势与绝对优势"><a class="header" href="#比较优势与绝对优势">比较优势与绝对优势</a></h3>
<p>如何从理论上解释这种现象？</p>
<p><strong>为了增加总产量，应该让生产该商品机会成本更小的生产者来更多地生产它。专业地人干专业的事。那么经济的总产量就增加了</strong>。</p>
<p><strong>比较优势原理</strong>（机会成本）：每个人各自生产他们具有<strong>比较优势</strong>的产品、然后进行交易，那么 他们的情况都会变好。</p>
<p>度量生产成本差异有两种方法：</p>
<ol>
<li><strong>比较优势</strong>：为了一种产品而放弃另一种产品的<strong>机会成本</strong></li>
<li><strong>绝对优势</strong>：生产单位产品所需要的时间成本（错误的度量方法）</li>
</ol>
<p>绝对优势错在哪里？</p>
<p><img src="life-and-thinking/keep-learning/assets/1585716262683.png" alt="李鬼与李逵" /></p>
<p>李逵一天的产量不管是鱼还是柴的单位时间成本都比李鬼高，但是按照机会成本来算的话，其打鱼的机会成本太高了，还不如向李鬼买鱼划算。相同的例子：</p>
<ul>
<li><strong>教授</strong>打字打得既快又好，但是其打字的机会成本就高于他的秘书</li>
<li><strong>老虎伍兹</strong>打高尔夫球打得很好，修剪草坪也修得很好，但是不如交给邻居家的小孩干</li>
<li>大学的目的就是发现自己的比较优势</li>
</ul>
<p>所以，<strong>比较优势决定了贸易和分工。样样比别人强，样样自己干，从经济学上讲，并不一定是正确的。</strong></p>
<h2 id="4-供给与需求"><a class="header" href="#4-供给与需求">4. 供给与需求</a></h2>
<p>供给与需求是经济学家最常用的两个术语。</p>
<p>买方决定需求；卖方决定供给；买方和卖方共同决定市场结果。</p>
<h3 id="需求-消费者"><a class="header" href="#需求-消费者">需求-消费者</a></h3>
<p><strong>需求定律</strong>：其他条件不变，价格上升导致需求量下降。</p>
<p><strong>消费者收入</strong>：收入增加，对<strong>正常商品</strong>的需求量会增加，对<strong>劣质品</strong>的需求量会减少。</p>
<p><strong>替代品和互补品</strong>：新冠肺炎 ——&gt; 医用口罩需求上升，其互补品的需求都会上升，例如普通口罩，消毒酒精，<strong>裹尸袋</strong>等，用联系的思想看问题。</p>
<h3 id="供给-生产者"><a class="header" href="#供给-生产者">供给-生产者</a></h3>
<p><strong>供给定律</strong>：其他条件不变，价格上升导致供给量增加。（什么赚钱种什么，卖家都是趋利的，也是盲目的）</p>
<h3 id="市场类型"><a class="header" href="#市场类型">市场类型</a></h3>
<ul>
<li>
<p><strong>竞争市场</strong></p>
<p>有<strong>众多</strong>买者和卖者的市场是竞争市场，价格空间比较小，很难操作；价格作为外生变量，不是个人所能操控的，买家和卖家都是<strong>价格接收者 price taker</strong>。</p>
<p>需求量是买者愿意而且能够购买的商品数量。</p>
</li>
<li>
<p><strong>市场类型：垄断</strong></p>
<p>Monopoly</p>
<p>只有<strong>一个</strong>卖者，卖家是价格操控者。</p>
</li>
<li>
<p><strong>市场类型：寡头</strong></p>
<p>Oligopoly</p>
<p>只有<strong>少数几个</strong>卖者。百事可乐与可口可乐；石油出口国。</p>
</li>
</ul>
<h3 id="供给与需求"><a class="header" href="#供给与需求">供给与需求</a></h3>
<ul>
<li>如果石油价格上升是由于供给不足，则一定会引起 GDP 增长下降</li>
<li>如果较高的石油价格反映的是强劲的需求，那么它就是健康的全球增长的结果</li>
</ul>
<p>房价上升了，但是需求依然火爆，这健康吗？不健康，因为中国的房价不是一个市场问题，是一个政治问题！</p>
<h2 id="5-弹性及其应用"><a class="header" href="#5-弹性及其应用">5. 弹性及其应用</a></h2>
<p>弹性用来衡量买者和卖者<strong>对市场环境变化做出反映的程度大小</strong>。</p>
<p><strong>价格变化引起的需求量的变化，更考虑边际</strong>。</p>
<p>给定百分之一的<strong>价格变化</strong>，<strong>需求量变化</strong>的百分数就是需求的价格弹性。</p>
<p>它衡量了一种物品的需求量对该物品价格变化作出反应的程度大小。</p>
<p>需求价格弹性的决定因素，以下的特征<strong>具有较大的价格弹性</strong>:</p>
<ul>
<li>奢侈品</li>
<li>替代品数量越多</li>
<li>市场界定得越狭隘</li>
<li>时间间隔越长</li>
</ul>
<p><strong>价格弹性高</strong>：价格上升，需求大幅降低，总收益下降；</p>
<p><strong>价格弹性低</strong>：价格下降，需求大幅下降，总收益上升。</p>
<p><strong>刚需通常都缺乏弹性</strong>。例如粮食，水电，住房。我卖的专业课资料也是刚需，弹性很小</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何"><a class="header" href="#如何">如何</a></h1>
<p>[TOC]</p>
<h2 id="如何-1"><a class="header" href="#如何-1">如何</a></h2>
<p>记录一些小技巧，保持终身学习</p>
<h2 id="如何保持终身学习"><a class="header" href="#如何保持终身学习">如何保持终身学习</a></h2>
<p>心态 / 态度</p>
<p><strong>Stay hungry，Stay foolish.</strong></p>
<ul>
<li>保持好奇心</li>
<li>保持谦虚</li>
<li>保持批判性思维</li>
</ul>
<p>实践</p>
<ul>
<li>提高<strong>主动获取信息</strong>的能力</li>
<li>锻炼自己<strong>总结信息</strong>的能力</li>
<li>坚持<strong>写作</strong>，提高写作能力</li>
</ul>
<p>身体是革命的本钱，没有好的身体，充足的精力，何谈学习</p>
<h2 id="如何拍照"><a class="header" href="#如何拍照">如何拍照</a></h2>
<p>Closer to the camera = bigger in the photo</p>
<p>越靠近摄像头，越显得大。例如图中男生的胳膊，靠近和远离摄像头，其拍出来的效果完全不一样，制造出景深效果。扬长避短。</p>
<img align="left" src="life-and-thinking/keep-learning/assets/1575768388208.png" alt="Closer and Bigger" style="zoom:67%;" />
<p>拍照技巧</p>
<ul>
<li>与图中的景物保持水平或垂直</li>
</ul>
<h2 id="如何写作"><a class="header" href="#如何写作">如何写作</a></h2>
<ul>
<li>养成写作输出的习惯</li>
<li>不要为赋新词强说愁，要有所思，有所感</li>
<li>像给朋友写信一样，写文章</li>
<li>真诚</li>
</ul>
<h2 id="如何演讲--报告"><a class="header" href="#如何演讲--报告">如何演讲 / 报告</a></h2>
<ul>
<li>想象着在和一个好朋友介绍</li>
<li>做好充足的准备</li>
<li>真诚</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1Jg411T7AX">7年新闻主播的眼神管理法，解救双眼无神，演讲不自信！</a></p>
<p>不要回避眼神交流，不要在心理想着把大家当成傻瓜，要真诚地对待听众。</p>
<p>注意眼神留白，不要一直死盯着一个地方。</p>
<p>心理暗示：你并不是在和一大群人讲话，而是“几个人”。确实，只有少数几个人会认真听我们的演讲报告，眼神和他们互动就好了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="办公-tricks"><a class="header" href="#办公-tricks">办公 tricks</a></h1>
<p>[TOC]</p>
<h2 id="ppt"><a class="header" href="#ppt">PPT</a></h2>
<h3 id="幻灯片母版"><a class="header" href="#幻灯片母版">幻灯片母版</a></h3>
<p>PPT 可以设置通过设置版式来提高制作效率。如果多张幻灯片使用的版式类似，可以将相同的元素抽取为模板，制作版式。</p>
<p>通过 视图 —&gt; 幻灯片母版 切换到幻灯片母版编辑视图，进而编辑母版。</p>
<h3 id="演讲者模式"><a class="header" href="#演讲者模式">演讲者模式</a></h3>
<p>快捷键：Alt + F5</p>
<h3 id="图片编辑"><a class="header" href="#图片编辑">图片编辑</a></h3>
<p>PPT 可以把图片背景扣成透明，给图片换色，真滴强。甚至还能做动画……</p>
<h2 id="windows-powertoys"><a class="header" href="#windows-powertoys">Windows PowerToys</a></h2>
<ul>
<li>Fancy Zones 按 Shift 键拖动窗口实现快速分屏</li>
<li>长按 Windows 键，弹出快捷键指导</li>
</ul>
<h2 id="windows-2"><a class="header" href="#windows-2">Windows</a></h2>
<ul>
<li>Windows + - 方法或缩小屏幕</li>
<li>Windows10 可以在声音中控制每一个 App 的声音</li>
</ul>
<h2 id="写邮件"><a class="header" href="#写邮件">写邮件</a></h2>
<p><a href="https://github.com/hunzaboy/codedmails">codedmails</a>：邮件的 html 模板</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="movies"><a class="header" href="#movies">Movies</a></h1>
<p>[TOC]</p>
<p><a href="https://space.bilibili.com/17819768?spm_id_from=333.338.viewbox_report.7#/">《电影最Top》</a>是我在B站最喜欢的一款节目。能看得出来，发条张是一个真正的用心做视频，而且又有文采的Up主。今天看到了他讲的一期节目：<a href="https://www.bilibili.com/video/av18663010/">《电影最TOP 88: 2017年度十大引进佳片盘点》</a>，有一句话我感触颇深，遂决定在此开篇Blog，写下老张的金句，也算是看完节目的一点收获吧。</p>
<h2 id="todo-2"><a class="header" href="#todo-2">TODO</a></h2>
<ul>
<li>小偷家族</li>
<li>老无所依</li>
<li>倩女幽魂</li>
<li>铁雨</li>
<li>笑傲江湖</li>
</ul>
<h2 id="电影台词"><a class="header" href="#电影台词">电影台词</a></h2>
<blockquote>
<p>最初,没有人在意这场灾难，这不过是一场山火 、一次旱灾、一个物种的灭绝、一座城市的消失。直到这场灾难，和每个人息息相关。 《流浪地球》</p>
</blockquote>
<h2 id="电影最-top"><a class="header" href="#电影最-top">电影最 TOP</a></h2>
<h3 id="嬉皮士文化"><a class="header" href="#嬉皮士文化">嬉皮士文化</a></h3>
<p>阿甘正传 / Beatles / 毒品滥交 / 回归自然 / 婴儿潮 / 1960s</p>
<h3 id="勇往直前"><a class="header" href="#勇往直前">勇往直前</a></h3>
<p><strong>“爷们”这个词不是体现在你说话多大声以及脖子上金链子有多粗，而在于责任、担当和勇气。</strong></p>
<p>出自：<a href="https://www.bilibili.com/video/av18663010/">《电影最TOP 88: 2017年度十大引进佳片盘点》</a></p>
<h3 id="发条橙"><a class="header" href="#发条橙">发条橙</a></h3>
<p>看了老张的解说后，我开始反思自己看电影的品味，一直以来，我只是将电影当作娱乐，还总喜欢看爆米花电影。但是老张在看完发条橙后能有如此深刻的感悟，而且能够写出质量极高的文案，这点醒了我，点醒了一个一直躺在自己的舒适区，不去拓展自己的懒人。</p>
<p>老张的解说让我想起了<strong>斯科特派克</strong>在《少有人走的路》中说的人性的矛盾。世界上有多大的善，就有多大的恶，在矛盾中保持平衡。我们需要做的，是接受自己人性丑恶的一面，例如懒惰、自大，在成长中不断反省自己的原罪，将生命视为自己的责任，努力满足生命的需要。</p>
<p>出自 <a href="https://www.bilibili.com/video/av20467279/">电影最TOP 91: 神一般的大师级导演，库布里克电影生涯全盘点</a></p>
<h3 id="恐怖游轮"><a class="header" href="#恐怖游轮">恐怖游轮</a></h3>
<blockquote>
<p>活着，带着世界赋予我们的裂缝去生活。用残损的手掌抚平彼此的创伤，固执地走向幸福。人只要竭尽全力就应该是幸福的，拥抱当下的光明，不寄希望于空渺的乌托邦，振奋昂扬，因为生存本身，就是对荒谬最有力的反抗。——《西西弗斯的神话》</p>
</blockquote>
<p>出自 <a href="https://www.bilibili.com/video/av44837943">细读经典 65: 这部烧脑神作讲了个永远也无法结束的故事《恐怖游轮》</a></p>
<h3 id="小偷家族"><a class="header" href="#小偷家族">小偷家族</a></h3>
<p>看是枝裕和的电影是一种很奇妙的体验，他可以把那些言语无法形容的感觉拍出来，就像看一幅又像日出又像日落的油画，里面有希望也有哀婉，真实的生活，本来就是如此的模棱两可吧。</p>
<h3 id="星际穿越"><a class="header" href="#星际穿越">星际穿越</a></h3>
<p>不要温驯的走进那良夜，老年应当在日暮时老来少咆哮，咆哮吧咆哮，痛斥那光的退缩，智者在临终的时候对黑暗妥协，因为他们的语言已黯然失色，不要温驯的走进那良夜。——Dylan Thomas</p>
<h3 id="贝利叶一家"><a class="header" href="#贝利叶一家">贝利叶一家</a></h3>
<p>梅开方泣别，子欲去远游。孩子总要长大，在另一个枝桠上组成另一个家庭开枝散叶，声明的历程永远包含着欢欣与离别，就像宝拉在歌里唱的：我不是要逃离，我只是去飞翔。</p>
<p>最近因为找工作的事情，情绪不稳定，对我妈发脾气，我自己挺后悔的。</p>
<h3 id="一一"><a class="header" href="#一一">一一</a></h3>
<p>杨德昌：程序员出身。</p>
<h3 id="赵本山"><a class="header" href="#赵本山">赵本山</a></h3>
<p>从小孤儿，跟着瞎子叔叔卖艺。</p>
<p>百善孝为先，论心不论事，论事贫家无孝子。</p>
<p>万恶淫为首，论事不论心，论心终古少完人。</p>
<h3 id="职场"><a class="header" href="#职场">职场</a></h3>
<p>凭良心做事的人，运气都不会太差。</p>
<p>癞蛤蟆爬脚背，不咬人膈应人。</p>
<p>Follow your heart.</p>
<h2 id="电影配音"><a class="header" href="#电影配音">电影配音</a></h2>
<ul>
<li>
<p>西方</p>
<ul>
<li>
<p>约翰-威廉姆斯</p>
<p>大白鲨、星球大战、辛德勒名单、哈利波特配音（乔治-卢卡斯，斯皮尔伯格 合作）</p>
</li>
<li>
<p>埃尼奥-莫里康内</p>
<p>荒野大镖客配音（意大利，莱翁内小学同学，两人一起合作）</p>
</li>
<li>
<p>詹姆斯-霍纳</p>
<p>燃情岁月，勇敢的心，泰坦尼克号，阿凡达，美丽心灵</p>
</li>
<li>
<p>汉斯季莫</p>
<p>狮子王，末路狂花，勇闯夺命岛，加勒比海盗，星际穿越（克里斯托福-诺兰）</p>
</li>
</ul>
</li>
<li>
<p>香港：胡伟立</p>
<p>香港电影配乐大师，偷工、唐伯虎点秋香、醉拳（周星驰）</p>
</li>
<li>
<p>香港：黄霑</p>
<p>我的中国心，上海滩，倩女幽魂，沧海一声笑，黄飞鸿，梁祝（划船不用桨、一生全靠浪）（徐克）</p>
</li>
<li>
<p>内地大师：赵季平</p>
<p>黄土地，红高粱，活着，霸王别姬，大话西游，水浒传，乔家大院</p>
</li>
<li>
<p>日本：久石让</p>
<p>（宫崎骏，北野武）Summer，菊次郎的夏天，太阳照常升起</p>
</li>
<li>
<p>日本：坂本龙一</p>
<p>末代皇帝（贝托鲁尼）</p>
</li>
</ul>
<h2 id="演员"><a class="header" href="#演员">演员</a></h2>
<ul>
<li>梁朝伟和周星驰都是出身单亲家庭</li>
</ul>
<h2 id="todo-3"><a class="header" href="#todo-3">todo</a></h2>
<ul>
<li>马大帅</li>
<li>大事件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="每日新闻"><a class="header" href="#每日新闻">每日新闻</a></h1>
<h2 id="2021-11-22"><a class="header" href="#2021-11-22">2021-11-22</a></h2>
<ul>
<li>联发科最近发布天玑 9000，性能超过骁龙 888，红米K50 将搭载此款芯片</li>
</ul>
<h2 id="2021-11-27"><a class="header" href="#2021-11-27">2021-11-27</a></h2>
<ul>
<li>最近宁波工程学院黑人外教杀人事件审理结果出来了，女方倒贴 50 多岁的黑鬼，国男对国女还有信任吗</li>
</ul>
<h2 id="2021-11-29"><a class="header" href="#2021-11-29">2021-11-29</a></h2>
<ul>
<li>jetbrain 发布下一代轻量 IDE Fleet</li>
</ul>
<h2 id="2021-12-03"><a class="header" href="#2021-12-03">2021-12-03</a></h2>
<ul>
<li>中国有 8500 万残疾人</li>
</ul>
<h2 id="2021-12-06"><a class="header" href="#2021-12-06">2021-12-06</a></h2>
<ul>
<li>央行降准，银行有钱放贷了</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="为什么要设立这个栏目"><a class="header" href="#为什么要设立这个栏目">为什么要设立这个栏目</a></h1>
<p>为了能够静下心来。全神贯注来工作,清虚心静过生活。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="王德峰-中西文化差异"><a class="header" href="#王德峰-中西文化差异">王德峰-中西文化差异</a></h1>
<p><a href="https://www.bilibili.com/video/BV1E741117Br">复旦哲学王子：上课吸烟谈“觉悟”</a></p>
<ul>
<li>
<p>当今社会的两大问题：</p>
<ul>
<li>没有任何一个阶层，有幸福感，民族没有<strong>精神家园</strong></li>
<li>社会处于解体边缘：普遍的信任危机，利己主义</li>
</ul>
</li>
<li>
<p>文化入侵</p>
</li>
<li>
<p><strong>法的理性</strong>不会成为一个民族的价值基础</p>
</li>
<li>
<p>当前政府正在做的事情：重组政府与市场的关系</p>
</li>
<li>
<p>日本的大和民族没有吸收法家思想的原因：无法无为而治，<strong>环境太险恶</strong>，没法退一步海阔天空，所以很<strong>严谨</strong>，<strong>缺乏幽默感</strong></p>
</li>
<li>
<p>文明区主要靠宗教来划分</p>
</li>
<li>
<p>中华文明<strong>无宗教</strong>，中国人学不成西方的根源在于：<strong>汉语</strong>，<strong>缘分</strong>一词同时包含偶然性和必然性，西文就无法翻译</p>
</li>
<li>
<p><strong>金刚经</strong>，<strong>三句义</strong>：<strong>世界，非世界，是名世界</strong>。世界不是实体的，佛教的共识：缘起性空。<strong>事物不是实体</strong>，因缘而起，不是永恒的，都在走向灭亡，缘起：事物<strong>因缘而起</strong>，性空：事物最终会最走向灭亡。</p>
<p><strong>恋爱观</strong>：因缘而起，是夫妻，非夫妻，是为夫妻。而非柏拉图式的恋爱观：每个人带着一个实体，一个期望来衡量对方，是错误的。实体本不存在，谁都不是天生的妻子或丈夫，丈夫是妻子成就的，妻子是丈夫成就的，<strong>因缘而起</strong>。分手：缘已至此。</p>
<p>应无所住（执着），而生其心。</p>
<p>元明时期，<strong>儒佛道合流</strong></p>
</li>
<li>
<p>Religion 宗教：重建人与神之间的契约</p>
</li>
<li>
<p>人与自然的关系</p>
<ul>
<li><strong>苏格拉底</strong>的学生：<strong>柏拉图</strong>，现实世界的缺陷都来自于其和<strong>理念</strong>之间的差距，所以要<strong>改造世界</strong>，<strong>以彼岸的标准来改造此岸</strong>，<strong>柏拉图主义</strong>。</li>
<li>中华民族的思想：<strong>天人合一</strong>，不改造世界</li>
</ul>
<p><strong>吃饭</strong>：外国人吃饭，用刀叉，解剖分析，<strong>主体消灭客体</strong>；中国人吃饭，用<strong>筷子</strong>，是<strong>艺术</strong>，用<strong>筷子的艺术活动完成了一次天人合一</strong>。</p>
<p><strong>核能与太阳能</strong>：不能利用<strong>核能</strong>，这是改造世界的产物，蕴含着巨大的危险，而应该使用<strong>太阳能</strong>。</p>
</li>
<li>
<p><strong>佛教</strong>，佛教实际上是<strong>无神论</strong>的，<strong>菩萨是人</strong>，是<strong>觉悟者</strong>，<strong>众生是佛，佛是众生</strong>。<strong>下下人有上上智</strong>。</p>
<p><strong>放下屠刀，立地成佛</strong>。中国人都在佛学思想里，都潜移默化地被儒佛道影响。</p>
</li>
<li>
<p><strong>儒家</strong>：大学之道，在明明德，在亲民，在止于至善。从人民中来，到人民中去。</p>
</li>
<li>
<p><strong>智慧从烦恼中来</strong>，世界没有烦恼，还谈什么智慧？<strong>烦恼是用来修行的</strong>。</p>
<p>一个美女从面前走过，不动心，那是假的，佛也动心，因为佛就是众生，<strong>率性</strong>而为。</p>
</li>
<li>
<p><strong>真理，不是逻辑的真理，是生命情感的境界。</strong></p>
<p><strong>中庸</strong>第一段：<strong>天命之谓性，率性之谓道，修道之谓教。道也者，不可须臾离也，可离非道也。是故君子戒慎乎其所专不睹，恐惧乎其所不闻。莫见乎隐，莫显乎微，故君子慎其独也。喜怒哀乐之未发谓之中，发而皆属中节谓之和。中也者，天下之大本也；和也者，天下之达道也。致中和，天地位焉，万物育焉。</strong> </p>
<p><strong>君子和而不同，小人同而不和</strong>。</p>
<p>中国无宗教，但是中国有哲学，是升华人生情感的哲学。</p>
<p>诗经，一言以蔽之，<strong>思无邪</strong>。（无邪：诚，<strong>性情之正</strong>）我们无时无刻都在情感之中。</p>
</li>
<li>
<p><strong>如何判断自己是否读懂了中国经典：心生喜悦，流泪，如人饮水，冷暖自知</strong>。莫听川林打叶声，何妨吟啸且徐行。</p>
</li>
<li>
<p>国外的哲学注重<strong>理性思考和推理</strong>，锻炼头脑，<strong>中国的哲学滋养人们的心灵</strong>。</p>
</li>
<li>
<p><strong>小孩子的教育：背经典</strong>。<strong>小和尚念经，有口无心</strong>。</p>
</li>
<li>
<p><strong>道家</strong>：<strong>反者道之动 弱者道之用。天下万物生于有 有生于无</strong>。（我的理解：光明孕育自黑暗，正反不是对立的，是相互融合，相互作用的。太极图。）</p>
<p><strong>反向思考。</strong></p>
<p><strong>任何事物都必将走向其反面</strong>。（熵论）</p>
<p>资本主义如果想要长久，就必须包含其对立面：社会主义；</p>
<p>学业要成功，必须包含对立面：困难；</p>
<p>要打倒敌人的最好方法：捧杀，欲擒故纵，美人计。（君主论简直小儿科）</p>
<p>困难是我们的恩人，敌人是我们的老师。<strong>祸兮福之所倚，福兮祸之所伏</strong>。</p>
<p>爱情一定走向自己的反面：婚姻（<strong>亲情，恩爱</strong>）。</p>
</li>
<li>
<p>儒家和道家的区别：儒家教我们善恶观，道家教我们如何过得自由一点</p>
</li>
<li>
<p><strong>五伦的最高价值，人生价值的完美</strong></p>
<ul>
<li>君臣：君臣有义（忠于国家）</li>
<li>父子：父子有亲（双向）</li>
<li>夫妇：夫妇有别（共命运，各司其职，男女平等太抽象，女权是伪概念。西方只懂得 I love you，是主体面对客体，象征着一种权利，中国人表达爱情：你这个<strong>冤家</strong>，你这个杀千刀的。<strong>爱情的真相</strong>：<strong>舍不得离开你，又恨你，两者相互成就</strong>。 西方的柏拉图式爱情，不接地气。表白，不能说，I love you，应该适当表达好感，然后征求对方同意，提现交互性）</li>
<li>兄弟：长幼有序</li>
<li>朋友：朋友有信</li>
</ul>
</li>
<li>
<p>西方人生价值的完美：<strong>马斯洛金字塔</strong></p>
<p>从低到高：生理需求，安全需求，爱与归属的需求，尊重的需求，自我实现的需求。</p>
<p>**实现了自我价值后，离开五伦，会有幸福感吗？**富贵不还乡，如衣锦夜行？</p>
</li>
<li>
<p>中国古文化有别于古代帝王专制的意识形态，取其精华，去其糟粕。</p>
</li>
<li>
<p>儒佛道现代化</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="王德峰-阳明心学"><a class="header" href="#王德峰-阳明心学">王德峰-阳明心学</a></h1>
<p>[TOC]</p>
<p>https://www.bilibili.com/video/BV1YB4y1F7d5</p>
<h2 id="当代中国现状"><a class="header" href="#当代中国现状">当代中国现状</a></h2>
<ul>
<li>
<p><strong>富贵不能乐业，贫穷难耐凄凉</strong></p>
<p>出自《红楼梦》曹雪芹对贾宝玉的判词</p>
<pre><code>我信你是因为我信我自己，
随着家庭本位社会的解体，
我们进入了个人主义社会。

但个人主义却没有精神基础，
最终沦为物欲的个人，
个人实现物欲需要彼此帮助，
逐渐形成了熟人社会。

贫贱难耐凄凉，
富贵不能乐业，
左也不安右也不安，
人生不能树立信念，
只有那个明确的功利目标，
偷换人生目标的功利目标。

这就是当代的社会现状！
</code></pre>
</li>
<li>
<p>我们下一代最缺失的，不是知识，不是机巧，不是运用逻辑和符号的能力，而是缺乏人生的基本信念</p>
</li>
<li>
<p>我们追求卓越，缺失去了灵魂的卓越</p>
</li>
<li>
<p>阳明心学的现实意义：白领阶层焦虑，根本问题在心，需要改变人生态度。</p>
</li>
</ul>
<h2 id="是什么--为什么"><a class="header" href="#是什么--为什么">是什么 / 为什么</a></h2>
<ul>
<li>
<p>王阳明的著作：《传习录》</p>
</li>
<li>
<p>中国哲学的主题：人如何安排好自己这个最难安排的生命</p>
</li>
<li>
<p>王阳明心学是中国哲学最高成果，中国哲学本质上是人生哲学，因此王阳明心学是人生哲学最高成果</p>
</li>
<li>
<p>孟子：人生总是有所求。求有两种：</p>
<ul>
<li>求则得之，舍则失之，是求有益于得也，求在我者也</li>
<li>求之有道，得之有命，是求无益于得也，求在外者也</li>
</ul>
</li>
<li>
<p>破山中贼易，破心中贼难</p>
</li>
<li>
<p>不仁者，不可以久处约，不可以长处乐；贫贱难耐凄凉、富贵不能乐业，左也不安，右也不安</p>
</li>
<li>
<p>心为什么不能安顿：人有无限心</p>
</li>
<li>
<p>无限心是什么？人无时无刻不在筹划着未来。烦恼从此中出，精彩也从此中出。无限心无法在现实世界安顿，因为事物总会走向灭亡。所以只能出世才能安顿无限心。</p>
</li>
</ul>
<h2 id="怎么做"><a class="header" href="#怎么做">怎么做</a></h2>
<p>先出世，后入世，以出世的精神，做入世的事情</p>
<h3 id="三大哲学"><a class="header" href="#三大哲学">三大哲学</a></h3>
<ul>
<li>中国哲学：人生问题（儒道佛三家合流 —&gt; 阳明心学）</li>
<li>欧洲哲学：知识问题</li>
<li>印度哲学：</li>
</ul>
<h3 id="出世入世"><a class="header" href="#出世入世">出世入世</a></h3>
<h4 id="儒家"><a class="header" href="#儒家">儒家</a></h4>
<p>核心：仁。</p>
<p>儒家：无所为而为</p>
<p>有所为而为，做事情有目的。无所为而为，我们并不把我们当前所作的事情当作达成另一件事的手段，而是因为其本应当做（学习 -&gt; 格物致知），我们做种种的事情是因为其本应当作。</p>
<p>从仁学走向心学，是孟子，孟子是中国哲学心学的开创者。</p>
<h4 id="道家"><a class="header" href="#道家">道家</a></h4>
<p>道家：无为而无不为</p>
<p>无为是指不人为的做事。做减法。</p>
<ul>
<li>
<p>天人合一</p>
<p>儒道的共识。儒家的重点在人，道家的重点在天。</p>
<p>道家，做减法。为道日损，损之又损。生非贵之所能存，身非爱之所能厚；生亦非贱之所能夭，身亦非轻之所能薄</p>
</li>
<li>
<p>道可道，非常道</p>
<p>道不可言说，道可以说出来，但说出来就不是道了</p>
<p>了解天道唯一的方法：减去人为的东西</p>
<p>读《道德经》，学会如何做减法</p>
<p>做事情，不要添加人为的东西，不要增加太多欲望和期待</p>
</li>
<li>
<p>生有涯而知无涯，以有涯随无涯，殆己 —&gt; 谦卑</p>
</li>
</ul>
<h4 id="佛家"><a class="header" href="#佛家">佛家</a></h4>
<p>佛家：无心而为</p>
<p>每个人来到这个世上都带着业力来的，要做事来消业。举例：毛泽东。</p>
<p>除心不除事。</p>
<p>我终日吃饭，未曾咬住一粒米；我终日穿衣，未曾挂住一缕棉絮</p>
<h3 id="心学"><a class="header" href="#心学">心学</a></h3>
<h4 id="是什么-5"><a class="header" href="#是什么-5">是什么</a></h4>
<p>心学源于孟子。</p>
<ul>
<li>
<p>荀子-性恶论：人是生物，有求生自保的本能，竞争生存资源，遵守道德是为了让竞争控制在合适的范围内。</p>
</li>
<li>
<p>孟子-性善论：恻隐之心(仁之端) 羞恶之心 辞让之心 是非之心，四个善端</p>
</li>
</ul>
<p>最后荀子获胜，提倡以礼治国。</p>
<p>心的翻译：Gemiit(德文)，英文无法翻译。</p>
<p>论证心的存在：必生怵惕恻隐之心。人与人之间有形骸间隔，又有仁心感通，一体之仁。</p>
<p>吾心便是宇宙，宇宙即是吾心。— 陆九渊</p>
<p>天地之大德日生。</p>
<p>反驳达尔文的理论：1. 适者生存，越高级的生物，对环境的适应能力越差，越低级的生物，对环境的适应能力越强 2. 进化是能量不断积聚的过程，与热力学第二定律的熵增相悖。（这个我不赞同，老师外行了，哈哈哈哈）</p>
<p>良知即是天理。良知乃是天理昭明灵觉处，故良知即是天理。— 王阳明</p>
<p>心学第一命题：心即是理。（第一定律）</p>
<p>万物皆备于我矣。反身而诚，乐莫大焉。强恕而行，求仁莫近焉。— 孟子</p>
<p>学问之道无他，求其放心而已。— 孟子</p>
<p>乡愿，德之贼也。— 孔子</p>
<p>乡愿人格：遵守道德是为了谋求利益，不是出于内心的自觉。</p>
<p>王阳明临走之前留下八字：此心光明，亦复何言。</p>
<p>王阳明墓在绍兴。</p>
<h4 id="心学-禅宗"><a class="header" href="#心学-禅宗">心学-禅宗</a></h4>
<p>禅宗五祖：弘忍法师</p>
<p>禅宗六祖：慧能法师</p>
<p>孟子心学的淹没 —&gt; 禅宗 —&gt; 阳明心学</p>
<p>佛学中国化的最高成果：禅宗。禅宗就是心学，用佛家的语言说心学。</p>
<p>禅宗的宗旨：教外别传，不立文字，直指人心，见性成佛</p>
<p>佛学所求：涅槃</p>
<p>不睹众相，常观金体。不是看不到相，而是不为相所惑。不住相，不着相。</p>
<p>金刚经八字：应无所住(住相)，而生其心。佛金浩如烟海，读不胜读，一本金刚金足矣。</p>
<p>佛法在世间，不离世间觉，离世觅菩提，恰如求兔角。— 六祖慧能大师</p>
<p>智慧从烦恼中来。不要拒绝烦恼。烦恼是波浪，水还是水。</p>
<p>下下人有上上智, 上上人有没意智。</p>
<p>五蕴 —&gt; 破 应无所住，而生其心</p>
<ul>
<li>色 五官接触外部事物</li>
<li>受 感受，感觉</li>
<li>想 欲望</li>
<li>行 行动</li>
<li>识 辨别、区分</li>
</ul>
<p>佛心：人生不朽之价值的总和</p>
<p>爱情归入佛门：</p>
<pre><code>《班扎古鲁白玛的沉默》
作者：扎西拉姆·多多
你见，或者不见我
我就在那里
不悲不喜
你念，或者不念我
情就在那里
不来不去
你爱，或者不爱我
爱就在那里
不增不减
你跟，或者不跟我
我的手就在你手里
不舍不弃
来我的怀里
或者
让我住进你的心里
默然 相爱
寂静 欢喜
</code></pre>
<p>身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。  两个错误：讲烦恼与心对立；将修行当作是对烦恼的拒绝，将众生的烦恼拒之门外（小乘佛教），住净相。大智慧就是大悲悯。l</p>
<p>根器(慧根)能否测量？不能测量，但是能判断。智慧就是悲悯。智慧从烦恼中来。</p>
<p>空：出世；空空：入世。</p>
<p>何期自性，本自清净；何期自性，本不生灭；何期自性，本自具足；何期自性，本无动摇；何期自性，能生万法。</p>
<p>即心即佛。</p>
<p>功德与福德。见性是功，平等是德。众生平等，人皆有佛心。众生是佛。</p>
<h4 id="阳明心学"><a class="header" href="#阳明心学">阳明心学</a></h4>
<ul>
<li>
<p>心即是理，心外没有理（扪心自问，问心无愧）</p>
</li>
<li>
<p>《大学》，初学入德之门</p>
<p>大学之道，在明明德，在亲民，在止于至善</p>
<p>格物致知，诚意正心，修身齐家治国平天下</p>
</li>
<li>
<p>龙场悟道：自性具足，心外无物。良知是天理之昭明灵觉处，故良知即是天理。</p>
</li>
<li>
<p>良知：生命情感本身的存在。良知是天理之昭明灵觉处，故良知即是天理</p>
</li>
<li>
<p>头脑和心的区别举例：失恋。此情无计可消除，才下眉头，却上心头。我们不可能用逻辑推理把生命情感消解掉。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命运与修行"><a class="header" href="#命运与修行">命运与修行</a></h1>
<p>王德峰 - 开启中国古典哲学的大门 - 命运与修行</p>
<p>[TOC]</p>
<h2 id="命运与修行-1"><a class="header" href="#命运与修行-1">命运与修行</a></h2>
<p>资本技术的基本特征：进步强势。资本不增殖，就会死亡。</p>
<p>人生被进步强势的资本所裹挟，不进则退。</p>
<p>时间就是金钱，效率就是生命？时间是金钱买不来的。</p>
<p>我们人生成败的标准，是被外部植入了，而不是发自本心的。</p>
<p>中国有 2.9 亿农民工，每个人都应该自得其所。</p>
<p>富贵不能乐业，贫贱难耐凄凉。</p>
<p>读书为了什么？富贵？为什么要考一个好的初中，为什么要考一个好的高中，为什么要考一个好的大学，为什么要考研？为什么你到现在还是不快乐？</p>
<p>能被掌握的，算是命运吗？哪些是命，哪些不是命？命：出身，性格，健康，职业，配偶，女子。</p>
<p>要低调。</p>
<p>孔子：不知命，无以为君子。富贵不能淫，贫贱不能移，威武不能屈。</p>
<p>乐从何来，活着是为了什么？学习是快乐的。</p>
<p>孟子：求则得之，舍则失之，是求有益于得也，求在我者也；求之有道，得之有命，是求无异于得也，求在外者也。</p>
<h2 id="不知水"><a class="header" href="#不知水">🐟不知水</a></h2>
<p>🐟在水里，他可以知道水中任何东西，唯独不知道水。想要鱼知道水，只有一种办法，把它从水里捞出来。</p>
<p>我们活着，我们都存在，我们怎么说得出存在呢？</p>
<p>加入世界上只有一种颜色叫红颜色，我们会知道红颜色吗？我们要知道红颜色的前提，是要有绯红的颜色，把它比较出来，我们本来就在存在中，我们怎么可能知道存在呢？</p>
<p>我们要知道存在，需要知道非存在，就是虚无，但是进入虚无，生命就没了。</p>
<p>人有余事，人活着，居然知道自己终有一死，知道自己终有一天进入虚无。 不是我们的智力让我们与动物有区别，而是我们对存在的认知。</p>
<blockquote>
<p>只有经历痛苦，才知道真正的快乐。</p>
</blockquote>
<h2 id="中国智慧与当代人生"><a class="header" href="#中国智慧与当代人生">中国智慧与当代人生</a></h2>
<p>时间就是金钱，效率就是生命？</p>
<p>疫情后的反思：缺少两个敬，敬畏天道，敬重人心。</p>
<p>我们长久得不敬畏人心，把人当作工具看，包括把自己也当工具看，任何一个人，哪怕其社会地位极其卑微，下下人有上上智，我们仍然要敬重他。</p>
<p>中庸：天命之谓性，率性之谓道，修道之谓教。道也者，不可须臾离也，可离非道也。是故君子戒慎乎其所专不睹，恐惧乎其所不闻。莫见乎隐，莫显乎微，故君子慎其独也。喜怒哀乐之未发谓之中，发而皆属中节谓之和。中也者，天下之大本也；和也者，天下之达道也。致中和，天地位焉，万物育焉。</p>
<p>喜怒哀乐，这就是人生。</p>
<p>天下之大本在于我们的生命情感。</p>
<p>人生的每一个细节，都有天道灌在其中。</p>
<p>中国哲学，讨论的是生命情感，是升华人生情感的哲学。</p>
<h2 id="我们为什么要学哲学"><a class="header" href="#我们为什么要学哲学">我们为什么要学哲学</a></h2>
<p>胡塞尔，布拉格演讲 欧洲科学的危机和先验现象学
现代人，让自己的整个世界观，受到实证科学的支配，并且迷惑于实证科学所造就的繁荣，这种独特的现象意味着，现代人漫不经心地抹去了，那些对于真正的人来说，至关重要的问题，只见事实的科学，造就了只见事实的人。</p>
<p>哪些问题
康德：纯粹理性批判</p>
<ul>
<li>我们能够知道什么（有限的存在能够知道什么）</li>
<li>我们应当做什么</li>
<li>我们能够希望什么（未来）</li>
<li>人是什么</li>
</ul>
<p>我们从一个物质上普遍不满足的时代，进入一个精神上普遍不安宁的时代。</p>
<p>我们用理性对存在所构成的知识，是否能够从中推出，我们应当做什么的价值呢</p>
<p>尼采：我们从事物中发现的东西，其实是我们预先塞到事物中去的。塞进去叫艺术和宗教，重新把它领出来的是科学。（科学也是有先验的）</p>
<p>人心开两扇门：生灭门（经验知识，有限心），真如门（如其所示，如其本来，无限的不生不灭的本质真相，无限心，🐟不知水）
无家可归</p>
<p>人心如何安顿，科学无法让人安心立命</p>
<p>既出世，又入世，把理想主义和现实主义统一</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一个男生怎么样才算是正在成熟了"><a class="header" href="#一个男生怎么样才算是正在成熟了"><a href="https://www.zhihu.com/question/431134549/answer/1711330681">一个男生怎么样才算是正在成熟了？</a></a></h1>
<p><strong>1、在与自己为敌的路上</strong></p>
<p>他慢慢开始知道人无高低之分，他不再喜欢与他人竞争，因为他知道自己赢了一个对手之后还有更强的对手，一辈子都赢不完。</p>
<p>于是他把所有人都看作自己的朋友，把他们当作帮助自己与自己竞争的伙伴，和那个理想中的自我比较，不断的超越自我。</p>
<blockquote>
<p>就这一条就值得你点个赞</p>
</blockquote>
<p><strong>2、活在当下</strong></p>
<p>他慢慢开始知道现在是他唯一拥有的东西，没必要为了未来的自己放弃了当下，他知道当下的自己不是为了实现未来的工具，他知道奖励自己，也知道安慰自己</p>
<p>“世界那么大，你现在就可以去看看。”</p>
<blockquote>
<p>当你急着奔向未来的时候，说明你已经不喜欢现在了。——《禅与摩托车维修艺术》</p>
</blockquote>
<p><strong>3、活在裆下</strong></p>
<p>他慢慢开始正视“爱”与“性”你认识到这两个东西是不可分割的存在，又意识到这两个东西是平等的存在，他开始学会用“爱”克制“性”而不是让“性”遮蔽自己的双眼</p>
<p><strong>4、由内而外的自信</strong></p>
<p>他不再讨论过去的事情，用过去的辉煌来作为当下的困难的盾牌，他开始正视自己的自卑，开始接受自己做不到一些事情的事实，并尝试去改变。</p>
<p>不再为自己的无能找借口，不再羡慕高学历的人，认为自己有学历一样能成功，不再羡慕有钱的家庭，不在有认为我有这样的家庭也能成功这样的心态</p>
<p>他开始由内而外的去掉自己的自负，正视自己的自卑，开始一步步走向自信</p>
<p><strong>5、由内而外的自尊</strong></p>
<p>他开始慢慢懂得，讨好不是爱的方式，爱是平等的尊重而不是低价值的讨好，更不是逾越于他人之上的控制</p>
<p>他知道，<strong>我值得被爱，我值得拥有归属感，我有勇气全心全意的去爱</strong></p>
<p><strong>6、懂得谦虚</strong></p>
<p>他开始慢慢懂得谦虚是让自己利益最大化的品质，他知道除了真正为他的好事高兴的人以外的人都在嫉妒和厌恶</p>
<p>他不喜不悲，平和的去对待一件好事，一件坏事，他知道总有人不喜欢你为你的好事嫉妒，他知道总有人喜欢你为你的好事高兴，他知道总有人被骄傲冲昏头脑，他知道山外大有人在</p>
<p><strong>7、变成一个慢热的人</strong></p>
<p>他开始慢慢知道过早袒露出真心会被别有用心的人伤害，暴露自己的伤口会被撒盐，所以他变成一个慢热的人</p>
<p>他知道慢热才能看清楚一个人，才能让交付的心不被伤害，才能让别人缝补你的伤口</p>
<p><strong>8、拿得起放得下，有一颗「<a href="https://www.zhihu.com/search?q=%E5%B9%B3%E5%B8%B8%E5%BF%83&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1711330681%7D">平常心</a>」</strong></p>
<p><img src="life-and-thinking/peace/assets/v2-d5365ce2bd4fca49ac488e5a52ea8527_720w.jpg" alt="img" /></p>
<p>他开始慢慢知道，世事无常，有些人注定要分离，所以他学会了珍惜当下</p>
<blockquote>
<p>人生就是这样
有时会很痛苦
但到了最后
一切都很值得
爱是最好的礼物</p>
</blockquote>
<p><strong>9、做事有自己的原则和底线</strong></p>
<blockquote>
<p>即使再愤怒，也不会动手
即使再爱对方，被背叛之后也会立即止损
即使利益再大，也不愿意违法</p>
</blockquote>
<p><strong>10、做事不触碰别人的原则和底线</strong></p>
<p>他知道，不触碰别人的原则和底线是最基本的尊重，相互尊重才是一切关系的基础</p>
<p>逾越别人的底线等于把一个人彻底踩在脚下一般不尊重</p>
<p><strong>11、懂得感恩</strong></p>
<p>他知道感恩是很重要的品质，只有感恩才会让别人愿意重复帮助你</p>
<p>他知道感恩要从现在开始，比如看见一篇优质的回答就会点赞，答主才会有动力创作出更好的文章</p>
<p><strong>12、变得温柔</strong></p>
<blockquote>
<p>拿到外卖小哥送来的外卖，会轻轻的关上门，而不是随手一丢
在公共场合出门会面向有人的一面关门
在饭局上别人抬手夹菜会帮对方扶住袖口</p>
</blockquote>
<p><strong>13、开始培养自己的品味</strong></p>
<p>他开始打理自己的形象，学习穿搭，培养自己的审美品味，变成一个用心生活的人，用心的对待每一件事，他知道自己的生活态度开始变化的同时，自己也会飞速成长起来</p>
<p><strong>14、有更多的自我意识</strong></p>
<p>他慢慢开始知道，自己的情绪不解决，自己永远无法解决问题，遇到问题会先解决自己的情绪，立刻开始行动</p>
<p>他开始拥有更多的自我意识，能够察觉到自己的情绪，不再敏感大条，不会因为外界的因素导致自己的情绪变化，不再因为别人的目光所贬低自己</p>
<p><strong>15、会调节自己的节奏</strong></p>
<p>他知道，生活有生活的节奏，爱情有爱情的节奏，友情有友情的节奏，学习有学习的节奏，但他不再跟着别人的节奏，他知道他要主导这些节奏</p>
<p>生活在自己的节奏里，当爱情的节奏快了，他会主动调整自己的节奏，而不是等待对方调整节奏，比如迈入婚姻的，可能对方没准备好，他慢下来，调整节奏</p>
<p>他知道这样的生活才会有幸福感</p>
<p><strong>16、有共情能力</strong></p>
<p>他知道，一个人是否受人欢迎，是否能拉近与别人的距离，就在于共情能力的好坏</p>
<p>如果一个人连共情都学不会，那一定是情商低的典范，因为这种人往往以自我为中心</p>
<blockquote>
<p>你被分手了一个朋友带着你去酒吧喝酒
另一个朋友陪着你一起难过</p>
</blockquote>
<blockquote>
<p>你看《泰坦尼克号》看到潸然泪下
陪你看的朋友说这个片段好垃圾</p>
</blockquote>
<p>他开始懂得，什么是共情</p>
<p><strong>17、具有决断力</strong></p>
<p><strong>他知道及时止损是什么意思</strong></p>
<p>他知道那些连自己亲密关系中的爱人都可以背叛的人不值得他继续付出，他会一脚踹开不值得原谅的人，会拒绝不值得原谅的人的道歉</p>
<p>他知道赌博的投入不会让他损失的钱重新回到自己的口袋，他不会为赌博时脑子一热的的自己买单，他会当即立断的退出</p>
<p><strong>18、会独立思考</strong></p>
<p>他知道公众的舆论是一把刀子，会插进当事人的胸口，在事情反转之后的自己会把刀子拔出来插向自己</p>
<p>他会自己思考事情的来龙去脉而不是人云亦云，在没有更多证据线索之前不会妄下定论，在自己没有能力辨认事实之前不会跟随舆论伤害当事人</p>
<p>他知道，只有自己思考，才能活成他自己</p>
<p><strong>19、变得自律</strong></p>
<p>他知道自己的目标是什么，知道自己的理想在哪，知道自己如何得到</p>
<p>他知道今天晚上几点跟手机分开，知道今天晚上几点入睡每天几点起来，知道今天的计划有没有完成，知道今天过得怎样，知道明天要做些什么</p>
<p>他知道自律不是束缚，自律是自由，他做着自己热爱的事情而不是逼迫自己“坚持”</p>
<p><strong>20、看周星驰的电影不再大笑</strong></p>
<p>他知道喜剧的本质是悲剧，当他看到喜剧不再笑的时候</p>
<p>他会心的微微一笑</p>
<p>因为他知道他在表达什么</p>
<p><strong>21、明白大多数信息对自己没有用</strong></p>
<p>比如乱七八糟的抖音，比如垃圾袋怎么套在垃圾桶上，你要获取的是对自己有帮助的信息，而不是把自己的时间浪费在一些奇奇怪怪的知识之上</p>
<p>他知道这些信息对他毫无帮助，他知道更重要的东西是什么，他知道当他有了耐心和时间之后，就能做到90%的事情</p>
<p><strong>22、明白世界上本没有对错</strong></p>
<p>他知道自己的想法全部都是主观的，而且自己根本无法逃出这个主观的影响，永远住在自己的主观世界中。</p>
<p>也许你觉得这杯水是烫的，我觉得是凉的，那么我们都是对的，因为在自己的主观下，所有人都是对的，所以我不会与你争辩这杯水的温度，因为所有东西都不是非黑即白的，而是有灰色地带的</p>
<p>摘下自己的有色眼镜看世界，世界才会变得五彩斑斓，各种不同的观点思想交错在一起才是这个世界本该有的多样的色彩</p>
<p><strong>23、有责任心</strong></p>
<p>他知道他不能因为一时兴起就轻易许诺，他知道一诺千金的重要，他懂得为自己的言行负责，并承担后果</p>
<hr />
<p><strong>下面是成熟的递进关系</strong></p>
<p><strong>24、停止幻想</strong></p>
<p>他知道幻想只会抬高自己的心理预期，他知道做事只能脚踏实地，他开始一点点的进步而不是幻想不切实际的暴富</p>
<p>他深知活在当下的重要性，多想的人永远停留在多想而不是行动</p>
<p><strong>25、意识到自己只是一个普通人</strong></p>
<p>他接受自己只是一个普通人的设定，但他不会自暴自弃，不怨天尤人，不自我设限，只是做好分内的事情</p>
<p><strong>26、不再抱怨</strong></p>
<p>他知道抱怨这种低级的方式不但解决不了问题还会影响自己的情绪，所以他开始行动起来寻找解决问题的方法</p>
<p><strong>27、学会了反省</strong></p>
<p>他坦然接受自己可能错了的事实，并学会了复盘，每天反省自己并思考更好的办法，开始站在别的角度思考并开始慢慢接受自己</p>
<p><strong>28、开始寻找自己的内心诉求</strong></p>
<p>他开始思考自己想要什么，什么让自己开心，什么是自己内心最深处的诉求，我的存在感从何而来，明白自己的利益，真正认识到自己是“谁”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="古诗词"><a class="header" href="#古诗词">古诗词</a></h1>
<p>[TOC]</p>
<img align="left" src="life-and-thinking/peace/assets/image-20211124195350087.png" alt="image-20211124195350087" style="zoom: 45%;" />
<hr />
<h2 id="先秦"><a class="header" href="#先秦">先秦</a></h2>
<h3 id="君子于役"><a class="header" href="#君子于役">君子于役</a></h3>
<p>君子于役，不知其期。曷至哉？<em>鸡栖于埘</em>。日之夕矣，羊牛下来。君子于役，如之何勿思！
君子于役，不日不月。曷其有佸？鸡栖于桀。日之夕矣，羊牛下括。君子于役，苟无饥渴？</p>
<h3 id="采薇"><a class="header" href="#采薇">采薇</a></h3>
<p>采薇采薇，薇亦作止。曰归曰归，岁亦莫止。靡室靡家，玁狁之故。不遑启居，玁狁之故。</p>
<p>采薇采薇，薇亦柔止。曰归曰归，心亦忧止。忧心烈烈，载饥载渴。我戍未定，靡使归聘。</p>
<p>采薇采薇，薇亦刚止。曰归曰归，岁亦阳止。王事靡盬，不遑启处。忧心孔疚，我行不来。</p>
<p>彼尔维何？维常之华。彼路斯何？君子之车。戎车既驾，四牡业业。岂敢定居？一月三捷。</p>
<p>驾彼四牡，四牡骙骙。君子所依，小人所腓。四牡翼翼，象弭鱼服。岂不日戒，玁狁孔棘。</p>
<p><em>昔我往矣，杨柳依依。今我来思，雨雪霏霏。行道迟迟，载渴载饥。我心伤悲，莫知我哀！</em></p>
<h2 id="两晋"><a class="header" href="#两晋">两晋</a></h2>
<h3 id="陈寿"><a class="header" href="#陈寿">陈寿</a></h3>
<h4 id="二十四史-三国志"><a class="header" href="#二十四史-三国志">二十四史-三国志</a></h4>
<p>一点寒芒先到，随后枪出如龙。</p>
<h3 id="曹植"><a class="header" href="#曹植">曹植</a></h3>
<h4 id="明月上高楼"><a class="header" href="#明月上高楼">明月上高楼</a></h4>
<p>明月照高楼，流光正徘徊。上有愁思妇，悲叹有余哀。</p>
<p>借问叹者谁，言是客子妻。君行逾十年，孤妾常独栖。</p>
<p>君若清路尘，妾若浊水泥；浮沉各异势，会合何时谐。</p>
<p><strong>愿为西南风，长逝入君怀</strong>。君怀良不开，贱妾当何依。</p>
<h3 id="陶渊明"><a class="header" href="#陶渊明">陶渊明</a></h3>
<h4 id="移居二首"><a class="header" href="#移居二首">移居二首</a></h4>
<p>昔欲居南村，非为卜其宅。
<em>闻多素心人，乐与数晨夕</em>。
怀此颇有年，今日从兹役。
敝庐何必广，取足蔽床席。
邻曲时时来，抗言谈在昔。
奇文共欣赏，疑义相与析。
春秋多佳日，登高赋新诗。
过门更相呼，有酒斟酌之。
农务各自归，闲暇辄相思。
相思则披衣，言笑无厌时。
此理将不胜？无为忽去兹。
衣食当须纪，力耕不吾欺。</p>
<h2 id="南北朝"><a class="header" href="#南北朝">南北朝</a></h2>
<h3 id="陆凯"><a class="header" href="#陆凯">陆凯</a></h3>
<h4 id="赠范晔诗"><a class="header" href="#赠范晔诗">赠范晔诗</a></h4>
<p>折花逢驿使，寄与陇头人。</p>
<p><strong>江南无所有，聊赠一枝春。</strong></p>
<h3 id="郦道元"><a class="header" href="#郦道元">郦道元</a></h3>
<h4 id="三峡"><a class="header" href="#三峡">三峡</a></h4>
<p>巴东三峡巫峡长，猿鸣三声泪沾裳。</p>
<h3 id="世说新语"><a class="header" href="#世说新语">世说新语</a></h3>
<p>桓公北征经金城，见前为琅琊时种柳，皆已十围，慨然曰：“<strong>木犹如此，人何以堪</strong>！”攀枝折条，泫然流泪。</p>
<h2 id="唐诗"><a class="header" href="#唐诗">唐诗</a></h2>
<h3 id="李白"><a class="header" href="#李白">李白</a></h3>
<h4 id="清平调其一"><a class="header" href="#清平调其一">清平调·其一</a></h4>
<p><strong>云想衣裳花想容，春风拂槛露华浓。</strong>
若非群玉山头见，会向瑶台月下逢。</p>
<h4 id="将进酒"><a class="header" href="#将进酒">将进酒</a></h4>
<p>君不见，黄河之水天上来，奔流到海不复回。</p>
<p>君不见，高堂明镜悲白发，朝如青丝暮成雪。</p>
<p>人生得意须尽欢，莫使金樽空对月。</p>
<p>天生我材必有用，千金散尽还复来。</p>
<p>烹羊宰牛且为乐，会须一饮三百杯。</p>
<p>岑夫子，丹丘生，将进酒，杯莫停。</p>
<p>与君歌一曲，请君为我倾耳听。</p>
<p>钟鼓馔玉不足贵，但愿长醉不愿醒。</p>
<p>古来圣贤皆寂寞，惟有饮者留其名。</p>
<p>陈王昔时宴平乐，斗酒十千恣欢谑。</p>
<p>主人何为言少钱，径须沽取对君酌。</p>
<p>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</p>
<h4 id="送友人"><a class="header" href="#送友人">送友人</a></h4>
<p><strong>青山横北郭，白水绕东城。</strong>
此地一为别，孤蓬万里征。
<strong>浮云游子意，落日故人情。</strong>
挥手自兹去，萧萧班马鸣。</p>
<h4 id="侠客行"><a class="header" href="#侠客行">侠客行</a></h4>
<p><strong>赵客缦胡缨，吴钩霜雪明。</strong></p>
<p><strong>银鞍照白马，飒沓如流星。</strong></p>
<p><strong>十步杀一人，千里不留行。</strong></p>
<p><strong>事了拂衣去，深藏身与名。</strong></p>
<p>闲过信陵饮，脱剑膝前横。</p>
<p>将炙啖朱亥，持觞劝侯嬴。</p>
<p>三杯吐然诺，五岳倒为轻。</p>
<p>眼花耳热后，意气素霓生。</p>
<p>救赵挥金槌，邯郸先震惊。</p>
<p>千秋二壮士，烜赫大梁城。</p>
<p><strong>纵死侠骨香，不惭世上英。</strong></p>
<p><strong>谁能书阁下，白首太玄经。</strong></p>
<h4 id="黄鹤楼送孟浩然之广陵"><a class="header" href="#黄鹤楼送孟浩然之广陵">黄鹤楼送孟浩然之广陵</a></h4>
<p>故人西辞黄鹤楼，烟花三月下扬州。</p>
<p><strong>孤帆远影碧空尽，唯见长江天际流。</strong></p>
<h4 id="赠新平少年"><a class="header" href="#赠新平少年">赠新平少年</a></h4>
<p>韩信在淮阴，少年相欺凌。
屈体若无骨，壮心有所凭。
一遭龙颜君，啸咤从此兴。
<strong>千金答漂母，万古共嗟称。</strong>
而我竟何为，寒苦坐相仍。
<strong>长风入短袂，两手如怀冰。</strong>
故友不相恤，新交宁见矜。
摧残槛中虎，羁绁鞲上鹰。
何时腾风云，搏击申所能。</p>
<h4 id="答王十二寒夜独酌有怀"><a class="header" href="#答王十二寒夜独酌有怀">答王十二寒夜独酌有怀</a></h4>
<p>昨夜吴中雪，子猷佳兴发。万里浮云卷碧山，
青天中道流孤月。<strong>孤月沧浪河汉清，北斗错落长庚明。</strong>
怀余对酒夜霜白，玉床金井冰峥嵘。人生飘忽百年内，
且须酣畅万古情。君不能狸膏金距学斗鸡，
坐令鼻息吹虹霓。君不能学哥舒横行青海夜带刀，
西屠石堡取紫袍。吟诗作赋北窗里，万言不直一杯水。
世人闻此皆掉头，有如东风射马耳。鱼目亦笑我，
请与明月同。骅骝拳跼不能食，蹇驴得志鸣春风。
折杨黄华合流俗，晋君听琴枉清角。巴人谁肯和阳春。
楚地由来贱奇璞。黄金散尽交不成，白首为儒身被轻。
一谈一笑失颜色，苍蝇贝锦喧谤声。曾参岂是杀人者，
谗言三及慈母惊。与君论心握君手，荣辱于余亦何有。
孔圣犹闻伤凤麟，董龙更是何鸡狗。一生傲岸苦不谐，
恩疏媒劳志多乖。严陵高揖汉天子，
何必长剑拄颐事玉阶。达亦不足贵，穷亦不足悲。
韩信羞将绛灌比，祢衡耻逐屠沽儿。君不见李北海，
英风豪气今何在。君不见裴尚书，土坟三尺蒿棘居。
少年早欲五湖去，见此弥将钟鼎疏。</p>
<h4 id="访戴天山道士不遇"><a class="header" href="#访戴天山道士不遇">访戴天山道士不遇</a></h4>
<p><em>犬吠水声中，桃花带露浓</em>。
树深时见鹿，溪午不闻钟。
野竹分青霭，飞泉挂碧峰。
无人知所去，愁倚两三松。</p>
<h3 id="杜甫"><a class="header" href="#杜甫">杜甫</a></h3>
<h4 id="偶题"><a class="header" href="#偶题">偶题</a></h4>
<p><strong><em>文章千古事，得失寸心知</em>。</strong>
作者皆殊列，名声岂浪垂。
骚人嗟不见，汉道盛于斯。
前辈飞腾入，馀波绮丽为。
后贤兼旧列，历代各清规。
法自儒家有，心从弱岁疲。
永怀江左逸，多病邺中奇。
騄骥皆良马，骐驎带好儿。
车轮徒已斫，堂构惜仍亏。
漫作潜夫论，虚传幼妇碑。
缘情慰漂荡，抱疾屡迁移。
经济惭长策，飞栖假一枝。
尘沙傍蜂虿，江峡绕蛟螭。
萧瑟唐虞远，联翩楚汉危。
圣朝兼盗贼，异俗更喧卑。
郁郁星辰剑，苍苍云雨池。
两都开幕府，万宇插军麾。
南海残铜柱，东风避月支。
音书恨乌鹊，号怒怪熊罴。
稼穑分诗兴，柴荆学土宜。
故山迷白阁，秋水隐黄陂。
不敢要佳句，愁来赋别离。</p>
<h4 id="水槛遣心二首"><a class="header" href="#水槛遣心二首">水槛遣心二首</a></h4>
<p>去郭轩楹敞，无村眺望赊。
澄江平少岸，幽树晚多花。
<em><strong>细雨鱼儿出，微风燕子斜</strong></em>。
城中十万户，此地两三家。
蜀天常夜雨，江槛已朝晴。
叶润林塘密，衣干枕席清。
不堪祗老病，何得尚浮名。
浅把涓涓酒，深凭送此生。</p>
<h4 id="江南逢李龟年"><a class="header" href="#江南逢李龟年">江南逢李龟年</a></h4>
<p>岐王宅里寻常见，崔九堂前几度闻。</p>
<p><strong>正是江南好风景，落花时节又逢君。</strong></p>
<h4 id="秋兴八首-其二"><a class="header" href="#秋兴八首-其二">秋兴八首 其二</a></h4>
<p>夔府孤城落日斜，每依北斗望京华。</p>
<p><strong>听猿实下三声泪，奉使虚随八月槎。</strong></p>
<p>画省香炉违伏枕，山楼粉堞隐悲笳。</p>
<p>请看石上藤萝月，已映洲前芦荻花。</p>
<h4 id="九日五首-其一"><a class="header" href="#九日五首-其一">九日五首 其一</a></h4>
<p>重阳独酌杯中酒，抱病起登江上台。
<strong>竹叶于人既无分，菊花从此不须开。</strong>
殊方日落玄猿哭，旧国霜前白雁来。
弟妹萧条各何在，干戈衰谢两相催！</p>
<h4 id="旅夜书怀"><a class="header" href="#旅夜书怀">旅夜书怀</a></h4>
<p>细草微风岸，危樯独夜舟。</p>
<p>星垂平野阔，月涌大江流。</p>
<p>名岂文章著，官应老病休。</p>
<p>飘飘何所似，天地一沙鸥。</p>
<h4 id="闻官军收河南河北"><a class="header" href="#闻官军收河南河北">闻官军收河南河北</a></h4>
<p>剑外忽传收蓟北，初闻涕泪满衣裳。</p>
<p>却看妻子愁何在，漫卷诗书喜欲狂。</p>
<p>白日放歌须纵酒，青春作伴好还乡。</p>
<p>即从巴峡穿巫峡，便下襄阳向洛阳。</p>
<h4 id="严郑公宅同咏竹"><a class="header" href="#严郑公宅同咏竹">严郑公宅同咏竹</a></h4>
<p>绿竹半含箨，新梢才出墙。
色侵书帙晚，阴过酒樽凉。
<em>雨洗娟娟净，风吹细细香</em>。
但令无剪伐，会见拂云长。</p>
<h3 id="王勃"><a class="header" href="#王勃">王勃</a></h3>
<p>初唐四杰</p>
<h4 id="滕王阁序"><a class="header" href="#滕王阁序">滕王阁序</a></h4>
<p>豫章故郡，洪都新府。星分翼轸，地接衡庐。<strong>襟三江而带五湖，控蛮荆而引瓯越</strong>。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p>
<p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p>
<p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。<strong>云销雨霁，彩彻区明</strong>。<strong>落霞与孤鹜齐飞，秋水共长天一色</strong>。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p>
<p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。**关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。**怀帝阍而不见，奉宣室以何年？</p>
<p>嗟乎！时运不齐，命途多舛。<strong>冯唐易老，李广难封</strong>。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？<strong>穷且益坚，不坠青云之志</strong>。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p>
<p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p>
<p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p>
<p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p>
<p>画栋朝飞南浦云，珠帘暮卷西山雨。</p>
<p>闲云潭影日悠悠，物换星移几度秋。</p>
<p>阁中帝子今何在？槛外长江空自流。</p>
<h3 id="张若虚"><a class="header" href="#张若虚">张若虚</a></h3>
<h4 id="春江花夜月夜"><a class="header" href="#春江花夜月夜">春江花夜月夜</a></h4>
<p>春江潮水连海平，海上明月共潮生。
滟滟随波千万里，何处春江无月明！
江流宛转绕芳甸，月照花林皆似霰；
空里流霜不觉飞，汀上白沙看不见。
江天一色无纤尘，皎皎空中孤月轮。
江畔何人初见月？江月何年初照人？
人生代代无穷已，江月年年望相似。
不知江月待何人，但见长江送流水。
<strong>白云一片去悠悠，青枫浦上不胜愁</strong>。
谁家今夜扁舟子？何处相思明月楼？
可怜楼上月徘徊，应照离人妆镜台。
玉户帘中卷不去，捣衣砧上拂还来。
<strong>此时相望不相闻，愿逐月华流照君。</strong>
鸿雁长飞光不度，鱼龙潜跃水成文。
昨夜闲潭梦落花，可怜春半不还家。
江水流春去欲尽，江潭落月复西斜。
斜月沉沉藏海雾，碣石潇湘无限路。
不知乘月几人归，落月摇情满江树。</p>
<h3 id="孟郊"><a class="header" href="#孟郊">孟郊</a></h3>
<p>游子吟</p>
<h4 id="登科后"><a class="header" href="#登科后">登科后</a></h4>
<p>昔日龌龊不足夸，今朝放荡思无涯。
<strong>春风得意马蹄疾，一日看尽长安花。</strong></p>
<h3 id="贾岛"><a class="header" href="#贾岛">贾岛</a></h3>
<h4 id="题诗后"><a class="header" href="#题诗后">题诗后</a></h4>
<p>两句三年得，一吟双泪流。</p>
<p>知音如不赏，归卧故山秋。</p>
<h3 id="元稹"><a class="header" href="#元稹">元稹</a></h3>
<h4 id="离思五首其四"><a class="header" href="#离思五首其四">离思五首·其四</a></h4>
<p><strong>曾经沧海难为水，除却巫山不是云。</strong></p>
<p><strong>取次花丛懒回顾，半缘修道半缘君。</strong></p>
<h4 id="遣悲怀-其一"><a class="header" href="#遣悲怀-其一">遣悲怀 其一</a></h4>
<p>谢公最小偏怜女，自嫁黔娄百事乖。
<strong>顾我无衣搜荩箧，泥他沽酒拔金钗。</strong>
野蔬充膳甘长藿，落叶添薪仰古槐。
<strong>今日俸钱过十万，与君营奠复营斋。</strong></p>
<h4 id="遣悲怀三首其三"><a class="header" href="#遣悲怀三首其三">遣悲怀三首·其三</a></h4>
<p><strong>闲坐悲君亦自悲，百年多是几多时。</strong>
邓攸无子寻知命，潘岳悼亡犹费词。
<strong>同穴窅冥何所望，他生缘会更难期。</strong>
<strong>惟将终夜常开眼，报答平生未展眉。</strong></p>
<h3 id="崔颢"><a class="header" href="#崔颢">崔颢</a></h3>
<h4 id="长干曲"><a class="header" href="#长干曲">长干曲</a></h4>
<p>君家何处住，妾住在横塘。
停船暂借问，或恐是同乡。</p>
<p>横塘：莫愁湖</p>
<h3 id="李商隐"><a class="header" href="#李商隐">李商隐</a></h3>
<h4 id="无题-1"><a class="header" href="#无题-1">无题</a></h4>
<p><strong>昨夜星辰昨夜风，画楼西畔桂堂东。</strong></p>
<p><strong>身无彩凤双飞翼，心有灵犀一点通。</strong></p>
<p>隔座送钩春酒暖，分曹射覆蜡灯红。</p>
<p>嗟余听鼓应官去，走马兰台类转蓬。</p>
<h4 id="乐游原"><a class="header" href="#乐游原">乐游原</a></h4>
<p>向晚意不适，驱车登古原。</p>
<p>夕阳无限好，只是近黄昏。</p>
<h4 id="月"><a class="header" href="#月">月</a></h4>
<p>过水穿楼触处明，藏人带树远含清。
初生欲缺虚惆怅，<em>未必圆时即有情</em>。</p>
<h4 id="北青萝"><a class="header" href="#北青萝">北青萝</a></h4>
<p><em>残阳西入崦，茅屋访孤僧</em>。
落叶人何在，寒云路几层。
独敲初夜磬，闲倚一枝藤。
世界微尘里，吾宁爱与憎。</p>
<h3 id="杜牧"><a class="header" href="#杜牧">杜牧</a></h3>
<h4 id="赠别"><a class="header" href="#赠别">赠别</a></h4>
<p><strong>多情却似总无情</strong>，唯觉樽前笑不成。</p>
<p>蜡烛有心还惜别，替人垂泪到天明。</p>
<h4 id="遣怀"><a class="header" href="#遣怀">遣怀</a></h4>
<p>落魄江湖载酒行，楚腰纤细掌中轻。
<strong>十年一觉扬州梦，赢得青楼薄幸名。</strong></p>
<h4 id="九日齐山登高"><a class="header" href="#九日齐山登高">九日齐山登高</a></h4>
<p>江涵秋影雁初飞，与客携壶上翠微。
<strong>尘世难逢开口笑，菊花须插满头归。</strong>
但将酩酊酬佳节，不用登临恨落晖。
古往今来只如此，牛山何必独沾衣。</p>
<h3 id="白居易"><a class="header" href="#白居易">白居易</a></h3>
<h4 id="琵琶行"><a class="header" href="#琵琶行">琵琶行</a></h4>
<p>浔阳江头夜送客，枫叶荻花秋瑟瑟。主人下马客在船，举酒欲饮无管弦。<strong>醉不成欢惨将别，别时茫茫江浸月。</strong></p>
<p>忽闻水上琵琶声，主人忘归客不发。寻声暗问弹者谁，琵琶声停欲语迟。移船相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱琵琶半遮面。转轴拨弦三两声，未成曲调先有情。弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢捻抹复挑，初为《霓裳》后《六幺》。大弦嘈嘈如急雨，小弦切切如私语。嘈嘈切切错杂弹，大珠小珠落玉盘。间关莺语花底滑，幽咽泉流冰下难。冰泉冷涩弦凝绝，凝绝不通声暂歇。别有幽愁暗恨生，此时无声胜有声。银瓶乍破水浆迸，铁骑突出刀枪鸣。曲终收拨当心画，四弦一声如裂帛。东船西舫悄无言，唯见江心秋月白。</p>
<p>沉吟放拨插弦中，整顿衣裳起敛容。自言本是京城女，家在虾蟆陵下住。十三学得琵琶成，名属教坊第一部。曲罢曾教善才服，妆成每被秋娘妒。五陵年少争缠头，一曲红绡不知数。钿头银篦击节碎，血色罗裙翻酒污。今年欢笑复明年，秋月春风等闲度。弟走从军阿姨死，暮去朝来颜色故。门前冷落鞍马稀，老大嫁作商人妇。商人重利轻别离，前月浮梁买茶去。去来江口守空船，绕船月明江水寒。夜深忽梦少年事，梦啼妆泪红阑干。</p>
<p>我闻琵琶已叹息，又闻此语重唧唧。同是天涯沦落人，相逢何必曾相识！我从去年辞帝京，谪居卧病浔阳城。浔阳地僻无音乐，终岁不闻丝竹声。住近湓江地低湿，黄芦苦竹绕宅生。其间旦暮闻何物？杜鹃啼血猿哀鸣。春江花朝秋月夜，往往取酒还独倾。岂无山歌与村笛？呕哑嘲哳难为听。今夜闻君琵琶语，如听仙乐耳暂明。莫辞更坐弹一曲，为君翻作《琵琶行》。感我此言良久立，却坐促弦弦转急。凄凄不似向前声，满座重闻皆掩泣。座中泣下谁最多？江州司马青衫湿。</p>
<h4 id="池鹤二首"><a class="header" href="#池鹤二首">池鹤二首</a></h4>
<p>高竹笼前无伴侣，乱鸡群里有风标。
低头乍恐丹砂落，晒翅常疑白雪消。
转觉鸬鹚毛色下，苦嫌鹦鹉语声娇。
<em>临风一唳思何事，怅望青田云水遥</em>。
池中此鹤鹤中稀，恐是辽东老令威。
带雪松枝翘膝胫，放花菱片缀毛衣。
低回且向林间宿，奋迅终须天外飞。
若问故巢知处在，主人相恋未能归。</p>
<h4 id="长相思九月西风兴"><a class="header" href="#长相思九月西风兴">长相思·九月西风兴</a></h4>
<p><em>九月西风兴，月冷露华凝</em>。
思君秋夜长，一夜魂九升。
二月东风来，草拆花心开。
思君春日迟，一日肠九回。
妾住洛桥北，君住洛桥南。
十五即相识，今年二十三。
有如女萝草，生在松之侧。
蔓短枝苦高，萦回上不得。
人言人有愿，愿至天必成。
愿作远方兽，步步比肩行。
愿作深山木，枝枝连理生。</p>
<h4 id="长恨歌"><a class="header" href="#长恨歌">长恨歌</a></h4>
<p>汉皇重色思倾国，御宇多年求不得。</p>
<p>杨家有女初长成，养在深闺人未识。</p>
<p>天生丽质难自弃，一朝选在君王侧。</p>
<p><strong>回眸一笑百媚生，六宫粉黛无颜色。</strong></p>
<p>春寒赐浴华清池，温泉水滑洗凝脂。</p>
<p>侍儿扶起娇无力，始是新承恩泽时。</p>
<p>云鬓花颜金步摇，芙蓉帐暖度春宵。</p>
<p><strong>春宵苦短日高起，从此君王不早朝。</strong></p>
<p>承欢侍宴无闲暇，春从春游夜专夜。</p>
<p>后宫佳丽三千人，三千宠爱在一身。</p>
<p>金屋妆成娇侍夜，玉楼宴罢醉和春。</p>
<p>姊妹弟兄皆列土，可怜光彩生门户。</p>
<p>遂令天下父母心，不重生男重生女。</p>
<p>骊宫高处入青云，仙乐风飘处处闻。</p>
<p>缓歌慢舞凝丝竹，尽日君王看不足。</p>
<p>渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p>
<p>九重城阙烟尘生，千乘万骑西南行。</p>
<p>翠华摇摇行复止，西出都门百余里。</p>
<p>六军不发无奈何，宛转蛾眉马前死。</p>
<p>花钿委地无人收，翠翘金雀玉搔头。</p>
<p>君王掩面救不得，回看血泪相和流。</p>
<p>黄埃散漫风萧索，云栈萦纡登剑阁。</p>
<p>峨嵋山下少人行，旌旗无光日色薄。</p>
<p>蜀江水碧蜀山青，圣主朝朝暮暮情。</p>
<p>行宫见月伤心色，夜雨闻铃肠断声。</p>
<p>天旋地转回龙驭，到此踌躇不能去。</p>
<p>马嵬坡下泥土中，不见玉颜空死处。</p>
<p>君臣相顾尽沾衣，东望都门信马归。</p>
<p>归来池苑皆依旧，太液芙蓉未央柳。</p>
<p>芙蓉如面柳如眉，对此如何不泪垂。</p>
<p>春风桃李花开夜，秋雨梧桐叶落时。</p>
<p>西宫南苑多秋草，落叶满阶红不扫。</p>
<p>梨园弟子白发新，椒房阿监青娥老。</p>
<p>夕殿萤飞思悄然，孤灯挑尽未成眠。</p>
<p>迟迟钟鼓初长夜，耿耿星河欲曙天。</p>
<p>鸳鸯瓦冷霜华重，翡翠衾寒谁与共。</p>
<p>悠悠生死别经年，魂魄不曾来入梦。</p>
<p>临邛道士鸿都客，能以精诚致魂魄。</p>
<p>为感君王辗转思，遂教方士殷勤觅。</p>
<p>排空驭气奔如电，升天入地求之遍。</p>
<p>上穷碧落下黄泉，两处茫茫皆不见。</p>
<p>忽闻海上有仙山，山在虚无缥渺间。</p>
<p>楼阁玲珑五云起，其中绰约多仙子。</p>
<p>中有一人字太真，雪肤花貌参差是。</p>
<p>金阙西厢叩玉扃，转教小玉报双成。</p>
<p>闻道汉家天子使，九华帐里梦魂惊。</p>
<p>揽衣推枕起徘徊，珠箔银屏迤逦开。</p>
<p>云鬓半偏新睡觉，花冠不整下堂来。</p>
<p>风吹仙袂飘飖举，犹似霓裳羽衣舞。</p>
<p>玉容寂寞泪阑干，梨花一枝春带雨。</p>
<p>含情凝睇谢君王，一别音容两渺茫。</p>
<p>昭阳殿里恩爱绝，蓬莱宫中日月长。</p>
<p>回头下望人寰处，不见长安见尘雾。</p>
<p>惟将旧物表深情，钿合金钗寄将去。</p>
<p>钗留一股合一扇，钗擘黄金合分钿。</p>
<p>但令心似金钿坚，天上人间会相见。</p>
<p>临别殷勤重寄词，词中有誓两心知。</p>
<p>七月七日长生殿，夜半无人私语时。</p>
<p><strong>在天愿作比翼鸟，在地愿为连理枝。</strong></p>
<p><strong>天长地久有时尽，此恨绵绵无绝期。</strong></p>
<h3 id="王维"><a class="header" href="#王维">王维</a></h3>
<h4 id="送元二使安西"><a class="header" href="#送元二使安西">送元二使安西</a></h4>
<p>渭城朝雨浥轻尘，<em>客舍青青柳色新。</em></p>
<p>劝君更尽一杯酒，西出阳关无故人。</p>
<h3 id="其他-7"><a class="header" href="#其他-7">其他</a></h3>
<h4 id="咸阳城东楼"><a class="header" href="#咸阳城东楼">咸阳城东楼</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E8%AE%B8%E6%B5%91">许浑 </a></p>
<p>一上高城万里愁，蒹葭杨柳似汀洲。</p>
<p><strong>溪云初起日沉阁，山雨欲来风满楼。</strong></p>
<p>鸟下绿芜秦苑夕，蝉鸣黄叶汉宫秋。</p>
<p>行人莫问当年事，故国东来渭水流。</p>
<h4 id="咏柳二首"><a class="header" href="#咏柳二首">咏柳二首</a></h4>
<p>顾云</p>
<p>带露含烟处处垂，绽黄摇绿嫩参差。
长堤未见风飘絮，广陌初怜日映丝。
斜傍画筵偷舞态，低临妆阁学愁眉。
离亭不放到春暮，折尽拂檐千万枝。
闲花野草总争新，眉皱丝干独不匀。
<strong>乞取东风残气力，莫教虚度一年春。</strong></p>
<h4 id="逢雪宿芙蓉山主人"><a class="header" href="#逢雪宿芙蓉山主人">逢雪宿芙蓉山主人</a></h4>
<p>刘长卿 </p>
<p>日暮苍山远，天寒白屋贫。
<strong>柴门闻犬吠，风雪夜归人。</strong></p>
<h4 id="菩萨蛮"><a class="header" href="#菩萨蛮">菩萨蛮</a></h4>
<p>作者：<a href="https://www.baidu.com/s?wd=%E9%9F%A6%E5%BA%84&amp;rsv_idx=2&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;rsv_cq=%E8%8F%A9%E8%90%A8%E8%9B%AE%C2%B7%E4%BA%BA%E4%BA%BA%E5%B0%BD%E8%AF%B4%E6%B1%9F%E5%8D%97%E5%A5%BD&amp;rsv_dl=0_left_exactqa_detail_28239&amp;rsv_pq=dc5ee7040009ef61&amp;oq=%E8%8F%A9%E8%90%A8%E8%9B%AE%C2%B7%E4%BA%BA%E4%BA%BA%E5%B0%BD%E8%AF%B4%E6%B1%9F%E5%8D%97%E5%A5%BD&amp;rsv_t=f04bKIuhdiZueQphVwNwniYpBQNlZHrKzKacbgCVhb7JVvLlyttD3XDL%2BJ8RzXaBY%2FHE">韦庄</a></p>
<p>人人尽说江南好，游人只合江南老。<strong>春水碧于天，画船听雨眠。</strong>
垆边人似月，皓腕凝霜雪。<strong>未老莫还乡，还乡须断肠。</strong></p>
<h4 id="荷叶杯记得那年花下"><a class="header" href="#荷叶杯记得那年花下">荷叶杯·记得那年花下</a></h4>
<p>韦庄</p>
<p>记得那年花下，深夜，初识谢娘时。水堂西面画帘垂，携手暗相期。
惆怅晓莺残月，相别，从此隔音尘。<em>如今俱是异乡人，相见更无因</em>。</p>
<h4 id="淮上与友人别"><a class="header" href="#淮上与友人别">淮上与友人别</a></h4>
<p>郑谷</p>
<p>扬子江头杨柳春，杨花愁杀渡江人。</p>
<p><strong>数声风笛离亭晚，君向潇湘我向秦。</strong></p>
<h4 id="河湟旧卒"><a class="header" href="#河湟旧卒">河湟旧卒</a></h4>
<p>张乔</p>
<p>少年随将讨河湟，头白时清返故乡。
<em>十万汉军零落尽，独吹边曲向残阳</em>。</p>
<h4 id="上堂开示颂"><a class="header" href="#上堂开示颂">上堂开示颂</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E9%BB%84%E6%AB%B1%E7%A6%85%E5%B8%88">黄櫱禅师 </a></p>
<p>尘劳迥脱事非常，紧把绳头做一场。
<em>不经一番寒彻骨，怎得梅花扑鼻香</em>。</p>
<h4 id="题都城南庄"><a class="header" href="#题都城南庄">题都城南庄</a></h4>
<p>崔护</p>
<p>去年今日此门中，人面桃花相映红。</p>
<p>人面不知何处去，桃花依旧笑春风。</p>
<h4 id="寒食"><a class="header" href="#寒食">寒食</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E9%9F%A9%E7%BF%83">韩翃 </a></p>
<p>春城无处不飞花，寒食东风御柳斜。</p>
<p>日暮汉宫传蜡烛，轻烟散入五侯家。</p>
<h4 id="边方春兴"><a class="header" href="#边方春兴">边方春兴</a></h4>
<p><em>草色青青柳色浓</em>，玉壶倾酒满金钟。
笙歌嘹亮随风去，知尽关山第几重。</p>
<h4 id="寄李儋元锡"><a class="header" href="#寄李儋元锡">寄李儋元锡</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E9%9F%A6%E5%BA%94%E7%89%A9">韦应物 </a></p>
<p>去年花里逢君别，今日花开又一年。
<em>世事茫茫难自料，春愁黯黯独成眠</em>。
身多疾病思田里，邑有流亡愧俸钱。
闻道欲来相问讯，西楼望月几回圆。</p>
<h2 id="五代十国"><a class="header" href="#五代十国">五代十国</a></h2>
<h3 id="李煜"><a class="header" href="#李煜">李煜</a></h3>
<h4 id="渡中江望石城泣下"><a class="header" href="#渡中江望石城泣下">渡中江望石城泣下</a></h4>
<p><strong>江南江北旧家乡，三十年来梦一场。</strong>
吴苑宫闱今冷落，广陵台殿已荒凉。
云笼远岫愁千片，雨打归舟泪万行。
兄弟四人三百口，不堪闲坐细思量。</p>
<h2 id="宋朝"><a class="header" href="#宋朝">宋朝</a></h2>
<h3 id="苏轼"><a class="header" href="#苏轼">苏轼</a></h3>
<h4 id="定风波"><a class="header" href="#定风波">定风波</a></h4>
<p>莫听穿林打叶声，<strong>何妨吟啸且徐行</strong>。
竹杖芒鞋轻胜马，谁怕？<strong>一蓑烟雨任平生</strong>。
料峭春风吹酒醒，微冷，山头斜照却相迎。
回首向来萧瑟处，归去，<strong>也无风雨也无晴</strong>。</p>
<h4 id="行香子过七里濑"><a class="header" href="#行香子过七里濑">行香子·过七里濑</a></h4>
<p>一叶舟轻，双桨鸿惊。水天清、影湛波平。鱼翻藻鉴，鹭点烟汀。过沙溪急，霜溪冷，月溪明。
重重似画，曲曲如屏。算当年、虚老严陵。<strong>君臣一梦，今古空名。但远山长，云山乱，晓山青。</strong></p>
<h4 id="望江南超然台作"><a class="header" href="#望江南超然台作">望江南·超然台作</a></h4>
<p>春未老，风细柳斜斜。试上超然台上望，半壕春水一城花。烟雨暗千家。
寒食后，酒醒却咨嗟。<strong>休对故人思故国，且将新火试新茶。诗酒趁年华。</strong></p>
<h4 id="洞仙歌咏柳"><a class="header" href="#洞仙歌咏柳">洞仙歌·咏柳</a></h4>
<p><strong>江南腊尽，早梅花开后，分付新春与垂柳。</strong></p>
<p>细腰肢自有入格风流，仍更是、骨体清英雅秀。</p>
<p>永丰坊那畔，尽日无人，谁见金丝弄晴昼？</p>
<p>断肠是飞絮时，绿叶成阴，无个事、一成消瘦。</p>
<p>又莫是东风逐君来，便吹散眉间一点春皱。</p>
<h4 id="定风波南海归赠王定国侍人寓娘"><a class="header" href="#定风波南海归赠王定国侍人寓娘">定风波·南海归赠王定国侍人寓娘</a></h4>
<p>常羡人间琢玉郎。天应乞与点酥娘。尽道清歌传皓齿。风起。雪飞炎海变清凉。
<strong>万里归来颜愈少</strong>。微笑。<strong>笑时犹带岭梅香</strong>。试问岭南应不好。却道。<strong>此心安处是吾乡</strong>。</p>
<h4 id="江城子乙卯正月二十日夜记梦"><a class="header" href="#江城子乙卯正月二十日夜记梦">江城子·乙卯正月二十日夜记梦</a></h4>
<p>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。*<strong>纵使相逢应不识</strong>，*尘满面，鬓如霜。</p>
<p>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p>
<h4 id="次前韵寄子由"><a class="header" href="#次前韵寄子由">次前韵寄子由</a></h4>
<p>我少即多难，邅回一生中。**百年不易满，寸寸弯强弓。**老矣复何言，荣辱今两空。泥丸尚一路，？古语云，十方薄伽梵，一路涅槃门。？所向余皆穷。似闻崆峒西，仇池迎此翁。胡为适南海，复驾垂天雄。下视九万里，浩浩皆积风。回望古合州，属此琉璃钟。离别何足道，我生岂有终。渡海十年归，方镜照两童。还乡亦何有，暂假壶公龙。峨眉向我笑，锦水为君容。天人巧相胜，不独数子工。指点昔游处，蒿莱生故宫。</p>
<h4 id="自题金山画像"><a class="header" href="#自题金山画像">自题金山画像</a></h4>
<p>心似已灰之木，身如不系之舟。
问汝平生功业，黄州惠州儋州。</p>
<h4 id="临江仙夜饮东坡醒复醉"><a class="header" href="#临江仙夜饮东坡醒复醉">临江仙·夜饮东坡醒复醉</a></h4>
<p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p>
<p>长恨此身非我有，何时忘却营营。夜阑风静縠纹平。<em>小舟从此逝，江海寄余生。</em></p>
<h4 id="西江月世事一场大梦"><a class="header" href="#西江月世事一场大梦">西江月·世事一场大梦</a></h4>
<p>世事一场大梦，人生几度秋凉。夜来风叶已鸣廊。看取眉头鬓上。</p>
<p>酒贱常愁客少，月明多被云妨。中秋谁与共孤光。把盏凄然北望。</p>
<h4 id="南歌子感旧"><a class="header" href="#南歌子感旧">南歌子·感旧</a></h4>
<p>寸恨谁云短，绵绵岂易裁。半年眉绿未曾开。明月好风闲处、是人猜。
<em>春雨消残冻，温风到冷灰</em>。尊前一曲为谁哉。留取曲终一拍、待君来。</p>
<h4 id="六月二十日夜渡海"><a class="header" href="#六月二十日夜渡海">六月二十日夜渡海</a></h4>
<p><em>参横斗转欲三更，苦雨终风也解晴</em>。
云散月明谁点缀？天容海色本澄清。
空余鲁叟乘桴意，粗识轩辕奏乐声。
九死南荒吾不恨，兹游奇绝冠平生。</p>
<h4 id="春宵"><a class="header" href="#春宵">春宵</a></h4>
<p>春宵一刻值千金，花有清香月有阴。</p>
<p>歌管楼台声细细，秋千院落夜沉沉。</p>
<h3 id="欧阳修"><a class="header" href="#欧阳修">欧阳修</a></h3>
<p>北宋</p>
<h4 id="浪淘沙把酒祝东风"><a class="header" href="#浪淘沙把酒祝东风">浪淘沙·把酒祝东风</a></h4>
<p>把酒祝东风，且共从容。垂杨紫陌洛城东。总是当时携手处，游遍芳丛。
聚散苦匆匆，此恨无穷。今年花胜去年红。<strong>可惜明年花更好，知与谁同？</strong></p>
<h4 id="蝶恋花海燕双来归画栋"><a class="header" href="#蝶恋花海燕双来归画栋">蝶恋花·海燕双来归画栋</a></h4>
<p>海燕双来归画栋。帘影无风，花影频移动。半醉腾腾春睡重。绿鬟堆枕香云拥。</p>
<p>翠被双盘金缕凤。**忆得前春，有个人人共。**花里黄莺时一弄。日斜惊起相思梦。</p>
<h3 id="范仲淹"><a class="header" href="#范仲淹">范仲淹</a></h3>
<h4 id="岳阳楼记"><a class="header" href="#岳阳楼记">岳阳楼记</a></h4>
<p>庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。</p>
<p>予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？</p>
<p>若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。</p>
<p>至若<strong>春和景明，波澜不惊</strong>，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有<strong>心旷神怡，宠辱偕忘</strong>，把酒临风，其喜洋洋者矣。</p>
<p>嗟夫！予尝求古仁人之心，或异二者之为，何哉？<strong>不以物喜，不以己悲</strong>；<strong>居庙堂之高则忧其民；处江湖之远则忧其君</strong>。是进亦忧，退亦忧。然则何时而乐耶？其必曰“<strong>先天下之忧而忧，后天下之乐而乐</strong>”乎。噫！微斯人，吾谁与归？</p>
<p>时六年九月十五日。</p>
<h3 id="黄庭坚"><a class="header" href="#黄庭坚">黄庭坚</a></h3>
<h4 id="雨中登岳阳楼望君山"><a class="header" href="#雨中登岳阳楼望君山">雨中登岳阳楼望君山</a></h4>
<p>投荒万死鬓毛斑，生出瞿塘滟滪关。
<strong>未到江南先一笑，岳阳楼上对君山。</strong>
满川风雨独凭栏，绾结湘娥十二鬟。
可惜不当湖水面，银山堆里看青山。</p>
<h3 id="李清照"><a class="header" href="#李清照">李清照</a></h3>
<h4 id="清平乐年年雪里"><a class="header" href="#清平乐年年雪里">清平乐·年年雪里</a></h4>
<p>年年雪里。常插梅花醉。<strong>挼尽梅花无好意。赢得满衣清泪。</strong></p>
<p>今年海角天涯。萧萧两鬓生华。看取晚来风势，故应难看梅花。</p>
<h4 id="一剪梅红藕香残玉簟秋-1"><a class="header" href="#一剪梅红藕香残玉簟秋-1">一剪梅·红藕香残玉簟秋</a></h4>
<p>红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。</p>
<p>花自飘零水自流。一种相思，两处闲愁。<strong>此情无计可消除，才下眉头，却上心头。</strong></p>
<h3 id="秦观"><a class="header" href="#秦观">秦观</a></h3>
<p>北宋</p>
<h4 id="踏莎行"><a class="header" href="#踏莎行">踏莎行</a></h4>
<p>雾失楼台，月迷津渡。桃源望断无寻处。可堪孤馆闭春寒，杜鹃声里斜阳暮。</p>
<p><strong>驿寄梅花，鱼传尺素。砌成此恨无重数</strong>。郴江幸自绕郴山，为谁流下潇湘去。</p>
<h4 id="鹊桥仙纤云弄巧"><a class="header" href="#鹊桥仙纤云弄巧">鹊桥仙·纤云弄巧</a></h4>
<p>纤云弄巧，飞星传恨，银汉迢迢暗度。<strong>金风玉露一相逢，便胜却、人间无数</strong>。
柔情似水，佳期如梦，忍顾鹊桥归路。<strong>两情若是久长时，又岂在、朝朝暮暮</strong>！</p>
<h3 id="姜夔"><a class="header" href="#姜夔">姜夔</a></h3>
<h4 id="扬州慢"><a class="header" href="#扬州慢">扬州慢</a></h4>
<p>淳熙丙申至日，予过维扬。夜雪初霁，荠麦弥望。入其城，则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。予怀怆然，感慨今昔，因自度此曲。千岩老人以为有“黍离”之悲也。</p>
<p><strong>淮左名都，竹西佳处，解鞍少驻初程</strong>。过春风十里。尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒。都在空城。</p>
<p>杜郎俊赏，算而今、重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡、冷月无声。念桥边红药，年年知为谁生。</p>
<h3 id="晏几道"><a class="header" href="#晏几道">晏几道</a></h3>
<h4 id="南乡子花落未须悲"><a class="header" href="#南乡子花落未须悲">南乡子·花落未须悲</a></h4>
<p>花落未须悲。红蕊明年又满枝。惟有花间人别后，无期。水阔山长雁字迟。</p>
<p>今日最相思。记得攀条话别离。**共说春来春去事，多时。**一点愁心入翠眉。</p>
<h3 id="柳永"><a class="header" href="#柳永">柳永</a></h3>
<h4 id="望海潮东南形胜"><a class="header" href="#望海潮东南形胜">望海潮·东南形胜</a></h4>
<p>东南形胜，三吴都会，钱塘自古繁华。</p>
<p>烟柳画桥，风帘翠幕，参差十万人家。</p>
<p>云树绕堤沙，怒涛卷霜雪，天堑无涯。</p>
<p>市列珠玑，户盈罗绮，竞豪奢。</p>
<p>重湖叠巘清嘉，<strong>有三秋桂子，十里荷花</strong>。</p>
<p>羌管弄晴，菱歌泛夜，嬉嬉钓叟莲娃。</p>
<p>千骑拥高牙，乘醉听箫鼓，吟赏烟霞。</p>
<p>异日图将好景，归去凤池夸。</p>
<h4 id="八声甘州对潇潇暮雨洒江天"><a class="header" href="#八声甘州对潇潇暮雨洒江天">八声甘州·对潇潇暮雨洒江天</a></h4>
<p>对潇潇暮雨洒江天，一番洗清秋。渐霜风凄紧，关河冷落，残照当楼。是处红衰翠减，苒苒物华休。<strong>惟有长江水，无语东流。</strong></p>
<p>不忍登高临远，望故乡渺邈，归思难收。叹年来踪迹，何事苦淹留？想佳人、妆楼颙望，误几回、天际识归舟。争知我，倚栏杆处，正恁凝愁！</p>
<h3 id="其他-8"><a class="header" href="#其他-8">其他</a></h3>
<h4 id="满江红"><a class="header" href="#满江红">满江红</a></h4>
<p>怒发冲冠，凭栏处、潇潇雨歇。抬望眼、仰天长啸，壮怀激烈。<strong>三十功名尘与土，八千里路云和月</strong>。莫等闲、白了少年头，空悲切。</p>
<p>靖康耻，犹未雪。臣子恨，何时灭。驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。</p>
<h4 id="卜算子我住长江头"><a class="header" href="#卜算子我住长江头">卜算子·我住长江头</a></h4>
<p>李之仪 </p>
<p>我住长江头，君住长江尾。<strong>日日思君不见君，共饮长江水</strong>。</p>
<p>此水几时休，此恨何时已。<strong>只愿君心似我心，定不负相思意</strong>。</p>
<h4 id="柳枝词"><a class="header" href="#柳枝词">柳枝词</a></h4>
<p>郑文宝</p>
<p>亭亭画舸系春潭，直到行人酒半酣。</p>
<p><strong>不管烟波与风雨，载将离恨过江南</strong>。</p>
<h4 id="神童诗四喜"><a class="header" href="#神童诗四喜">神童诗·四喜</a></h4>
<p>汪洙</p>
<p>久旱逢甘露，他乡遇故知。</p>
<p><strong>洞房花烛夜，金榜题名时</strong>。</p>
<h4 id="神童诗"><a class="header" href="#神童诗">神童诗</a></h4>
<p>汪洙</p>
<p>天子重英豪，文章教尔曹；
万般皆下品，惟有读书高。
少小须勤学，文章可立身；
满朝朱紫贵，尽是读书人。
学问勤中得，萤窗万卷书；
三冬今足用，谁笑腹空虚。
自小多才学，平生志气高；
别人怀宝剑，我有笔如刀。
朝为田舍郎，暮登天子堂；
将相本无种，男儿当自强。
学乃身之宝，儒为席上珍；
君看为宰相，必用读书人。
莫道儒冠误，诗书不负人；
达而相天下，穷则善其身。
遗子满赢金，何如教一经；
姓名书锦轴，朱紫佐朝廷。
古有千文义，须知学后通；
圣贤俱间出，以此发蒙童。
神童衫子短，袖大惹春风；
未去朝天子，先来谒相公。
年纪虽然小，文章日渐多；
待看十五六，一举便登科。
大比因时举，乡书以类升；
名题仙桂籍，天府快先登。
喜中青钱选，才高压俊英；
萤窗新脱迹，雁塔早题名。
年小初登第，皇都得意回；
禹门三级浪，平地一声雷。
一举登科目，双亲未老时；
锦衣归故里，端的是男儿。
玉殿传金榜，君恩赐状头；
英雄三百辈，附我步瀛洲。
慷慨丈夫志，生当忠孝门；
为官须作相，及第必争先。
宫殿召绕耸，街衢竞物华；
风云今际会，千古帝王家。
日月光天德，山河壮帝居；
太平无以报，愿上万年书。
久旱逢甘雨，他乡遇故知；
洞房花烛夜，金榜挂名时。
土脉阳和动，韶华满眼新；
一支梅破腊，万象渐回春。
柳色浸衣绿，桃花映酒红；
长安游冶子，日日醉春风。
淑景余三月，莺花已半稀；
浴沂谁氏子，三叹咏而归。
数点雨余雨，一番寒食寒；
杜鹃花发处，血泪染成丹。
春到清明好，晴天锦绣纹；
年年当此节，底事雨纷纷。
风阁黄昏夜，开轩内晚凉；
月华在户白，何处递荷香？
一雨初收霁，金风特送凉；
书窗应自爽，灯火夜偏长。
庭下陈瓜果，云端闻彩车；
争如郝隆子，只晒腹中书。
九日龙山饮，黄花笑逐臣；
醉看风落帽，舞爱月留人。
昨日登高罢，今朝再举觞；
菊荷何太苦，遭此两重阳。
北帝方行令，天晴爱日和；
农工新筑土，天庆纳嘉禾。
檐外三竿日，新添一线长；
登台观气象，云物喜呈祥。
冬天更筹尽，春附斗柄回；
寒暄一夜隔，客鬓两年催。
解落三秋叶，能开二月花；
过江千尺浪，入竹万竿斜。
人在艳阳中，桃花映面红；
<em>年年二三月，底事笑春风</em>。
院落沉沉晓，花开白雪香；
一枝轻带雨，泪湿贵妃妆。
枝缀霜葩白，无言笑晓凤；
清芳谁是侣，色间小桃红。
倾国姿容别，多开富贵家；
临轩一赏后，轻薄万千花。
墙角一枝梅，凌寒独自开；
遥知不是雪，为有暗香来。
柯干如金石，心坚耐岁寒；
平生谁结友，宜共竹松看。
居可无君子，交情耐岁寒；
春风频动处，日日报平安。
春水满泗泽，夏云多奇峰；
秋月扬明辉，冬岭秀孤松。
诗酒琴棋客，风花雪月天；
有名闲富贵，无事散神仙。
道院迎仙客，书道隐相儒；
庭裁栖凤竹，池养化龙鱼。
春游芳草地，夏赏绿荷池；
秋饮黄花酒，冬吟白雪诗。</p>
<h4 id="玉楼春春景"><a class="header" href="#玉楼春春景">玉楼春·春景</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E5%AE%8B%E7%A5%81">宋祁 </a></p>
<p>东城渐觉风光好。縠皱波纹迎客棹。*绿杨烟外晓寒轻，*红杏枝头春意闹。</p>
<p>浮生长恨欢娱少。肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。</p>
<h4 id="八声甘州灵岩陪庾幕诸公游"><a class="header" href="#八声甘州灵岩陪庾幕诸公游">八声甘州·灵岩陪庾幕诸公游</a></h4>
<p>吴文英</p>
<p>渺空烟、四远是何年，青天坠长星？幻苍崖云树，名娃金屋，残霸宫城。**箭径酸风射眼，腻水染花腥。**时靸双鸳响，廊叶秋声。</p>
<p>宫里吴王沉醉，倩五湖倦客，独钓醒醒。问苍波无语，华发奈山青。水涵空、阑干高处，送乱鸦斜日落渔汀。连呼酒、上琴台去，秋与云平。</p>
<h4 id="唐多令芦叶满汀洲"><a class="header" href="#唐多令芦叶满汀洲">唐多令·芦叶满汀洲</a></h4>
<p>刘过</p>
<p>安远楼小集，侑觞歌板之姬黄其姓者，乞词于龙洲道人，为赋此《唐多令》。同柳阜之、刘去非、石民瞻、周嘉仲、陈孟参、孟容。时八月五日也。</p>
<p>芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。
黄鹤断矶头，故人今在否？旧江山浑是新愁。<em><strong>欲买桂花同载酒，终不似，少年游</strong></em>。</p>
<h4 id="蚕妇"><a class="header" href="#蚕妇">蚕妇</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E5%BC%A0%E4%BF%9E">【作者】张俞 </a>【朝代】宋</p>
<p>昨日入城市，归来泪满巾。</p>
<p>遍身罗绮者，不是养蚕人。</p>
<h4 id="沁园春丁酉岁感事"><a class="header" href="#沁园春丁酉岁感事">沁园春·丁酉岁感事</a></h4>
<p>谁使神州，百年陆沉，青毡未还？怅晨星残月，北州豪杰；西风斜日，东帝江山。刘表坐谈，深源轻进，机会失之弹指间。**伤心事，是年年冰合，在在风寒。**说和说战都难，算未必江沱堪宴安。叹封侯心在，鳣鲸失水；平戎策就，虎豹当关。渠自无谋，事犹可做，更剔残灯抽剑看。麒麟阁，岂中兴人物，不画儒冠？</p>
<h4 id="汉宫春梅"><a class="header" href="#汉宫春梅">汉宫春·梅</a></h4>
<p>晁冲之</p>
<p>潇洒江梅，向竹梢疏处，横两三枝。东君也不爱惜，雪压霜欺。无情燕子，怕春寒、轻失花期。却是有，年年塞雁，归来曾见开时。
清浅小溪如练，问玉堂何似，茅舍疏篱。<strong>伤心故人去后，冷落新诗</strong>。微云淡月，对江天、分付他谁。空自忆，清香未减，风流不在人知。</p>
<h4 id="西江月世事短如春梦"><a class="header" href="#西江月世事短如春梦">西江月·世事短如春梦</a></h4>
<p>世事短如春梦，人情薄似秋云。不须计较苦劳心。万事原来有命。</p>
<p>幸遇三杯酒好，况逢一朵花新。片时欢笑且相亲。明日阴晴未定。</p>
<h4 id="芳心苦杨柳回塘"><a class="header" href="#芳心苦杨柳回塘">芳心苦·杨柳回塘</a></h4>
<p>贺铸</p>
<p>杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。
返照迎潮，行云带雨。依依似与骚人语。<em>当年不肯嫁春风，无端却被秋风误</em>。</p>
<h4 id="雨后池上"><a class="header" href="#雨后池上">雨后池上</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E5%88%98%E6%94%BD">刘攽 </a></p>
<p>一雨池塘水面平，淡磨明镜照檐楹。
东风忽起垂杨舞，更作荷心万点声。</p>
<h4 id="西江月阻风山峰下"><a class="header" href="#西江月阻风山峰下">西江月·阻风山峰下</a></h4>
<p><a href="https://hanyu.baidu.com/s?wd=%E5%BC%A0%E5%AD%9D%E7%A5%A5">张孝祥 </a></p>
<p>满载一船秋色，平铺十里湖光。波神留我看斜阳。放起鳞鳞细浪。
明日风回更好，今宵露宿何妨。水晶宫里奏霓裳。准拟岳阳楼上。</p>
<h3 id="辛弃疾"><a class="header" href="#辛弃疾">辛弃疾</a></h3>
<p>南宋豪放派诗人</p>
<h4 id="贺新郎"><a class="header" href="#贺新郎">贺新郎</a></h4>
<p>邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。
甚矣吾衰矣。怅平生、交游零落，只今余几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？<strong>我见青山多妩媚，料青山见我应如是</strong>。情与貌，略相似。
一尊搔首东窗里。想渊明、停云诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人、不见吾狂耳。知我者，二三子。</p>
<h4 id="水龙吟登建康赏心亭"><a class="header" href="#水龙吟登建康赏心亭">水龙吟·登建康赏心亭</a></h4>
<p>楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺髻。<strong>落日楼头，断鸿声里，江南游子</strong>。把吴钩看了，栏杆拍遍，无人会，登临意。</p>
<p>休说鲈鱼堪脍，尽西风，季鹰归未？求田问舍，怕应羞见，刘郎才气。可惜流年，忧愁风雨，树犹如此！倩何人唤取，红巾翠袖，揾英雄泪？</p>
<h4 id="水调歌头-盟鸥"><a class="header" href="#水调歌头-盟鸥">水调歌头 盟鸥</a></h4>
<p>带湖吾甚爱，千丈翠奁开。先生杖屦无事，一日走千回。凡我同盟鸥鹭，今日既盟之后，来往莫相猜。白鹤在何处，尝试与偕来。
破青萍，排翠藻，立苍苔。窥鱼笑汝痴计，不解举吾杯。废沼荒丘畴昔。<strong>明月清风此夜，人世几欢哀。东岸绿阴少，杨柳更须栽。</strong></p>
<h2 id="明朝"><a class="header" href="#明朝">明朝</a></h2>
<h3 id="唐寅"><a class="header" href="#唐寅">唐寅</a></h3>
<h4 id="桃花庵歌"><a class="header" href="#桃花庵歌">桃花庵歌</a></h4>
<p>桃花坞里桃花庵，桃花庵里桃花仙；桃花仙人种桃树，<em>又摘桃花卖酒钱</em>。
酒醒只在花前坐，酒醉还来花下眠；半醒半醉日复日，花落花开年复年。
但愿老死花酒间，不愿鞠躬车马前；车尘马足富者趣，酒盏花枝贫者缘。
若将富贵比贫贱，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。
别人笑我太疯癫，我笑他人看不穿；不见五陵豪杰墓，无花无酒锄作田。</p>
<h3 id="归有光"><a class="header" href="#归有光">归有光</a></h3>
<h4 id="项脊轩志"><a class="header" href="#项脊轩志">项脊轩志</a></h4>
<p><strong>庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。</strong></p>
<h2 id="清朝"><a class="header" href="#清朝">清朝</a></h2>
<h3 id="林则徐"><a class="header" href="#林则徐">林则徐</a></h3>
<p>子孙若如我，留钱做什么，贤而有财，则损其志</p>
<p>子孙不如我，留钱做什么，愚而多财，益增其过</p>
<p>——林则徐家训</p>
<h3 id="纳兰性德"><a class="header" href="#纳兰性德">纳兰性德</a></h3>
<h4 id="送荪友"><a class="header" href="#送荪友">送荪友</a></h4>
<p><em>人生何如不相识，君老江南我燕北</em>。
何如相逢不相合，更无别恨横胸臆。
留君不住我心苦，横门骊歌泪如雨。
君行四月草萋萋，柳花桃花半委泥。
江流浩淼江月堕，此时君亦应思我。
我今落拓何所止，一事无成已如此。
平生纵有英雄血，无由一溅荆江水。
荆江日落阵云低，横戈跃马今何时。
忽忆去年风月夜，与君展卷论王霸。
君今偃仰九龙间，吾欲从兹事耕稼。
芙蓉湖上芙蓉花，秋风未落如朝霞。
君如载酒需尽醉，醉来不复思天涯。</p>
<h2 id="打油诗"><a class="header" href="#打油诗">打油诗</a></h2>
<pre><code class="language-text">百望山上望百度，百度大搜质量部；
上线报警谁拦截，分级发布找崔祜。
</code></pre>
<h2 id="名句"><a class="header" href="#名句">名句</a></h2>
<ul>
<li>
<p>我有江南铁笛，要倚一枝香雪，吹彻玉城霞</p>
<p>清 — 张惠言</p>
</li>
<li>
<p>流水不争先，争的是滔滔不绝</p>
<p>老子 — 道德经</p>
</li>
<li>
<p>龙盘虎踞帝王州，帝子金陵访故丘</p>
<p>李白</p>
</li>
<li>
<p>某甲虽在黄梅随众，实未省自己面目。今蒙指受入处，<strong>如人饮水</strong>，<strong>冷暖自知</strong>，行者即是某甲师也</p>
<p>景德传灯录</p>
</li>
<li>
<p>组合句</p>
<p>两句三年得， 一吟双泪流。文章千古事，得失寸心知。</p>
</li>
<li>
<p>与君初相识，犹如旧人归</p>
</li>
<li>
<p>未曾相逢先一笑，初会便已许平生</p>
</li>
</ul>
<h2 id="现代诗"><a class="header" href="#现代诗">现代诗</a></h2>
<h3 id="毛泽东"><a class="header" href="#毛泽东">毛泽东</a></h3>
<h4 id="忆秦娥-娄山关"><a class="header" href="#忆秦娥-娄山关">忆秦娥 娄山关</a></h4>
<p>西风烈，长空雁叫霜晨月。
霜晨月，马蹄声碎，喇叭声咽。
<strong>雄关漫道真如铁，而今迈步从头越</strong>。
从头越，苍山如海，残阳如血。</p>
<h3 id="余光中"><a class="header" href="#余光中">余光中</a></h3>
<h4 id="寻李白"><a class="header" href="#寻李白">寻李白</a></h4>
<p>酒入豪肠，七分酿成了月光；
余下的三分，啸成剑气；
绣口一吐，就半个盛唐。</p>
<h3 id="顾城"><a class="header" href="#顾城">顾城</a></h3>
<h4 id="门前"><a class="header" href="#门前">门前</a></h4>
<p>我多么希望，有一个门口</p>
<p>早晨，阳光照在草上</p>
<p>我们站着，扶着自己的门窗</p>
<p>门很低，但太阳是明亮的</p>
<p>草在结它的种子，风在摇它的叶子</p>
<p>我们站着，不说话，就十分美好</p>
<h2 id="成语"><a class="header" href="#成语">成语</a></h2>
<ul>
<li><strong>宠辱不惊</strong></li>
</ul>
<h2 id="文言文"><a class="header" href="#文言文">文言文</a></h2>
<ul>
<li>
<p><strong>东食西宿</strong></p>
<p>齐人有女，二人求见。东家子丑而富，西家子好而贫。父母疑不能决，问其女，定所欲适，难指斥言者，偏袒，令我知之。女便两袒。怪问其故。曰：“欲东家食，而西家宿。”此为两袒者也。</p>
</li>
<li>
<p>君子之泽，三世而衰，五世而斩</p>
<p>语出孟子。【君子之泽，五世而斩；小人之泽，五世而斩】</p>
</li>
<li>
<p>一曲肝肠断，天涯何处觅知音？</p>
<p>出自功夫</p>
</li>
<li>
<p>风赋</p>
<p>夫风者，天地之气，溥畅而至，不择贵贱高下而加焉。</p>
</li>
</ul>
<h2 id="英文"><a class="header" href="#英文">英文</a></h2>
<ul>
<li>Follow excellence, success will follow you</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="王德峰坛经十品"><a class="header" href="#王德峰坛经十品">王德峰坛经十品</a></h1>
<h2 id="资源"><a class="header" href="#资源">资源</a></h2>
<ul>
<li>B站视频 <a href="https://www.bilibili.com/video/BV1uZ4y1D787">复旦大学教授王德峰解读《坛经》横屏4K精修</a></li>
<li>文稿 word 版本 <a href="https://pan.baidu.com/s/1V8YaIEdluBFCWwwzGqOOSw">百度网盘</a> 8888</li>
</ul>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<h3 id="中国思想史概要"><a class="header" href="#中国思想史概要">中国思想史概要</a></h3>
<p>在这样一个非常的时代，在这样一个中国社会转型最关键的历史时期，我们都在改革开放几十年当中，我们都为国家做了事情，也为自己做的事情，但折腾很大。今天中华民族最根本的问题是没有精神家园。我们从一个物质上普遍不满足的时代，进入了一个精神上普遍不安宁的时代。每一个民族都要找到自己安心立命的根本，西方人如何安心？靠对上帝的信仰，以对上帝的信仰来立心。那么中国人如何安心？就靠我们自己这个心，以<strong>本心立命</strong>，这是中华民族跟其他民族不同的地方。</p>
<p>除了中华民族之外，你看这个世界上所有的其他民族，无一不是依靠宗教的。西方是基督教为主；阿拉伯世界是伊斯兰教为主；印度现在不是佛教，是印度教；非洲都有部落宗教。总而言之，无一不以宗教来立他们的信仰，只有一个民族不是靠宗教的，靠的是<strong>哲学</strong>。（可以说靠的是“道”）</p>
<p>我们汉语当中本来没有。是近代日本学者西周在《尚书》当中找了一个“<strong>哲</strong>“字，把一个“学”，再跟它连起来翻译西方的philosophy。“哲学”这个词就出现在现代汉语当中了。但是西方所讲的哲学跟中国的哲学性质上是根本不同的。西方哲学的主题是知识。先解决知识问题，再解决人生问题。探讨这个关于外部世界的客观、可靠、有效的知识，它是如何可能的。客观知识的前提、方法和基础，是西方哲学研究的主题。中国哲学的主题就是<strong>人生</strong>，<strong>人生问题</strong>解决了再解决<strong>知识问题</strong>，这正好跟西方哲学倒过来。西方哲学不是不讨论<strong>人生问题</strong>的，但是他们先要解决<strong>知识问题</strong>。他们认为解决知识问题是解决人生问题的前提，就像苏格拉底那句话“美德即知识”。</p>
<p>所以我们中国的哲学走了跟西方哲学不同的道路，学界因此就有人怀疑，我们能否称我们本民族的论道的学问，能称它为哲学吗？中国无哲学，这也是一种观点。但是我觉得不要计较词的用语、用法。就是说我们实际上中国自有自己的哲学，为什么说中国的思想也能称哲学？哲学跟宗教的区分是什么？我们不是个宗教的民族，我们中华民族是哲学的民族。</p>
<p>那么哲学和宗教的区分是什么呢？宗教要把对神的信仰作为前提的，先信仰再理解，再理解教义。那么哲学不树立一个超越的神，所以中华民族不以对神的信仰来立心，我们这个民族没有上帝管人心。所以中国价值里边不可能也不能把宗教的观念放进去，美国价值就一句话，刻在美元的硬币上，英语是这么说的：“IN GOD AND LIBERTY WE TRUST”。God就是上帝，liberty就是自由，把这句话翻译成汉语就是“我们信仰上帝和自由&quot;。因为美国是个新教国家。</p>
<p>那么中国价值里面不包含对神的信仰。中国哲学是个大概念，主要的组成部分：儒、道、佛三家。我们现在通常都把佛教当宗教看了，其实它不是宗教。因为<strong>佛教是无神论的</strong>，无神论的唯心主义。释迦摩尼是个普通的人。梵文当中有一个词叫“Buddha”，翻译成汉语就是“<strong>佛”</strong>，“Buddha”这个梵文的单词本意就是<strong>觉悟者</strong>，佛就是觉悟了的人，所以他不是神。所以佛教严格来说根本不是宗教，但是他在民间获得了宗教信仰的形式而已。我们拜佛的时候把他当神拜了，祈求他的保佑，祈求它赐福与我们，这是像宗教了，但他违背了佛教的本意。</p>
<p>释迦摩尼圆寂之前最后一次说佛法是应他的一个弟子的请求。这个弟子跟佛陀讲，因为佛陀已经宣布了自己很快就要圆寂了。弟子终于急了就跟佛陀讲，我追随你那么多年，你从来没有为我说过佛法。如今你要走了，你能不能也为我说一次佛法呢？佛陀认为他这个要求是有道理的。他说好，你要听我为你佛法，你现在坐下来我给你讲。释迦摩尼说我现在跟你说佛法，这佛法就是。我从悟道以来所说的一切佛法，都是每个人本都具备的，这就是我要跟你说的佛法。</p>
<p>这句话一说出来，那个弟子当下开悟。它表明什么？表明佛教不是宗教。释迦摩尼所说的佛法是人心本自具备的，只是被遮蔽了。遮蔽了。我们的生活就到处是烦恼，种种的妄念遮蔽了我们本心，这是先要说明的一件事。</p>
<p>当然现在一般的习惯，包括政治上都还是把佛教当宗教看了。世界上三大宗教：基督教、伊斯兰教、佛教。这个“大”就是指信仰的人多，信仰很多的，信仰基督教的人，世界上人口比例也高，伊斯兰教的人口比例也高，佛教的比例也高，亚洲东南亚许多佛教国家。这是在这个意义上，把它列为了三大宗教之一，世界上。其实它不是宗教，我们中国人确实也有些佛教徒是像信仰宗教一般的信仰佛教。那么当然无可指责，他们也非常认真，认真地修行，勇猛精进，让我们旁人觉得很值得佩服。</p>
<p>但是我们每一个中国人，其实都应该学佛的。我今天来到这里了，我们跟大家有这样一个缘分，在这个集贤元典会上，我们有多次的机会来交流。那么我先要声明的一点，学佛其实我们的目标是很明确的，就是<strong>见性成佛</strong>。那么成佛是在物的那一刻发生的。我要声明的一点，我在这里不敢说讲经说法。你敢说你在讲经说法的话，你至少要有实证。什么实证呢？底下无论听你讲经说法的人有多少，多还是少，至少要让其中一个开悟吧。我是不敢担保我能让你们开悟的。第一，我还没到，自己还没有悟呢。下根之人、小根之人嘛没办法。第二个，各位的悟，包括我自己的悟，都要一个缘，这叫“<strong>悟缘</strong>”，悟要有缘的。</p>
<p>《坛经》当中第7品叫《机缘品》，讲了12个例子。机缘就是抓住了这样一个人的特征。一个禅宗祖师，抓住了前来问佛法的人的根本特征，又抓准了这样一个场合这样一件事情，这个场合这件事情叫<strong>缘</strong>。抓准了，这叫抓住了<strong>机缘</strong>，那么说话要对机，就是面对着前来问佛法的人，抓住他的根本特征，说话投他的机。话不投机半句多，对准它的机说话要锋利，这叫“<strong>机锋</strong>”。有可能让那个人悟，我没这个本事的。各位呢，悟缘是否成熟了也不知道，所以先要声明一条，我们大家一起读《坛经》，要看各自的<strong>悟缘</strong>，包括我自己的<strong>悟缘</strong>。但是我们的目标还是要明确的。虽然不能、不敢奢谈、扯谈这个“<strong>悟</strong>”的可能，我们至少要做到一件事情，这就是我们一起读《坛经》想要明确的目标-一就是起<strong>正知</strong>、<strong>正见</strong>。</p>
<p>我敢这么说，包括我王德峰在内，生活在这世界上大多数情况下我们所起的都是邪知、邪见，不是<strong>正知</strong>、<strong>正见</strong>。我们还每每以为自己这个邪知、邪见是正知、正见的。因为没学过佛的缘故。以为自己如此正直的一个人，做事情是那么认真，那个目标是正当的。我这样的想法，这样的跟人打交道全是正知、正见。拿佛教的境界照一照，一看，都是邪知、邪见。因为全是邪见，我们就烦恼不断，烦恼在佛教里就叫<strong>尘</strong>，灰尘。这个人世间到处都是烦恼，所以这个世界又被称为“<strong>尘世”</strong>。</p>
<p>我们一起读《坛经》最起码的目标，我们应该努力的就是起<strong>正知、正见</strong>，破邪知、邪见。如果有这样的目标能够达到，我们大家聚在一起，每月一次的，也就没有浪费时间。</p>
<p>中国的思想发展非常的有意思。我们首先这个民族是一个伟大的民族。因为公元前五世纪左右，世界上有四个民族为人类打开了四种思想和智慧的境界。一个是我们中华民族，在先秦的时候，也就是公元前5世纪，为人类提供了孔子和老子；一个古代希腊，也在这段时间为人类提供了苏格拉底和柏拉图；一个古代印度，也在这段时间为人类提供了释迦摩尼；一个古代以色列，也在这段时间为人类提供了犹太教最初的先知人物，这批人人很多，姓名无法考，他们打开了东方犹太思想的境界。所以人类的思想和智慧就四种境界，没有第五种，也不是只有一种。所以我们中华民族是有福气的。我们是这四种思想和智慧境界中的一种的开启者。我们打开了儒家和道家的境界，释迦牟尼打开了佛学的境界，古希腊的苏格拉底、柏拉图打开了哲学的境界，古代以色列打开了犹太思想的境界。</p>
<p>这件事情先清楚，所以叫公元前5世纪就有一个名称叫“<strong>轴心时代</strong>”。先秦，是中国思想的开端，先秦之后，经过短暂的秦朝，秦朝就二世而亡的，到秦始皇儿子手里就维持不住，然后天下大乱。秦朝走了法家的道路，终于不行。西汉初年采取黄老之术，无为而治，这叫与民休息。但是终于这个民族还是必须建立它的社会秩序的根据理论，就思想根据，要论道。</p>
<p>于是到汉武帝的时候，就两个人物联起手来，一个政治家汉武帝，一个思想家董仲舒。联起手来，罢黜百家，独尊儒术，从此儒家成为道统。西汉、东汉，两汉中国思想的重点，集中在为建立典章制度而寻找学术的根据，叫<strong>经学</strong>。</p>
<p>从儒家的经典当中，去寻求建立典章制度的依据，这时候的特征叫经学。东汉末年，天下又乱，三国纷争，就进入魏晋时期，已经建立起来的典章制度不能被遵守了。礼崩乐坏，第二次礼崩乐坏。第一次东周末年，第二次又天下大乱，那么中国知识分子纷纷躲到道家学说里去了，要全身避害，得个人的自在。所以魏晋时候，中国思想的特征是玄学，玄学就是道家的学说，集中精力研究三部经典，道家的经典。一部《周易》，其实《周易》也是儒家的经典。一部《周易》，一部《老子》，一部《庄子》，合起来叫<strong>三玄</strong>，那就是魏晋玄学。但道家的思想救不了中华民族的文化生命，道家叫每一个人避开这乱世，求个人的自在。</p>
<p>所以魏晋时期，虽然学术上有精彩的地方，就玄学的研究取得很高的成果，还有一批魏晋文人身体力行展示出潇洒风流的人格，这也是蛮精彩的一段，叫魏晋名士。《世说新语》大家去看都会看到，非常精彩。我们今天的人离开魏晋名士的人生境界还蛮远的了，但是毕竟不能挽救衰弱的文化生命，于是终于我们迎来了一次很好的机会。</p>
<p>我们两汉之际从印度传到中国的佛经，经过好几个世代。中国知识分子的努力，翻译、理解、消化、吸收。到了唐朝的时候终于做成了一件伟大的事情--让佛经说汉语。让佛经说汉语就是把佛陀的思想融入中国思想了，并没有完全做到这一点，但基本做到了。</p>
<p>有些的佛教佛经中的观念，在汉语当中直到今天找不到合适的词，所以仍然用声音来翻译的。音译的，比方说“三昧”、“般若”，唯识宗讲的“末那识”、“阿赖耶识”等等，这一切都是用汉语的发音来音译梵文的单词。这种情况还是存在，但基本上让佛经说汉语了，这件事情非常伟大。一个想要挽救自己衰落的文化生命的民族，终于得到了另外一个民族的思想和智慧的启发，得到了佛陀思想的启发。所以隋唐的时期，中国思想的特征就是佛学。有了隋唐这段重要的思想发展的时期，也就是得佛学思想启发的时期，才为后来中国思想的再一次高峰做了准备。再一次高峰就是宋明新儒学。没有隋唐的佛学，就没有宋明新儒学。因为宋明新儒学是儒、道、佛三家合流了。以儒为根本，融合了佛家和道家，终于实现了儒、道、佛三家合流。无论是程朱<strong>理学</strong>，还是陆王<strong>心学</strong>，都是儒道佛三家思想的合流。</p>
<p>这个儒家终于叫新儒家了，跟先秦时候的原儒不一样。因为吸收了道家，更重要的是得佛学的启发。宋明新儒学最高成果：陆王<strong>心学</strong>，就是陆象山、王阳明的<strong>心学</strong>，把中国哲学推向最高峰。后来就是衰落，到近代就是学西方，大致这样一个发展的脉络，我勾勒了一下。从此脉络当中，我们可以体会到佛教对中国的重大意义了。它融入中国思想的标志是什么？一、进入汉语，二、进入了普通民众的内心，否则不能言中国化。</p>
<p>让佛家的思想进入中国老百姓的内心去，这件事情做了最根本的贡献的就是惠能。所以我们今天的中国人，只要说汉语，你哪怕不识字是个文盲，从来不可能去读儒道佛三家的经典。你仍然在儒道佛三家的思想里，你也在佛家的思想里，因为你说汉语。比方说有一个词，我们今天中国人经常要用，叫“缘分”。我跟你说一句话“我遇到你真是缘分啊”，你立刻明白了，这个词是无法翻译成欧洲语言的。比方说你翻译成英语，你试试看，翻不过去。</p>
<p>为什么？在“缘分”这个词里边，它既表示偶然性又表示必然性。我遇到你，我们彼此的相遇，并不是预先计划好安排好的，我们叫不期而遇，这是偶然性的。但他“缘分”同时表示必然性，中国人还说这样一句话，有缘千里来相会，我之间哪怕有千里之隔，我们终会见面的，这是必然的。中国人还说500年修来同坐一条船，同坐一条船的缘分，居然是五百年修成的，可见是必然的了。你在英语当中一定找得到一个词，表示偶然性，contingency，你也找得到另外一个词表示必然性，necessity，但你绝对找不到这样一个词，它既表示偶然性又表示必然性，所以翻译不过去。“缘分”二字，居然把一对对立的范畴统一在其中了，偶然性必然性是对立的范畴。</p>
<p>我举这个例子表明什么？你只要说出缘分二字，你已经在佛家思想里了。所以佛家的思想经过了中国化，融入了中国思想，又进入了老百姓的内心深处，这才叫真正的中国化。大量的词，如果不是翻译佛经，汉语当中并不存在。“觉悟、因果、业力、思维、意识、真理、境界、心心相印”等等这些词语本来在汉语中根本没有，因为翻译佛经的缘故，都进入了汉语的，汉语当中多了这一大堆词。还有那么多成语，比如说“百尺竿头更进一步”，禅宗的思想。你跟老外讲他听不懂的，你爬到了竹竿顶上，你还能进一步吗？你进到哪里去呢？我们中国人全知道“百尺竿头更进一步”，佛家的禅宗的思想，我们在读《坛经》的时候都会讨论到这一句。所以学佛这件事情是每个人中国人都应当做的事。</p>
<p>我们在科学中，不等于在思想中；我们在知识中，不等于在智慧中。人总得解决一个问题，什么问题？人如何安排好自己这个最难安排的生命。这个心灵的安顿，是每个人都面对的问题。因为人生的问题就是：我们有无限心，我们的心有无限的一面，它如何安顿？使人生成了问题，有问题才有学问，学问都是因为问题引起的。</p>
<p>现在我们说的是人生问题，那么它就引起了中国哲学，引起了儒家，引起了道家，也引起了释迦摩尼的佛学。这个问题不是我们人类的头脑虚构出来的，我们的人生是问题，不，他就是问题。我们向来在这个问题里的。</p>
<p>所以孔子说的是对的，“不仁者不可以久处约，不可以长处乐”。“<strong>约</strong>&quot;，就是节约的&quot;约”，表示<strong>贫贱的生活处境</strong>，“<strong>乐</strong>”，就是快乐的乐，表示<strong>富贵的生活处境</strong>。“不仁”者什么意思？心中无仁之常体。仁义道德的“仁”，心中无仁之常体的人，你给他怎样的生活处境都没用，不可以久处约，贫贱受不了——贫贱难耐凄凉，不可以长处乐，富贵也受不了的——富贵不能乐业，这叫左也不安，右也不安，这叫<strong>不仁者</strong>。</p>
<p>所以每个人其实都面对一个如何安顿好自己这个无限心，这样一个人生问题。人生是麻烦的，真是很麻烦。生活中到处都是烦恼，外部，呃，我们生命的外部麻烦容易解决，我们安排好一个适合人类生存的环境，各种文明都做这个事的，无论古代还是近代的文明，都要先做这件事。但生命外部的麻烦解决了，生命内部的麻烦最难处理。所谓征服世界容易，征服自己难。这就是我们讲中国哲学起来了，先前只是儒家、道家，后来来了佛家。到隋唐的时候，完成了佛学中国化。我们中国人哲学是人生哲学，它就三个方面：<strong>儒家、道家、佛家</strong>。</p>
<h3 id="在中国文化中的地位"><a class="header" href="#在中国文化中的地位">在中国文化中的地位</a></h3>
<p>人是最麻烦的事情。人最可爱也最可恶。人可爱的一面它可以往上走的，它的境界往上走，上通神圣，成圣成贤；它也可以往下堕落，下坠恶道，禽兽不如。这总有一个根源吧，佛家揭示这根源，儒家也揭示这根源。人为什么最可爱也最可恶呢？根源在于我们的生命情感不合适。我们活在这个世界上总是喜怒哀乐，爱爱恨恨。人生就这样，人是最高的有情物。生命情感的最高境界在人那里，不在动物那里的。动物也有一些情感，高级动物。他们也叫<strong>有情物</strong>，所以佛家的意思对一切有情物都要慈悲。但最高的有情物是人。最高的有情物最麻烦也是他的生命情感，不会合适的爱，也不懂得合适的恨。</p>
<p>所以孔子说“唯仁者”，心安顿好的仁者，“唯仁者”才能合适地爱，才能合适地恨。“唯仁者才能爱人，能恶人”，“恶”就是恨，这都合适。不合适是什么情况呢？爱一个人，爱之欲其生，恨一个人，恨之欲其死，人间的罪恶就来。所以生命情感的调适、升华就是来解决我们的心的问题。</p>
<p>心和头脑有区分。头脑里活动的是概念、判断、推理，掌握经验、掌握知识，趋利避害。心里边活动的是<strong>生命体验</strong>。解决头脑的问题就是<strong>增加知识</strong>，并不能解决心灵的问题。某人恋爱了，后来失恋了，失恋是很大的痛苦，他无法排解。后来找一个知心的朋友来倾诉他这份失恋的痛苦。那么知心的朋友听了他的陈述之后也很同情他的，想劝他把这件事情放下，想想看该怎么劝？没办法劝。后来知心朋友蛮聪明的，他想出来一句话跟失恋的人这么说：“你要知道，天涯何处无芳草？”那个失恋的一听，头脑想通了的，因为这些这句话完全符合理性。他的潜台词就是，你如此钟爱的女子现在离你而去了，你很难过我能理解。但你要知道，他并不是世界上唯一的女子啊！所以知心朋友说了这句完全合乎理性的话，诉诸失恋者的头脑。这个失恋的人头脑想通了，他头脑做出一个决定，把这件事情放下。他刚刚做好这个决定，心里又阵阵的难受起来。就像李清照那首词所讲的：“此情无计可消除，才下眉头，却上心头。”下来眉头，叫头脑想通了呀，“却上心头”，心里又来了，这就是头脑和心的区分。</p>
<p>所以很简单，<strong>头脑</strong>里活动的是<strong>概念、判断、推理，心</strong>里边活动的是**生命情感、生命体验。**我们试想一下，我们是否可能用我们头脑中的概念、判断、推理，把我们心理的生命体验给它消解掉了？消解得掉吗？消解不掉！头脑与心的区分明白了，再问一个问题：哪一个更根本呢？是头脑更根本还是心更根本呢？心更根本！所以这是中国哲学最了不起的地方，它最精彩的地方就直指人心。</p>
<p>今天的年轻的一代，由于这样一个充满竞争的时代和社会，经常会患许多心理疾患：焦虑症啊、忧郁症啊。那么他们就请心理医师帮助了。所以心理咨询是一个很盛行的行业，心理医师们怎么帮助他们呢？第一件事情，听他的陈述。他把自己准备好了，那是个垃圾桶，你什么垃圾都往里面扔吧，我很耐心地听着呢。听得差不多了，那么现在心理医师给他建议了，几条建议，这些建议的原则无非叫他怎么转移注意力。一开始还有效，后来终于还是没效。没效就最后一招在口袋里。心理医师最后一招就在他的口袋里有药。服了那个药，心里就舒服了，久而久之，患上了药物依赖症，问题还是没有解决。</p>
<p>我向来以为这样的年轻人，根本问题的解决不是找心理医师，要读像《坛经》这样的书，根本上解决一个人的生态度问题。人生态度没解决你怎么办？而人生态度的解决就是心灵的生命情感的升华。放下那个<strong>小我</strong>吧，你焦虑、你忧郁，无非围绕着一个<strong>小我</strong>转的。这个<strong>小我</strong>是什么呢？佛经当中最短一部经叫《心经》，我们都应该背得出来，260个字。“观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，渡一切苦厄。”什么叫<strong>五蕴</strong>？就是平时我们这颗心呀，色、受、想、行、识五个方面，我们把这个心当真了。然后守住它，围绕着它，执着于它。哪有不患焦虑症、忧郁症的呢？人生态度没有树好，这个<strong>小我</strong>总放不下嘛。所以我们要回归我们中国的哲学，也就是回归儒、道、佛三家的思想。</p>
<p>这个民族又要论道了，整个民族论道，每一个民族成员、我们个人的生活也逼得我们要去论道，要去体会伟大的人文经典，中国的人文经典，根本上解决一个<strong>安心</strong>的问题。达摩初祖来到东土，就是在中国要传心法，到了惠能叫第六祖。禅宗第一祖就是达摩，印度人。到了中国以后很快就发现自己很孤独，心法无法传呐。他遇到梁武帝，他要度化梁武帝，他想。两个人交流了，梁武帝是笃信佛教的。那么交流之下梁武帝就先问了达摩一个问题，他说我这一辈子不知造了多少庙，供养了多少和尚，这功德大不大？达摩直截了当地跟梁武帝说这不叫<strong>功德</strong>！然后梁武帝听了就心里不舒服，两个人不投机，不投机就没办法了。那么达摩也就放弃了度化梁武帝的愿望。梁武帝也就觉得我跟达摩没什么缘分，各自走开。当然梁武帝也不会去干扰达摩。因为他毕竟是笃信佛教的皇帝，所以各自走开了，所以达摩是蛮孤独的。</p>
<p>有一个人来找他，这个人叫慧可。慧可后来成了第二祖的哦。这个慧可呢要找达摩，达摩也不大相信你真心来找我嘛。为了表达自己强烈的愿望，为了表达自己求佛法的强烈的愿望，慧可居然断了自己的左臂。断了左臂之后，达摩看到他的真诚了，就跟他交流了。结果慧可跟达摩讲：“我心不安，乞师与安。”祈求你师傅啊，帮我来安心啊。达摩说：<strong>安心</strong>，好啊，你要安心，好啊。把你的心交给我，我给你安。这是达摩对他的回答。安心好啊：“把汝心交给我，我与汝安！”慧可回答了：“欲求自心，了不可得”。你叫我把心交给你，拿出来交给你，我找不到他呀。达摩马上回答：“吾与汝安心竟。”我已经帮你把心安好了。</p>
<p>这种对话各位可以在《五灯会元》里找到，禅宗公案当中的一条。我们要参一参是吧？达摩提出来的这句话是非常厉害的，你要安心可以呀，你把心交给我，我帮你安。他要慧可把心拿出来，慧可找不到，这事情大了。他就直接说了“欲求之心，了不可得”。达摩一下一句话就来，不啰嗦的哦。“吾与汝安心竟。”</p>
<p>我就把你心安好了，慧可当下大悟。我们平时要安的<strong>心</strong>是什么东西呢？其实都是“<strong>念</strong>”，比方说我做副教授，假定哦，做到现在十年了，还没有升教授。难过啊。眼看如果明年再升不了教授，我就以副教授退休了，你知道吧？这个事情不安哪。我们有种种的念都没办法安，其实它不是心，是<strong>念</strong>。所以这个达摩就跟慧可讲，你把心拿出来，他都拿不出来，他发现他要去安的东西，全是这些起起伏伏、生生灭灭的“<strong>念</strong>”罢了。你既然知道找不到心，我就帮你安好了。慧可大悟，言下大悟啊。</p>
<p>想想看，“<strong>念</strong>”从哪里来的？<strong>念</strong>由<strong>心</strong>起的，但我们别把<strong>念</strong>当<strong>心</strong>，如果这些<strong>念</strong>是给我们带来烦恼的，我们要找的是<strong>心</strong>本身的根源，<strong>心</strong>本来不需安，但<strong>心</strong>的用法不对，用出<strong>妄念</strong>来了，问题的要点在这里。就是心有两种用法，一种用法用出烦恼，还有一种用法用出智慧。</p>
<p>所以佛陀的思想，特别是他后来开了传心法的一路，就让禅宗最初的萌芽出现了，就是灵山法会。在那场灵山法会上释迦摩尼说佛法突然不说了，拈花一笑。底下一个迦叶尊者会心一笑。这一刻叫心心相印。叫第一次传心法，传的是心法。这样就开了禅宗的源头，开了禅宗的源头。所以佛教的思想进入了中国，中国人这时候真是要面对一个安心的问题，文化生命的衰落，在道家的思想境界里，心其实也安不了的。他们只能是什么？这个叫””越名教而任自然”，超越儒家的名教，自然率性地生活而已。但是心其实也是没安好的。这一点王阳明本人最有体会。</p>
<p>王阳明少年的时候，想要做圣贤嘛。后来又听了一个学者，大师级的学者跟他讲，你可以学程朱<strong>理学</strong>的。有学圣贤的道路可循的，有路可寻呐。后来就是格物啊，格那个竹子格了七天。没格出天理来，倒是格出一身病了。这件事我们都知道，后来怎么办？一生病没办法，躲到道家学说里要养生去了。道教养生，后来还是不行，想要学佛。甚至想要到一个山上去，一头扎到佛门的思想里去。后来他发现心还是没安。</p>
<p>当然，当时王阳明是不是接触禅宗的，后来知道是接触禅宗的。禅宗给他校大的启发，但是他心还是没安好的原因是什么？后来他发现佛教的目标跟儒家的目标根本是不一样的。佛教的目标是<strong>了生死</strong>，儒家的目标是<strong>天下关怀</strong>，然后他又从佛家里面出来，但禅宗深刻地影响了他。龙场驿站，在龙场，他做驿站站长，就贵州龙场，他在那里悟道。那一天晚上半夜里，王阳明就是顿悟的哦，他之所以能顿悟，是因为什么？修了禅宗了。</p>
<p>所以指向安心的问题，在道家思想里安不了心，由于佛家的启发，然后新儒家来。我们这样一个集贤元典会，讲了要读两本书，一部是《坛经》，一部是《传习录》。我们不能先读《传习录》的，这不光是一个时间顺序的问题。我们不读《坛经》，是读不懂《传习录》的。为什么呢？因为王阳明是谁？儒家中的惠能。他其实就是惠能，但他用的语言是儒家的语言。他指向的做圣贤的目标是儒家的目标。佛家的目标是成佛，成佛什么意思？<strong>摆脱、解脱生死的苦恼，叫涅槃的境界</strong>，**涅槃的境界叫不生不死，那叫成佛。**所以王阳明是儒中的惠能，所以不懂《坛经》，如何懂得了《传习录》呢？所以这样我们这个顺序就是确定下来了：先《坛经》后《传习录》，有这个缘故。</p>
<p>好，这一大堆话全是开场白。那么下面我们言归正传，我们要读《坛经》了，读《坛经》之前，先讲禅宗它的大纲是什么？禅宗大纲是十六个字：“<strong>教外别传，不立文字，直指人心，见性成佛。</strong>”</p>
<p>佛教传到中国来，两汉之际佛教进入中国，经过一段时间有各种的宗派起来。有些是直接从印度，基本上未加改变地被继承下来的宗派，像密宗、律宗、三论宗都没有中国化，还有唯识宗。还有其他宗派，开始逐渐进入中国化，那么各种宗派都是从借助一本或两本佛经做根据，来解释佛教的教义。唯独禅宗，它在各种教派之外，不以某一个方面的佛教，释迦摩尼的教义，做根据来立它的派，这叫“<strong>教外别传</strong>。”</p>
<p>“<strong>不立文字</strong>”，佛经是要的，但是真理并不在佛经的文字中，不立文字。“<strong>直指人心，见性成佛</strong>”。传心法就是要超出文字才传得过去。心法又叫秘意，心法、秘意不在文字里的。但是禅宗也是要说话的。最奇怪的事情是什么？最主张不立文字的禅宗，留下的文字最多。看来自相矛盾，其实不矛盾。禅宗总是跟你说话，就一句一句地逼你，你回应一句，他又抓到你的问题了，最后让你没有立足之地。他是用文字，说话也是有文字的，虽然没写出来，用文字来逼，逼到不可说那一刻，心法传过去。</p>
<p>我们打个比方，攀登城楼要梯子的是吧？我们爬梯子登城楼，到了城楼顶上，我们这梯子自然撤了。我们就把语言比喻为登城楼的梯子，倘若你登到城楼上的话，你还在梯子上，没到城楼顶上。所以先前说话是必要的，就是爬，攀登城楼，到顶上终于没办法说，到不可说那一刻，心法传过去，那叫直指人心。“<strong>直指人心、见性成佛</strong>。”</p>
<p>这是十六字大纲，禅宗的特色，每一个宗派都有它的特色。人们都说<strong>净土方便，密宗诉胜</strong>。这两宗都有各自的优点、长处，净土的长处是方便，那叫方便法门了。净土宗怎么修？念佛，所以这一宗又叫念佛宗。每天念几千遍：“南无阿弥陀佛”，几十年如一日，有什么可能呢？仰仗佛力，横超三界，到达净土，虽然还没有悟哦。到了西方净土，因为那里条件好，再听佛法，就悟了，叫花开见佛，这是净土。所以修的人是认认真真修几十年，净土也有修成了的。修成的标志，就了生死，知道自己什么时候走啊，走了以后摆脱六道轮回，叫<strong>横超三界</strong>，这叫净土方便。密宗呢？<strong>殊胜</strong>，特别有优势，什么意思？他有神通，密宗是修神通的，当然修得很艰难。根器好的修得短一点，根器差的几十年闭关，20年闭关，20多年闭关的都有，出来真有神通。神通是实证的，6个神通，天耳通、天眼通，神境通、宿命通、他心通，漏尽通。这个神通也不是假的，他也是能实证的，所以我们就不去多讲。</p>
<p>现在藏传佛教密宗很厉害，藏密，修神通修成的真不少的，当然现在到汉族地区骗人的也不少，真的上师也是有，确有神通。那么所以密宗的修行的原则，叫<strong>即身是佛</strong>。我们的肉身，在佛教里叫色身，要把它修成法身，即有神通。色身就是肉身、就是肉体啊，要把它修成法身，这样<strong>即身是佛</strong>。那么我们看看禅宗，禅宗叫什么？<strong>即心即佛</strong>。所以直指人心啊，成佛之关键是<strong>转识成智</strong>。</p>
<p>这是心的事情。我们平时的心是假的，叫<strong>业识，业力造成的识</strong>。我们有种种的期待、焦虑、希望、绝望、恐怖等等，都是<strong>识</strong>，也是要把它转成智，<strong>转识成智</strong>，路径好多。不同的宗派就是修行的不同的法门，最终目标都要<strong>转识成智</strong>。那么禅宗是舍去了其他各种宗派的各种复杂的繁琐的程序，都撇开了，<strong>直指人心</strong>。所以这种法门叫<strong>般若法门</strong>。每一种宗派都是修行的法门。</p>
<p>所以这里顺带说一下，佛经不能把它当理论著作来读的，而是<strong>实践</strong>，就是<strong>学佛的实践的道路，叫法门</strong>。你把佛经当理论著作来研究也可以，那叫学者的事，禅宗最反对这样做。别把佛经当成是一大堆知识，他是<strong>法门，是实践的道路</strong>，是这个意思。</p>
<p>那么不同的宗派，是不同的法门，禅宗是什么法门？<strong>般若法门</strong>。般若是最高的智慧。中国人一直以前不懂什么叫般若，所以用声音来译，直到今天还是一样，<strong>般若智</strong>。这一点明了了。禅宗是修智慧的；密宗要修身，即身是佛，然后有神通；净土宗只是念佛，坚持不懈，以便横超三界，大致做一个说明哦。所以我们进入了《坛经》的阅读，就是进入禅宗。</p>
<p>那么禅宗的16个字。我们把这书打开看一看。第一品，从弘忍法师那里得了衣钵的惠能，隐居了15年。15年之后，出头露面在广州法性寺，在广州法寺时他才剃度出家的。后来转到了曹溪，在现在的韶关市城里边有一个庙叫大梵寺，第一次说佛法。《行由品》第一，就讲这个第一次说佛法。应当时一个刺史的要求，请求，魏刺史。</p>
<p>前面两段我们先不管，看第三段，第一页，这页码跟大家一致吗？应该是。</p>
<p>你们是精装本的，是吧？第一页的倒数第二行说：“大师告众曰：善知识，菩提自性，本来清净，但用此心，直了成佛。”<strong>菩提就是最高的觉悟，叫无上正等正觉</strong>，最高的觉悟。这种觉悟是领会虚无的觉悟，叫般若智。</p>
<p>“菩提自性”，每个人都有，而且他“本来清净，但用此心，直了成佛”。开宗明义第一句话，就说出禅宗是<strong>修心的，修智慧的，是直指人心的</strong>。但用我们自己的心，“直了成佛”，“直了”两个字表示顿悟，直了两个字就是<strong>顿悟</strong>。</p>
<p>前面我在白板上写了16个字是禅宗之大纲。禅宗后来就分了两派，北派的和南派的。北派的领袖神秀，南派的领袖惠能。神秀主张<strong>渐悟</strong>。惠能主张<strong>顿悟</strong>。所以惠能这里的16个字是禅宗当中的顿教的大纲，顿教大纲主张顿悟的。“直了“二字就是这个意思。“直了”就是<strong>顿悟</strong>。好，这样我就做了一个基本的交代。</p>
<p>佛教对中国的意义，对每个中国人的意义，我们不是去研究佛学，我们是学佛。我们要把“佛学”两个字倒过来的哦，我们不是做佛学，我们是<strong>学佛</strong>。佛学是大学里教授的事，我们复旦哲学学院就有佛学专家，有的人做了一辈子的学者，研究佛学从来没学过佛。所以把<strong>佛学</strong>倒过来<strong>学佛</strong>，**学佛是生命实践。**然后我们讲了这个禅宗，禅宗是佛学中国化的最高成果。</p>
<p>所以我们毛泽东那句话说得很到位的，他说：“唐代出了一个唯心主义哲学家，六祖惠能，他被视为禅宗的真正的典籍人，但他是文盲。他的《六祖坛经》是非常深刻的，是人民群众的佛经。”这句话的最后一句话最到位。我们的毛主席对以往的中国思想史上的人物批评的多，表扬的少，是吧？孔子都被他批评了，但是唯独对惠能极加赞赏。这句话说出了《坛经》是一部人民群众的佛经，这句话说出了惠能完成了佛学革命，把参禅这种精神活动从少数文人的圈子里边解放出来，让他深入到每个老百姓的内心深处去，所以这叫<strong>佛学革命</strong>。</p>
<p>它已经是人民群众的佛经，没有这一步，哪有佛学中国化呢？不进入老百姓内心深处去，怎么中国化？现在我们的执政党也主张马克思主义中国化是吧？马克思主义中国化。如果老是我们这些搞马克思主义哲学研究的学者做的事情，他怎么能中国化？</p>
<p>马克思的思想中，能够深入中国每个老百姓内心深处去，他才叫中国化。这一天哪一天到来？我不知道哦。但是惠能做成了这件事，把禅宗的思想引入老百姓的内心深处，所以一部人民群众的佛经。他能做成这一点的一个前提条件是他自己是百姓中的一员，为什么？普通劳动者，文盲，不识字。别的人还担当不了这个使命。幸亏他是不识字的，他如果受到了教育，因为他父亲三岁的时候就去世了，他失去了受教育的机会，跟母亲相依为命，慢慢长大。一个砍柴火、卖柴火的劳动者、文盲。如果他得到了良好的教育，识了那么多字，有那么多的书读过了，他还能做这件事吗？做不成了。这个惠能有来历，他必须遭遇到不识字这样一个童年的艰难的生活处境。文盲！他才能做成这样一件伟大的事。这样，我们对读《坛经》的一些最基本的了解都具备了哦，然后我们才可以一品一品的来读，一共十品。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="行由品"><a class="header" href="#行由品">行由品</a></h1>
<p>我们刚才是一个开场白，讲了佛学思想融入中国思想，完成一个中国化，最高成果——禅宗。惠能是禅宗的真正的奠基人，虽然前面经过了从达摩一直到弘忍这五祖，每一祖彼此之间都是传衣钵，终于弘忍的法师，把衣钵传给了惠能。这时候禅宗是最初的一个准备阶段，还不能说禅宗的基础被奠定好了，到了惠能那里，才完成了这件伟大的事情。在他之后叫一花开五叶，南派的禅宗是顿教，他底下有发展出五个宗派：沩仰宗、临济宗、曹洞宗、法眼宗等。所以惠能是个关键的人物。</p>
<p>我们刚才讲他不识字，是文盲，早年不幸，父母早亡，使他失去了受教育的机会。从这件事看来，他是应该有来历的了。</p>
<p>佛教讲我们每个人都有来历。今天说起来似乎是迷信。我们这次来到世界上并不是第一次来，先前来过多次，叫<strong>累世累积</strong>。我们过去世所做的事情老早就结束了，事倩结束了并不是什么东西都没留下来。有东西留下来的，那叫“<strong>业</strong>”，业力的观念就来了，来到中国后来就有了汉语当中“<strong>业力</strong>”这个词语。我们前世，哪怕把再前世所做的事情都结束了，业留存下来形成一种力量，叫<strong>业力</strong>，把我们再次投入到这个世界上来。</p>
<p>从生物学的角度，我们出生，只是刚出生的时候，纯然一个小动物罢了，除了是个小动物别无其他。但佛教说我们带着东西来，并不是没东西的，带着<strong>业力</strong>来了，各人的业力不一样。所以各个人在这个世界上做的事情是彼此之间差别很大。比方说习大大做的事情，我王德峰做不了。如果我今天还在想，我也应该做国家领袖的嘛，说不定我去做总书记也蛮好的。如果我今天还这么想，我的悟性也太差了。我的事情习大大也许能做，但也未必做得好，他可能也可以做一个大学教授，但未必会得哲学王子的名声。所以各人有各人要做的事。</p>
<p>假如我今天还在想，我本应该本科毕业以后就下海的，说不定今天在中国富豪排行榜上有我的名字的。如果我今天还这么想，我的悟性也太差了。我现在明白我的来历，我一定带着这样的<strong>业力</strong>来专门做什么事情，这辈子研究空之又空的学问叫哲学，讲空之又空的课，写空之又空的文字。吃粉笔灰、做教书匠、吃开口饭，这就是我的<strong>业力</strong>要消。别人的事情我做不了，企业家的事我做不了，钟点工的事我也干不了。政治家做不了，做一个教师。各个人都有来历，佛教是讲的很清楚。所以惠能也有他的来历，他带着使命来的。我们看第二页，我现在跟大家本子一样，第二页就《行由品》开始了。这个惠能的《六祖坛经》一共十品。“品”就是今天我们讲的chapter，“章”。当时叫“品”。第一品交代什么事情呢？就是惠能悟法得衣的来历、来源、缘由。讲这个，叫《行由品》。《坛经》是唯一一部中国人自己说的佛经。佛经浩如烟海，都是释迦摩尼所说。唯有一部中国人自己说的经，被列入佛经了，可见他的地位之高，它列入了佛家的经典。</p>
<p>佛经的开头总是要交代时、交代地方、交代哪些人，所以也是这样开头了。</p>
<p>时——具体时间不说的，比如说佛经往往这么开头：“一时佛在舍利国”，是吧？等等。有多少人迎接在这里，然后他先用斋就是吃饭，饭吃完了 “食讫”，开始说“如是我闻”是吧？那么这个《坛经》也是这么写的，惠能不识字因此他也不会写字。他圆寂之前跟一个弟子讲，这个弟子叫法海，不是《白蛇传》的那一位哦。始终追随他左右，悟了之后就追随他左右，然后记录了惠能说佛法的所有的言论。惠能走之前跟他讲，你要把记录下来了，我说佛法的所有的言论汇编成册，让它留布于世，于是我们得到了这种《坛经》。当然经过好后人的多次的修改、补充，这些，但是基本思想全是惠能本人的，这一点无可怀疑。胡适先生喜欢做考证的文字，据他的考证的结论，《坛经》其实不是惠能的，是神会的。这也是太荒谬！这我们不去讲。《坛经》是惠能的思想，这是毫无疑问。虽然经过后面的加工、修改、补充，但仍然不脱离惠能的本意，这是肯定无疑的。</p>
<p>那么我们看，那一天大师，就是惠能到了宝林，就是宝林寺，今天叫南华寺。好多年前我去，大概五六年前、四五年前我去过了，是去瞻仰惠能的肉身像，这真身始终还在的，不坏的。在南华寺有三具真身，其中一具就是惠能的。所以，惠能在得了佛法，得了衣钵隐居了15年之后，在广州先出头露面，就法性寺（即现今广州的光孝寺）。然后印宗法师，就是当时的广州法性寺的方丈印宗法师那天下午就给惠能剃度，他正式出家。然后到了广东韶关市，在这个庙里，当时叫宝林寺的，现在叫南华寺。到了宝林，但是他没有先在宝林寺说法，而是被谁请出来了呢？韶州韦刺史。</p>
<p>“与官僚入山，请师出”，把他请到城中，那一个寺庙，叫大梵寺讲堂，请他“为众开缘说法&quot;。</p>
<p>“师升座次”。师升坐之后，“刺史官僚三十余人、儒宗学士三十余人、僧尼道俗一千余人”，场面蛮大。“同时作礼，愿闻法要。”</p>
<p>开头第一句话就讲了，禅宗当中的顿教，北面叫渐教，就是主张渐悟的，南面惠能主张顿悟。所以开宗明义讲了顿教的16字大纲，这16字应该牢记在心：“菩提自性，本自清净，但用此心，直了成佛。”</p>
<p>我们成佛靠什么？就靠我们的<strong>本心</strong>哪，这个<strong>本心是菩提自性</strong>啊.人人都具备，他本来清净，“直了“二字表示顿悟。所以先把16字的大纲讲一下，底下就说了：“善知识！且听惠能行由，得法事意。”先把我的来历交代一下。他说自己了。这个严父嘛，就是说自己的父亲。我们一般都讲父严母慈。 “严父，本贯范阳”，本来是河北那个地方的人也做过官，后来被贬谪了，其实就等于流放，流放到岭南，就广东这一带，做了新州百姓，广东新兴县当时叫新州。</p>
<p>“此身不幸，父又早亡”，惠能三岁的时候他父亲去世了，“老母孤遗”，他跟母亲相依为命。“移来南海，艰辛贫乏，于市卖柴。”砍柴火、卖柴火的。</p>
<p>有一次，他把柴火卖到一个客店里了，“时有一客买柴，使令送至客店，客收去，惠能得钱，却出门外，见一客诵经”。有一个人坐在街边上念经，他听到了八个字啊，这里没说听到哪八个字，实际上就是《金刚经》当中的八个字：“因无所住而生其心。”这八个字实际上是《金刚经》的核心思想，“<strong>住</strong>”，是指<strong>住相</strong>，我们必须不住相，<strong>本心才起来</strong>，叫“<strong>而生其心</strong>”。</p>
<p>“因无所住而生其心。”他“一闻经语”，他听到这八个字，“心即开悟”。就问这个人，你诵什么经呢？这个人回答说《金刚经》。从哪里来的呢？那个人就说了我是从蕲州，就是今天的湖北黄梅县，有一座庙东禅寺，东禅寺的方丈是五祖弘忍大师，有五祖弘忍在那里做方丈的，助化一方了，门人据说有1000多人。那时这个法会蛮繁盛的哦。</p>
<p>“我到彼中礼拜，听受此经，大师常劝僧俗”，弘忍法师都劝大家，无非是出家人还是在家人都要念诵《金刚经》。佛经浩如烟海读不胜读，我们只要读其中一部就够了，终身受用。这部经就是《金刚经》，这弘忍的意思。我听了弘仁法师的话所以每天要念，就这个意思。弘忍说：“但持金刚经，即自见性，直了成佛。”弘忍法师也主张顿悟的其实——<strong>直了成佛</strong>。</p>
<p>“惠能闻说，宿昔有缘”，他也是从佛家的角度讲，自己这样一件事是有缘的，也累世累积积累出来的。想想看我们这些人不知听过多少遍八个字啊，“因无所住而生其心。”可曾开悟呢？没有啊。我现在都不敢说我开悟了，但惠能当时就听到这八个字，“心即开悟”。这就是佛教一直用这个概念叫“<strong>宿慧</strong>&quot;。</p>
<p>我们的智慧都是来自前世的，前世的积累。“宿”就是上辈子，前世。我们任何人，哪怕都是凡俗之辈，多少总有一点智慧的哦，只不过是小根之人，不是上根之人。如果我们但凡有一点智慧，这智慧肯定不是这辈子生出来的，都是前辈、前世、再前世传过来的。所以佛教一直跟我们讲的一个道理就是说，我们这辈子没什么东西能传到下辈子，比方说钱财生不带来死不带去。但是有两样东西能传，一个是我们这辈子所造的<strong>业</strong>，无论是善业也罢，恶业也罢，能传到下辈子；还有一个就是我们这辈子所长的<strong>智慧</strong>，也能传到下辈子。</p>
<p>那么我们怎么长智慧呢？我们自己长不了智慧的，我们必须去传承。智慧在以往，所以“<strong>宿慧</strong>”这个概念是站得住脚的。我们即使不相信前世、再前世、三世轮回。我们即使不相信的话，我们也必须承认智慧在古代。就是我刚才讲轴心时代，人类在智慧的领域里面，从来没什么进步，思想从来都是旧的，新的叫<strong>思潮</strong>。</p>
<p>这个“<strong>宿慧</strong>”概念先要立起来，我们为什么要读一点比如说《坛经》呢？就是我们这辈子长智慧没有别的路啊。我们必须读两本大书：<strong>一本是现实人生无字的书</strong>，我们天天都在读；还有一本大书，就是<strong>伟大的人文经典</strong>，在中国就是儒、道、佛三家的经典。我们要在这两本大书之间来回走，我们才能长智慧。我们自己是长不出智慧，你哪怕阅历人生光读一本无字的人生现实的书也长不了智慧。有的人经历过很多的事情，到了七八十岁了，你以为他有智慧吗？未必。年轻人问问他，他可以讲许多以往的故事给你听，他经历过许多事情，有的事情还惊心动魄，此人一生大起大落，最后年轻人问这个老人，你能不能从你所经历的所有这些事情当中，讲几条基本的人生教训给我听听呢？他却未必说的上来。这样的人很多，一辈子就事论事，这叫痴长七十岁、八十岁。所以阅历人生不能担保我们有智慧。我们还要同时要读另外一本大书，这本书是传承先哲的智慧的书，我们要在这两本大书之间来回走才能长智慧。</p>
<p>比如说我王德峰写的哲学专著，各位不必去读哦，没什么意思的。我饭碗的需要，评职称的要求，动不动几十万字呢。想想看老子《道德经》才多少字啊？五千言。我一篇学术论文就一万多字，是他字数的倍数啊，没什么意思。我知道主要两个人读的，一个我；一个编辑。发表了之后记录下来叫学术成果。每年年底要填表啊，要考核呀。想想看老子《道德经》五千言，世世代代的中国知识分子不断的对他重加注释，重加阐发。研究《道德经》的著作已经汗牛充栋了，将来还将继续增多。所以智慧在古代。</p>
<p>我是向来反对第二手著作的。要读就要读元典，所以我们叫元典，元典会嘛。第二手的材料，是通过那些学者的理解，那个狭隘的头脑再挤出来的东西。就好像吃饭，他咀嚼过了再吐出来让我们吃，这怎么行？有些学者的著作要读，因为它帮助我们排除了对古汉语理解上的障碍，那就注释做得好的。像中华书局的，还可以啊，未必都恰当，我都看过。那么找不到更好的版本，所以我就建议用中华书局本还比较可靠。其实后来发现还有一个本子更可靠，上海古籍出版社的。你们不妨有网上去看看，有没有哪一本来，注释的非常好，主要是近代一个丁福宝做的笺注，做得非常到位了。这是学者的功劳，帮助我们排除理解古文字的障碍。因为古汉语跟现代汉语是有蛮大的差别的，这同样一个词，在古汉语是什么意思跟今天现代汉语当中意思真不同的，所以我们解除了这些，排除那些文字理解上的障碍之后，我们千万别去看那些学者对他的解释。</p>
<p>那么大家马上要问，你这不是也坐在这里解释吗？你们就不必听我解释了，用我头脑挤出来的东西是吧？吐出来让大家消化？不！我刚才跟你讲的分明，我们一起来讲读。我只不过是领个头，把我的人生体会讲一点，放到《坛经》里讲出来。那么大家自己也都在讲，其实是这样一件事。我绝不做学者的工作，最后还有翻译成白话文那是蛮荒唐的事情，这里也有白话文吧？没有，是吧，哦，有！别去看哦。我建议大家译文不必看，因为他要翻译成白话文，他先要有一个理解作它的前提的，这个理解又是属于翻译者本人的不要去看，只读原文，注释、解决文字理解的障碍，或者有些典故的说明就可以了。这是先要交代清楚的。所以我们长智慧没有别的道路。</p>
<p>我们这个文明太复杂了，非常精致化，充满各种知识和技巧。在这种文明中生活的人，离开智慧最为遥远，我们开不了天眼了嘛。当初的那些先哲能开天眼，因为他们的文明不像今天这种文明，比较朴素。在这种朴素的文明中的人，才可能俯仰天地，领会天人之际，这叫<strong>开天眼</strong>。我们是开不了天眼，我们要有智慧，只能是对古代智慧的传承。</p>
<p>人类社会在其他领域里面都不断进步，科技日新月异的，社会制度也在变革之中，但是思想和智慧从来没什么进步。所以今天我们中国人又要返回我们本有的智慧了。所以国学的兴起、复兴啊，就是这个缘故。国学复苏了，我们都去读孔子的《论语》了，《孟子》了，老子的《道德经》，《庄子》，读《坛经》等等。这些原因就是这样。否则我们只要看今天学者写的书就可以了是吧？所以这个先不讲。</p>
<p>这里表明惠能这个人是有宿慧的，听到这八个字，他“心即开悟”。然后那个人跟他讲了，这个为什么读《金刚经》的缘故。那么他就发下一个大愿，一定要找到弘忍法师求他度我。当然有人帮助了，有一个人帮助了惠能，给了他10两银子。10两银子当时是一笔巨款，当时十两银子不得了。到后来，货币有所贬值嘛，其实到了红楼梦那个时候的银子也是蛮贵重的哦。我们想想，读过《红楼梦》一定知道贾雨村怎么得到了一个最重要的帮助啊？就是甄士隐，贾雨村寄居在一个葫芦庙里，一个落魄书生囊中羞涩。饱学之士，但是没钱、没盘缠，无法到京城去赶考。后来他隔壁邻居就是甄士隐，欣赏他嘛，给了他50两银子，他就可以进京赶考。盘缠有了，考中之后，还要剩下的银子在官场上打点才能获得他所要的官职。50两银子改变了贾雨村的命运。</p>
<p>当时10两银子，对惠能来说不得了，可以安顿好老母的生活。于是他上路，从广东赶往湖北，前往黄梅要“参礼五祖”。</p>
<p>好，我们再翻过来。第七页，“惠能安置母毕，即便辞违”，马上就告别了母亲了，“不经三十余日”，一个多月的时间，“便至黄梅，礼拜五祖。”</p>
<p>弘忍法师接见了他，劈头问了他一个问题：“汝何方人？欲求何物？”你哪里来？来求什么？跟今天保安问的一样的。</p>
<p>惠能就回答了：“弟子是岭南新州百姓，远来礼师，惟求作佛，不求余物。”弘忍就说了，哦，“汝是岭南人”，獦獠人啊。中原一带的汉人瞧不起南方人，把他们看成是南蛮之辈，没开化的。给他们一个贬低的称呼叫“獦獠&quot;。</p>
<p>“若为堪作佛？”怎么做得了佛呢？</p>
<p>“人虽有南北，佛性本无南北”，当即回答了。</p>
<p>“獦獠身与和尚不同”，我是獦獠，你是什么？中原一带的人，我跟你这个不一样。“佛性有何差别？”这种话一说出来弘忍法师心里明白了，此獦獠 “根性大利”。或叫根器吧，佛家用语。根性、根器既是慧根，我们智慧的根。别看这獦獠啊，“根性大利”，这样的人最适合于把佛法传给他。</p>
<p>这个概念我们现在都不用的，长久不用，我们用另外一个概念叫智商。现代心理学发明了一套测量我们智力水平的量化的方法，基本单位叫智商。某人智商如果达到115，在其他条件也具备的情况下，一定考得取大学。这个心理学的概念。我们现在都希望自己的孩子智商要高。智商很高的复旦大学医学院的学生，给同学喝的水里下了毒了！他考得取复旦智商怎么会低呀？这个复旦大学我们都知道的。我一直讲这样一句话，如果把中国大陆的应届高中毕业生比喻为一锅汤的话，汤的第一层油水一定三所大学分享：北大、清华、复旦。这是历史造成的局面，到今天还如此。所以你考取复旦怎么智商可能低呢？而且不光考取复旦医学院，已经被获准直升博士。他是在读硕士，可见是复旦医学院的高材生呢！智商怎么可能低呢？却做了那样的事情，导致两个家庭的悲剧。智商很高，根性不利。我们现在都不用这个概念了。</p>
<p>这件事发生以后，我就跟那些年轻的朋友，他们做了年轻的父母，我跟他们讲，要重新思考一下什么是我们下一代成长的成功。那个孩子，给同学喝的水里下了毒的孩子，他的父母一定一度认为他的孩子成长得非常成功。考取复旦还直升博士，马上做医学博士的人了，多成功啊？现在再想想究竟成功了没有呢？所以我们必须重新返回这样一个重要的概念叫“<strong>根性</strong>”，他无法测量哦，没办法量化的，它是指智慧的根。但是你可以判断，怎么判断呢？</p>
<p>假如你的孩子是才三岁，那叫初涉人世。有一天，你跟他在弄堂里，上海弄堂，假定啊，在弄堂里走，走到弄堂的那一端，那里一个很大的垃圾箱。他看见一个拾荒者，在垃圾箱里面翻捡什么？人家丢弃了的发霉的食物，你的孩子看到了心里难过了，向你提出一个请求，你能不能给他一些钱让他去买健康的卫生的食品？倘若你的孩子是这么向你请求的，你一定放心，你的孩子根性不错，根器有利。为什么？<strong>智慧</strong>跟<strong>悲悯</strong>是统一的，<strong>大智慧</strong>就是<strong>大悲悯</strong>。</p>
<p>你三岁的孩子跟那个拾荒者是素昧平生啊。不是说那个人认识他，曾经帮助过他，然后他现在孩子要求帮助这个人，不是这么回事。素昧平生的路人，他的悲悯之心起来了，这叫慧根好啊。你就从此放心，他哪怕智商不高没关系，这一生你不用为他担心的。我们要重新改变我们对孩子的成长的判断。</p>
<p>好，这是我的感慨，发表一下。回到正文哦。这个五祖没有表现出对他的喜爱哦，因为诸弟子都在边上，“且见徒众总在左右”，他怎么办？他没收惠能做弟子，他让惠能到舂米房里舂米去了，“随众作务”。</p>
<p>惠能就讲了，“惠能启和尚，弟子自心常生智慧，不离自性，即是福田。“这话又说得对。“未审和尚教作何务？”你准备叫我去干什么呢？</p>
<p>弘忍就说了：“这獦獠根性大利！汝更勿言，著槽厂去。”到他舂米坊里去。厨房后面有碓子，这个和尚也要吃饭的嘛，厨房后面都有那些舂米的，干这活的作坊，叫他到作坊里去。干嘛呢？舂米。</p>
<p>“惠能退至后院，有一行者”，行者其实就是修佛但还没有出家的人。有时候就像我们今天讲的在庙里出现了什么义工。有一个行者，就差使惠能干嘛？“破柴踏碓”。砍柴火，然后干嘛？踏碓。舂米是一个很繁重的体力劳动哦，一块很大的碓石，上方系在一根又粗又长的木棒上，这叫杠杆。这一头踩下去，碓石往上升，石头一放叫舂米。叫他干这个活，他干这个活，为什么弘忍法师这么对待他？</p>
<p>底下又说了，经过8个多月的时间有一天，弘忍法师偶然遇到了惠能了，就跟他悄悄的讲，“吾思汝之见可用”，你的这个见解，是很有用处的。</p>
<p>“恐有恶人害汝，遂不与汝言，汝知之否？“所以我不跟你交流，你懂吗？</p>
<p>惠能说：“弟子亦知师意”，我其实明白你的意思，“不敢行至堂前”，不敢到你方丈室来啊，“令人不觉”，不能让别人知道，大家都很默契的哦。</p>
<p>为什么当时是这个局面？当时是唐朝，朝廷支持佛教，一个寺院的方丈一定同时是寺院地主，广有田产。所以衣钵的传承就是田产的继承。眼看弘忍法师年岁大了，不知道他的衣钵将来传给谁呢？衣钵的传承同时就是田产的继承嘛，所以丛林里边、寺庙里边就不清净了。所以弘忍法师当然有很高的智慧，他就不收他做弟子呀，教惠能去干活去，其实是对惠能最好的保护啊。就这层意思，那么惠能心里也就明白。</p>
<p>我们再翻过来看，第11页。弘忍法师有一天真觉得自己年岁大了，要解决衣钵传承的问题了，把众门人都唤来，众弟子们都叫到边上了，跟他们讲话，看看这几句话怎么讲。</p>
<p>“吾向汝说，世人生死事大”，哎，这第一句话就是说“世人生死事大”。对于世界上每一个人来说，没有什么事情比生死的事情更大，这一点我们能同意的。</p>
<p>“汝等终日只求福田”，你们跟着我学佛那么多时间了，每天求的是<strong>福田</strong>。要种福田、求福报。今天大多数学佛的善男信女们大概心中也就是这个目标。所以今天的寺庙香火多旺啊。那个叫什么？普陀山是吧？每年那么多人干嘛？那里有观音，观音可是有求必应的嘛。你儿子今年高考了，你干嘛？马上到普陀山进香许愿去，求菩萨的帮忙嘛，要求一个福报嘛，让孩子能够考得上大学。如果真考取了，你得还愿是吧？普陀山还得再去一次，无非如此，都做这样的事。</p>
<p>当时东禅寺的弟子们也这样，“只求福田，不求出离生死苦海”。修佛的根本目标你们都忘了，<strong>修佛是为了解脱生死之苦恼</strong>，你们把这根本目标完了，求的只是现世的幸福。</p>
<p>“自性若迷”，自己的本性看不到，“福何可救？”你们得了福报，也解决不了你们什么摆脱生死轮回这件事情，解决不了一个消除你累世累积的恶业。“得福报者”，这是真的啊，佛教一直承认的。你做的事情总会有结果，做的好事一定有好的结果，这是得福报。这辈子不行下辈子有也可以，三世因果都这么讲。那么你下辈子，由于这辈子做了许多布施的事情哦，福报在下辈子应了。下辈子有富贵，有富贵归有富贵哦，恶业并没有消掉。恶业没消，你一样的烦恼和痛苦，你下辈子的富贵给你带来的烦恼，恐怕比这辈子的贫贱更多。其实我们归根到底要摆脱的是什么？消解的是<strong>恶业</strong>，要摆脱<strong>生死的轮回</strong>。所以，福报得了，如何可以救你呢？一样救不了你，叫“福何可救？”</p>
<p>“汝等各去”，你们各自走吧，“自看智慧，取自本心般若之性”，你们本来本心都有什么般若智的啊。般若智我们等会再说。“各作一偈”，叫他们做偈句。“偈”句是佛教中的一种诗歌的题材，用一首短短的诗来表达对佛法的领会。做了以后给我看。“若悟大意”，如果能悟了佛法的大义的，“付汝衣法，为第六代祖”，那叫考试来了。都要大家去做偈句去吧。</p>
<p>而且还关照他们，“火急速去，不得迟滞，思量即不中用”，哎，你不要搞那种思考推理，没用的。“见性之人，言下须见”，照理他们当场就有了，应该马上念出他的偈句来。“若如此者，轮刀上阵，亦得见之。“你打仗啊，跟人家正在生死相搏的时候，旁边有人问你佛法，你一面打一面我随口就念出来，这才叫对的。“思量就不中用”，回去反复思考推究，最后写出几句偈句一定不行的。跟他们都这么讲的，但是哪一个弟子当场说出来了？都回去再讲。</p>
<p>“众得处分”，看来弘忍法师对他们都不满意的哦。然后彼此就在想了，我们做还是不做这个偈句呢？“我等众人，不须澄心用意作偈，将呈和尚。有何所益？神秀上座，现为教授师，必是他得。“就等于，神秀其实就是弘忍法师的助教，弘忍法师对神秀很器重的，所以让他做了首座弟子，其实不仅是上坐，叫首座弟子。首座弟子是因为他是让他做了教授师嘛，这叫首座弟子了，排名第一位的。将来衣钵一定是他得，我们也去做偈句，那是白用心力。</p>
<p>其实后面一层意思还没说出来的，将来他得了衣钵，我们做偈句等于是跟神秀竞争，将来他得了衣钵，没有我们好果子吃的，所以大家都想好了不做。那么神秀也在想做还是不做？</p>
<p>底下一段就说：“神秀思惟，诸人不呈偈”，是因为我成了他们的教授师，“我须作偈”，给和尚看，如果不呈偈和尚如何知道我心中的见解的深浅呢？“我呈偈意，求法即善，觅祖即恶&quot;，看来神秀这个人不错的哦，我如果想要做第六代主，这我念头就不对了，我是为了得佛法。所以我偈句上去的话呢，是求的是佛法不是求衣钵。所以如果我去觅主，就是寻求做第六代主的地位，“却同凡心，夺其圣位奚别？”有什么差别呢？就像凡俗之辈，明明是一个凡俗之人，却想要做圣位。</p>
<p>“若不呈偈，终不得法，大难大难。”他对自己没把握，究竟做还是不做，不做的话，佛法得不到，做的话，如果弘忍法师进来说做得不好，其实不光得不到佛法，后面这些都隐掉的哦，在众弟子面前也不能做教授师了吧？失去了威望。</p>
<p>“五祖堂前，有步廊三间，拟请供奉卢珍画《楞伽经变相》及五祖血脉图。“本来是准备请一个供奉卢珍，供奉是当时朝廷对那些有专门的才华的人给他的一个地位叫供奉，此人是善作画的叫卢珍。弘忍法师要请他来画，画那个《楞伽经变相》以及五祖血脉图。禅宗的谱系是一直写，记得非常清楚的。从第一祖怎么传到第五祖弘忍法师的，一个个人物都要画出来，叫血脉图。其实就是禅宗的是谱系，画出来，“流传供养”。这个走廊的墙壁本来派这个用处的。那么神秀终于把自己的偈句做成了，几次想要给弘仁法师看，但到了方丈室门口他就心里慌了，叫“心中恍惚，变身汗流，拟呈不得”，前后“经过四日&quot;，13次过去又退回去，到了方丈室又退回去，有13次呢。后来他想还不如把它写在走廊的墙上。让他看见如果说做得好就出来礼拜，承认是自己做的，如果说做得不好，我这个白白地在山中修了这么多年，受人礼拜，人家都把我当教授师拜的。所以他后来想出的主意就是说不署名，把这个偈句书写在墙上不要署名。如果弘忍法师说做得好就承认是自己做的，做得不好就不吱声，就这个意思。</p>
<p>那一天晚上三更时分，在人家都睡着的情况下，自己执着灯，来到了南廊壁间，书写了他的偈句。这个偈句我们都蛮熟的哦：</p>
<p>“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”</p>
<p>写好了自己到房里去了，周围的人没有人知道。他又在想五祖明天如果见到偈句欢喜的话，那就是我神秀与佛法有缘了，如果说不堪那是我还迷着呢。</p>
<p>“宿业障重”，他也讲宿，累世累积的业，业障太重了，所以让我见不能领会佛法。“不合得法，圣意难测。房中思想，坐卧不安，直至五更。”才睡着。神秀当时就这个样子的。</p>
<p>好，我们再翻过来看，其实弘忍法师对自己的弟子们，修佛所达到的境界都了然于胸的哦。虽然神秀被放到首座的位置上，弘忍也仍然知道他没有入门。</p>
<p>第二天天亮了，弘忍法师把卢供奉找来了，就那个画家来了，要他在南廊壁间绘画图像。突然见到墙上有偈句了，于是他就叫人跟卢供奉讲，这里不用画了，“劳尔远来”，对不起你了。佛经当中有这样的话，凡所有的相，“所有相，皆是虚妄”。把那个从第一祖到他自己第五祖的形象都画在墙上，“皆是虚妄。但留此偈，与人诵持，依此偈修，免堕恶道。依此偈修，有大利益。”表面上是赞美了神秀的偈句的，要众弟子们都按照这个偈句来修啊，这个偈句对你们修行有大利益。叫“门人炷香礼敬，尽诵此偈，即得见性。”我不免要想，佛家不打诳语呀，你明明弘忍法师对这个偈句并不满意的是吧？为什么还叫众弟子们去炷香礼敬，每天要背诵呢？</p>
<p>我后来一想，神秀的偈句的境界，确实要比其他弟子们要高，他并没有把修佛看成是得福报的事情，不是求福报的事情，不是求种福田、求福报，而是要保持我们的心本来的干净。我们不要把自己的身体看成仅仅是肉身，还要看成是法身，叫“身是菩提树”。我们的心本来很干净，叫“心如明镜台&quot;，但是本来干净的心来到人世间呢，人世间到处都是灰尘，就难免要沾染上灰尘，那么怎么办？“时时勤拂拭”，就是不断地保持我们干净的心跟外部世界的灰尘之间的隔绝状态。“勿使惹尘埃”。这个偈句表达了神秀对修行的理解，这个理解本身有问题吗？我们待会再来看，但是他这样理解已经要比其他弟子高了吧？高了。</p>
<p>所以叫其他弟子们，你们每天都要念呐。私下里把神秀找到方丈室了，问了他这个偈是不是你做的？“偈是汝作否？”神秀因为已经听到弘忍法师对他的赞美了所以他就说承认了嘛。“实是秀作，不敢妄求祖位，望和尚慈悲，看弟子有少智慧否？”有那么一点智慧吗？</p>
<p>弘忍法师直截了当地讲的：“汝作此偈，未见本性，只到门外，未入门内。如此见解，觅无上菩提，了不可得。”这个“菩提”啊，本是树喽，就是释迦摩尼在菩提树下悟道的，那么所以菩提树就成了什么？<strong>无上正等正觉</strong>的象征。<strong>菩提就是无上正等正觉</strong>。像你这首偈句所表达的见解呢，离开菩提呀，还很远呢。</p>
<p>“无上菩提，须得言下识自本心，见自本性，不生不灭，于一切时中，念念自见，万法无滞，一真一切真，万境自如如。”这段话是对他的提示了，为他讲开示了。“如如之心，即是真实。”我们的心，平时的心，全求的是<strong>如意</strong>，我们要换求如意的心，为<strong>如如</strong>之心。这个话说起来呢又是一大堆话了。</p>
<p>我们平时这个心，刚才讲叫假的心一一<strong>业识</strong>，跟外部事物的关系是什么？希望外部事物称我们的意，如我们的意。每一个事物跟我们的关系，就是这种如意或者不如意的关系，平时的假的心就这样的。</p>
<p>不如意嘛就是<strong>烦恼</strong>，烦恼就是不如意，我们的心烦恼不断，就是我们假的心不断在求如意呢。在求如意的情况下，事物的真实意义并不向我们呈现。万事万物呈现给我们的意义都是假的，假在哪里呢？因为我们想那个事物如我们的意。不如我们的意的时候，我们就把它排除了，把它看成是不好的东西，如我们意的事物才叫好的东西，这样我们就看不到事物的本来、真实的意义，看不到。要换如意之心，为“如如之心”才对。“如如”，什么意思？<strong>如事物的本来</strong>，来领会这个事物，叫<strong>如其本来</strong>，如如，所以这个意思就来了。“如如之心，即是真实”，所以我们的心思，平时的心全假的。</p>
<p>所以这段话很重要的，完全可以说是经典。“于一切时中，念念自见&quot;，你每一个念头，你都看一看它的根源。“万法无滞”，<strong>法</strong>就是<strong>事物</strong>，<strong>万法</strong>就是<strong>万事万物</strong>。在你面前的都是<strong>如其本来</strong>地呈现了，这叫”一真一切真，万境自如如。”我们人生不断地在不同的处境当中，但是我们都把处境区分了。这叫顺境，那叫逆境，这叫善境，那叫恶境。种种的区分，都因为我们自己的心所造成的。本应当“万境自如如”。“万境自如如”的前提，是我们的心是“如如之心。”</p>
<p>佛教的，禅宗的思想，特别要破除<strong>二元对立</strong>，二元对立要破除。叫佛法是<strong>不二之法</strong>，不要在“二“之中。我们的种种妄念都来自“二”，因为我们区分了好坏、顺逆、利害、得失、苦乐，成对成对的哦，干净、肮脏，成对成对的二，要把它破了。谈恋爱的人最明白，境由心生啊。昨天晚上两个人手拉着手压马路呢，曾经是花前月下，温言款语的。不知道怎么回事分手，分手的时候之前，两个人不开心了，不开心之后就不欢而别，回到家里肯定睡不着，因为你在谈恋爱嘛，睡到床上就在回顾整个今天晚上跟他在外面走路啊，讲话啊，究竞说了些什么，一个个回顾一下。然后呢心里不定了，不定想到明天要上班，没办法，转个身睡吧。早晨起来了，到了单位里了，其实暗中在期待他发短信给我，是吧？但是你在外面很忙的，9：30到了，短信还没来，10：00到了，短信还没来，你觉得周围一片都是灰蒙蒙的，你知道其实那一天阳光灿烂，但你觉得周围都是灰蒙蒙的。那些同事们的脸色，你觉得都不对的哦，但你也没办法，就在等啊等啊，11：30还没来，到12：00，一个短信跳进来了，一看往日的温言款语又来了。此刻，你突然发现今天阳光多么灿烂，每一个同事都向你露出了微笑。这个境就变了吧？先前叫逆境，现在变顺境了，境由心生啊！哪有这个境本身客观上是顺的，或者客观上是逆的呢？所以这个禅宗是要求我们“念念自见”。这个是把自己的，我的感受放进去。众人都会有这种感受，境由心生，这是佛家很有道理的话。没有什么客观上绝对的顺境，客观上绝对的逆境，哪有这种事情。中国道家的思想，下面也会讲这个，利和害，祸与福，都是转换的嘛。</p>
<p>如果你有这样的见解的话，“若如是见，即是无上菩提之自性也。汝且去一两日思惟，更作一偈，将来吾看”，再拿来给我看，“若入得门，付汝衣法。“把衣钵和佛法都传给你。神秀往后面几天，做不出来了，“又经数日，作偈不成，心中恍惚，神思不安，犹如梦中，行坐不乐。“再也做不出第二首。但是东禅寺里的弟子们，都在念诵神秀的偈句，就被惠能听见了。有一个童子，小和尚，小沙弥了，“于碓坊过，唱诵其偈，惠能一闻，便知此偈未见本性。”</p>
<p>惠能听到神秀的偈句就知道他这个偈句不行。虽然惠能并没有得到弘忍法师的指点，却早识大意，佛法的大意他都已经有所明白了。就跟那个童子讲，你诵的是什么偈呢？童子说你这个獦獠不懂的，“大师言：世人生死是大。欲得传付衣法”他想要传衣钵就令门人来做偈呀，“若悟大意，即付衣法，为第六祖。”那么神秀上座弟子就在南廊壁上书写了无相偈。弘忍法师就请大家多念，“依此偈修，免堕恶道。”等等，这些事情就告诉惠能听了。</p>
<p>惠能就说了：“上人”，他尊称这个童子上人呐，“我此踏碓，八个余月，未曾行到堂前。”请你把我引到那个偈面前来，我来去礼拜他。那么童子就把这个惠能引到了这个偈句面前了。那么惠能说不识字呀。我不识字，你读给我听吧。边上又有一个人了，叫张日用的，便高声朗读。“惠能闻已”，听完了，就说了，我也有一个偈句，就请你张别驾帮我写在这墙上吧。那个别驾就瞧不起他了。“汝亦作偈，其事希有。”这事情也太稀罕了吧。你这个獦獠还做什么偈呢？</p>
<p>好，我们翻过来看23页。惠能的回答非常厉害，“欲学无上菩提，不得轻于初学”，切不可轻视初学者。底下一句更厉害，“下下人有上上智，上上人有没意智”，这话后来是广为流传的啊。然后到了毛泽东时代，他被修改成这样一句话，“**卑贱者最聪明，高贵者最愚蠢。****”**这样的话有来历的，来自禅宗呀。</p>
<p>下下人，就是生活在社会最底层的人，却可能有很高的智慧。上上人，就是社会地位很高的人，却可能没有智慧。小时候我大概是在小学六年级的时候，最初读到坛经，读到这一段的时候，心中就起了疑惑。什么疑惑？我想惠能这句话就等于告诉我，地位低的人才可能有很高的智慧，地位高的人却没智慧，我心里就纳闷。我心里想我们有没有智慧这件事情，跟我们的社会地位高低应该没必然关系吧？地位高的人也可以有智慧，所以我就一直就不明白。当时实在是不懂，但这句话都记在心里了。后来才明白惠能讲的真有道理。</p>
<p>为什么“下下人有上上智”道理何在？为什么“上上人有没意智”道理又何在？生活在社会最底层的人，想想看，你就是生活在社会最底层的人，你还能把自己不断的拿出来跟别人比吗？每一次比较你都发现自己比别人低，你还活还是不活？你应该自杀的。下下人没办法拿自己跟别人比的，每一次比总是最低的了，你就是摆地摊的你知道吗？城管一来你慌的不得了马上逃啊，城管走了你再溜，溜出来摆地摊了。你就是每天在人家家里做钟点工的，你知道吧？你就是装修房子的普通的一个泥瓦匠，你怎么跟别人比呢？所以下下人没办法把自己跟别人比，所以他们最不会去“<strong>住相</strong>”。他每天投入到生活本身中去，上有老母需要奉养，边上有妻子和丈夫需要互相帮助，底下有孩子嗷嗷待哺，你每天投入生活本身嘛。你无法“<strong>住相</strong>”，你不能“<strong>住相</strong>”。一个不“<strong>住相</strong>”的人才可能有什么？<strong>智慧</strong>。每天投入到生活的真谛中去，这叫“下下人有上上智&quot;。那么上上人就比较难了，比方说你是上海市市长，地位可高了，昨天晚上你还读了《金刚经》的，记住了“应无所住而生其心”。第二天早晨起来，你的司机和秘书都在楼底下等着你呢。你一出行前呼后拥警车开道，每天遇到你的人一律地向你鞠躬，每天在提醒你地位高。甚至要拍你的马屁，还唯恐拍不到。昨天晚上《金刚经》又白读了。你要不住相真难，各位。因为周围的人要提醒你的，你地位高，你就是“上上人有没意智”。我后来才明白这个道理的。</p>
<p>我这个人平时不看报也不看不听新闻的，等乔布斯去世了之后我才知道苹果是他开创的。那么有一次我就偶然看到一个电视节目，上海电视台做的节目，介绍乔布斯生前的事迹。镜头都一个个放出来，其中有一个镜头就是乔布斯在斯坦福大学做演讲，斯坦福大学那一年毕业典礼邀请了乔布斯去做演讲的。他上面在讲话的形象，底下就打出字幕来，就是英文噢，当时正在说什么？我突然看到一句：&quot;Stay foolish，Stay hungry。&quot;英语了。Foolish什么意思？愚笨。Hungry——饥饿。他在跟斯坦福大学的毕业生们讲，你们要永远保持什么？Stay在这里做了一个联系动词，因为后面两个都是形容词，构成系表结构，就应该翻译成“保持”。“Stay foolish，Stay hungry。”要他们保持愚笨，保持饥饿。我一看到这句话第一反应，此人应该学过佛。我为什么有这个反应？什么叫foolish and hungry？下下人。既愚笨又饥饿，穷啊，又笨啊，不就是下下人吗？然后乔布斯提醒了那些斯坦福大学的毕业生们，你们都心存高远是吧？志向很高啊。你们是名牌大学毕业的，将来要去做社会精英的啊，你们心里都这样想。有朝一日你们成了社会精英了，别忘了这句话：保持愚笨，保持饥饿。永远记得自己是下下人。后来有人告诉我，乔布斯真学过佛的。所以惠能这句话厉害了，你哪怕贵为政治局常委你也要记得自己是下下人，你才可能有上上智。</p>
<p>所以我后来终于懂了惠能为什么把下下人跟上上智连在一起，又把上上人跟没意智连在一起。这凭什么连在一起？现在明白，因为下下人无法“<strong>住相</strong>”。我们但凡有一点本事，但凡有一点地位，我们就跟着“<strong>住相</strong>”了，地位越高“<strong>住相</strong>”越厉害，而且还不由你自主呢。周围的人全捧着你，还不敢得罪你呢。你就觉得仿佛自己能呼风唤雨了。还有智慧吗？没啦。所以我觉得我们一起读《坛经》，其实就是读我们自己的生活，这样才有意义。我顺带讲这些伟大的人文经典怎么去读它？它不是我们学术研究的对象。</p>
<p>中国的儒、道、佛三家的经典跟西方哲学不一样的，西方哲学是严密的<strong>范畴演绎和概念的推论</strong>呐，一步一步非常严密的思考的。读了西方哲学著作有好处的，就把我们理性思考训练的十分彻底和周密，跟学数学差不多。这个就是锻炼我们理性思考。但是中国的人文经典不是理性思考。读这些儒、道、佛三家的经典，就是什么？叫这一段经文理读懂了，这一段经文你能把自己的生命感受放得进去。读儒、道、佛三家的经典，就在读我们自己的生命感受。因为我们每个人就都在这个世界上生活过一段时间了，我们每个人都在自己的生活当中积累起自己的生命感受，但还从来没机会去读过它。我们通过读儒、道、佛三家的经典，比如说我们现在读《坛经》就获得了一种机会来读我们自己的生命感受。读和不读区别在哪里？不读的话，我们的生命感受是散漫的，不成境界。通过阅读儒、道、佛三家的经典，我们有一个机会<strong>把我们的生命感受提升为生命的境界</strong>。这就是我们跟儒、道、佛三家的经典的阅读关系。这种阅读关系不是学术研究关系，是提升我们自己的生命感受的那种关系。</p>
<p>所以佛经啊，比如坛经的意思，本不在我们心外。所以我们得把自己的生命感受放进去，如果这一段你放得进去，你就读懂了这一段。放不进去你只是字面上理解了，完全不一样的。有许多人把佛经的道理讲得头头是道，你知道的，那可是堪称学者了，但他的生命感受从来没进去过。所以我刚才讲我们不是做佛学的。我们是学佛的，本着学佛的态度来读《坛经》，就把生命感受放进去，有时候放进去很不得了的，结果那叫什么？<strong>悲喜交集</strong>。佛教里边叫做读佛经，读到心生<strong>法喜</strong>，这段你才读懂了，你无动于衷的头脑理解的，你根本没懂。</p>
<p>我现在有许多跟我年龄相仿的人已经十几年学佛了，我一看他们这样学佛我都是很佩服的，因为精进的很。每天诵经哦，诵经都是几个小时。有时候我这些中学同学我就相遇了，我说你每天诵多少遍经？他说多少遍经。我一看，我说根本不能跟你比，你在诵经的时候我在喝酒呢，我的境界太低了。那么我忍不住要问他一句，我说你诵经诵到今天，那么多年诵经你可曾流过泪？他对我这问题很惊讶，没流过泪，怎么会流泪呢？我说你就从来没懂过。因为佛经是提升我们生命情感的本质呀。生命情感的提升是什么意思？叫“<strong>悟</strong>“呀。而这个“<strong>悟</strong>”是什么？一下子转过来的。“<strong>顿悟</strong>”什么意思嘛？毛泽东时代又有一句话，其实源于禅宗的思想，什么话？“灵魂深处爆发革命**。**“我后来才明白，一看这句话我想起来了，不就是“<strong>顿悟</strong>”的意思吗？不是头脑爆发革命噢，头脑没什么革命的，头脑就知识增多了。</p>
<p>我们上海电视台有一个叫第一财经，各位知道吧？还有一个专栏节目叫头脑风暴，你知道吧？我一看我就笑了，头脑哪有风暴？心里才会有风暴的。头脑风暴这种节目专门找谁你知道吧？商界领袖，商界成功人士、商界精英来讲他们成功的经历。底下那么多年轻的观众们就在看着呢，那么特别是今天的大学生就想复制他们。你能复制马云吗？你能复制柳传志吗？你能复制王健林吗？他们都在做这个梦。因为那些人都在它那里讲，他在改革开放的哪一个关键阶段会有一系列很好的idea（观念）导致他们成功了，全扯淡！别信。让他们成功的根源绝不在他们口中说出来的这些观念。他们经历过的事情，他不会翻出来讲的，那是心灵的考验。头脑怎么会有风暴呢？我就纳闷了灵魂才会有风暴的，你知道吧？</p>
<p>所以什么叫“<strong>顿悟</strong>”？灵魂深处爆发革命，爆发就“顿“呀，“悟”呀，就是革命呀。是什么东西的革命啊？<strong>生命情感的升华</strong>，是这种事情。所以那些朋友跟我讲，读了十几年佛经从没流过泪，我说你也基本上白读了，对你没什么影响。口中就是文字喽，我说不跟小和尚念经一样吗？我们老百姓不说嘛，小和尚念经——有口无心。文字倒在不断地朗诵，心从来没上去过。要口诵心行，心跟上去。什么叫心跟上去？生命感受跟上去，一开始跟不上去的，还陌生的很，哎，多次之后就上去了。</p>
<p>所以当我今天再度读“下下人有上上智，上上有没意智”的时候，你的感受就上去了。</p>
<p>所以这是顺带讲噢，我们怎么读《坛经》。所以我们这样一个聚会是非常好的，各位都有许多自己的生命感受，像我一样都在这世界上活了几十年了，都建立起自己的生命感受，还从来没有机会翻捡过呢。翻捡翻捡，读一读。借助什么来读自己的生命感受，接受经典来读自己的生命感受。那个经典不是在我之外的，佛说佛法不是为他自己，他已经成佛了还说什么呢？是为我们这些什么凡夫俗子，叫众生——迷了的众生。他跟我们说，就我们要跟上去，怎么跟上去？我们的生命感受跟上去。所以这是一个恰当的理解。</p>
<p>不光是读《坛经》如此，读儒家的经典也如此。读论语、读孟子、读老子、庄子也是如此。我们才会在儒、道、佛三家里边得我们真正的收获。这种收获是生命情感的升华。而生命情感的升华意味着什么呢？因为我们的心——<strong>本心</strong>起来，他不是头脑知识多了，不是这个东西。就像我刚才讲，现在年轻人真应该读这些东西，为什么呢？看看自己于不知不觉当中，在这个有病的时代和社会当中，我们的人生态度出了什么问题，<strong>人生态度的改变</strong>才是根本，否则他们没出路，精神上没出路。</p>
<p>我们已经上午已经进入了第一品了。行由品的讲读，第一品讲了惠能悟法得衣的缘由。弘忍法师觉得自己年岁大了，应该解决衣钵的传承问题，所以把众弟子叫到边上，跟他们讲话。然后要求他们各做一偈句，各人都做一个偈句。“呈来我看，谁得佛法之大义，就能得衣钵，为第六代祖。”后来神秀在半夜三更时分，在南廊的壁上书写了他的偈句，但是没有署名。“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”弘忍法师让东禅寺的弟子们每天都要念诵这个偈句，说念诵这个偈句有“大利益”，就是对大家的修行有好处。后来惠能听见了，让一个童子完整的念给他听。听完之后惠能说我也来做一首。边上有一个张日用瞧不起他，说你这样一个獦獠居然还要做偈句，这种事情也太奇怪了。惠能就跟他讲，不可轻视初学者，“下下人有上上智，上上人有没意智。”那么我们上午就讲到这里。</p>
<p>为什么下下人可能有很高的智慧，上上人却可能没智慧？这其间的关系我们上午讨论了。<strong>下下人生活在这个社会中，无法“<strong>住相</strong>”，无法把自己跟别人比，所以他每天就投入到生活本身中去了。这样的人不会被许多的邪知邪见所遮蔽，因为他必须养家糊口，所以可能有很高的智慧。但是地位高的人却难了，不容他不“<strong>住相</strong>”啊，周围的人都在提醒他地位高呢。这层意思我们上午讲了。所以惠能的这一个非常有名的话，后来就成了中国后来那句话的来历，就是“卑贱者最聪明，高贵者最愚蠢</strong>。”****这个来历就是惠能这句话下下人和上上人。</p>
<p>那么我们接着看，底下还有一句也非常厉害的：“若轻人，即有无量无边罪”。把轻视他人看成是很大的罪，这是禅宗的一个基本思想。禅宗在中国就是佛学中国化最高成果，在中国思想史上破天荒第一次提出了众生平等的原则。在这之前众生平等的思想在中国并没有，连孔子还说“上智与下愚不移也”，“小人与女人难养”，还是不平等的。所以禅宗在中国思想史上是一个划时代的一个里程碑。为什么轻视他人是无边无量的罪呢？看人世间的种种的罪恶，总有一个根源的，这根源就是<strong>轻视他人</strong>。倘若你去读那个希特勒的《我的奋斗》这本书，光看这本书你会觉得这个作者思想素高，要担当整个人类的命运。说日尔曼民族承担着这个使命，他把他自己的一生交给了这个民族，何等崇高之境界。但就是这个希特勒犯下了滔天之大恶业，原因是<strong>轻视他人</strong>。他首先轻视了犹太人，而后还轻视了斯拉夫人。对犹太民族实行了种族灭绝的政策，骇人听闻的暴行，奥斯维辛集中营等等，大量的屠杀犹太人。把这个人世间的灾难或者苦难归结为一部分人，归结为犹太人了，在人之间做了这样一种区分，那是罪恶的根源。所以佛家的思想非常通透，所以这句话就说得出来了：“若轻人，即有无量无边罪。”</p>
<p>那么听了惠能这番话，张别驾肯定心里有点慌了，你们的话是上纲上线的啊。“下下人有上上智，上上人有没意智。若轻人，即有无量无边罪。”，那不就上纲上线了吗？这纲上的对，这线上的对。所以张别驾就跟他讲，“放但诵偈，吾为汝书。“你把你的偈句念诵出来，我帮你写在墙上。但是有条件，什么条件？“汝若得法，先须度吾”，你必须首先来度我，“勿忘此言”。那么惠能就念出他的偈句了，</p>
<p>“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃？”</p>
<p>这个偈句念出来，边上听的人都惊讶了，果然境界高了。大家说“奇哉，不得以貌取人，何得多时使他肉身菩萨”，也没想到他站在我们面前一个活生生有血有肉的人，一个普通人其貌不扬却是菩萨。</p>
<p>那么现在我们不妨就来讨论一下，神秀的偈句与惠能的偈句差别在哪里？为什么惠能的偈句境界要比神秀的高？高又高在哪里呢？换句话说，神秀的偈句毛病在哪里？因为惠能的偈句是完全针对的神秀的偈句，那叫针锋相对。你说菩提是树，“身是菩提树”，我就偏说“菩提本无树”，你说我们的心本来很干净就在那里存在着，他说没有，“本来无一物，何处惹尘埃？”。 </p>
<p>神秀的偈句毛病在哪呢？我们刚才已经做了一些讨论，神秀的偈句表明了神秀对修行的理解，什么是佛家的修行呢？在神秀看来，就是要保持我们本来的干净的心，跟外部世界的灰尘之间的隔绝状态，始终保持这种隔绝，叫“时时勤拂拭，勿使惹尘埃。”那么<strong>尘世</strong>是什么？<strong>尘</strong>就是<strong>烦恼</strong>。人世间无处不是烦恼，所以这个世界一定是尘世，那么本来干净的心落到这个世界中来了，难免要沾染上灰尘，因为难免沾染灰尘，所以要修行。</p>
<p>修行是保持我们的心的干净。问题出来了，我们要问烦恼来自哪里的？烦恼就是来自我们的心嘛，没有心哪有烦恼呢？动物没有人那样的心，所以动物是没有烦恼的。你说动物有心脏没问题，心脏不会生烦恼。你说高级一点的动物，有mind，就意识、心智。你说这个心，他也不生烦恼。如若不信，那么我们讨论，动物为什么说它没有烦恼？动物会有<strong>焦虑</strong>。狗啊、猫啊、黑猩猩啊都会<strong>焦虑</strong>，为什么啊？若他饥饿了没有食物，他焦虑了急了；若它的安全受到威胁了，它焦虑了；如果他身体生了病，肉体痛苦了，它也焦虑，鸟兽的哀鸣我们听到了，但这一切都不能说烦恼，只是<strong>焦虑</strong>。倘若我们给动物这三样东西一样都不缺，<strong>食物、安全、健康</strong>都不缺，它每天活得很欢。</p>
<p>人不一样的噢。我们通常情况下每天这三样东西都有，一、肚子没饿着，有食物；二、我们的安全没受到威胁，我们安全；三、我们身体还没生病身体健康。我们同时拥有这三样东西，<strong>食物、安全、健康</strong>，我们照理应该很开心，什么事都没有。事情多着呢！烦恼不断。假如人获得这三样东西，就没事情了，人散了。绝大多数人在通常情况下都是这三者都齐备，<strong>食物、安全、健康</strong>没用。烦恼不断！烦恼从哪里来？来自我们心有<strong>无限的一面</strong>，什么叫心有无限的一面？就是要<strong>筹划未来</strong>。筹划了未来就要实现自己的愿望，要如意。倘若愿望没有实现叫不如意，不如意就是烦恼，所以我们的人心才生出烦恼来了。</p>
<p>这个世界上，世界没什么干净肮脏的区分的，世界本有灰尘吗？**灰尘是指烦恼，并不来自世界本身，来自人心。**所以神秀的偈句第一个毛病就看清楚了，不要把心和烦恼对立起来，是两样不同的东西，然后把他们隔开，不是这样。你隔不开，烦恼就从心里生啊。第一个毛病看清楚了。</p>
<p>第二个毛病，假如我们修行就是要把烦恼拒之门外，如何可能？而且他一开始就违背了佛教的初衷。他这个境界啊，神秀这个偈句的境界最多是小乘的境界，求自己本人干净，叫<strong>自了汉</strong>。大乘境界，大乘佛教的境界是要把众生的烦恼也看成是自己的烦恼，要把众生的罪过也看成是自己的罪过。你要拥抱众生的烦恼，而不是把他拒之门外。第二个毛病。</p>
<p>大悲悯才是大智慧呢。对众生的烦恼没有感同身受，对众生的罪过没有自己的悔罪的感受，那不是大乘佛教的境界，他就远离了大智慧。因为大智慧就是大悲悯，这又是个毛病。如果更进一步讨论毛病很多，我们以后还会提到神秀的偈句。菩提是智慧的象征，“无上正等正觉”。请问智慧从哪里来？也从我们心里生出来，因此不能把智慧跟烦恼也看成是彼此对立的东西，实际上是来自同一个心，心的一种用法，用出烦恼，还有一种用法用出智慧。那么烦恼跟智慧就有关系，这个关系是什么？<strong>烦恼是我们长智慧的材料</strong>。假如人世间本无烦恼，要智慧干嘛？因为有大烦恼才可能生大智慧，人类始终以痛苦为代价学习真理的。</p>
<p>我上午讲到悟要有缘，这个缘是什么？对于我们大多数小根之人来说，要生活中遇到痛苦，到一定程度这个悟的缘就成熟了。如果再得到了大善知识的开导，大善知识就是禅宗祖师这样的人物，抓住了这个机缘让你开悟。你没事情的话不可能悟，大痛苦大烦恼来了，你的悟的缘就成熟了。所以不能简单的把智慧跟烦恼对立起来，他们本出一个根源，那就是<strong>心</strong>。</p>
<p>所以后来悟了佛法之后的惠能说了这样一句话，“烦恼即菩提”，烦恼就是菩提，没有烦恼怎么可能觉悟呢？好，这样我们看神秀的偈句毛病看得清楚了。那么惠能是针对的他的毛病有了自己的偈句。这个偈句把所谓本来干净的心现成的存在以及外部的烦恼，现成的作为灰尘也存在，这两者都无掉了。“本来无一物，何处惹尘埃？”，这个偈句书写在墙上了，当中省略了许多叙述噢。实际上后来第二天，弘忍法师来了，见到了众弟子都在边上，弘忍法师脱下自己一只鞋子，用这个鞋子把墙上惠能的偈句擦掉了。说了一句话，“亦未见（本）性”，“亦未见性”。当然仍然是对惠能的保护。众弟子一听，我们的师傅也不怎么欣赏惠能的偈句，惠能就继续安全。但是他说“亦未见性”这句话仍然是真话。佛家不打妄语，虽然惠能的偈句境界要比神秀的高，但是还未见本性，弘忍法师说了一句真话。那么为什么说他还未见性呢？假如我们心中老是念着惠能的偈句，我们能见性吗？其实也不能见性。惠能的偈句先把神秀偈句当中的心和烦恼的对立，这种对立给它无掉了，把它空了。但是你不能停留在空里面，这只是学佛达到的第一层境界，第一层境界不是究竟的境界。我们上午提到了《金刚经》当中八个字呀，“应无所住而生其心”。那么惠能的偈句其实只是说出了这8个字的前4个字的境界：“应无所住”。</p>
<p>我们既不要住我们自己本来干净的心，这种住仍然是住了啊，叫<strong>着了净相</strong>，<strong>住了净相</strong>。外部世界，万事万物对人的意义，如果它是给我们带来烦恼的东西，这烦恼不是这个事物的属性，是我们的心跟这个事物的关系。我们住相，“应无所住”的“<strong>住</strong>”就是住相的意思。“<strong>相</strong>”什么意思？就是我们把世界上所有的事物和所有的人都区分出一个高低贵贱，这就叫“<strong>相</strong>”。还停留在这个区分里叫“<strong>住相</strong>”。<strong>相</strong>是客观的，我们也不能否认。有的事物重要，有的事物不太重要。你LV包比我这个包贵得多，价格昂贵的多，质量好的多，这种差别是真实的。假如我看到你背着LV包向我走来，我一眼看，哦！世界顶级的品牌包。然后我再看我这个包，它简直不是包，这就是<strong>住相</strong>了。你那个LV包的质量尽可以比我这个包好的多，价格也昂贵的多，但绝不妨碍我这包还是包，这就叫<strong>不住相</strong>。</p>
<p>人心生烦恼的原因，就在于我们心往外面求，向外侈求。我们对外部事物做了种种的分别：高低、贵贱、好坏等等。这种分别就是相形成的，然后停留在这相里边，心就不得安定，烦恼就来。所以要把它无掉。相存在，但不著相，那叫“于相离相”。惠能的偈句讲出了，“应无所住而生其心”，这“应无所住”这4个字的境界。于是就呈现出学佛的第一层境界，就是要<strong>空</strong>！但不能停留在空里面，停留在空，活在这世界上没什么意思，佛教不是教我们自杀的学问，当下离开这个世界吧，不是的。</p>
<p>第二步要把这空再空掉，这叫<strong>空空</strong>。无了之后并不是什么东西都没有，有东西来。什么东西来了？<strong>本心</strong>起来了，叫”而生其心”。这8个字的后4个字的境界，惠能尚未达到。所以弘忍法师说他“亦未见性”。弘忍法师用鞋子把墙上惠能的偈句擦掉了，这个动作本身是禅意，深有禅意。你惠能的偈句说的是无的境界，说的是空的境界。你只是这个境界，不能停留在你这个境界里，对你所说的“空”，我还得“空“一次。对你所说的无，我还要对你无一次，那叫擦掉。这个动作本身就是禅意，对空空一次，对无无一次，那叫<strong>空空</strong>。</p>
<p>当然周围的弟子没有人能够领会，佛家不打妄语，所以说他“亦未见性”就这个道理。现在有些人学佛第一步恐怕达到了，“万法皆空，诸行无常”，你不能停留在这一点上，当时惠能达到了这个境界。</p>
<p>五祖弘忍看到了这个偈句，其实心里明白了时机已经成熟，今天晚上一定有人入悟，而且这个人一定是惠能，所以他预做准备。他做了什么准备呢？等会我们就知道了。第二天五祖弘忍法师终于到舂米房里去见惠能了，春米房又叫碓坊。“次日祖潜至碓坊”，注意啊，用了个“潜”字，潜伏的潜，可见环境的险恶。弘忍法师作为堂堂一师之祖啊，要去见一个舂米房里的惠能都要避人耳目，悄悄地溜进去。读这种佛经，或者读一些文学作品就得这么读啊，一个字你就知道环境了。走进碓坊，正在见谁啊？惠能正在舂米呢。舂米，繁重的体力劳动啊。我上午讲一块很大的碓石，上方系着一根又长又粗的木棒上，那叫杠杆。这一头踩下去，碓石往上冲，这一头一放叫舂米。惠能是个身体瘦弱的人，没那么大的力气，后来他想了一个办法，找了一块蛮大的石头缚在腰上增加体重，这叫“腰石舂米”。</p>
<p>弘忍见他是“腰石舂米”的，第一句话就来了，“求道之人，为法忘躯，当如是乎！”表扬他了。你是个求道的人，为了求得佛法，你忘记了自己的身体，正应当如此。底下问他问题了：“米熟也未？”。米熟了吗？米舂好了没有？惠能是何等人物？根器大利的人，他怎么会从字面上理解弘忍法师的提问呢？他回答说“米熟久矣，犹欠筛在。”弘忍法师是何等人物？怎么会光从字面上理解这个回答呢？他立刻明白惠能在告诉他什么？一个“筛“字是师傅的师的谐音。当然惠能不识字，如果惠能识字也很清楚了，我们把“筛”这个竹字头拿掉不就是师吗？弘忍法师知道惠能在告诉自己，我老早准备好了，只差最后一个环节，由你师傅来帮我开悟。弘忍法师也不说话，以手杖敲了碓石三下，“祖以杖击碓三下而去”，惠能心领神会，叫我三更时分到方丈室去。</p>
<p>“三鼓入室”。到了方丈室以后，弘忍法师用很大的袈裟，把窗户遮掩了，不让灯光透露出去，终于在灯下给惠能讲《金刚经》了。讲到“应无所住而生其心”这8个字的时候，惠能言下大悟，连说了五个“何期”，他悟了什么？“一切万法不离自性”，连说五个“何期”，他就接着师傅说下来了，“<strong>何期</strong>”就是<strong>没有想到</strong>。</p>
<p>“何期自性本自清净，何期自性本不生灭，何期自性本自具足，何期自性本无动摇，何期自性能生万法”，连说五个何期。我们一个一个来看，<strong>自性就是自本性，也就是佛性</strong>，<strong>人人都具备</strong>。我们每个人怀里都揣着一个宝，叫<strong>佛性</strong>，佛性不是从外面去求得的，人人都具备的，所以又叫<strong>自性</strong>。他怎么样的？<strong>本自清净</strong>，什么意思？神秀说这个心干净噢，但是会脏，染上尘埃。会染上灰尘，所以要擦。但是佛性，我们本有的自性，不是这样的东西，它犹如一块宝石呀。所以佛教当中禅宗就有一个故事讲的好，叫“春池拾砾”。这个比喻非常有意思，说是春天，那个池塘里面有一块宝石掉进去了。那么众人都跳下去捞这块石头，捞这个宝石，人们纷纷的跳下这个池水中，去捞那个宝石，捞宝石捞不到，为什么？把水弄混了。其实不必跳下去的。把水弄混了，又捡起来的，绝不是那宝石，是瓦砾。他既然是宝石，在水里它有自净的功能，他能够把水弄干净了。你只要静静的等在边上看着，它水就澄清了，澄清了，你自然看到它在那里了。一个能被沾染上灰尘的，还能叫宝石吗？你说一块瓦砾本来干净也可以呀。那么瓦砾也沾染上灰尘，你去擦，那就是瓦砾罢了。我们的佛性就是宝石呐，它自净啊，否则它怎么叫宝石呢？所以不存在它会有沾染上灰尘，灰尘是它里边生它也可以让它干净，这就叫“本自清净”。</p>
<p>我们现在都要到外面去找宝石呢，如“春池拾砾”一样的做法，纷纷忙活得不得了，要去找那个宝石。宝石不必找，把我们这混乱的烦恼的生活弄干净了，它自己就有自净的功能了。所以第一句话就来了：“何期自性本自清净”。一个“本自清净”就明白了，哪有什么从外部沾染到灰尘然后再去擦。我们还不免问神秀，擦灰者又是谁呢？你本该干净的心，然后灰尘上去了是吧？还要擦，擦者是谁？擦者是在心之外的东西吗？不可能，还是我们的心的。我们的心自己在擦自己呢，那叫什么？“本自清净”。你除非要另设一个高于我们心智上的，比方说另设一个上帝来帮助我们，那叫西方思想。我们的心充满了罪孽，叫原罪，只有上帝能够拯救我们，这是西方基督教思想。我们每个人都有佛性，它“本自清净”。如果生烦恼，它也能把烦恼自己给它去掉，不要另外的东西来擦它的灰。所以这一层来了。</p>
<p>“何期自性本不生灭”。我们平时的心是假的，叫<strong>业识</strong>，种种的念头起来又消失，那叫生生灭灭，<strong>佛性不生不灭</strong>。</p>
<p>“何期自性本自具足”，它自身圆满，毫无欠缺。真理不要到心外去求，真理我们本性本都具备的，这又让我们想起谁了？想起了孟子。孟子说“万物皆备于我，反身而诚，乐莫大焉”。孟子的思想是心学的萌芽，禅宗是佛教中的心学，抓住了这个心了。真理不要到心外去求，“万物皆备于我，反身而诚”，反求诸己，其快乐是无比的。《孟子·尽心上》讲的原话。所以中国人能把佛陀的思想中国化，是因为中国人本有自己的智慧——儒家和道家，才能把它中国化的。所以“何期自性本自具足”就说出了我们要相信自己了，相信我们的<strong>自本心、自本性，即佛性</strong>。</p>
<p>“何期自性本无动摇”，我们人生的处境千变万化，无论是苦境还是乐境，无论是顺境还是逆境，都不足以撼动我们这个自性。不足以撼动自性，就”何期自性本无动摇&quot;。</p>
<p>最后“何期自性能生万法”。<strong>万法</strong>就是万事万物。佛教当中讲“法”这个字，有两种含义，<strong>一种就是指是事物，还有一种是指佛法</strong>。在这里是万事万物。什么叫能生万法？是不是我们的自性创造的万事万物来？那我们变造物主了。不是创造着万事万物，而是<strong>万事万物的真实的意义指向我们的自性呈现</strong>，这叫<strong>能生万法</strong>。我们的自本心不起来，万事万物对我们的意义，都是由我们的<strong>业识</strong>，想要如意的假的心，所形成了“意”，都不是真实的意义。好，这样连说五个“何其”。弘忍法师听他说出这五个“何其”来，明白了他已经悟了。第24页翻过来，“祖知悟本性”，五祖知道惠能已经悟了本性，就跟惠能讲，“不识本心，学法无益”，学佛法有什么用处呢？“若识自本心，见自本性，即名丈夫、天人师、佛”认可他了啊。你如今是丈夫、天人师。六道当中，你不光可以教人，还有天上天道中你都能做的老师了。还有就是佛，同样的意思。所以他决定把衣钵传给他。跟他讲，“汝为第六代祖，善自护念”，这话也重要。修行的人经常会讨论一个问题，悟了之后还要不要修？也还是要修的，这个修跟悟之前的修不一样，悟了之后的时候叫“<strong>护念</strong>”。如何“<strong>护念</strong>”？<strong>用你每时每刻的生命实践来体现佛理，来印证佛理</strong>，这就叫“<strong>护念</strong>”。这些话我们以后还会讲到的。</p>
<p>禅宗讲人的修行分了两大阶段：第一阶段是要读佛经的，也要得到大善知识的开导，然后有朝一日“<strong>悟</strong>”。顿悟之后第二阶段来了，叫“<strong>证悟</strong>”。前面阶段叫“<strong>解悟</strong>”。当中一个关键的环节，就是<strong>顿悟</strong>。一个顿悟了的人自见佛性了，见性成佛了，还要“<strong>护念</strong>&quot;，叫“<strong>证悟</strong>”。整个就是人生修行的两大阶段，顿悟之后还是要修，这个“<strong>修</strong>”是什么？不再在那里读佛经讲解佛经的道理，这些都不必要了，佛经不必读，也不要听什么人来讲经说法了。因为已经进入了“<strong>证悟</strong>”阶段，就是用你自己的生命实践来印证佛理，这“<strong>证悟</strong>”了，这叫“<strong>护念</strong>&quot;。</p>
<p>“善自护念，广度有情”，天下一切有情物，包括动物在内，有知觉的都叫有情物。“广度有情，流布将来，无令断绝”。告诉他使命，什么是你惠能的使命？这就是。底下来一个偈句：“有情来下种，因地果还生。无情既无种，无性亦无生。”前两句说什么？后两句说什么？前两句说有，后两句说无。为什么要讲这四句你是偈句呢？前两句就说了，你惠能是一个“有情”，你来下“种”了，“种”下去会有果生出来，你承担好你的使命，就能够“广度有情，流布将来”，将来心法不会断绝，你完成使命你就走吧。一种叫“圆寂”了，是吧？“圆寂”嘛，就是“无情既无种”，这个“既”呢，也就是“也”，通这个意思，通这个字的意义。“无情亦无种”就这个意思。“种”，你就没有什么事倩要做了，你走吧。“无性亦无生”，你已经不生不灭了。所以这个偈句就说出了惠能的使命，你完成好使命你就走。确实如此，惠能寿命并不长，76岁也就走了。</p>
<p>然后弘忍法师跟他讲，“昔达摩大师，初来此土”，来到我们中国了——东土。“入未之信”，没有人相信他，“故传此衣，以为信体”，一个信物，“代代相承”，这只是个外物吧，真正传的是<strong>以心传心</strong>。“法则以心传心”，那叫传心法，“皆令自悟自解”。“自古佛佛”就佛与佛之间，前面的佛后面的佛，“自古佛佛惟传本体，师师密付本心”，前面的祖师和后面的祖师都是传心法的。</p>
<p>这个信物到现在成了争端了，衣钵成了起纷争的根源了，大家都要来抢。所以到你这里我传给你了，你就别再往后传了。弘忍法师跟他讲清楚的，衣钵传到你第六祖结束，不要再往后传。再往后传还了得，如今已经纷争四起了嘛。弘忍法师的处境很像当时的康熙。康熙传位传给谁还了得，十几个儿子在争斗啊。现在他衣钵传给谁还了得，东禅寺那么多弟子在争斗，所以到你那里你就别再传了。“止汝勿传，若传此衣，命如悬丝”，你就性命攸关了。“汝须速去，恐人害汝”，你今天马上要走，此地不可停留，看得很清楚。那么惠能自然要问我往哪里走呢？“逢怀则止，遇会则藏”，<strong>怀</strong>是怀集县，<strong>会</strong>是四会县，一个广东一个广西（其实也都是在广东），也就是告诉他将来的归宿了。你惠能将来的归宿，归宿是什么？就在两广之间住化一方，不可离开那里。这是神通啊！对未来很清楚的。所以后来都这样，每一个禅宗祖师把心法，把佛法传给他下面一个，就是肯定给他一个8个字的，跟大家讲你将来的归属，你要牢记在心的。</p>
<p>我们再看下去，三更时分的惠能就得了衣钵了，然后就跟师傅讲，“能本是南中人”，南面的人，“素不知此山路，如何出得江口？”这里人地两生，山路我也不清楚。弘忍法师说不要烦，你不要忧愁，“吾自送汝”，我会送你的。这就我刚才讲的什么？弘忍法师已经知道今天一定有人悟啊，预做准备，悟的人一定是惠能。做了什么准备呢？我们翻过来看，第30页。黄梅县东山寺附近有一条江叫九江，九江有个驿站，驿站边上有一个渡口，“祖相送直至九江驿”把他一路送到九江的驿站边上。他预做准备，准备了一艘船呐。上了船之后呢，五祖亲自来摇橹了，这个动作很有意思的唉。我们中国人的规矩都是这样的，哪有老师给学生摇的？总学生摇橹嘛。那么为什么五祖要摇橹？我们看下去就知道了，</p>
<p>“请和尚坐”，惠能急了，你坐下吧。</p>
<p>“弟子合摇橹”，我应该来摇橹。</p>
<p>弘忍法师一句话来了，“合是吾渡汝”，应当是我渡你嘛。这个一语双关嘛。我渡你，这是对惠能的最后的考验。</p>
<p>惠能极快的回答了一句：“迷时师度，悟了自度，度名虽一，用处不同。”厉害！</p>
<p>这两个人其实都是同一个档次的，都是祖师了，你知道吧？那话多厉害的，都是。</p>
<p>你这个动作就有意思给我了，你向我提问了，我还不能回上来吗？我来摇橹。本是我来渡你的嘛，不，“迷时师度，悟了自度”，当中没有任何间隔，紧凑的不得了。</p>
<p>边上以为他们在说闲话，哪里是闲话？我最后的考验给你了。这种考验有两层意思：一层意思你悟透了没有？还有一层意思是什么？你以后去传扬佛法，我能放心吗？你要让我放心啊。多少的艰难困苦在你前面等着你呢，所以我来渡你吧。不，“悟了自度”，就是叫他师傅放心。我现在如今自渡了，“自性自度”，我自性看清楚了。<strong>自性</strong>就是<strong>自本性，佛性</strong>了。当然自己度自己了，其实就是让他的师傅放心。请大家注意。最后给他一个印可的话，有弘忍法师印可惠能，最后的话是什么？我们等会看，底下惠能继续说了。我是“生在边方”的，边疆这一带的，语音不正，就如今讲的就是粤语这样的话，不正呐。“语音不正”的，所以在这个地方我怎么办？“蒙师传法，今已得悟，只合自性自度”。说明确，说明白了，这句话一旦说出来，弘忍法师马上印可同他，怎么印可的？“如是如是。”请注意“如是如是”这话，承认后一个人已经悟了，并且可以做祖师了，可以住化一方了，你要给他资格的。怎么给他资格？你认同他，认同他说什么话呢？一般是这么说，完整一点啊，“汝既如是”，你既然是如此的，“吾亦如是”，你跟我一样了。这就是印可他的话。</p>
<p>倘若一个禅宗祖师跟你说出这句话来，“汝既如是，吾亦如是”的话，你明白了，他给了一张教师资格证书，就这个意思。你否则没资格做教师的。我们现在也有教师资格证书，我也领了一张的，复旦大学跟我讲了 “汝既如是，吾亦如是”，那么我就安心做教授嘛，他就是教师资格证书的颁布。这个教师当然是祖师啊，禅宗祖师或简称<strong>禅师</strong>。你做禅师要有人认可你的，你在哪里开悟的，那个人认可你，你就得了这证书了。</p>
<p>所以当弘忍法师终于跟惠能说，“如是如是”，就清楚了。那一方你可以住化了。</p>
<p>“以后佛法，由汝大行”，就靠你了。</p>
<p>“汝去三年，吾方逝世”，全清楚的。你走了之后三年之后我会离开的，离开这人世间了，就会圆寂的。全清楚啊。这时候弘忍法师不是活得好好的吗？又没什么病痛，知道。当然这是最起码的。</p>
<p>修佛三层境界：第一层<strong>阿罗汉</strong>，第二层<strong>菩萨</strong>，第三层<strong>佛</strong>。照理说来，一个人出家了到庙里做和尚，假如他是真修行的话，是真和尚的话，不敢说他一定达到<strong>菩萨</strong>或<strong>佛</strong>，但他至少达到<strong>阿罗汉</strong>。那么达到<strong>阿罗汉</strong>的标志是什么？非常简单，<strong>知道自己什么时候走</strong>。当然五祖不仅是阿罗汉境界。但是说阿罗汉他当然有了这个境界。所以他就跟惠能讲，三年之后我就走了，对他来了一番谆谆的嘱咐。</p>
<p>“汝今好去，努力向南，不宜速说，佛法难起。”你如今得到佛法了不可到处去说，你要隐居15年，隐居15年，这话这里没出来，有的本子里就有。那么二十四史里边，《宋高僧传》里边，《惠能传》里边就有，就是叫他隐居十五年的，我不免感慨。弘忍法师跟惠能讲，你现在不能到处去说佛法的，你要隐居十五年，“不宜速说，佛法难起”。这表明弘忍法师对他当初所属的时代，把握得非常准确，所以我就联想了，假如弘忍法师把衣钵传给惠能是在1978年，他会说什么？我相信他一定说你要隐居30年，“不宜速说，佛法难起”。1978年中国改革开放刚刚起步，全体中国老百姓人人都做着发财的梦。你这时候跟人家去说佛法，谁要听？30年过去了，少数人成功了，大多数人被市场改革一波又一波的浪潮扔到了弱势群体里，终于绝了发财的望，只求个安居乐业。</p>
<p>如今中国社会充满了病症，安居乐业，这四个字都难得。无论是有产的还是无产的，都不“安”也不“乐”，我们凭什么把我们的孩子一定要送到国外去，有国也不肯归。那么没钱的，这房子也不知道在哪里噢，实际的“居”也搞不清楚，“业”也是不稳定的。好，我们这个就不说，一说就变成愤青了，不好。但是这个事实放在那里。如今社会充满了病症，佛法是要用来治病的，病没有起来谁要这个药。如今病已经起来，如今你去跟别人说佛法，有的是人要听。所以我就感慨，弘忍法师对他所在的时代把握得非常准确，叫他隐居15年。</p>
<p>好，当晚就走了，过了江，告别了师傅。“发足南行”，往南面跑啊。这个跑你怎么跑得了呢？跑了两个月都还没逃掉呢。为什么？第一，我刚才讲惠能这个人身体瘦弱，这是其一。其二，它是南面的人是吧？湖北这个地方，他人地两生啊，山路他也走不惯呐，所以很快的就被东禅寺的弟子们追赶上来了。到了大庾岭，“逐后数百人来”，不得了啊这个气势，几百人追上来。其中有一个人跑得最快，因为出家之前是什么？一介武夫——四品将军，这个叫惠明。出家以后的法号惠明了，也是弘忍法师的弟子之一。</p>
<p>他跑得比众人都快，一马当先。“为众人先，趁及惠能”，惠能躲不了了。惠能怎么办？把衣钵放在一块石头上，自己躲在草丛里，跟惠明讲：“此衣表信，可力争耶”。还有一个版本是说惠能跟他讲，这衣你搬不动，就是要提醒他。什么叫搬不动？这个“衣“表示什么？传扬佛法之大任，你担当不了，就这个意思。都是一语双关。但是惠明没悟嘛，还是要上来搬的。</p>
<p>书中就写到，“提掇不动”，果然搬不动。没办法了，跟草丛中的惠能讲话了：“行者行者，我为法来，不为衣来！”。这话说的好了，我归根到底不是为了衣钵而来，我为了求佛法而来的。好，你既然这么说。惠能就从草丛里出来了，你要听佛法可以呀，现在请你坐下。</p>
<p>惠能自己盘坐石上。惠明这时候作礼了，你要听佛法得作礼吧。“望行者为我说法”。你看，口口声声，一声一口地称他为什么？<strong>行者</strong>。这要符合事实啊，符合什么事实？惠能尚未剃度出家。弘忍法师没收他做弟子嘛，所以他现在在佛教界的最高地位无非是行者，跟孙悟空一样的，孙悟空不就孙行者嘛。</p>
<p>惠能讲了：“汝既为法而来”，你既然为了佛法来的，叫他 “屏息诸缘，勿生一念”，把各种念头都放下来，这等于叫惠明打坐。打坐第一步当然要“屏息诸缘”，什么念头都不要有，不要想着这件事，想着那件事，叫他打坐。</p>
<p>“良久”，就坐了很长一段时间，惠明坐了很长一段时间。惠能终于开口说话了。就两句说下去的啊，这两句一说下去，惠明悟了。惠能说这样两句，第一句“不思善，不思恶&quot;；第二句“正与么时，那个是明上座本来面目”，两句一说下去，惠明言下大悟。</p>
<p>我们不免要问，为什么他听到这两句会言下大悟呢？我们也听到这两句，悟了没有呢？这是一个非常典型的公案。禅宗有许多公案，每一个公案都是一个祖师让另外一个人悟的例子。我们看这个公案吧，猜一猜。第一句话“不思善，不思恶”。我刚才讲，上午就讲一个禅宗要让另外一个人悟，必须抓住这个前来问佛法的人的特征，你不能不同的人来问你佛法，你用同一句话回答，这不行的。人与人之间千差万别，所以禅宗祖师要有一个本事啊，这个本事就抓住前来问佛法的人特征，抓住他这个<strong>机</strong>，接他这个<strong>机</strong>，对他这个<strong>机</strong>，说话要准确而锋利，叫<strong>机锋</strong>。</p>
<p>那么惠明什么特征呢？惠能心里明白此人哪，要来把衣钵夺回去，也不是为了自己的。惠明这个人最大的特点就是善恶分明，爱憎分明。他不能容忍惠能拿了衣钵就走。他并不认为自己可得衣钵，他也知道自己没资格，但他不能容忍惠能，为什么？你都还没出家呢。你尚未剃度出家，你如今在佛教界的最高地位无非是行者，凭什么拿着我师傅的衣钵就走了呢？一个没有出家的人违背了佛教界最起码的道德标准。为了这一点，我惠明一定要把你的衣钵给他夺回来。惠能知道他怎么想，所以第一句话就来了。“不思善，不思恶”，这个对的准啊。因为你心里就想这个东西，我告诉你今天这个事情跟善恶的对立没关系，跟出家还是在家的区别没关系，而是谁能够担当传扬佛法的大任。所以这第一句话就把大家都在纠结和争执的这件事情本身消解掉了。有意义吗？禅宗里面叫这种话叫“<strong>夺境</strong>”，把这个事给夺了。</p>
<p>我们要学一点禅宗的，我们在自己的生活或者工作的经验当中，一定会遇到这样的情况的。当初这件事情发生了，大家都觉得它不得了的大事情，多少人参与其中，纠结争执不已。假如你也在其中，你试试看能否把它夺了。这件事情，当时大家都觉得不得了的大，多少年过去了，回头再看这件事情，它还有意义吗？它老早烟消云散，这种事情碰到过吗？</p>
<p>我们复旦大学2005年，要举行隆重的庆典，庆祝复旦大学100周年诞辰。复旦是1905年创立的，百年校庆。我有一个非常好的同学，就是跟我博士是同届的，我们一起拿博士学位的，戴博士帽。两个人又学的是同一个专业，关系非常好，又是邻居。他被校长委派的干嘛？校庆办主任。百年校庆成立了一个校庆办。这种校庆办主任其实没有实权的，他的责任就是协调各方。我们复旦大学也是半个官场，多少行政部门，人事处啊，财务处啊，什么教务处，什么研究生院呐，那么多。都是各个部门都有它的第一把手啊，都实权在握。那么你要搞这个校庆是不是你要有一个校庆办主任来协调各方，但它本身又没权。那一天是我印象太深了，第二天举行百年校庆，前一天我就陪着他，我知道他累了那么久了，我又是好朋友，我今天来陪你。虽然我没有任何职位噢。他就在校庆办办公室里边跟我聊天，一面焦急地等待着什么？手机的通知。为什么？他在等待一个部门给他一个资料，这个资料非常重要，就是牵涉到明天校庆大会的会场上的第二排以后的座位谁坐谁坐。有许多各方的来宾吧，还有中央领导都来的。当时那么第一排不用他管，排座次是很大的一件事，第一排的排座次不用他管，校长办公室都讲好了的事情。二后面事情全他的，而那些人也不得了的人，有地方政府官员。有非常重要的角色都要来，怎么排？他就等另外一个部门给他资料。他不能自说自话。等到10点、11点、12点都没来，等到凌晨2点他发急了，他就知道这个人在刁难他。他拿起这个手机往地上摔，头往墙上撞。我一把抱住他，我说还了得，这一撞我不抱他，他肯定撞得头破血流噢。我拖住他，跟他讲的一句话，我说你干嘛？多少年之后，谁再讨论这次校庆怎么搞的？当时我拖住他的，还好没出事情。出事情，傻掉了，头撞墙了，撞出大事情还了得。还好，多少年过去了，我跟他仍然是非常要好的，我们同科出身嘛，都是同届博士，有时候经常在校园里遇到。有一次我偶然想起这件事情，我就问他了，我说十几年过去了，如今有谁在谈论当初复旦大学百年校庆是怎么进行的？有多少成功的经验？有多少失败的教训？谁会讨论这件事情？老早过去了，连留下的那些文字的东西也堆在仓库里没人看你知道吧？我们百年校庆那么多画册，没人看的，都过去了，他说倒是的噢。我说我当时就拖住你了，你知道吗？否则你这个小命值得吗？赔上去了。</p>
<p>这就叫什么？“<strong>夺境</strong>”呀。我最觉得现在中国官场上那些官吏们其实蛮可怜的，这辈子几十年做的事情，每一次都不得了的事情，过去全没意义的，一生就虚度了。回顾往日，我做过校庆办主任，这算什么？没意思呀。但当时很认真，因为我们都是很认真的人，然后在里面纠结，你事情应该做好，但别纠结。你要能“<strong>夺境</strong>&quot;。</p>
<p>所以第一句话“<strong>夺境</strong>”。</p>
<p>光<strong>夺境</strong>还不行。第二句话来了——“<strong>夺人</strong>”，把惠明这个人给他夺了。“正与么时”，正当此时此刻，“哪个是明上座本来面目？“这一问问得好，把明上座这个<strong>小我</strong>给他夺了。这话说得很巧妙的。他尊称惠明叫什么？<strong>上座</strong>。你称我行者是吧？好，我就称你<strong>上座</strong>，对呀。我都不是弘忍法师的弟子，你都是上座弟子，你地位比我高的多。好，我把你端起来，明上座，尊称你为明上座。且问明上座是你的本来面目吗？这一问问得好！假如明上座是你的本来面目的，当初怎么会是四品将军的呢？假如四品将军是你的本来面目，你怎么后来又成了明上座呢？可见四品将军也罢，明上座也罢，都不是你的本来面目。</p>
<p>我们每个人都会珍惜自己这个小我的，不断的拿出来跟别人比，如果发现别人比自己高，心生<strong>嫉妒</strong>。如果发现别人比自己低，心生<strong>傲慢</strong>。其实我们真的想一想，我们不断拿出来跟别人比的那个我是自己的本来面目吗？1966年文化大革命爆发，我是当时小学三年级的学生，很快知道我是谁了。父亲叫走资派，母亲叫逃亡地主，于是我叫狗崽子。狗崽子是我的本来面目吗？肯定不是。多少年过去了，昔日的狗崽子成了今天的复旦教授，难道我因此就可以说复旦教授才是我本来面目吗？能说吗？照样不可说。就像狗崽子不是我的本来面目一样，复旦教授同样不是我的本来面目。所以这一问，这倒是个问题让他去参的，这叫话头啊。让惠明参话头。这一问问得好了，惠明一下子明白了，你跟我的差别其实都没意思。噢，我们上座。你呢行者，比我们低。你也不应该拿着衣钵走，违背了佛教界起码的道德标准，都错了。这叫<strong>夺人</strong>。境也夺了，人也夺了。<strong>人境俱夺</strong>，还剩下什么？Noting is，<strong>虚无</strong>。惠明的<strong>心跟虚无契合了</strong>，这就叫<strong>悟</strong>。</p>
<p>我们不知道什么叫<strong>悟</strong>。<strong>悟</strong>不是认知活动。认知活动就是我们平时学习科学，学习经验，学习知识，都是做加法。知识越多越好，就认知活动总是有所得。你学了牛顿物理学，你理解了牛顿三大运动定律，有所得吧？有。悟是什么？在认知活动当中有能知和所知的区分，我们每个人都是能知的主体，就是我们有认识能力，我们发挥我们的认识能力去获得那种客观的知识，客观事实就叫<strong>所知</strong>，<strong>有所得</strong>。悟没有能悟和所悟的区分。悟不是这样一件事情，有一样东西在某处等着我们，等待我们悟到它。有一天我终于悟到它了，没这件事。悟不是这样的。如果是这样的话，跟<strong>知</strong>没区别。<strong>悟是无所得的！<strong>为什么说它无所得？是我们的心跟虚无默契了。<strong>默契虚无</strong>，领会虚无的智慧叫什么？<strong>叫般若。<strong>什么叫</strong>般若</strong>？就是</strong>领会虚无的智慧</strong>。我们现在还是用音译的，叫“<strong>般若”</strong>。这一点非常要紧，常人都把<strong>悟</strong>和<strong>知</strong>混淆了，因为混淆的缘故不能接受惠能讲顿悟，只能接受神秀讲渐悟。我们得渐渐的悟起来，从悟的少到悟的多，最后彻底悟了，这全是错的。</p>
<p>知识是渐渐积累的，你学牛顿物理学，怎么学？你不能一开始就学他后面的东西是吧？你得按部就班呐，循序渐进啊，那叫<strong>认知活动</strong>呀。<strong>渐知是对的</strong>，知识是积累的过程。哪有渐悟的？悟是要么悟了，要么没悟啊。要么你跟虚无默契了，那叫般若智来了，要么你根本没有，哪有渐渐多起来的事，这些都得交代明白。其实我们中国人本应当是很清楚的，只是现在是糊涂了。你比方说我跟你说一句话吧，“你要有觉悟啊”。你立刻听明白我的意思了吧？你绝不会误解的，你不会误解为我要求你要有知识，不是这个意思吧？希望你有<strong>觉悟</strong>，不是希望你有<strong>知识</strong>。这是两码事。我们本来很清楚。现在倒是不清楚了，只知道认知，不知道觉悟。</p>
<p>所以我们现在最要紧的事情不是知识再多一点，这有什么要紧呢？庄子老早说过了，“生有涯而知无涯，以有涯逐无涯，殆已。”人生是有限的，知识是无限的，以有限的人生去追逐那无限的知识有什么结果呢？没结果的。但现在的人主张知识不断更新，终身教育。如果这个教育是走向觉悟的倒也蛮好，就不断增加新知识。有时候我觉得我知识太少了。因为这个知识太多了，你知道我到银行办件事我都搞得不清楚了，现在。一系列的概念跟我讲了一下，我就想这很简单，我不就是买个外币，然后就汇给我儿子在国外留学嘛，这么简单事，弄得我很复杂，你知道吧？我想怎么这么复杂？现在知识真多。知识多的一个重要标志是什么？职业越来越细分化，以前根本没有的职业，现在全来了吧，叫专业细分。啊，那么你就慌了，心里头这个也不懂，那个也不懂，不懂得实在太多，你怎么办？你去学吧。我想我是不想学的，那是没完没了的东西。所以我们今天要明白一件事情，就是说我们真的关心自己悟过没有？有没有觉悟？而不是关心我们知识有多还是少。所以一定要把悟跟认知活动区分开来，这是一个必须讲的要点。</p>
<p>那么悟是不是无所得？对，无所得。惠明此刻“言下大悟”了，还悟得不够彻底，你看，他露出马脚来了。他底下问什么？“上来”，现在尊称惠能，你在上我在下了啊，你跟我说话是从上面说到我下面，叫“上来”。“密语密意外，还更有密意否？”他还不放心。是不是你还有什么密意没告诉我？ “<strong>密意</strong>”就是心法喽。</p>
<p>惠能怎么回答的？我们看33页，那会儿回答多清楚啊。“与汝说者，即非密也&quot;，哪里有密啦？比方说，他们两个人了，边上还有一个人听到了吧？肯定听到了。惠能跟惠明说话边上听得到吗？一定听得到，哪有密呢？我跟你说了就没密了嘛。</p>
<p>“汝若反照，密在汝边”，就说我跟你说的话，你要把文字去掉，回归本心来领会，叫“反照”。于是密意就在你这一边了。什么意思啊？我这个密意传给你了，我心法传过去了，你一“反照”就跟我<strong>心心相印</strong>，什么话都说不出来。</p>
<p>我们读经文也是这样的，佛祖释迦摩尼说了那么多话给我们读啊，我们要“反照”，就是我上午讲的什么叫“反照”？<strong>把自己的生命感受领进去</strong>，你就在“反照”啊。你不“<strong>反照</strong>”，这些文字大家都不看到了，大家都看得到。哪有密意，不密的啊。一“反照”，心法过来了嘛，叫“<strong>密意</strong>”。“<strong>密意</strong>“就是无法用语言表达，因为它超出语言，语言只是传密意前面的方法。到了不可说那一刻，密意就过去了。</p>
<p>所以这时候的惠明还问了一个傻问题，你刚才讲了密意给我，还另外有没有密意呢？还在担心还有什么没告诉我？那个回答就清楚了。我跟你说话不密的啊，你要“反照”，“密在汝边”。这时候的惠明感慨了，他说“惠明虽在黄梅”，就在黄梅东山寺，跟从着弘忍法师那么多年，“实未省自己面目”，都把外在社会加给他的符号当真了。你知道，比如说现在我有一个符号叫复旦教授是吧？我只是说我就是复旦教授，未省自己面目呢。把自己跟一个社会符号等同了，这怎么行呢？所以他说现在我明白了，我长久以来从来没有看清楚自己的面目嘛。</p>
<p>“今蒙指示”多亏了你指示。“如人饮水，冷暖自知”，这话说得好。悟的时候，悟是我们最真切的受用，是我们的心灵跟虚无的默契，这叫<strong>悟</strong>。因为它跟虚无的默契，就无法用语言表达，所以这种最真切的受用无法用语言表达，所以叫什么？“冷暖自知”！说出了一个人在悟的时候的最真切的感受，我们得了一点知识，以前没学到过的，懂了这条知识我们也会愉悦，也是有所受用，但是绝不会”如人饮水，冷暖自知”，绝不会到这个境界的，这叫最高的受用。我们心灵最高的受用，从此之后一无所惧呀。你看清自己本来面目，你还怕什么？你还患得患失吗？所以禅宗让我们进入了这样的人生境界：**自由、自信、平静、勇敢。**真正的大无畏属于禅宗的境界。</p>
<p>这时候的惠明彻底服了，就跟惠能讲，你虽然还是行者，你这个行者就是我的师了。“今行者即惠明师也”，关键是前面的话，他说了自己没有看到自己的本来面目，然后如今呢？叫“如人饮水，人暖自知”。这句话也说出来，惠能印可他了。怎么印可的？</p>
<p>“汝若如是，吾与汝同师黄梅。”也就是说“吾亦如是”。我们大家都“善自护持”嘛。“善自护持”，“<strong>护</strong>“就是<strong>护念，</strong>“<strong>持</strong>“就是<strong>不退让不退转</strong>，悟了之后不要退转。</p>
<p>惠能这话说的其实也蛮谦逊的哦。你是如此的，我跟你是有一个共同的师，就是黄梅。也就是“吾亦如是”。这时候悟了，惠明悟了。当然要问我今后往哪里走呢？“逢袁则止，遇蒙则居”跟他讲了，他将来住化一方的地方在江西。我们看第一条注释，它讲了地名了， “<strong>袁</strong>”应该是指袁州，“<strong>蒙</strong>”指袁州那座蒙山，其实也就是江西宜春这一带。讲了惠能告诉惠明将来的归宿，你就在江西这一带主化一方。也颁发了一个资格证书给他。实际就是这样。</p>
<p>所以第一品非常有意思噢，其中还有一个惠能让惠明悟的例子。我们现在通过这个例子说了很多话，什么叫禅宗讲的悟？我们把<strong>悟</strong>跟<strong>知</strong>分开来，就像我们学了很多知识不等于有智慧一样的道理。那么禅宗讲的<strong>智慧</strong>，就是<strong>对虚无的领会</strong>那叫<strong>般若智</strong>。后来洋人也知道了。有人就讲了，禅宗的智慧不仅是中国人的智慧，而且是整个人类所能有的最高智慧。为什么是所能有的最高智慧？他终于达到不可言说那一份上了，还有比他高的吗？没有了！所以后来不是有许多美国的洋人和尚，他们出家都是洋人噢，人种上就是洋人，语言上母语就是英语，那么出家也晓得参禅呢。当时上世纪60年代中华人民共和国对外封闭的，但是日本有禅师的。所以这帮美国的洋人，都是和尚到日本去，围绕着日本好几个禅师。在那里参，参了十几年没有一个成功。后来我想这也是自然的事情噢，因为你用英语怎么才能得到这个问题，这个语言啊，看你怎么说话是吧？讲这种话你怎么翻译成英文，呵呵！谁有本事把《<strong>五灯会元</strong>》翻译成英文，那我服了他。这是不可能的。所以这也没办法，所以洋人只能望洋兴叹，这是没办法的事。</p>
<p>我们在这第33页上，讲惠明悟了。然后惠能跟他讲了他将来的归宿，要在江西这一带住化一方，给他八个字，“逢袁则止，遇蒙则居”。好，他们就告别了。惠明“礼辞&quot;。</p>
<p>底下说惠能后来到了曹溪了，仍然被恶人寻逐。到了四会这个地方，实际上当初就是他的师傅弘忍法师跟他讲的，“逢怀则止，遇会则藏”。就在躲那里了，在四会县，避难于猎人队伍当中。“凡经一十五载”，15年呐，跟猎人在一起。“随宜说法”，碰到合适的时候，随时随地随宜跟他们讲佛法，当然会让猎人受用，那么猎人当然也容纳了他，那问题在于什么？</p>
<p>猎人天天在杀生呢。打猎。那么他也不会去做这个事情。叫他守住那个网啊，“每见生命，尽放之”，有时候打来的鸟兽还没死还活着，这种情况下惠能一定把这些鸟兽放了。每见生命就还活着就把它放了。吃饭的时候呢，惠能当然要吃素了。但是他也在吃饭，只有一个锅子，锅里面都是煮肉的，那么他就把他的蔬菜放到了肉锅里面，“或问”就是有人问你怎么好这样呢？你不是修佛的吗？回答：“但吃肉边菜”。这句话也很妙。其实也在启发那个人，禅宗的境界就是这样，不要著了境相。干净和肮脏要分得非常彻底，素的和荤的一定要分得非常彻底，这不对的。</p>
<p>这个莲花是佛教的象征，莲花生长在哪里的？污泥里嘛。也不要拒绝人世间嘛。猎人以打猎捕杀鸟、禽兽为生嘛，你也不能反对的。所以他说“但吃肉边菜”，这些话说的都很有启发性。</p>
<p>“一日思惟”，有一天他想起来了，就是说弘忍法师跟他讲的是吧？15年嘛，隐居15年，15年之后你就得出来了，出来传法了。“时当弘法，不可终遥”，不能老是躲来躲去。</p>
<p>所以他就到了广州法性寺出头露面。当时是印宗法师，是法性寺的方丈。那一天正在讲《涅槃经》，由于讲《涅槃经》的缘故，正好有风吹幡动这个景象出现，跟《涅槃经》中的文字的含义有关联了，于是就发生一个争论，“风吹幡动”，一个和尚说这是风动，还有一个和尚说这是幡动，“议论不已”，争论不休。突然有人站起来说了，惠能来说：“不是风动，不是幡动，仁者心动”，佛教的这个和尚、住持跟人说话，总是先尊称那个人为仁者，他遇到什么人都说仁者。<strong>仁者</strong>就是你啊，“不是风动，不是幡动”，是你的心动了。这句话一说出来举座皆惊，“一众骇然”。印宗马上请他上席了。“征诘奥义”，就询问他佛教的奥妙的道理，惠能的回答是 “言简理当，不由文字&quot;，就是不跟着佛经的文字走，说话都是简要恰当。所以印宗法师就说，你不是普通人了，“行者定非常人”，老早就外面传说了，黄梅的衣钵往南边来了，莫非就是你？“莫非是行者？”。既然惠能准备好出头露面，当然就承认了，“不敢”。印宗马上作礼了。然后还是要求验证一下，“请传来衣钵，出示大众”，你把衣钵拿出来给大家看一看，那是信物嘛。</p>
<p>然后又向他提问，“黄梅付嘱”就把衣钵付嘱给你，肯定教了你了。“如何指授？”如何指教你坐禅这件事？因为禅宗嘛，向来坐禅是它的功夫，主要功课，怎么教你坐禅、如何禅定这样的问题。</p>
<p>惠能说：“指授即无”，没具体教我怎么坐禅，怎么禅定，只说一个道理，叫“见性”。“惟论见性”要自见本性。“不论禅定解脱”。印宗就非常惊讶！你得了弘忍法师第五祖的衣钵，你一定比我们更清楚该怎么坐禅，该怎么禅定解脱嘛，具体的方法都没有吗？很惊讶！“何不论禅定解脱”呢？，惠能回答说，这叫“二法”。论禅定解脱就是“二法”，“不是佛法”，要区分<strong>做</strong>还是<strong>不做</strong>，<strong>定</strong>还是<strong>未定</strong>，<strong>解脱</strong>了还是<strong>没解脱</strong>，全是“<strong>二法</strong>&quot;。</p>
<p>“佛法是不二之法&quot;，所谓“不二法门”。就是我上午讲的要解除消解那个<strong>二元对立</strong>。</p>
<p>我们看上面争论哪，风动还是幡动，是不是各执一端？一个主张风动，执了这一端，还有一个主张幡动，执了另一端，两者就对立，一对立的就没完没了的争论。其实共同来自一个根源，叫什么？<strong>心动</strong>。这个思想非常深刻，西方人要通过康德才明白这个道理的。</p>
<p>我们如果读过一点西方哲学的历史，知道有这么一段叫康德哲学。德国古典哲学的开创者，康德就这么讨论问题。他说这个世界上的事物是运动的还是静止的，我们别把运动或者静止看成是物质自身的状态，物质本身无所谓动还是静，运动和静止不是描述物质本身的两个范畴，不是描述物质状态的两种范畴，一个叫运动，一个叫静止。运动和静止来自人对外部事物的一种认识形式。这是康德的<strong>先验哲学</strong>。没有什么物质自身有运动和静止，实际上是人心，它有一种认识形式叫<strong>范畴</strong>，这种范畴不是描述外部事物的状态，而是能整理外部事物的方式。这一条原则，其实就达到了惠能讲的，你必须讨论风动呢？还是幡动？运动和静止其实是人心领会出来的，是这样一层意思了。这种意思已经很不错了噢。</p>
<p>其实惠能更有一层意思是超出康德的。他是讲的是修行啊，禅宗讲的是<strong>修心</strong>。“不是风动，不是幡动，仁者心动”，这句话的更重要的境界在哪里呢？我举一个例子，这个例子当然是传说，传说说苏东坡也修佛，修佛修到蛮有境界的样子的，自己比较的得意，写了一首诗，诗的最后两句这么讲的，“八风吹不动，端坐紫金莲”。按照佛教的说法，你活在这个社会中，总有8种风不断地吹。比如说有人赞美你了，一种风；有人诋毁你了，又一种风；有人错怪了你了，又一种风；有人奉承你了，又一种风，种种的风有8种之多。然后苏东坡有一个佛教界的朋友，他们两个人隔江而居。苏东坡在这里做个小官，那么江的对岸就是他和尚朋友，那么苏东坡就觉得自己达到这个境界了，做人“八风吹不动，端坐紫金莲”，很得意。把这首诗写好了，派底下的差役过江给那个和尚看。和尚一看，底下批了两个字“放屁”，这个字又回去了。那么苏东坡一看愤怒了，受不了了。我这个境界不容易的噢，你居然还说我放屁。过江跟他理论理论。那个和尚笑了，你还说“八风吹不动”，我一个屁就把你吹到对岸来了嘛。你不是过江吹过来了吗？这个故事很有意思的，苏东坡当时真的境界没到，就八风都吹过来了，你就坚持说不动了，就这个意思了。境界根本没到。</p>
<p>什么叫真正的禅宗的境界？人家表扬你，你没觉得他在表扬；人家诋毁你也没觉得这是在诋毁，这风不存在！你觉得风吹过来了，其实是你心动了呀，问题的要点在这里。你心不动哪有这八种风呢？赞美你没觉其为赞美，诋毁你没觉得其诋毁，因为诋毁不到你，也赞美不到你。你在那里，不是这样一个人，这样一个性格，这样做过的事情，这些都不是你的本来面目。</p>
<p>比方说你看我不顺眼是吧？你骂我了。你骂到我了吗？没骂到。你也许骂到了一个某复旦教授，你觉得我脸长得不好看，如此这般的相貌走在马路上，还有碍观瞻。你说我太难看了，丑的不得了，你没骂到我，这不是我，你心动了。全在讲你喽。你心不动哪有风呢？所以苏东坡当时的境界，如果这个传说是真的，苏东坡当时的境界还是有风，然后要坚决顶住，就这个意思。那么自然这个和尚朋友要笑了。问题不在那，不在外面有风，而在于你心动了就有风，所以惠能一句话点出来了，“不是风动，不是幡动，仁者心动”，到这一层境界才是禅宗的境界嘛。</p>
<p>所以这一段小故事呀，就是两个和尚议论风动幡动，这个小故事很有意思。第一，它破二元对立，风和幡两个极端，谁动了？都来自共同的根源是吧？心动。二元对立就消解掉了——“不二之法&quot;。你站在善一端，坚决的拒绝恶，看上去很好，你执着于<strong>善</strong>，你对善执着到一定程度，它本身又会变成<strong>恶</strong>，中国历史上不就礼教杀人吗？礼教不是很好吗？道德秩序道德规则嘛。你坚持到底，恶就可能在其中，中国的思想本来的智慧呀。</p>
<p>所以那些故事听说过吧，很好的故事。师傅和徒弟两个人和尚啊，然后一个女孩子要过河。师傅就把这个女孩子抱到河对岸了，弟子在边上受不了，你天天不教导我们吗？这女色怎么好近呢？你不光近女色，还抱着她呢。所以到了对岸之后呢，弟子终于问师傅了，你怎么还抱着女孩子呢？这个师傅怎么回答的？我已经把她放下来，你还抱着呢。这就对了嘛。你心里抱着呢，我只是去帮助她嘛，我心里没抱过。然后你指责我，说明我放下她，你心里还抱着。这个弟子一下子没话说了，禅宗啊！中国儒家讲“<strong>男女大防</strong>”。男女授受不亲啊，那么这个嫂子掉到河里去了，你怎么办？你还守到这条规则不救嘛？嫂子溺水了，你跟他之间这个关系，你能随便动她？当然此时此刻要救了。嫂子溺水你还必须把她救上来，这是没有什么男女大防的事情。所以不要执着，不要执着两边，要看事情的本来。这都是很好的道理。</p>
<p>那么底下印宗就问了：“如何是佛法不二之法？”惠能就跟他讲了，你刚才不是在讲《涅槃经》吗？惠能不是进了法性寺吗？他也坐在底下听呢，惠能不识字，他自己不可能去读《涅槃经》，但是印宗读一段要讲一段，然后他边上就对经文有了了解，这也是天才。我们如果识字的人，有一种人是有天才的叫过目不忘，过目成诵。现在惠能是过耳不忘。你讲过一段就印到我心里了。</p>
<p>所以他现在说“法师讲《涅槃经》，明佛性是佛法不二之法。如高贵德王菩萨白佛言”，这都是《涅槃经》里的内容哦，刚才他听到的内容。当初不是《涅槃经》里，不是讲了吗，高贵德王菩萨对佛说，“白佛言”就是。</p>
<p>“犯四重禁，作五逆罪，及一阐提等，“这样的人都是十恶不赦之人。“当断善根佛性否？”他都在背诵《涅槃经》中的话。</p>
<p>佛是这么回答的，“善根有二：一者常，二者无常”。善根是指每个人都有的善根，不过有的是小根，有的是上根之人，但总有善根。<strong>常</strong>就是<strong>始终在</strong>的，<strong>无常</strong>就是<strong>被遮蔽了</strong>，好像他无善根了。日常生活当中，被遮蔽了，那么常和无常都有。</p>
<p>但是“佛性非常非无常，是故不断”。我们把佛性和善根做一个区分。我们人来到这世界上，按照佛教的说法，我们都有根器的，只不过根器有的利有的不利；有的善根种得深，有的善根太浅，那么这里边真有差别。但是人都有佛性，善根好的人领悟自己的佛性，看到自己的佛性方便，善根比较浅的人不容易。所以佛性本身“非常非无常”，所以哪怕犯的滔天之大恶业的人，你也不能说他没希望，因为佛性还在。“是故不断，名为不二；一者善，二者不善”。人与人之间就有善与不善，“佛性非善非不善，是名不二”。</p>
<p>后来王阳明4句话，我们如果听说过的，有4句话，它是晚年的王阳明总结的。最后一生，对自己一生做学问的概括就4句话。第41话“<strong>无善无恶心之体</strong>”。第2句话“<strong>有善有恶意之动</strong>&quot;，意愿、意向起来了。因为外部有事物，那么意就起来，意一动有善有恶了。“<strong>知善知恶是良知，为善去恶是格物</strong>”。就4句话。你看第1句话就来自禅宗，阳明讲心之体，禅宗讲佛性——无善无恶。他本自清净了，意动了才会有区分。所以他说“佛性非善非不善，是名不二”。</p>
<p>又讲了一个“蕴之与界”，<strong>蕴</strong>是五蕴的意思。那么这也是佛教的常识，基本常识我们要讲一讲。五蕴哪5个？<strong>色、受、想、行、识</strong>。这个五蕴。我们每一个<strong>小我</strong>之心就5个方面。第一，我们每个人都有五官感觉的能力，这五官感觉的能力一发挥，听觉、视觉、嗅觉、味觉、触觉就获得外部事物现象。“<strong>色”<strong>就是</strong>现象</strong>。我们接触外部事物，通过五官感知外部事物。就形成了<strong>现象</strong>，被我们感知到。感知到的同时，我们有感受，有“<strong>受</strong>”，有的叫苦，有的叫热。你吃了黄连不是很苦吗？你吃了蜜糖很甜呢，这就有<strong>受</strong>。广义上人类生活有许多感受，苦乐等等。因为感受过苦，也感受过乐，就想趋乐避苦是吧？那个愿望起来，欲望起来叫“<strong>想</strong>”。欲望起来，就要实现它，“<strong>行</strong>”就是意志，意志起来了。意志起来了以后，就要达到自己的目标。先要分别是事物吧，你要趋利避害，趋乐避苦，你要认识事物吧，这叫“<strong>识</strong>”。<strong>要对事物进行分别</strong>。好，这5个方面，我们的五官感觉的能力，获得外部事物的表象，然后我们有感受苦啊，乐啊，顺啊，逆啊等等，然后就引起我们的欲望，愿望。这愿望起来，就有意志要起来，意志起来，就要实现自己的目的，通过认识外部事物。所以这样，<strong>色、受、想、行、识</strong>。</p>
<p>我们平时的心也就这5个方面做出来的。所以他又叫<strong>五堆</strong>，<strong>五蕴</strong>又叫<strong>五堆</strong>，是我们在平时<strong>小我</strong>之心的巢穴，所以叫<strong>五蕴</strong>，那么叫<strong>主观世界</strong>了。外界叫<strong>客观世界</strong>。“蕴之与界”。主观上我们都是一个个<strong>小我</strong>，也就是五蕴构成的，<strong>色、受、想、行、识</strong>。那么外部世界，我们获得外部事物的表象。然后我们就有一个感受，有了感受就有愿望，愿望要实现就有意志，意志就要通过分别“识“来引领，最后达到自己目的的。那么这就是外部事物，多次向我们呈现了，叫<strong>外界</strong>。“蕴之与界”，<strong>主观世界</strong>跟<strong>客观世界</strong>的区分，这是凡夫所看到的。“凡夫见二，智者了达其性无二。”这里要批一批是吧？朴素的唯物主义信念。所谓外部世界自身存在，离开<strong>色、受、想、行、识</strong>，我们也没有外部世界。不要把它看成是两样不同的东西。这个要说清楚，要说一大堆话，我觉得也没有必要。但是大概的意思我们要能够明白。比方说外部事物是怎么向我们呈现的？离开<strong>五蕴</strong>它呈现不了，于是我们也没世界，这一点可以肯定的。</p>
<p>王阳明说“<strong>心外无物”。“心外无物</strong>”，我们按照以往我们哲学学过的，高中阶段就学了。然后到大学还学了至少是公共课，公共课里面也要学一点马克思主义哲学，那本教科书来。我一看到这种话，彻头彻尾的唯心主义。那么当时有人就反驳王阳明，在《传习录》里呀，有一个人就问王阳明了，你说心外无物，我且问你，山间的花自开自落，与你的心何干？山间不是有那个花吗？它自己开放了又凋谢了，跟你的心有什么关系？俨然一个唯物主义的反驳。那么王阳明怎么回答的呢？他跟那个人讲，“汝“就是你了，“<strong>汝未去见那花时，汝心与花一时俱灭。</strong>”如果你不去见那个花，你的心跟花都不存在。“<strong>汝一去见那花时，汝心与花一时都明了起来</strong>”，就这么回答的。</p>
<p>那么我本科阶段学哲学嘛，在复旦哲学系读中国哲学史，读到这一段，就讲王阳明一段，那么要读一点原著吧，就看了《传习录》。看到这一段那个问题也是我想问的噢。“<strong>心外无物</strong>”，那山间的花自开自落，与你的心有什么关系呢？一个唯物主义的常识信念支配了我，然后我就等着王阳明回答你这个。结果王阳明这么一回答，我想你没回答问题噢，你不就是回避问题吗？当时真不懂，后来才明白王阳明讲的真有道理。那个花自己客观存在，什么意思？跟我们没关系，它自身就存在，这什么意思？我们称这个东西为花，是我们人称的，给它一个名称，那么我们给它这个名称什么意思呢？当然有意思的，至少两个方面：一个它可能是一个植物学概念，花是植物的生殖器官，这层意义有了，或者没有这层意义。另外一层意义，花是我们审美的对象。比方说牡丹花象征富贵，玫瑰花象征爱情，我们看到花心里喜悦了，它是审美的对象。你把这些都拿掉，既没有植物学的概念，也没有审美的意识在里面，我们仍然称它为花，究竟在说什么呢？我们凭什么称它为花，英语叫flower。什么意思呢？所以一个事物称其为事物，这个事物跟其他事物区分开来了的这件事情是<strong>人心</strong>做出来的，各位同意吗？你把人心对它的规定拿掉，你不可能称它花吧？最后你称它为什么？物质。你最多称它物质，物质等于什么也没说，天下的事物全是物质，但是事物的区分呢？不讲！我们是唯物主义者，一谈区分你就离不开人心了吧？你把人心拿掉，这个事物有区分吗？都没了还说它在，只能说它是物质了。但这句话等于什么也没说。所以物质等于nothing，花才是thing。花是物嘛，物都离不开人心。王阳明没说心外无物质，没这么说，他说的是<strong>心外无物</strong>。</p>
<p>至于物质这个概念王阳明也不会有，因为他就没意义。nothing  is，nothing而已。thing就是物。你说物质Matter，matter什么东西——nothing，你不能称它是什么。所以把人心拿掉哪有事物呢？你硬说还有，那给出一个<strong>物质</strong>这个哲学上的<strong>范畴</strong>罢了。如果这一点我们能同意我们就知道，<strong>唯心主义</strong>呀要比我们的<strong>朴素的唯物主义</strong>信念高明得多。</p>
<p>我们有一个世界向我们呈现。什么叫世界向我们呈现？各种事物，不同的事物我们都发现了。然后它们有一个关系叫因果关系啊。什么关系？一个井然有序的世界向人呈现，是因为人心呐。你把心拿掉我们没世界。物质就是混沌一片。物质世界这个概念是错的，哪有物质世界呢？一谈世界嘛，诸事诸物成立的世界了，物质不是世界。</p>
<p>我们一定要把唯物主义坚持到底。怎么坚持呢？比如说我吃饭，你不能说这个饭是我的心造出来的啊，对的，不是说我心造出来的。但是我说吃饭一说就出问题了，心上去了，规定它了，我正在摄入“卡路里”。一个营养学概念上去了，或者我正在吃“法国大餐”，一个烹调学概念上去了。你必须不能说，你也不能想，你就埋头吃，这叫<strong>唯物主义</strong>。你把唯物主义坚持到底，你就是跟动物一样，既不能想又不能说。那么你就彻底<strong>唯物主义者</strong>。所以这个事情就这么讲了。有道理的啊，真有道理。用唯物主义信念把它坚持到底，说世界就是物质，这个文明就没了。</p>
<p>哲学上要讨论<strong>唯物主义</strong>、<strong>唯心主义</strong>的对立问题，最终为的是认识到我们人类文明的根基在哪里。你说文明的根基在物质里，这算什么话？文明没了，世界也没了。这种唯物主义必须批判！它是我们的信念，常识信念，每个人都是不知不觉就是唯物主义者。你把唯物主义信念坚持到底的话，你就不可能领会文明的基础是什么？你也不可能诊断文明的病症，这些都跟你没关系了。所以这些话要说清楚。</p>
<p>别以为马克思是个唯物主义者，我们教科书上读到的马克思学说都是被歪曲了的，被贬低了的，被庸俗化的。马克思的哲学是超越唯物和唯心对立之上的东西，这些事情都有原著放在那里。1844年马克思的《经济学哲学手稿》，他发动哲学革命的地方都写得清清楚楚。很可惜我们教科书为什么不敢把原来的马克思端出来呢？这恐怕另有原因，那就是意识形态了。这个我们不扯了。</p>
<p>我们回到那个惠能这句意思上来，别以为<strong>主观世界</strong>和<strong>客观世界</strong>是两个不同的世界。<strong>五蕴</strong>，没有五蕴也没有我们所说的外界。所以他说“蕴之与界，凡夫见二，智者了达其性无二，无二之性即是佛性。”</p>
<p>好，我们翻到39页，惠能回答了印宗的提问之后，因为印宗不明白什么叫佛法是不二之法，惠能回答了。“印宗闻说，欢喜合掌”，然后自己说自己了“某甲”，古人自称自己是某，就是谦词吧。像我这种人讲经啊，叫“某甲讲经，犹如瓦砾；仁者论义”，你论义呀，“犹如真金。”</p>
<p>于是做一件要紧的事了。以后不能再称惠能为行者了吧，剃度出家。这件事还是印宗帮他做的。这没办法的，自己剃度怎么算？不算的。要人家帮你剃度了，那么帮你剃度的人必须是和尚，是吧？那么才行。你帮我剃？你杨老师帮我剃头，我还是得剃那个头，没出家呢。剃发这叫<strong>度</strong>，这叫<strong>剃度</strong>，度的第一步叫剃发。这个事是你准备出家的人的这种度法。剃度，剃度，一个“度”是不得了的。</p>
<p>中国人已经习惯来讲“度。有一次我在那里讲坛经的时候，课后我们哲学系的另外一个专家，他就是专门研究佛学的，他就看到我笑了一笑。</p>
<p>他说：“你也讲坛经吗？”</p>
<p>我说：“是啊。”</p>
<p>我知道他在问我什么，你知道吧。我说：“我讲坛经只是为了一个目的。”</p>
<p>他说：“什么目的？”</p>
<p>“引起你来度我。”</p>
<p>他笑了，然后我们两个人相视一笑，结束了。我的意思他也知道，咱们不论是有资格讲《坛经》，还是没资格讲《坛经》，我们讲《坛经》也是为了自己“<strong>度</strong>”，就是为了这件事了。</p>
<p><strong>度</strong>就是<strong>抵达彼岸</strong>，现实世界叫<strong>此岸</strong>。<strong>此岸</strong>就是烦恼不断，<strong>彼岸</strong>就是不生不死。那么这一个过去叫什么？当时中国人没有这个观念嘛。所以翻译佛经的时候碰到这个就用声音来叫<strong>波罗蜜</strong>，最初译成<strong>波罗蜜多</strong>，后来把多字也省了，就<strong>波罗蜜</strong>。<strong>波罗蜜</strong>实际上就是<strong>抵达彼岸</strong>。后来中国人就找了一个字——“<strong>度</strong>”，“<strong>度</strong>”这个字在古汉语当中通三点水这个“<strong>渡</strong>”字。两个字是通的，其实本意就是渡河，渡就是渡河。我们都要“<strong>度</strong>”，因为我们现在烦恼不断，至于彼岸是不是空间的远方？不是的啊，这后面会讲。先知道一个<strong>度</strong>字</p>
<p>佛教界的仪式，寺庙里的仪式，比如说你出家。第一，帮你剃发。剃发就是剃度，接受你“<strong>度</strong>”的决心。想要度的决心。所以当时就为他剃发了，一剃发完成了这件事情，就惠能成了出家人了，成了真正的僧人。成了僧人，马上印宗做的事情是拜他为师。“愿事为师”。</p>
<p>“惠能遂于菩提树下，开东山法门”。为什么叫东山法门呢？因为东山不是在这里的，在黄梅县。东禅寺附近那座山叫做东山。但是中国人喜欢把那个人跟他所在的地方挂起勾来，有些人的号其实就是地名呀。所以我们可以称弘忍法师为黄梅，他所主持的法会叫东山法会。那么现在惠能既然是弘忍法师的传承者，所以他开的法门叫东山法门。就这个意思，东山法门。</p>
<p>惠能最后回顾了一番。讲了这样一番话，前面来由都讲了一遍 “惠能于东山得法”，就得了弘忍法师的法。</p>
<p>“心口受戒，命似悬丝”，十五年来东躲西藏的，不断的有人来追逐他，要杀他，把衣钵夺回去。</p>
<p>“今日得与使君、官僚、僧尼、道俗同此一会，莫非累劫之缘”，我们这些人累世累劫到今世能见面，那叫“累劫之缘”。</p>
<p>“亦是过去生中”我们以往活过的过去世，就我们曾经做过的事情。叫“供养诸佛，同种善根”，到了这一世“方始得闻如上顿教”。我们才有这个缘，我惠能有这个缘，你们也有这个缘，能够听到禅宗当中的顿教。这也是“过去生中供养诸佛，同种善根，方始得闻如上顿教、得法之因。”这都是有因缘的。因为弘忍法师就主张顿悟的嘛，所以惠能他说他传承的就是<strong>顿教</strong>。</p>
<p>“教是先圣所传，不是惠能自智。”说的多好。惠能不是公元前5世纪的人，不是当初在轴心时代开天眼的人，就是我上午讲的，智慧在古代呢！所以我惠能只不过是从先圣那里传过来的，而不是我自己开的智慧。这话是老实话，也对，本来就是如此。</p>
<p>所以中国北宋的时候，有五大思想家叫北宋五子，周敦颐、张载、邵康节——就是邵雍，还有二程兄弟程颢、程颐，叫北宋五子，这五子当中有一子叫张载，讲中国哲学（当时没哲学这个词），讲论道的学问，说了4句话“为天地立心，为生民立命，为往圣继绝学，为万世开太平”。第3句话就讲的是哲学历史的以后的发展其实都是为往圣继绝学！让它不绝如缕的传承。这就是哲学史。</p>
<p>千万别以为哲学史是一个思想进步的历史，不是的。你说黑格尔要比柏拉图伟大，这话不能说。而是黑格尔面对他当时所处的欧洲的社会状况和那个时代，重新阐发柏拉图的学问。每一代哲学家都如此。应对时代的课题，重返古代的智慧开出他的学派，事情就这样，叫返本开新。没什么progress，没什么进步的。所以惠能也说了一句大真话了，“教是先圣所传，不是惠能自智&quot;。</p>
<p>“愿闻先圣教者”，凡是想要明白领会到先圣之“各令静心，闻了各自除疑”，那么大家都跟先代圣人无别了。</p>
<p>两句话都得讲，第一智慧不是自己开的，第二我们只要传承了智慧，我们也就是圣人了。第二句话是自信建立起来。</p>
<p>“一众闻法，欢喜作礼而退&quot;。大家都很欢喜，这就是行由品。这第一品蛮重要的噢。通过讲惠能如何悟法，如何得衣钵这样一个前后的来龙去脉的故事，给我们众多的启发，很多很多的启发，交代完了之后才进入第二品。</p>
<p>还剩下15分钟，有两种选择，一种是我们聊聊。大家提问，我可以回答，可以讨论，还有一种我们就直接进入第二品般若品。一共是十品，我们大概准备讲几次呀，要把十品讲六次这样子。第一品内容是非常丰富的，涉及到许多的方面。我也都分别讲了，但是有些没展开，因为有些可以到后面几品里面充分展开。</p>
<p>那这第一品呢，就是让我们第一明白了禅宗的大纲。然后又明白了禅宗当中一个顿教，又叫顿门，顿门的大纲。</p>
<p>禅宗大纲我们回顾一下，“教外别传，不列文字，直指人心，见性成佛”。这就是禅宗与其他宗派不同的地方，它是修智慧的，叫般若法门。然后惠能是主张顿悟的，叫南派的禅宗。主张渐悟的是北派的禅宗，领袖是神秀。南派嘛领袖是惠能。所以他的大纲叫顿门大纲，16个字“菩提自性，本来清净，但用此心，直了成佛”。我们要见性才能成佛，见性不异成佛，见性就是成佛。</p>
<p>这句话是非常基本的，其他宗派也是同样追求成佛这个目标。如果你修密宗，修出神通来不等于成佛，假如你未见性的话。所以藏传佛教有一个基本主张是有道理的，你要修密宗之前现在修<strong>显宗</strong>。先显后密，显宗就是把佛经的教义本身讲清楚，这样立正了。立了正了之后才好，然后你有了神通才不会乱用。如果显宗没修好，直截了当修密宗有了神通，有时候用的神通在害人呢。因为你自己没有见性啊，所以这是一个原则。</p>
<p>显密双修，但是先显后密，这是藏传佛教的一条原则很对。所以都要<strong>见性</strong>。什么其他宗也如此，唯识宗啊，三论宗啊，律宗啊，律宗也是守戒为主的一种修行。有许多戒律，最终要达到的是<strong>见性</strong>。</p>
<p><strong>见性</strong>就是成佛。我们每个人本来都是佛。但是我们在这个世界上，我们见不到自己的佛性，因为被遮蔽了。那么学佛其实是什么事情呢？其实就是去<strong>妄念</strong>，妄念去掉了，佛性自然被见了，被见到了。说起来也是分明简单，做起来非常的困难。</p>
<p>因为我们久而久之的，在这个妄念中生活，已经习以为常，不觉其妄。所以我讲我们读《坛经》就是起正知正见，这已经是一个了不起的收获。开悟成佛，我们姑且不论。</p>
<p>有许多说法都是有一定的道理，这辈子修不好的可能性很大是吧？下辈子继续来，但是这辈子已经有积累了，叫“同种善根”。所以准备到那一次，比如说惠能说他自己就是这样的，所以才有我们无上顿教的缘分。这个是一种很可以相信的说法，所以我们未必能指望这辈子修成了，但是我们能够指望的是起正知正见。</p>
<p>各位有什么疑问或者想要讨论的话？</p>
<p>这是关系到我们每个人的最根本的关怀，这叫终极关怀，就是学佛了。学佛是中国人解决自己终极关怀的唯一道路。所以每个人都得学。在我看来《坛经》是我们中国人最好的人生教科书之一，不是唯一，但是必须读的，人生必读的书。我们只要是中国人。在我看来少年时候就应该读过，读不懂没关系的，但是一定要读过。</p>
<p>所以我曾经在上海市教委的一次座谈会上，我提了一个建议，我们的基础教育当中不能没有《坛经》的部分内容，把它编入语文课课本本应该的，比如说行由品嘛。让我们的中学生就读到行由品多好，大家都没反对，也沉默了，后来也没人去做。编教科书这件事情很大，它都是国家规定动作。国家意志的体现。你不能随便来，但是我这个建议没人理，但是有人会理的，它不是官方的学校，他们就读了。所以我一直觉得中国基础教育要做大的改革。</p>
<p>我们今天坐在这里，读了一天的行由品，想想真是应该小时候读过的，你至少放在语文课里面选进去嘛，为什么不可以呢？而且这个故事是那么生动，对我们的孩子的启发那么大。完全懂是不可能，但将来长大了，碰到人生的坎坷困境，就是这些话都会想起来的。就怕你肚子里没东西的，那很糟糕，肚子里空空如也。我们从小也没有什么像欧洲国家。从小经受洗礼，加入教会，听牧师布道，这些事情我们也没有。我们就电脑从娃娃抓起，英语从幼儿园开始，就做这种事啊。然后奥数。全是头脑的活，没有心灵的事情，这叫空空如也。</p>
<p>这是我的感慨。这么好的文字本应该编入中学语文课本。因为语文课本的编定啊，这件事情是对我们下一代至关重要。因为语言这个东西太大，太根本。我们在汉语中我们就是中国人呐。那么我们说话的方式一开始是日常语言，在小时候，在家里，在弄堂里跟人打交道，全是日常语言，终于去读书了，读书就进入了真正的进入汉语了，进入汉语就是通过语文课读进去的呀，课本的选择多么重要。这件事情不是一般的语文教学的问题，是一个我们中华民族的下一代如何建筑它最初的精神家园的事情。</p>
<p>当然现在有一些进步的，比如说唐诗宋词教的多了，也主张啊，我们习大大也主张多一些经的。那么上海市政府当时一时没反应过来，还取消了许多古文的阅读，后来被中央知道了严厉的批评，然后他们马上修改了。这些事情就是折腾来折腾去的，这是感想，我们反正都是这些回来补课的人。回来补课。</p>
<p>那么这也是来得及的事情，来得及的事情。而且我们现在读呢？比以前好的多。比小时候读有一个优点，缺点是记忆力不行，背不出来，优点是我们有生活体验，就容易进去。容易进去这是一个长处，我们童子功肯定是没有了，所以现在有些家长蛮好的，他就是说自觉的让孩子背诵，背诵这件事情是很对的噢。实际上语文学习没什么很复杂的事情，第一要把好文章，优秀的经典的文章背得滚瓜烂熟，你会背你就会写，这是最基本的思想。</p>
<p>所以中国古代的私塾制度啊，有它的优点的，那就是童子功，到后来成了口腔的记忆呀。你第一句话出来，后面的话不假思索的跟出来了，那叫口腔的记忆。多厉害，但我们现在都没这功夫了。我们是大了中年了，才来读经的，大家也蛮好的其实。我们当时哲学系有一个老先生真厉害的，不得了的，教中国哲学。上课就一张卡片，今天讲几条，讲五点。一张卡片拿过来，然后四块黑板，两堂课写下来，上块黑板写满了还不够，都是引用原文的。中国古代哲学典籍中的原文呀，然后我们拼命在底下记，记了后心里还怀疑，你说不定弄错了，你别说可能的哦，然后回去查找。终于找到了，有一处是错了一个字的，然后下个礼拜上课就有意跟他讲，这个人叫严北溪严先生，我们查对了，你昨天引用的那一段话里面有一个字搞错了。他说是吗？你用的是什么版本？那么我们告诉他是什么版本。“这个版本错了，我告诉你，你再去看一看，后来的版本对这个版本做了校注。”那个版本这个字本来果然是错的。你服气的不得了。但是实际上他就是童子功，从小读的滚瓜烂熟的。不懂没关系的，记在肚子里了，所以讲课是随便写的。</p>
<p>还有一个我们都听说了，陈寅恪嘛。陈寅恪全是记在肚子里的，这都是不得了的事情。当然我们现代文明不可能让孩子这么用功了，我们要学许多东西了，要适应这个文明，不能完全是私塾的制度，但是我们多少要留一点时间给我们的孩子读诵这些经典。比方说五千言道德经，把它背出来，我认为是应该的。你不可能全懂，全懂怎么可能？你懂个两句三句五句已经是智慧了，终身受用。中国人那句话说的对，半部《论语》治天下，你懂半部就能治天下的，你知道吧？你还准备读一全本，你准备治两个天下？所以经典跟我们的关系就是这样。</p>
<p>我随便讲，比如说《道德经》当中有四个字叫<strong>上善若水</strong>，全体中国老百姓都知道，甚至成了广告词，真懂的有几个？你真懂了<strong>上善若水</strong>，这是终身的智慧，终身受用了。这就是经典跟我们的关系。</p>
<p>【学生：老师，那你给我们讲两句。】</p>
<p>最简单就是别忘了后面一句话，“水善利万物而不争，处众人之所恶，故几於道”。世界上最柔弱的东西就是水是吧？但是它也是最强大的。水渗透万物无法阻挡，而且它与世无争，水为什么是最高的山？它利万物而不争。处众人之所恶，什么意思？人人都不愿意待的地方叫低洼，水在那里照样的流，所以它最接近于<strong>天道</strong>。老子体恤我们，我们要去领会道，太难。他也明白这一点，第一句话道可道，非常道，道无法正面的说它是什么。但是体恤我们，想了一个很好的办法，找到了水的形象来启发我们领会<strong>道</strong>。我们都不愿意待在低洼处，那句俗话说的什么？说的有意思，它说水往低处流人往高处走。好了，你离开天道远了。老子的意思就是你的在低处照样流。</p>
<p>我们在市场经济的时代总想到竞争两个字，没有竞争哪有市场经济呢？好，我们就傻掉了。一个成功的企业家，并不是老是在跟别人竞争的。你能够有利于你的竞争对手，你也活着呢呀。这个道理我们一般不容易想得通。<strong>水善利万物而不争</strong>，你不跟世界上任何事物争，就没有世界跟你争，世界就不会跟你争，你就照样活着呢。</p>
<p>我们不要老是想到要做世界500强，道家告诉我们了：向水学习吧。所以道家的智慧让中国人有许多了不起的创造发明。其中一个就是朱毛红军，在井冈山斗争期间，艰苦不艰苦？敌强我弱，敌众我寡。几十万国民党大军前来围剿，三次反围剿，朱德和毛泽东共同总结了游击战的战略战术，一共16个字，我们都背得出来：“敌进我退，敌驻我扰，敌疲我打，敌退我追”16个字。想一想，这16个字在说什么？说的就是水！</p>
<p>水就是这样的，比方说一块巨大的岩石，向你推进而来了，水的态度是什么？自动让开。你来吧，你总不可能没完没了的向前推进吧。你总有一天要停下来。你一旦停下来，水就把你包围了。然后慢慢的渗透你瓦解你，你终于撑不住了是吧？水就漫延过去了。16个字，游击战战略战术16个字只有中国人可能发明的，因为中国人当中有道家的智慧。你向<strong>水</strong>学习就对了。</p>
<p>后来全国胜利了，毛泽东领导的中国军队赢得了全国的政权，那么当时还以为世界革命的中心在苏联，后来发现苏联不行了，沦为修正主义乃至社会帝国主义。毛泽东说占了世界总人口1/4的中国人应当对人类有较大的贡献，所以就认为世界革命的中心转移到中国来了。因为这个缘故，所以中国当时有秘密的军校，专门为第三世界反政府的红色武装，培养军事人才呢。教他们干嘛，教他们游击战。中国的老师教得非常认真，外国的学生也学得非常用功，16字都背的滚瓜烂熟，回去打一仗败一仗，叫屡战屡败。中国的老师终于看不懂了，我们教的也蛮负责的，你们也学的蛮认真，你们怎么赢不了呢？这些中国老师不明白一个道理，什么道理？老子不是他们的，老子是我们的。</p>
<p>我们甚至不要背16字诀，我们每每就是像水一样的行动。</p>
<p>中国改革开放，江浙一带有许多民间的商人起来了，浙江最像水的是温州人。温州军团它像水一样漫到全国各地乃至世界各地，他们到一个地方就不跟你这个地方的贸易规则接轨的。我为什么跟你接轨呢？接轨我就没有我的戏好唱了。我是水。在你的夹缝里面流过去，弄得当地的那些人很恼火。西方美国欧洲这些国家都觉得中国人做事怎么不讲规则的？我怎么跟你讲规则？我是水，你比我强大，我就在那夹缝里流，这就是温州人呀，暗合16字诀，是不用背的。“上善若水”4个字要去体会，体会了就是一份智慧。中国的道家思想就形成了许多成语，比方说“木秀于林，风必摧之”这话真对啊！中国的企业家应当明白这个道理。什么叫我们中国企业的强大？不是一个数量上的比较，指标上的比较，而是要考量一下你的企业当经济危机袭击而来的时候，你还有没有生存的能力？如果你在危机面前有生存力，你就是个强大的企业，这是道家的原则。</p>
<p>一棵树长得比其他的树都高，骄傲地耸立在那里，当风暴袭击而来的时候，首先折断的就是这棵树，叫“木秀于林，风必摧之”。历史证明了这一点多少次，好几次世界性的经济危机爆发的时候，当时率先倒下的一定是当时世界上最强最大的企业，它轰然倒塌。小的企业就像矮小的树还在风里边摇摇晃晃，不倒呢。08年金融风暴袭击而来，美国什么企业倒了？雷曼兄弟轰然倒塌。所以这就是中国的智慧。我回答了你的问题，就是<strong>上善若水</strong>。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="般若品"><a class="header" href="#般若品">般若品</a></h1>
<p><strong>般若</strong>二字是对梵文当中prajñā的一个音译。我们用声音来翻译梵文的单词，这表明什么？我们当时中国人无法理解，何为“<strong>般若</strong>”？知道这是一种智慧，但又不敢简单的把它译成智慧。在拿不准的情况下，就直接用声音来翻译了。</p>
<p>第二讲为什么就要讲<strong>般若</strong>？因为这关系到如何认识禅宗。这一个佛教的宗派，它的主题是什么？每一种佛教的宗派都是一种修行的法门，这是第一条要搞清楚的。有禅宗啊，也有天台宗，有净土宗啊，也有密宗，也有律宗，也有三论宗，有唯识宗。在中国主要盛行的是大乘的八大宗派。那么八大宗派当中，不同的宗派就修行的不同法门，就是修行的道路和方法，别把他们当理论的学派来看待。</p>
<p>天台宗假如跟禅宗之间有交流、有争论、有争执的话，那么争论的绝不是学理，而是你那种法门更有效，还是我修行的法门更有效？讨论的是这件事情。净土宗的方便法门，叫你只要念佛就可以了，念什么佛号呢？“阿弥陀佛”。目标很清楚，就是“横超三界，达到西方的净土”，这就是它修行的法门。密宗它修行的法门是<strong>修神通</strong>。那么通过各种非常艰难的过程，闭关打坐，终于也根据不同的人的慧根终于修出神通来，这也是事实。它特别能够实证，神通一启用，我们不能不承认，这就是密宗的法门。那么禅宗的法门是般若法门。直接指向般若智慧。所以第二品就要讲禅宗的法门是什么？如这个品的标题所说的就是般若法门，那么什么是般若智呢？什么是般若智慧呢？我们一步步来看。</p>
<p>这本书就是翻到第41页，给各位手中的本子，前面讲的是行由品，然后第二天韦使君又来了，韦刺史来惠能这里“请益”。所以惠能升座了。</p>
<p>开头第一句话就说要大家一起念，“总尽心念摩诃般若波罗蜜多”。这样一句梵文的话。假如是净土宗的师傅来了，请大家坐下来，肯定叫大家“总尽心念南无阿弥陀佛”，因为它是净土宗法门，最重要的是阿弥陀佛，阿弥陀佛在西方净土等待着我们，将接引我们。西方三圣当中一个圣，现在许多寺庙都有三圣殿，你们去过吧？大雄宝殿后面又一进就是三圣殿，供奉着一个佛两个菩萨，当中一个佛就是阿弥陀佛。边上两个菩萨，一个是观世音菩萨，一个是大势至菩萨。这三个合起来叫三圣，三个圣人，这叫西方三圣，就在西方等我们的。我们好好修净土宗，可以横超三界，直达西方净土。</p>
<p>所以那些净土宗的人到了寺庙里一定要进入三圣殿，要拜这一佛两个菩萨，他们是西方三圣。那么禅宗的主题--修我们的心。我们还记得禅宗大纲一共16个字 “教外别传，不立文字，直指人心，见性成佛”，它是直指人心的修行，这是禅宗。直指人心修什么？修我们的般若智慧。</p>
<p>所以一起肯定念 “摩诃般若波罗蜜多”。那么什么叫“摩诃般若波罗蜜多” 呢？般若品。第二品围绕着这句话，“摩诃般若波罗蜜多”，分别解释然后再合起来。先解释什么叫摩诃，再解释什么叫般若，再解释什么叫波罗蜜多。大家一起念完了之后，惠能就开始说话了。</p>
<p>“善知识”，我们都是善知识，那么惠能是大善知识是吧？佛家跟人说话很尊重人，你们都是最高的有情物，动物都是有情物，人是动物当中最高的有情物叫“善知识”。这个知识不是我们今天讲的科学知识，而是指有灵觉的。灵觉又叫妙性，能够有妙性，我们<strong>心</strong>是<strong>灵觉</strong>是<strong>妙性</strong>。后来王阳明说 “一点灵明”，人都具有这一点灵明，所以佛家尊重我们每一个人都叫 “善知识&quot;。</p>
<p>“菩提般若之智”，<strong>菩提</strong>也是一个梵文了。后来那棵树叫菩提树，释迦摩尼在著提树下悟道的，所以<strong>菩提</strong>就是<strong>觉悟</strong>的意思。<strong>菩提就是正觉</strong>。</p>
<p>“<strong>三藐三菩提</strong>“听说过吗？“<strong>三藐</strong>”就是<strong>正等</strong>。一个三不是一二三四的三，它是用声音来译的，结果用了一个单词不是数量词。“<strong>三藐</strong>”实际上就是“<strong>正</strong>”的意思一一<strong>正等</strong>。三藐三菩提”三”译正了，<strong>菩提</strong>叫<strong>正觉</strong>，叫三藐三菩提这句话，译成汉语的话叫<strong>正等正觉</strong>。</p>
<p>“菩提般若之智”，就<strong>觉悟到般若的智慧</strong>，叫菩提般若之智。</p>
<p>“世人本自有之”，每个人都有的。</p>
<p>“只缘心迷，不能自悟，需假大善知识”，需要借助大善知识。</p>
<p>“示导见性”。我们这些善知识都最好遇到惠能这样的大善知识。在他的帮助下能够见性。</p>
<p>“当知愚人智人”，天下有愚人也有智人。</p>
<p>“佛性本无差别”，<strong>愚是迷了，智是见到了佛性</strong>，这就是智和愚的区分。智和愚不是聪明和愚笨。一个人笨点没关系的，但他却可能是大智之人，虽然他笨。一个人很聪明，但他是愚人，我们一定要搞清楚这个。今天天下聪明人多了，你去看看他们的行为，你就会发现哦，愚人！而且他在这种情况下，越是聪明越是愚。所以智和愚的区别是<strong>悟</strong>和<strong>迷</strong>的区别，智能和愚人都有佛性的。见到了佛性的是智，没见到佛性的叫迷了，叫愚，就这个事情。</p>
<p>“只缘迷悟不同，所以有愚有智”讲的清楚了。不要日常的理解啊，愚就是愚笨，智就是聪明，不是这个意思。很可惜时下那么多聪明人本事很大，其实是愚人。</p>
<p>“吾今为说摩诃般若波罗蜜法”，我现在今天就跟你们讲摩诃般若波罗蜜。</p>
<p>“使汝等各得智慧，志心谛听。”专心致志的来听吧。</p>
<p>“吾为汝说，善知识！世人终日口念般若，不识自性般若，犹如说食不饱”。当时的惠能所处的时代，中国学佛的人已经很多了，全国的人都知道般若，口中一直在说呢，说了没用。不知道般若智在自己本身是自性中的，不知道这一点，不识自性般若怎么说都没意思，就叫“说食不饱”，画饼是不能充饥的。</p>
<p>“口但说空，万劫不得见性，终无有益。”学佛的人肯定先要说空，那么大家都背得出来心经，心经当中有这样的话是吧？“照见五蕴皆空，度一切苦厄，舍利子，色不异空，空不异色，色即是空，空即是色”，一个空就来了吧。那么大家都会说。没用！</p>
<p>那么什么是般若之智？所以能先把这梵文翻译成了汉语。“善知识！摩诃般若波罗蜜是梵语”。“此言“其实用中国话来说，叫“大智慧到彼岸”。现在我们知道了，<strong>摩诃</strong>是什么意思？<strong>大</strong>。<strong>般若</strong>，你就直接翻译的话叫<strong>智慧</strong>。<strong>波罗蜜</strong>是什么？<strong>到彼岸</strong>。“大智慧到彼岸”——<strong>摩诃般若波罗蜜</strong>。然后它底下是分开来说，先说<strong>摩诃</strong>，再说<strong>般若</strong>，再说<strong>波罗蜜</strong>。波罗蜜，或者说一种以前是翻译成波罗蜜多，一个“多”字总在，然后由国人总喜欢说话短一点，那么担这多字省掉也一样，叫<strong>波罗蜜</strong>，<strong>波罗蜜</strong>或<strong>波罗蜜多</strong>，反正它总是这个词吧。后来中国人其实用了另外一个直接把它译出来了——“<strong>度</strong>”，<strong>波罗密</strong>或<strong>波罗密多</strong>就是<strong>度</strong>。“<strong>度</strong>”字是<strong>过河</strong>，从此岸抵达彼岸。</p>
<p><strong>度</strong>的思想，由于佛教进入中国普遍的被接受了，我们都要“<strong>度</strong>”啊。我不是专门研究佛学的学者，我们系里有专门的佛学专业，那么有一次我们佛学专业的那位教授听说我也在讲《坛经》就问我：“你现在也讲《坛经》了？”我说：“我讲《坛经》只有一个目的。”他说：“什么目的？”我说：“等你来度我。”他笑了。我通过哇啦哇啦讲《坛经》来吸引你，最后呢？你就来度我了。他也笑了。边上的不知道我们在说什么，一个“<strong>度</strong>“字是我们关心的事情。现实世界叫此岸，在这里面折腾，起起伏伏，于是我们想要解脱。没完没了的折腾，哪时候是个尽头？折腾到最后人要走了还没有解决一个问题。按照佛教的说法，这一辈子折腾了一辈子，然后一走，下次又来了，这叫<strong>轮回</strong>。生死轮回。我们这次来到世界上并不是第一次来，我们先前来过多次。每一次来都做了事情，事情老早完成了，结束了。但是有东西留下来，叫<strong>业力</strong>。业聚积成一种力量，又把我们再次投入这世界，于是又来了。我们也许觉得这很荒谬迷信。我们有科学了，怎么好相信这种事情？</p>
<p>其实这个事情取决于我们的悟性的啊。我们肯定是再一次来到这个世界，没办法用通过科学来论证这一点。但是我们都带着东西来，这是肯定的。这个东西就是<strong>业力</strong>。前世再前世积累出来的，于是积累出了一个王德峰，又积累出个习近平。我们来历不一样吧？毛泽东有来历，我王德峰也有来历，你们大家都有来历。所以这就是一直在折腾的。佛教的目标很清楚的就是<strong>解脱生死轮回</strong>，解脱轮回达到不生不死。那叫彼岸了吧。</p>
<p>由此岸到彼岸那叫<strong>度</strong>。然后一个人出家了，出家第一件事情是先先要第一个<strong>度</strong>是什么呢？<strong>度</strong>！剃度，就剃你的头发。你做和尚先要剃度吧，剃你头发的行为也叫<strong>度</strong>，叫<strong>剃度</strong>。所以<strong>波罗蜜多</strong>或<strong>波罗蜜多</strong>就是<strong>度</strong>的意思。这个<strong>度</strong>在古汉语当中跟“<strong>渡</strong>”是通的。我们现在应该看现代汉语的话，你应该写成三点水的。在古汉语这两个字是通的，所以直接三点水就拿掉了。实际上<strong>度</strong>就是这个“<strong>渡</strong>”的意思，就渡河，由此岸到彼岸就这个意思。那么有六种度，叫<strong>六度</strong>，<strong>六种波罗蜜多</strong>，或六种<strong>波罗蜜</strong>。第一种叫什么**？**</p>
<p><strong>布施，布施波罗蜜</strong>，这是一种度法；</p>
<p><strong>持戒</strong>，又是一种度法，叫<strong>持戒波罗蜜；</strong></p>
<p><strong>安忍，安忍波罗蜜；</strong></p>
<p><strong>精进波罗蜜；</strong></p>
<p><strong>禅定波罗蜜；</strong></p>
<p><strong>第6种，般若波罗蜜。<strong>一共6种，就叫</strong>六度</strong>。我们有几种度法？6种。</p>
<p>六种摆脱轮回，摆脱烦恼，摆脱生生灭灭，反正一句话摆脱人世间种种的折腾，怎么摆脱？如何从此岸到彼岸。这个度，6种。学佛一般从哪里开始呀？<strong>布施</strong>开始。现在中国民间善男信女做布施的很多，他们先相信了<strong>布施波罗蜜</strong>。那<strong>布施</strong>又有3种了：<strong>财布施，法布施，无畏布施</strong>。</p>
<p><strong>财布施</strong>是帮助人钱财，在钱财上帮助人。也不要误解，只有富人才布施，穷人也能财布施的。你现在饿的要死，我有两碗粥，我吃一碗，另外一碗给你，已经是<strong>财布施</strong>了。</p>
<p><strong>法布施</strong>是什么意思呢？跟人家讲佛法启发别人。当然不仅是讲佛法，教人家谋生的技巧，谋生的知识和经验，教人家科学知识，都是帮助人更好的生活的。这也算<strong>法布施</strong>的。法布施两种，一种佛法布施，跟人家讲佛法；还有一种就跟人家讲知识，教帮助人家更好的生活所需要的知识和经验。所以做教师这个职业蛮好的，教育这职业本身就是<strong>法布施</strong>呀。幼儿园老师、小学老师、中学老师、大学老师。大学老师，你哪怕教的是计算机、科学，你也是<strong>法布施</strong>，应该感到了高兴。身为教师就是法布施者，应该很高兴的，不要讨厌这个职业。</p>
<p>那么<strong>无畏布施</strong>就帮助人摆脱恐惧。有的人就是无畏布施者，比方说将军，带领着士兵，抗日战争是吧？<strong>无畏布施</strong>。再比方说医生救人，一个人患了病是不是恐惧了？医生用他的医术，用他对这个病人的关爱让这个病人摆脱恐惧，这都是属于<strong>无畏布施</strong>。所以做医生应该感到自己很高兴的，你是无畏布施呀，那么持戒又有种种，要守戒律。那么我们能做持戒的也不多，大家有的人做得到，有的我就做不到，最起码的五戒我都戒不了。这个饮酒我要饮是吧？很难。不杀生、不偷盗、不邪淫、不饮酒、不妄语。杀生我也做不到，不杀生我也很难做到的，我吃荤的了。饮酒我也做不到。妄语基本上要能戒，偷盗、妄语这个东西要戒。<strong>持戒布施</strong>。</p>
<p>那么<strong>安忍布施</strong>，人间有种种的苦，一种是人家害你，怨害。你受了冤枉你能忍吗？一种身体遭了病，痛苦了你能忍吗？艰苦的恶劣的环境你能忍吗？这叫<strong>安忍波罗蜜</strong>。</p>
<p><strong>精进</strong>就是学佛要专心致志，不能退转，持久不懈。现在有的人修行是可以的。我有一些中学同学，我说你们堪称四个字叫“勇猛精进”，绝不妥协。</p>
<p>这个<strong>禅定</strong>，那么现在有的人也开始实践了是吧？坐禅七，现在有些寺庙也提供了这种环境，七天时间你去坐禅，手机关掉。还要禁语不能说话。不知道在座谁去实践过，我有些朋友去过。那么在家里然后继续，每天要禅定，也是一种波罗蜜。</p>
<p>那么最后一种，惠能这里要讲的叫<strong>般若波罗蜜</strong>，用我们的般若智慧来度，就这个意思。怎么到彼岸的，大智慧到彼岸，那叫<strong>般若波罗蜜</strong>。</p>
<p>我们先来看他前面那句话，我们回到开头，“善知识！菩提般若之智，世人本自有之”。这话怎么理解？我们去觉悟到般若的智慧，这是每个人都有的。怎么理解？这不是句空话。惠能先跟我们讲，你们要相信自己呀，般若之智你们都有，每个人都有。听上去只是在鼓舞我们，很像励志的话，但是要有根据。根据这里他没说，我们来说说看。</p>
<p>那么最后一种，惠能这里要讲的叫<strong>般若波罗蜜</strong>，用我们的般若智慧来度，就这个意思。怎么到彼岸的，大智慧到彼岸，那叫<strong>般若波罗蜜</strong>。</p>
<p>我们先来看他前面那句话，我们回到开头，“善知识！菩提般若之智，世人本自有之”。这话怎么理解？我们去觉悟到般若的智慧，这是每个人都有的。怎么理解？这不是句空话。惠能先跟我们讲，你们要相信自己呀，般若之智你们都有，每个人都有。听上去只是在鼓舞我们，很像励志的话，但是要有根据。根据这里他没说，我们来说说看。</p>
<p>像我们这样在这个世界上活了几十年的人，大体都参加过某种活动，一种活动，这种活动是什么？别人的追悼会。去过吗？肯定去过了。亲人、朋友、同事突然去世了，然后我们去参加追悼会了。那个人前几天还活蹦乱跳的呢，突然就走了。消息传来我们极为震惊，然后去参加他的葬礼，走进了殡仪馆。在参加他追悼会的时候，站在他的遗体面前，你心中受到的震动是极大的。这个人前不久还是活蹦乱跳，还有他远大的人生计划要去实现，突然就终止了。你站在他的遗体面前，你感受到了什么？<strong>人生的短暂，每个人的渺小，有限性</strong>。一切我们的生活的未来，并不是理性的计划好决定的，这一个叫遭遇<strong>虚无</strong>。你站在他的遗体面前，你领会这件事情的时候，你就是遇到<strong>虚无</strong>了。</p>
<p>这样的追悼会一般来说一两个小时就结束了。追悼会结束之后，你从殡仪馆里边走出来，走到街上。街上人群熙熙攘攘，跟往常一样，皆为利来，皆为利往。满街的路人，你这时候感受到大家都很可怜，跟刚刚死去的亡者也跟你自己一样的可怜。无论这些路人当中有多少成功人士，或者有多少什么底层劳工阶层，满街的路人一样的可怜，都面对<strong>虚无</strong>。</p>
<p>你在上海假定啊，你要坐公交车回去了。由于这班公交车很久没有来，这个车站上挤满了人，终于这辆公交车就来了。人们蜂拥而上，干嘛？抢座位。这时候你抢不抢呢？你肯定不抢，你觉得毫无意义。到了车上两个人正为一个座位该是谁坐的？争起来了，吵起来了。你觉得他们很可笑，你就跟他们说了这一句话，用上海话说的。“阿拉上海宁”</p>
<p>【我是上海人，苏州北面的人将来到西宝新路，苏州南面的人将来到龙华山啊】</p>
<p>能听得懂上海吗？上海有两个殡仪馆，一个在苏州河北面叫西宝新路殡仪馆；一个苏州河南面龙华殡仪馆。这个上海人就说了，因为他刚刚去加过追悼会。</p>
<p>苏州北面的人将来到西宝新路，苏州南面的人将来到龙华山啊</p>
<p>这两个人一听过了不吵了，为什么？终极关怀来了。</p>
<p>当你参加了这段这次追悼会之后，你领会到虚无了。你从虚无的一边看人生了，这就是<strong>般若智</strong>。<strong>般若智慧就是领会虚无的智慧。<strong>假如你把你对人生的这份真切的感受，从</strong>般若智</strong>角度来感受人生，你把这种感受保持了一辈子，你就是<strong>佛</strong>。结果你只保持了两个小时，因为你回到家里坐下来想起来了，明天要评职称了。学术委员会一共有15票，我现在还没到半数，还差两票。这两个学术委员会委员，要到他们家里去看看。你带上了你的礼物，还带上了这几年出版的著作。到了这两个教授家里了，你那个可怜的样子噢。我如果今年再评不上正教授的话，我明年就以副教授退休了。引起他们的怜悯，为的是得到这两票。我们人生就这样的，从殡仪馆里面走出来之后，对人生的那份感受只维持了两个小时。</p>
<p>假如你把它延伸为一生呢？你就是<strong>佛</strong>！所以惠能说 “菩提般若之智，世人本自有之”。什么时候呈现的？你参加追悼会的时候它呈现了。所以他绝不打妄语，不是空的，跟我们讲你们要相信自己，你们本有般若智的，这话不是空话。所以我们有<strong>自性般若</strong>就这个意思。</p>
<p>我们会回到后面的这个地方，42页上，“善知识摩诃般若波罗蜜是梵语，此言”有的版本叫唐言，当时是唐朝，唐言就是汉语了。</p>
<p>“唐言大智慧到彼岸。此须心行，不再口念，”口上天天念也没用。</p>
<p>“口念心不行”，心不跟上去的话，就像我们通常讲小和尚念经是吧？有口无心，心不上去，就生命感受不放上去，就生命感受不放上去。</p>
<p>“如幻、如化、如露、如电”，这就借用了什么？他肯定听过《金刚经》嘛。金刚经最后的偈句是 “一切有为法，如梦幻泡影，如露亦如电，应做如是观。”口念心不行的话，那叫有为法当中的一种。天天说佛经，就以为这是一个功课了，这个功课就能帮助我们，但心不上去，这不行。</p>
<p>“口念心行则心口相应，本性是佛，离性无别佛”。好，这样讲完了以后，后面就分头开始说了，先说<strong>摩诃</strong>，而后再说<strong>般若</strong>，最后说<strong>波罗蜜</strong>，这样就完成了这个般若品了。</p>
<p>那么先说<strong>摩诃</strong>什么意思？大。<strong>摩诃</strong>是<strong>大</strong>，“心量广大，犹如虚空”，这个虚空其实无法形容，只能说它不是什么。比如说“无有边畔，亦无方园大小，亦非青黄赤白，亦无上下长短，亦无嗔无喜，无是无非，无善无恶，无有头尾。诸佛刹土，尽同虚空。”</p>
<p>“世人妙性本空，无有一法可得。”这句话最要紧。我们的心就是<strong>妙性</strong>，本空啊，“无有一法可得”，我们认识这个事物，认识那个事物，认识万事万物，我们都无法依靠他们的。先明白这一点心就大了。心大的前提是<strong>空</strong>，不空如何能大？什么叫心不空呢？你心中总有所附，好像有所依靠似的。比方说你有博士学位，你就说我这个是大知识分子，我有所附。你腰缠万贯，你金钱和财富是你心中所附的。你有各种经验和知识跟别人不一样，比别人高得多，这也是你有所附。你这样看待事情，不是那样看待事情。你的看事情的角度，你认为你的看法是真理，也是有所附。这样的心就是我们通常的心，它不空的，他东西多了。这个心不会大的。远离着<strong>摩诃</strong>呢。</p>
<p>接下来要怎么？全部把它空掉。“本无一法可得”，你有所依你就心不可能大，你就不能包容万物了，空了然后能含万物。所以第一件事情先要讲摩诃。</p>
<p>“自性真空，亦复如是”。所以我们先要大，大的前提是要空，不空是不可能大的，我们都积累了不少东西。积累了我们的财产，积累我们的地位，积累了我们的偏见。我们把这偏见当成正见，当成我们宝贵的知识和经验。我们依靠这些依靠那个来看待万事万物，一看就看错了。就是偏了就不能含万法了，不能包容了。所以这就是第一个要讲的意思叫<strong>摩诃</strong>，摩诃的第一层意思，就是<strong>空</strong>。这空已经很难做到了，很难做到的。</p>
<p>实际上我们中国人理解佛法，理解释迦摩尼的学问有一个基础的，这个基础是道家给我们奠定的。一个人永远要从低处出发的，不能从高处出发的。这是老子道德经里边不断跟我们提醒的话。你要往高处走，你先是从低出发。你别认为自己有什么东西。你什么也没有，你必须向水学习。水在高处流，在低处照样的流，在低洼处它也能流。所以《道德经》第八章 “上善若水，水善利万物而不争，处众人之所恶”。众人之所恶，就是人人都不愿意待在那个地方，叫低洼，水照样在那里。“处众中人之所恶，故几于道。”所以水最接近于<strong>天道</strong>。要向水学习。已经有这层意思。</p>
<p>中国人道家的智慧做基础的，你就能够领会佛家讲的<strong>摩诃</strong>。现在我们当下的人，在资本时代里边都喜欢高啊，自我宣传啊，闪亮登场呢。高调出场，这些全不空的，全带着东西来了，就是这个意思。那么广告业更主张这个东西，就宣传广告自我推销，文明的毛病就这样的。那么我们在这种里边我们就离开智慧很远了，所以惠能在这里先讲摩诃般若波罗蜜，里面先讲一个<strong>摩诃</strong>，讲<strong>摩诃</strong>，先要讲第一层意思<strong>空</strong>，空了然后我们心量广大了。</p>
<p>然后第二层继续说的是你先明白了<strong>空</strong>，但又不能执着于<strong>空</strong>。第二句话，“善知识！莫闻吾说空”，不要听到我说空了，“便即着空”，<strong>着空就执着于空</strong>。这第二句话又来，“执着于空”，我们不是活在这世界上了，我们确实应对万事万物，你把它们都看成是不存在的东西加以拒绝，不对的。<strong>空</strong>的目的不是拒绝人世间的事情，而是因为你空你能够包容它们。所以第二层意思一定要讲，讲完整了。</p>
<p>然后底下看他说“善知识！世界虚空，能含万物色像，日月星宿，山河大地，泉源溪涧，草木丛林，恶人善人，恶法善法，天堂地狱，一切大海，须弥诸山，总在空中。世人性空，亦复如是。”我们要把我们的自性看成是这个世界一样的，空而且大，只能包含万物。</p>
<p>“善知识！自性能含万法是大，万法在诸人性中”。即空，因为<strong>空</strong>然后能含万法，这样才把<strong>摩诃</strong>讲出来了，在<strong>空</strong>的之后才含万法的，你就不会执着于万法，你能包容它，并不执着它。</p>
<p>所谓<strong>不执着</strong>叫什么？“若见一切人恶之与善，尽皆不取不舍，亦不染着，心如虚空，名之为大，故曰‘摩诃’”。这话是要细细体会的，人皆有善恶吗？有。你不能否认的。但是你承认有善恶，领会有善恶，你不执着，这个一定是恶，那个一定是善，一执着又不行。所以这叫<strong>不取不舍</strong>。<strong>不取</strong>就是你不执着做善恶的对立；<strong>不舍</strong>，也就什么意思，你不否认善恶的区分。你舍了就把善恶的区分都否定掉了，这不可以的。但是有善恶你不能执着，坚定的划清界限，善与恶的那个界限一定要划清，抓住这条界限你就要取了，仍然是错的。所以叫<strong>不取</strong>，<strong>不舍</strong>，你就不染着了。于是这两层意思合起来，一个叫<strong>空</strong>，一个叫<strong>含万法又不染着</strong>，这叫<strong>摩诃</strong>。这样就把<strong>摩诃波罗波罗蜜</strong>的前面第一个<strong>摩诃</strong>讲完了。</p>
<p>我们刚才读般若品。读到42页的最后一段，我们再看一下这42页上的最后一段讲，“自性能含万法是大，万法在诸人性中。”万法就是万事万物，万事万物的意义都在人性之中。所以讲摩诃这个境界，摩诃就大的意思了。</p>
<p>第一层先讲空，不空不能大。第二，不能停留在空，空而后能含万法，这才叫大。然后说到“见一切人恶之与善，尽皆不取不舍，亦不染着”，这就叫“心如虚空，名之为大，故曰‘摩诃’”。</p>
<p>惠能这份说明其实有一个道家的思想做基础的。我们非常惊讶的就是惠能不识字是个文盲，他如何能知道那么多？对道家的精神有领会。那么我们现在也无法揣摩了。他肯定听过，不识字不能阅读，但是听。当时中国文化在日常生活当中不断的被讲的，像比如说《道德经》里的那些话，我们今天中国人比较生疏了，所以当时许多话都是很普遍的要会说的。五千言《道德经》。我们想一想《道德经》当中其中有一章是这么说的，“天地不仁，以万物为刍狗”， “圣人不仁，以百姓为刍狗”。这句话其实都会说，今天在中国不会说了，以前都会说天地不仁，圣人不仁，圣人就是治理百姓的人。</p>
<p>《道德经》当中凡提到圣人指的就是治理百姓的人。治理百姓的人应该达到<strong>天地境界</strong>。人生有几层境界，冯友兰先生说的蛮好，说4层境界：第一层境界叫<strong>自然境界</strong>。就我们出生的孩子在孩提时代。淳淳朴朴的赤子之心，那是自然而然，这叫<strong>自然境界</strong>。然后人总在长大，逐渐长大就知道这个世界上的利害得失，然后不断的学习趋利避害，那么就自然地进入了<strong>功利境界</strong>。</p>
<p>所以中国人那句老话说的对，“自在不成人，成人不自在。”你在孩子做儿童的时候，你童心是自在的。但是你总要长大，长大就知道趋利避害，那么就自然要进入<strong>功利境界</strong>，你就不自在了，功利境界。那么在<strong>功利境界</strong>之上还有一层境界，叫<strong>道德境界</strong>。我们不能否认<strong>道德境界</strong>的存在，为什么不能否认的？世界上有许多的事情它是非做不可的，不做整个社会解体了。而你去做这件事情的话，对你没有任何好处，甚至还带来伤害，但是你还是必须去做，这叫<strong>成仁赴义</strong>。</p>
<p>儒家强调这个境界的哦——“知其不可为而为之”。因为有那层<strong>道德境界</strong>在。人进入第三层境界，道德境界要当然比功利境界高，你把这个道德境界拿掉做事情的话，在社会上终于行不通的。你比方说三聚氰胺的事情我们听说过吧？这三鹿奶粉集团用三聚氰胺，然后我们中国人终于不敢喝奶了你知道吧？喝这个奶喝出事情来了，三聚氰胺不就导致三鹿集团的什么垮台吗？它只停留在功利境界里面。他当然要用三聚氰胺，人家都用我也必须用，否则我的成本比别人高，我在市场上就没有竞争力。这完全是在功利境界当中思考问题的。终于导致了这个集团瓦解。拥有一层社会责任。所以每一个企业它不光知道自己是一个资本增值的一个机器，而且还知道他是社会生活中的一个成员，这个社会成员要对社会生活，并对社会生活承担不可推卸的责任，那么这一层了解到那叫<strong>道德境界</strong>。</p>
<p>那么一个做企业的人，他一定知道。最初学管理科学是处理什么事情上，什么境界上的事情，功利境界上的事情。学MBA或者EMBA就是建在企业内部建立一个现代企业制度，什么叫现代企业制度？就是利用利益驱动机制。让每一个企业的员工能够有积极性，岗位职责、利益都定好，这是<strong>功利境界</strong>上的事情。然后你学了EMBA的课程，然后你在你的企业建立了现代企业制度之后，你发现问题没解决。你建立的制度应当要得到每一个员工的遵守。但是每一个员工都会认为你建立的这些规则制度都是来对付我们的，在道德上并没有认同。于是企业家终干发现还有下一步要做的事储就建立企业文化，什么叫建立企业文化？就树立本企业的价值观念、理念。那么中国企业家经过30多年改革开放的历史历程，就是这样一步一步进步的。从一个小老板摆地摊开始是吧？然后创立家族企业全在功利境界里面做事情的。后来才知道企业做大之后他是承担社会责任的，然后他跟员工之间的关系也不是家族内部的关系。你要运用人才你就要引进人才吧？你不是说引进一定要是三大姨八大姑的人，那么在这种情况下你怎么办？你要建立现代企业制度，建立现代企业制度之后又发现这个制度要被有效的执行啊，必须做到一点一—企业员工在道德上认同这个制度。</p>
<p>如何做到让他们认同这个制度呢？于是要建立企业文化。那么有一些企业家就这样进入了第二阶段了一—企业文化的建构。有道理的，别以为它是务虚不务实的事情，实在来说是很根本的事情。因为中国企业是中国的企业，员工都是中国人，你跟老外不要讲什么企业文化，你给他规则、合同就可以了，大家都是<strong>契约精神</strong>。</p>
<p>中国不是这样的，于是第三层境界就要来叫<strong>道德境界</strong>。如果你在你的企业里边成功的建立了企业文化的话，你就是这个企业有道德境界。它会产生什么效果？当一部分员工违背这个企业的制度，为了自己的利益，破坏了规则，违背了制度，其他员工会非常反感。如果达到这一层状况的话，这个企业的道德境界就是树好了。不是每天要有人看着管着，就像考勤机一样来检查着每一个人。大多数员工在道德上认同这个规则，也就是认同这个企业的文化和它的价值，然后以在企业工作为光荣，你道德境界就成功了。</p>
<p>那么你企业家怎么样？你还在上升，你要从道德境界上升到冯友兰先生讲的最高境界——<strong>天地境界</strong>。这什么意思呢？就是要做到惠能这里讲的“若见一切人恶之于善，尽兼不取不舍，亦不染着。”这本来是道家的境界，就是老子说的“天地不仁，以万物为刍狗”。什么叫<strong>刍狗</strong>？就把草扎成的狗。古人在祭祀的时候，把草扎成狗的模样，作为一个祭品放在圣坛上，那叫刍狗。然后祭典的仪式，祭祀的仪式结束以后，草仍然是普通的草，它先前是圣物，此刻又是普通的草。老子说天地包容万物了，它并不偏向，不能指什么？没有善恶的区分。好，某些物是善的，某些物是恶的，没有。刍狗是善的吗？圣物。祭奠仪式结束，它就是普通的草。没有善恶！所以“天地不仁以万物为刍狗”，就让万事万物各得其所，如其所是的存在就可以了，你不要区分。天地不偏爱的。就像天普降雨水的时候，它是不是只淋到一部分事物身上，另一部分是不淋到它身上？不会的。普降雨水，它不偏。天地的境界本如此。那么你管理一个企业或者你治理一个国家的圣人。你应该是<strong>天地境界</strong>。就是你在你管理的员工当中，不要区分出好人和坏人，员工在道德境界，但你要超出<strong>道德境界</strong>。如果你不超出<strong>道德境界</strong>，你这个企业家跟普通员工一样爱爱恨恨，那你肯定错了。一个企业一定会有一些员工品级不端正的噢，为自己的利益破坏了，以个人的利益破坏了企业的利益。</p>
<p>企业是大家共同的饭碗，某些人为自己的私利破坏了它。这种人你怎么办？你把他当敌人看，划为敌人的阵营。还有一部分员工道德是向来是端正的，品级端正，恪守这个规则，你说这是我的朋友，于是你这个企业家就在你的企业内部区分了敌人和朋友，两大阵营，你始终跟员工一样停留在什么？<strong>道德境界</strong>里面。善善恶恶，爱爱恨恨。你怎么好做企业家呢？你必须超脱，你必须上升到<strong>天地境界</strong>呀。“圣人不仁以百姓为刍狗”你就对了。</p>
<p>所以中国的道家思想做基础才会有会人说出这样的话：“见一切人是善与恶，尽皆不取不舍，亦不染着”。谁让你来担当企业的最高领导的？既然你这样做了，你是这个职位上的，你就应该在<strong>天地境界</strong>里边，你不能加入到一部分员工的队伍里边，跟另一部分员工战斗。你也不能想象你的企业应该和所有的员工都是道德上善良的人，这是不可能的。某些员工为自己的利益破坏了企业的利益，你只要指出他的错误就可以了，但你别把他打发为什么？你的敌人。你别给他贴这个标签，这叫<strong>天地境界</strong>。所以读道家的著作和读比如说禅宗的坛经，就是读我们的生活。这样我们就有正确的收获。</p>
<p>以前我在上海讲道家思想的时候，课间休息，有一位企业家朋友上来问我。</p>
<p>他说：“王老师我有一个难题，你看看你是怎么看法。”</p>
<p>我说：“什么难题？”</p>
<p>他说：“我们企业最近要进一部分人，要招人了，我希望得到的是德才兼备的人，但是德才兼备太难得。”</p>
<p>“那么基本情况是有的人是有德无才，有的人是有才无德。面对这种情况，假如你王老师会选择什么？是选择有的无才的，还是选择有才无德的？”</p>
<p>我脱口而出：“选择有才无德的。”</p>
<p>他非常惊讶，他说：“我以为你王老师肯定说要有德无才，德比才重要。没想到你是这么说的。你说说看你这么想法的道理在哪里？”</p>
<p>我说：“很简单，你想想毛泽东吧，毛泽东率领的中国工农红军，当时是秋收起义，肯定搞不好失败的是吧？然后带着部队到井冈山去了，朱德毛泽东领导的红军都是哪些人构成的？各色人等。旧军阀有吧，旧军官，朱德自己就是旧军官嘛，地痞流氓，一些不安分的穷人全来了，土匪。贺龙就土匪出身。你说不要他们，要干干净净道德上善良的人主持工农红军，这怎么可能？毛泽东眼睛很清楚，看人看很很准的，此人不是个好人是吧，但是他有用，进来”。</p>
<p>然后毛泽东做了这些最重要的事情是在中国工农红军里面建立了<strong>道德境界</strong>。怎么建立的？思想和组织两个保证。组织<strong>支部建在连上</strong>，三湾改编，然后思想是我们是<strong>人民的军队</strong>。我们跟人民的关系是鱼水关系，一大堆话，我们绝不是流寇和旧军队，他整个<strong>道德境界</strong>就建立好了。让那些人黑的进来，红的出去。你怎么好区分，说好人进来坏人不进来是吧？你这个境界就低了。要超出，为了共同的事业，你把共同的解放人民的事业讲清楚就好了。然后定一些制度都是体现原则的，你就可以了。官兵平等，士兵委员会。打仗的时候一定听军官的话，那叫军令如山倒。仗打完了过民主生活，对那些军官有不好的事情或者不好的行为的情况尽管提出批评嘛。毛泽东后来一直说这叫井冈山的经验。毛泽东建军原则，建军思想都在时期成熟的，那么我举这个例子叫井冈山的经验。毛泽东建军原则，建军思想都在时期成熟的，那么我举这个例子在说明什么？这些大人物呀，像毛泽东这种大政治家，他也是思想家。</p>
<p>就像曾国藩当时带领湘军怎么把湘军训练的这么好的？第一，意识形态——道德，这都是有前面的经验的，毛泽东一定知道这些东西。虽然曾国藩没有把支部建在连上，这件事情虽然没说，但他基本上做到了这个原则。所以湘军是到百姓当中是秋毫无犯的，所以他奠定了曾国藩战胜太平天国的基础呀。这些历史都放在那里。所以我就在想中国人的智慧，儒家的、道家的，做了一个基础，才有了惠能说的出这样的话。人有善恶，实际上<strong>人做的事情有善恶，人没有善恶</strong>。</p>
<p>后面第三品疑问品特别强调这个东西，不要见他人的是非。但是他人做事情有是非，事情有善恶有是非，但别把这个是非和善恶作为标签贴到做事情的人身上去。所以这一切都是对我们极有意义极高的启发。把我们做事情的境界往上提一如薛宝钗讲的，红楼梦里第56回就讲这句话。做什么事情都要用学问往上提呀，如果不用学问往上提，都流入到市井中去了。这是薛宝钗跟探春的一个辩论嘛。探春只知道法家的原则，要搞改革嘛。探春理家就是搞改革，什么改革？就联产承包责任制，读过《红楼梦》就知道，在大观园里边联产承包责任制跟中国改革第一步农村改革时期完全内容一样，但是薛宝钗马上在旁边提醒她，还要有儒家的境界，那个学问。</p>
<p>所以我请大家再看一段这个话就这个意思。就42页最后一段，即“若见一切人”，我们周围的人多了，有善有恶啊，有君子有小人，这是没办法的事情。你说林彪是小人吗？是君子吗？毛泽东看得清楚呀，打仗是不得了的人呐，叫战神啊。十大元帅当中最厉害的其实就是林彪啊，三大战役当中两大战役都离不开他，统帅百万太军，但这种人什么心胸狭窄，在政治的领域里边，毛泽东也看得清楚，所以该用他就用他。</p>
<p>你不能说林彪应该成为一个善人，然后我用你。哪有这种事情？好，这个是历史上的事情，我们不再讨论，有的人还在继续研究林彪怎么会叛逃，诸如此类这种事情咱们不管，这是举例子。人有善恶，对。“不取不舍，亦不染着”，你一染着就跟上去了，你要加入善人的队伍跟恶人战斗是吧？你染着了。</p>
<p>“心如虚空，名之为大，故曰“摩诃”。”我们心如虚空吗？我们能含万法吗？做不到，就<strong>摩诃</strong>两字没了。第一步讲<strong>摩诃</strong>。</p>
<p>然后我们看45页，第一段45页上第一段又再告诉我们不要着空，虽然要讲空，但不能着，不能执着。“善知识！迷人口说，智者心行。”那么又有一些这样的迷人，空心静坐，打坐坐禅，把心里腾空了，清空，什么念头都没有，静静的坐在那里叫“百无所思”，并且自以为这叫<strong>大</strong>，这就叫<strong>摩诃</strong>了。</p>
<p>“此一辈人，不可与语，为邪见故”，这叫邪见。你“百无所思”，你“空心静坐”，你就跟生活彻底分离了，跟现实生活彻底隔绝了，你空心静坐什么念头都没有，石头一定坐得比你好。你比得过石头吗？它本来就没心了，我们有心叫<strong>妙性</strong>，妙性的空不是<strong>百无所思</strong>。不是百无所思，是思多了，多到什么程度？<strong>广大</strong>。</p>
<p>你看下面一段，“善知识！心量广大，遍周法界”，世界各种事物组成的叫<strong>法界</strong>。</p>
<p>“用即了了分明”，<strong>你本来虚空的心用到每一个事物上去，就每一个事物的意义都出现了，因为你没有自我偏见，你把偏见拿掉是空了，空了以后你再去看事物，这叫了了分明</strong>。然后你行为那叫应用，应用便知一切。你看看后来阳明讲<strong>知行合一</strong>此处就有。用是你领会事物的意义，应用是实践。你<strong>把对事物的意义的领会用到跟事物打交道的这个行上去，那叫你知道了它</strong>。真切的知道它，这就是<strong>知行合一</strong>。<strong>应用是行</strong>呀。“一即一切，去来自由，心体无滞，即是般若。”</p>
<p>波罗第一要领会虚无的，第二以虚无的态度跟事物 打交道。你不能说参加了追悼会，从殡仪馆走出来之后觉得人生了无意义呀，唉，人活得再长也面对死亡，人生不就是空吗？于是人生如梦了，然后就别活了吧。怎么好可以这样你领会虚无，然后自己直接到虚无中去了就错了一—你叫<strong>执空</strong>，你把空还得空掉，那叫<strong>空空</strong>。那么就红楼梦里面一个叫空空道人，<strong>空空</strong>二字就这么来。</p>
<p>对第一层达到的境界再空一次，叫<strong>空空</strong>，回到现实世界。我们先要出世，那要空。出世而后入世，那叫<strong>空空</strong>。就空空了。<strong>空空</strong>就回到现实世界中来，如此才能算<strong>般若智</strong>。般若智慧是领会虚无的智慧，领会虚无而后按照对虚无的领会来跟事物打交道，来生活在这世界上，那才叫<strong>般若</strong>。</p>
<p>我们活在这世界上确实是短暂的。一切的事情产生了而后又消失了，生命正在走向衰老，最后一个终点就是死亡。是人生确实如此，你怎么办？你就在当下，活着的当下，直接跟虚无站在一边，来反观生命的意义。<strong>你跟虚无在一边了，你就是跟不朽在一边，然后活在当下</strong>。这是佛家追求的境界，不是说当下就死吧，离开这世界，不是这个意思。</p>
<p>我不知道在这里讲过吧，我母亲生前是一个克勤克俭的人，用过的东西都不肯丢的。后来我长大了自己成家了是吧？那么也经常回到我母亲的家里，回过去一看我真是受不了。我小时候他叫我去买小菜的菜篮子，多少年过去了，我都30多岁的人，这个蓝子还在。她用各种绳子把它捆绑起来，居然还可以装东西。家里一大堆全是这个的东西，我看见就像垃圾筒。我就不断的跟我母亲讲，这些东西都给扔掉了，你生活在一堆垃圾当中，她很愤怒，绝不同意。我也没办法是吧？</p>
<p>后来她走了，那么我跟我姐姐一起整理她的遗物，这些东西终于可扔了，反正她不在了。扔吧。但是我在扔的时候心里很难过，我想她如果在的话，她会非常愤怒。我现在趁她走了，我扔的。心里就有那种内疚了，但是当我内疚之心一起来的时候，我又在想此刻她正看着我呢，她在天之灵看着我扔她东西，她会怎么样？我想她一定微笑，扔吧。她此刻已经解脱了。她的在天之灵看着我扔她东西，她只有微笑而已，信不信？我相信肯定这样。</p>
<p>当我这样一想的时候，我又进一步想了一句，想了一层意思，什么意思呢？如果我此刻呢，就应该跟我母亲一样站在不朽的一边了，站在虚无的一边看自己当下的生活不就对了吗？心中法喜油然而生。我们确实活着，但是我们同时想象我们有一个在天之灵，看着自己的当下生活，我想这叫<strong>般若智慧</strong>。要体会的啊！</p>
<p>就是说比方说我们现在都希望现在年轻的父母，给我们留下很好的遗产多好。一大笔财富移赠给我们的后代。你想一想，这究竟是好事情还是不好的事情？就看你的心了。假如我父母亲都留下一笔巨大的遗产给我和我的姐姐，假定这样啊，结果会怎么呢？有两种可能，一种我跟我姐姐的境界都很高，无所谓。一大部分捐掉吧，我们也不要，我们后来真捐的，捐给龙华寺的。还有一种可能情况是什么？我跟我姐姐都在想，这该是谁的？谁拿多少？比例是应该怎么确定的，搞起来了吧？搞到后来执不下去，终要对簿公堂了。你说这个父母留给我们的遗产有了吧。搞到后来争执不下去，开始要对簿公堂了。你说这个父母留给我们的遗产有意义吗？于是父母在天之灵看着，当时他们想我们克勤克俭就是为了后代活得好一点，所以把遗产给你们了，他们坦然的走了。但是他们在这里看着我们对簿公堂呢，诉讼于法庭，他们痛苦吗？一定。看来不应该留给你们的。</p>
<p>这些东西全是什么东西？有遗产也罢，没遗产的获得也罢。你要有一个在天之灵，在虚无的一边看当下，你就知道怎么对待这笔遗产了。什么叫般若智？这就是。读《坛经》要实践的，实践上就是我们心灵的改变。以后我们还读《传习录》。《传习录》重在一个<strong>习</strong>字呀，它要是进入我们的生活，进入我们对生命的感受，改变我们的人生态度，这是最重要的，否则白学了。所以刚才这位朋友提出一个建议我觉得很好的，我们读《坛经》呐，每一次是否留出一点时间，大家讨论讨论。中国学问都是讲论的嘛，书院都是讲论，岳麓书院，白鹿洞书院在历史上是非常精彩的，那些大知识分子大思想家像朱熹，像陆九渊在白鹿洞书院讲，那么多人四面八方的都来了，来了就听，听完以后就开始讨论，这是中国的精神生活，中国历史上的精神生活。</p>
<p>西方历史上的精神，向来是到教会教堂里去的。中国没什么教堂，就是书院。这个讲论讲论是蛮好的。你看《传习录》都是对话，当然也有部分是书信。《传习录》分了上中下三卷，中卷是书信。上卷和下卷全是对话录。有疑即问，问了就解答，然后讨论。你阳明讲了一句，我觉得好像有点懂了，但是还是不清楚继续追问，然后阳明再继续回答，这是非常精彩的事情。读《传习录》很开心的。徐爱录、陆澄录、黄直录的都是非常精彩，因为他们都带着生活来的，来请教阳明的。所以我们刚才讲这一段就是把生活要讲进去，就是我们对人生的一些生命的感受，我们的许多的烦恼和折腾来自哪里？惠能就告诉我们，我们本有般若智，但是我们自己看不到它，我们要再度的发现我们本有的自性般若，所以这是一个最要紧的事。</p>
<p>我们再看下去，“善知识，一切般若智，皆从自性而生，不从外入，莫错用意”，别把意思用错了。这叫什么呢？“名为真性自用。一真一切真，心量广大”，“一真一切真”其实是弘法师说的话，他这里继续用了。弘忍法师当初跟神秀讲的 “一真一切真，万境自如如。如如自性，即是真实”，这叫<strong>如如自性</strong>。你<strong>如如自性</strong>一起来一切都是真的了，否则全是虚假的，如梦幻泡影。“心量广大，不行小道。”在惠能看来，佛教的这些重要的宗派之外的许多就是小道，包括修行的许多，民间流传的方法，都是小道。</p>
<p>“口莫终日说空，心中不修此行”。我们自己的生命体会不上去，叫“心中不修此行”。在禅宗看来修佛就是修心呢。心不上去，心中不修，此行怎么用怎么行?“恰似凡人自称国王，终不可得”。这样的人“非吾弟子”，这样就解释完了“<strong>摩诃</strong>”了。</p>
<p>摩诃解释完了就要学下面一个词了，叫“<strong>般若</strong>”。</p>
<p>“善知识！何名般若？般若者，唐言智慧也。”唐言就是汉语言了，因为当时是唐朝，假如宋朝叫宋言。好，那么汉朝叫汉言，就是汉语。用汉语来说叫<strong>智慧</strong>。</p>
<p>“一切处所，一切时中，念念不愚，常行智慧，即是般若行。”<strong>行就就实践</strong>。唯识宗它是讲道理讲得多。学唯识宗你一辈子学不完，那个佛理浩大、深刻，这叫<strong>解门</strong>。唯识宗的修行法门是<strong>解门</strong>，叫<strong>理解</strong>。有的人一辈子研究唯识宗。那么禅宗叫什么？<strong>行门</strong>——实践的法门，所以叫<strong>般若行</strong>。“一念愚即般若绝，一念智即般若生。世人愚迷，不见般若。口说般若，心中常愚”。</p>
<p>“常自言我修般若”，常常自己在说我正在修般若呢。</p>
<p>“念念说空，不识真空“，<strong>真空</strong>就是<strong>空空</strong>的境界了。先说一个“空”字还不真呢。</p>
<p>“般若无形相，智慧心即是，若作如是解，即名般若智。”很简短，就一段话就把般若做了一个说明。</p>
<p>“何名波罗蜜？”底下就解释第三个词，<strong>波罗蜜</strong>或者<strong>波罗蜜多</strong>。</p>
<p>“此是西国语”来自印度的，当时对中国来说，西方就是印度。中国有两次西学东渐的，第一次就是印度佛学进来，第二次就是近代西方学问来，叫<strong>西学东渐</strong>。</p>
<p>第一次就是印度佛学进来，这是“西国语”。“常言到彼岸”，用汉语来说就是到达彼岸。</p>
<p>“解义离生灭。着境生灭起”。你领会了这个佛理的话，你就离开生生灭灭了。你着了这个境，人生有种种的处境，你着境了，生生灭灭就起来了。好，底下一个非常好的比喻，叫此岸和彼岸的关系。人生起起伏伏，万事诸行无常，生生灭灭。好比是海面上的浪花。浪花起来了又下去了，海面永远是如此的，这叫<strong>此岸</strong>。“若水有波浪，即名为此岸。”那么什么叫<strong>彼岸</strong>呢？就是<strong>海水本身</strong>啊，海面的浪花，始终起起伏伏，请问海水增了还是减了？<strong>不增不减</strong>！大海就是这样的。尽管它的海面波浪不停的起伏，但是海水是不增不减的。我门千万别把彼岸看成是空间的远方。我们要抵达它。此岸和彼岸之间似乎有空间的间隔？没有。彼岸就在此岸中，<strong>海水就在浪花里</strong>，我们跟着浪花走，我们就遗忘了不生不灭的海水了，也就是遗忘了彼岸。这个比喻是实在是非常深刻的。我们待会面继续说。</p>
<p>他说“离境无生灭，如水常流通，即名为彼岸，故号波罗蜜”。什么叫渡？渡就是离境啊。一离境就无生灭，无生灭你不就在海水本身里了嘛。这就是<strong>波罗蜜</strong>。不是我们要跋涉千山万水，终于到达西方彼岸，不是这个意思。<strong>就当下</strong>！这个道理如果解的透了，那就是一个根本的境界出来了。我们不免要问，这海水平静得很，平静如镜，多好。也就没浪花和海水本身的区分。我们问海面的浪花是如何起来的？如何生生灭灭起起伏伏？这个解释很简单嘛，风吹的。这个禅宗有一个公案就讲一个徒弟一个弟子，他也坐禅想要禅定，坐了很久了，然后弄得他很苦，怎么苦呢？他每一次要坐定下来以后总是心神不定，各种念头起起伏伏的，然后他就抓住这个念头，要摁住他。摁不住的吧？这个念头你要摁住它就跳到别的地方去了，于是他就问他的师傅了，他说我打坐，我心里的念头像猢狲一样，就像猴子到处蹦蹦跳跳的，我都抓不住他也摁不住他。师傅啊，我怎么办？他问师傅的时候两个人正在路上走嘛，走到一个河边，他正好问了这个问题。师傅马上就指着河面跟他讲，你要摁住那个猢狲干嘛？你看这个河面，你看水面如风吹水自然成纹，就是波纹的纹，纹路的纹。风一吹，这水面不就是有小浪花了，有涟漪了，就起起伏伏了嘛。这是不可避免的，你不用摁着它，那个弟子当下就悟了。</p>
<p>那么禅宗公案放在那里，我当时想为什么就悟了呢？他怎么悟的呢？我们就讲这件事。海水不可能平静，它的海面。虽然海水常流通，就是它不增不减不生不灭，但是海面是不可能平静的，为什么？风会吹的，什么叫风？就是种种的境。顺境逆境，我们人生总是在不同的处境里的，这个境就像风，一吹，我们的心本是海水。他应该是不增不减的。但是处境一来你这个浪花就起来了。他拿海的浪花跟海水本身比喻我们这个心呀。处境一来就是起来了，浪花起来了。浪花起来，你就跟着浪花走，就是45页倒数第二行，你跟着浪花走叫什么？<strong>着境</strong>。着境嘛就生生灭灭了。你如果<strong>离境</strong>的呢？就风是吹了，但是你没觉得它是风，你就在海水本身里了。</p>
<p>以前传说的故事真假不知道，就是苏东坡我上次提到吧，苏东坡修佛呢。他有一个佛教界的朋友，当时他们两个人之间彼此有一条河流相隔，苏东坡在这个地方做个小官，修佛很认真，有一次觉得自己的境界到了，写下一首诗，这首诗的最后两句是怎么写的？“八风吹不动，端坐紫金莲”。他很得意，叫他底下的一个差役，过河去把我写的这首诗给那位和尚看看，和尚一看底下批了两个字“放屁”。这个差役就把它就传回来了是吧？把这张纸拿回来了。苏东坡一看忍不住愤怒起来。我修到这样一个境界，我都告诉你了，叫八风吹不动了，你居然说我放屁呀，我得跟你理论理论。过了江了，找到那和尚了，和尚说你还八风吹不动，我一个屁就把你从对岸吹过来了，这是个笑话。真假不论，这个笑话太有道理了。苏东坡当时的境界真没到。为什么？他着境嘛。</p>
<p>人世间有8种风，你要抵抗它，你仍然着境了。佛教说人世间有种种的风，有的人表扬你，那是一种风；有的人冤枉你，又是一种风；有的人贬低了你、诋毁了你又一种风，种种的风一共加起来有8种。问题出在哪里知道吧？还是惠能那句话“不是风动，不是幡动，是仁者心动”。倘若你能做到别人在诋毁你的时候，你不觉得他在诋毁：人家在赞美你的时候，你也没觉得他是在赞美，这个风就没了吧？你这个叫<strong>离境</strong>。<strong>离境嘛，无生灭</strong>。很难很难的，太难了！</p>
<p>我做学问的就是大学里老师，最容易关注什么事情，各位知道吧？人家对我的评价。一个学者恐怕如果他不关心钱财倒是可能的，因为他那个职业就是做学问。不喜欢钱财，也并不关心什么权力。我做一个干干净净的学者，认认真真做我的学术，但是有一样事情大多数学者免不了的就是Reputation——名声！名声是每每学者最关注的事情，我尽可以穷，也尽可以始终没有任何权力来，副处长也没做过。但是人家都说我学问了不起，我就很开心。人家说我学问不行就难过。这是学者很难避免的一个就是对名声的追求，所以他最容易受到这种影响。有人说某某人啊你的学问不行啊；或者有人说，啊，你的学问好得不得了。好，比如说我王德峰被称为哲学王子的，好，那么事情就来了。每一次出去讲课，人家叫我去做讲座，我心里就慌了你知道吧？大家期待着哲学王子。然后我讲话讲出来的那些东西，如果不能使大家觉得太有道理了，然后大家都高兴起来，如果大家觉得还没意思，那我完了。在讲座之前我心里就紧张。心来了是吧？就着境了嘛。你要不着境真难啊，我是亲身体会告诉大家。我在上海有些地方叫我去，比如说华师大、交大要我去做讲座，是人家一本正经开着车子到我这来请我，两个礼拜之后去做，那个广告、海报都在交大或者是华师的校园里面贴出来的是吧？我的光辉形象也在广告栏上，你知道吧。然后那么多人啊，把小礼堂挤得是满满的水泄不通，然后走廊当中全坐满了人，我一走进去一看还了得，咱今天怎么办？不能这样砸了。必须满足大家你知道吧？这样一个想法一来你知道要出问题的。你要表现出什么？要满腹的经纶，然后嘛辩才啊，满口的如珠玉般的语言是吧？然后来吸引大家。不行的。</p>
<p>然后我还多亏读过《坛经》，我心里想“离境无生灭”，咱别把这个看成什么事情，就好像我们普通人聊天一样就好了。大家也就是正好愿意跟你聊聊，你就聊聊，你心里有什么就说什么，肚子里有什么就说什么，人家赞美还是不赞美，你别管，你把你想告诉大家的真实的话说出来就罢了，说完了就走。你就应该这样的态度嘛。</p>
<p>后来我就理解那些明星为什么要吸毒，真的蛮可怜的。成千上万的粉丝呀歌迷们等着他来。他并不能保证每一次演唱成功的。演唱有许多即兴的成分，经过几次事情，这种的名声如此之大，出场费高得不得了，那么成千上万的歌迷在期待着你，你唱失败了完蛋，怎么办？吸毒啊。有原因的。他以此才能支撑住自己成千上万，像我这个场面还很小的是吧？他那个大了，多少人是坐着飞机远道而来听你这场演唱会，于是就吸毒。在毒品的迷幻的作用当中，他遗忘了自我。然后再一次成功的演唱了，就这个道理。其实蛮苦的，很苦的。只有一个办法：请这些明星们歌星们读《坛经》。就这样没有别的办法的啊。他不是《坛经》，他依赖的是毒品， “着境生灭起”，“离境无生灭”，这就叫<strong>波罗蜜</strong>了啊。</p>
<p>好，我们再翻过来看。那么我们再进一步说一说吧，就是说这个比喻为什么特别的重要。就是波浪和海水本身呀，波浪叫此岸，海水本身叫彼岸。这个比喻为什么特别重要？波浪是不是海水呀？是海水。你不能说波浪是波浪，海水是另外一种东西。它不是两样不同的东西，它就是海水，但是它起伏了，问题只是出在这里。那么人生是不免要起起伏伏吧，不免起起伏伏的原因是我们处境是不由我们自主的。我遇到这个处境还是遇到那个处境，谁能管得了这件事情？比方说当初中国人活得好好的，突然日本鬼子冲进来了，这叫风吹过来了。你说你别来，我们活得好好，我们是平静如水呢，他风来了别抵挡。你怎么办？浪花起来了，你要抗争要抗日战争是吧？对，这就是浪花起来了。浪花起来了，你别忘了这个浪花就是海水，在起伏中不要忘记<strong>佛性</strong>。我们说的<strong>渡当下即可渡</strong>，用什么渡的？就是用浪花来看海水。</p>
<p>我们每个人都是不断的由各种浪花组成的这样一个人生嘛。我们要从每一朵浪花里边就看到海水本身，这个浪花就是<strong>念</strong>，风一吹念就起，或者是出愤怒或者是欢欣鼓舞，这个念全是情感噢，不是理性思考。妄念就是不好的情感，情感总是起起伏伏，因为你的处境变化了，叫风吹了。东风来，今天东风明天西风，后天南风在后天北风，不同的处境让你浪花就起来，你的心念不断起，也就是生命情感——爱爱恨恨、愤怒喜悦、难过悲哀等等，统统统统都来，这叫种种的念！你要从你这份喜悦和这份悲哀，或者从这份愤怒当中看到海水的真相，这就对了。我们不是没有情感，也不是说我们终于修佛修到了心中毫无情感，那叫<strong>空心</strong>。心嘛是情感所在的地方不是头脑。修佛不是修的我们无情啊，那还要学什么？你跟石头学习，石头就无情，它没有喜怒哀乐。</p>
<p>我们人总是有喜怒哀乐，喜怒哀乐就是浪花，但是让每一种喜悦，每一种愤怒，每一种悲哀，每一种欢乐都具有佛性的价值，这是属于佛性本身的东西。你就对了。如何属于佛性本身呢？这份情感，你没受到风的影响，虽然是风造成了你生命情感的起伏，但是你总是看到这生命情感的不朽的东西是什么。我该欢乐仍然欢乐，这个欢乐不是个小我之心的欢乐，是<strong>宇宙之心的欢乐</strong>。现在都是我描写，慢慢来，后面都一层层都会讲出来的欢乐。小我的欢乐还是宇宙之心的欢乐，这是不一样的，完全不一样。</p>
<p>好，我们再看第46页上，“善知识！迷人口念，当念之时，有妄有非”。就是我们口中会念许多佛经的话，但是我们念了这些话，“有妄有非”，我们只是跟着字面走，这是口念的话。</p>
<p>“念念若行”呢？我们读佛经啊，我们心跟上去，这不是口中念，就心中在念。口念和心念，他没说心念，他说“念念若行”。我们读佛经是心在念着它，而不是口中念着它。如果“念念若行”的话，那叫<strong>真性</strong>！</p>
<p>“悟此法者是波罗法，修此行者是波罗行，不修即凡，一念修行，自身等佛”。这又非常有意思，有意思的话。后来他的一个弟子发挥了一下，这个弟子叫神会，也是惠能的一个重要的弟子。这个惠能说“一念修行，自身等佛”，神会说什么？让他把他发挥成这样一句话：“一念相应，便成正觉”。什么叫<strong>相应</strong>？这个浪花是一念，它相应着什么？<strong>海水本身</strong>。我是浪花，我同时就知道我是海水，<strong>不增不减不生不灭</strong>，这叫“一念相应”，这叫<strong>正觉</strong>来。</p>
<p>**我们不是不可以有喜怒哀乐，而是我们的喜怒哀乐和不朽的佛性在一起的。**当初有人吹捧毛泽东，那是康生讲的。我们听说文化大革命有一段叫“二月逆流”，那时叶剑英这些人愤怒了，谭震林是跳得最凶的一个人，陈毅也在那里跳。他们受不了文化大革命发展的状态是造反派夺权，夺各个省份、部门的权，这件事情他们愤怒了。你说造反、斗一斗，大家、群众都来批评领导这是可以的啊，毛泽东你发动文革就是为了这件事情的话，大家都愿意接受。结果发动夺权运动，夺权在什么时候发生的啊？1967年1月份，在上海首先，叫“一月风暴”，把上海市委的权全夺了。那个市委书记陈丕显、市长曹获秋统统下台了。造反派夺权了，然后毛泽东开始，毛泽东让人民日报发表文章，欢呼“一月革命”的风暴，全国各地都要来了。2月份来了。他们开始反对，在那个政治局会议上，开始挑战中央文革小组，那些人拍桌子把手指都拍断了，这叫“二月逆流”。然后这个事情汇报到毛泽东那里，毛泽东终于愤怒了，把那些人召来开会，他说我大不了再上井冈山，我还能打仗。跟林彪说，你现在也不行了啊，我跟你一起再上井冈山，让他们来领导这个文革吧。说了一大堆狠话你知道吧，这一大堆狠话说下去之后，这帮人就吓坏了，然后后来康生吹捧了毛泽东。毛主席今天说得话叫无产阶级的愤怒。我举这个例子在说什么呢？有一种愤怒是说来自佛性的。当然康生还没达到这个境界，但是他是捧了一下毛泽东。但是从佛理上讲呢，毛泽东的愤怒属于佛性的愤怒。就这个理。佛理就是这个意思，就是有一种愤怒不是出于个人的。喜怒哀乐就是种种的念，然后神会说“一念相应，便成正觉”，相应到哪里？<strong>佛性，正觉</strong>。那么禅宗说修行、顿悟，顿悟有时候就是这么顿的，突然一念抓住了。这一念抓住了，你就悟了。悟是怎么来悟的呢？不是修神通来悟，那是密宗的做法，修神通来悟。修念，抓住你那个念，看到这个念他的根源，然后你就成正觉。</p>
<p>后来文化大革命有句话就来了，“狠斗私字一闪念”，这些话怎么来的？就是禅宗来的。因为有禅宗思想中国人后面说了许多话呢。把禅宗拿掉，这些语言都没有的。比方说：“灵魂深处爆发革命”，不就是顿悟的意思嘛。很准的这句话，虽然用了政治的用处，我们把政治的意思拿掉，这句话是对的。禅宗讲的悟，为什么是悟？不是头脑，知识提高了，而是灵魂深处的事情**。悟是心灵的事情，不是头脑的事情**，这是第一项讲对了。第二他不是积累出来的，不是慢慢的悟出来的，而是暴发，那叫爆发，一下子。悟是心灵的事情，而且是心灵的生命情感的升华，升华呢？就是那句话--革命，灵魂的革命。所以禅宗讲的悟就是灵魂的革命。我们撇开这句话的政治背景，我们就说这句话本身的意思。“灵魂深处爆发革命”本身的意思就是顿悟，顿悟就是灵魂深处的革命，而且是突然来的，一下子叫爆发，一点都不假。</p>
<p>我们就不知道什么时候在自己身上能完成，革命就是这个意思，完成了嘛，你就悟了呀。难就难在这里。现在私下里许多年轻人有心里疾患，忧郁症、焦虑症。心理医生去帮他们，他们花了钱呐，心理咨询，看精神的疾患，看那个忧郁症，基本上是没用的。因为最后一招就是心理医生口袋里的药。其实这些年轻人需要解决的问题是人生态度的转变。你不转变的话你这个忧郁症永远治不好，你的焦虑症也治不好。为什么？你那个小我没放掉，你忧郁什么？焦虑什么？无非一个<strong>小我</strong>呀！你把这个<strong>小我</strong>拿掉，不就没事情了吗。于是世界那么美好你知道吧！你<strong>小我</strong>不放掉，这个世界到处是阴暗的、灰蒙蒙的，然后你随时准备跳楼，忧郁症最可怕的就是跳楼。这个世界明明是万里晴空、阳光灿烂，他总觉得周围是灰蒙蒙的一片。根源在哪里呀？执着于那个小我没放掉过，所以我认为最重要的是学《坛经》和《传习录》，而不是心理咨询。</p>
<p>所以我们年轻的一代正是要补课了，本应该从小的时候进入到这个境界哦，然后人世间有很多事情，你的心就很大了嘛。现在的心都很小的，我小时候我父亲一直跟我讲，人呢就应该旷达、达观，这话蛮深刻的影响到我，一些小事情很快就过去了。你别抓住他不放，人生以后的路很长，等等，这些话虽然很朴素，当时都说的。我们现在跟孩子都不说这些话，所以我们这个社会毛病生了。</p>
<p>我们接着上午的说下来，上午我们进入般若品，般若品的主题就是讲禅宗是一种怎样的法门，就是修般若智慧的法门，简单来说就是修智慧的法门。我们跟着惠能一路看下来，首先说明了般若智是一种最高的智慧，这个智慧中国思想中本来没有，是什么智慧？就是领会虚无的智慧。</p>
<p>虽然道家也讲<strong>有</strong>和<strong>无</strong>之间的区分和关系。但是道家讲的<strong>无</strong>不是佛陀讲的<strong>虚无</strong>，不是佛家那个<strong>空</strong>的观念，佛家把世界的本体看成是<strong>空</strong>，然后我们说<strong>般若智</strong>，是人人都具备的。菩提般若之智，每个人都具备，<strong>人性本自有之</strong>。</p>
<p>我们举了一个例子来说，也就是当我们去参加某人的追悼会的时候，其实我们的<strong>般若智</strong>就被唤醒了。我们就领会了虚无。拿着我们对虚无的领会来反观人生，我们就会有佛家所应该有的那种大悲悯。天下的人，无论是亲人还是陌生人，无论是成功者还是弱势群体，无一不可怜。我们都被虚无包围着，随时<strong>遭遇虚无</strong>。</p>
<p>假如你把对虚无的领会呀，延伸了一辈子，你就是<strong>佛</strong>。但通常我们只是把它延续了两个小时，我们又进入了生活的折腾之中了。人性本能领会虚无的，但他被遮蔽了，如果重新看见他那叫悟了，看不见他就迷了。愚蠢和智慧，不是愚笨和聪明的区分，是见或者没见佛性的区分。没见佛性的人叫<strong>愚人</strong>，虽然他可能极度聪明；见了佛性的人，就是<strong>智人</strong>，可能他智商并不高，我们上午也做了这个区分。有了区分我们才来谈<strong>般若智</strong>的。然后我们说整个般若品围绕着对一句话的解释，这句话是梵语当中的话，叫“<strong>摩诃若波罗蜜多</strong>”，这个多字拿掉也可以的。叫<strong>摩诃般若波罗蜜</strong>。摩诃是大。<strong>般若</strong>可以译成智慧。<strong>波罗蜜</strong>到彼岸。所以翻译成汉语就是这样一句话——<strong>大智慧到彼岸</strong>。到彼岸就是后来中国人用的一个字叫<strong>渡</strong>——保护过河，从此岸到彼岸，这就叫<strong>度</strong>。可以把三点水省省掉。就是那个度。现在在中国汉语当中广泛的使用。度己度人，大乘佛教发的一个大的誓愿就是“众生无境誓愿度”，要度众生。地藏王菩萨说：“地狱未空，我誓不成佛”，要度天下的人，一个度字。</p>
<p>那么佛家讲度有六层，第1种叫布施；第2种叫持戒；第3种叫安忍，安全的安，忍耐的忍；第4种叫精进，修行的精进，坚持不懈；第5种叫禅定；第6种叫般若。所以叫<strong>布施波罗蜜、，持戒波罗蜜、安忍波罗蜜、精进波罗蜜、禅定波罗蜜</strong>，第6种<strong>般若波罗蜜</strong>。所以第二品般若品就是讲<strong>般若波罗蜜多</strong>，要用智慧来度——禅宗的主题。特别讲持戒波罗蜜的是律宗，纪律的律，律宗把持戒看成主要的法门。那么这些我们上午都讲了，我只是简要的回顾。</p>
<p>那么摩诃就是大，大的第一层意思叫空，第二层意思是能含万法，能含万法就才是大呢。我们的心能包容万事万物，能包容万事万物的心叫“心量广大”的心。它的前提是先得空，不空就不能太，太不了。我们在这个生活中世界中生活了那么多年，我们的心不是空了，而是越来越多的东西，种种的知识、经验、偏见、成见，种种的地位、金钱、本事等等，其实都让我们的心不是空了，而是反过来的。我们都有所执着，有所附。就是好像我们依靠着什么重要的东西来活在这世界上，这样我们的心大不了。我们对事物的认识和对事物的态度都在某种一隅之见之中，这是天下人的通病。</p>
<p>所以第一件事情就是先要讲摩诃的。“自性本无一法可得”，这世界上没什么教命稻草可以捞。讲了摩诃，那惠能就用非常简洁的一段话讲了般若。般若就是用汉语来说叫智慧。这45页倒数第二段就一段话讲的，“一切处所，一切时中，念念不愚，常行智慧”，智慧是实践，不能脱离实践来讲什么智慧。我们后面在定慧品里边就能够明白这个道理。</p>
<p>“常行智慧就是般若行，一念愚即般若绝，一念智即般若生，世人愚迷，不见般若，口说般若，心中常愚”，天下许多人修佛都说自己在修般若，常自言我修般若，“念念说空，不识真空”，<strong>真空就是空空。第一个空就是说看清楚领会到虚无。第二个，在对虚无的领会中回到生活中去，而不要执着于空，把第一个空字在空掉，那叫空空，那叫真空。</strong></p>
<p>“般若无形相”，其实也就是说无法说他是什么东西。</p>
<p>“智慧心即是，本在你心里，若作如是解，即名般若智”。讲了般若智后就讲波罗蜜。</p>
<p>“何名波罗蜜”，就什么叫<strong>度</strong>呢？</p>
<p>“此是西国语，唐言到彼岸”，就是<strong>度</strong>。</p>
<p>“解义离生灭，着境生灭起，如水有波浪，即名为此岸。离境无生灭，如水长通流”，这就是此岸和彼岸的关系。此岸与彼岸之间并没有空间的相隔，<strong>此岸</strong>就是海水中的，海水水面上的波浪，<strong>彼岸</strong>就是这不生不灭不增不减的海水本身，这样的来解一个<strong>度</strong>字。实在是惠能极高的智慧体现出来了。我们就在生活的波浪中度吧。我们看透了每一个波浪，也就是每一个念，它的根源是<strong>自性</strong>，因为自性起念，就像海水起了波浪一样的。</p>
<p>那么如何会起波浪呢？因为人生处境一直在变化。这种变化的处境叫<strong>风</strong>，如风吹水，自然成纹，风一吹到水面上，水面上就起浪花。所以我们如何面对人生的不同处境，才是根本道理，根本的解决问题的一个态度，解决烦恼的态度。</p>
<p>“离境”——就风怎么吹，都不足以让我生烦恼。无论是顺境还是逆境，我们的心不起妄念，这叫<strong>离境</strong>。如果着境呢？就跟着风走，风怎么吹你就怎么想，处境怎么变你就怎么想，这叫“着境生灭起”，就是水的波浪。“离境无生灭”，就在彼岸了，就在佛性中，就在那<strong>不生不灭不增不减</strong>的海水本身里面了。</p>
<p>最困难的事情原来也就在这件事情上，我们如果把自己的每一个小我的人生看成是大海的，海面上的一朵浪花。我们自己这朵浪花如何能领会到海水本身呢？这是不是难啊？非常难！讨论禅宗的思想的人就在讨论到这个问题上时陷入困境。我们没有上帝的眼睛来看海水是吧？我们自己就是其中的浪花，如何让一朵浪花来领会海水呢？这是最难的事情。这个事情要后面的几品里面来说，实际上就是<strong>转识成智</strong>。我们每一朵浪花对生活的认识都是识，我们的种种的业识。要转识是为什么呢？<strong>智</strong>。“<strong>转识成智</strong>”。也就凭借我们的浪花认识海水本质，难就难在一个<strong>转</strong>字上，所谓<strong>悟就是转成</strong>了，不悟就是转不成。呐，一个<strong>转</strong>字！其实佛教各种宗派，各种不同的法门，也就是都是要完成这个“<strong>转”</strong>。</p>
<p>你每天念几千遍的话“南无阿弥陀佛”几十年坚持不懈，这叫净土宗，修净土，修净土法门也能成。别看很机械的做法，每天就念几千遍的“南无阿弥陀佛&quot;你能坚持下去吗？如果积累出来，按照净土中的看法，也能够达到<strong>转</strong>，也能**转识成智。<strong>所谓念</strong>“<strong>南无阿弥陀佛</strong>”，**<strong>其实就是把虚无总是不断的领到场</strong>，别把周围生活的得得失失当真当件事情，生活永远是利害得失的不断交替，痛苦和快乐的不断交替，你每天念几千遍“南无阿弥陀佛”，不断在提醒自己虚无在场，它也产生效果，也会产生转的效果。所以修净土宗修成的人真是不少，尤其是普通老百姓，许多的文盲。建国初年我们中国就是要扫盲，不识字的人很多很多的。</p>
<p>以前我们弄堂里就有一个老太太，姑姥就是修净土宗的，几十年念**“<strong>南无阿弥陀佛</strong>”<strong>，她后来就知道自己什么时候走啊，这是一个修成的正果。中国后来的局面是什么？佛教在中国影响之大，大到老百姓大多数人那里的一个局面叫</strong>禅净双修**。禅宗是主要的，在老百姓心目当中，认识当中，禅宗差不多等于佛教的同义语。大多数寺庙都是禅宗的寺庙，但是净土宗始终也是被人不断修着呢。后来一个格局叫<strong>禅净双修</strong>，配合的。不断念佛的人也是有的，知识分子修禅宗的多，但是也是不断念佛。</p>
<p>所以念珠我们知道吧？现在还成为工艺品，价格连城，实际上念珠是一个很简单的事情。你念一遍转一下念一遍转一下，因为你要记得自己念了多少次，所以他一串念珠上的每一颗颗粒的珠的数字是规定好的。然后还有另外一种颜色的一个珠，你来念了一圈拨一下那个珠，你最后就算出来了，我今天念了多少遍。“南无阿弥陀佛“念一下转一个念珠就这么来的嘛。</p>
<p>念珠念什么？就念佛呀，就是念**“<strong>南无阿弥陀佛”，就净土宗的修行呀，有一个计算。所以多禅净双修。都是要完成一个</strong>转**，这个<strong>转</strong>就是我们每一朵这样一个大海的小浪花，如何能够明白到、领会到大海本身，领会到大海本身，也就是领会不生不灭不增不减的佛性，这种领会叫<strong>智</strong>，“<strong>转识成智”</strong>。</p>
<p>所以怎么念？46页上就讲了，“迷人口念，当念之时，有妄有非”，你一面念着吧一面心里想着其他的事情你知道吧？这种人很多的，“南无阿弥陀佛”，“南无阿弥陀佛”，你以为他心里不想东西呀？那个人很坏，昨天那件事情很糟糕，明天我该怎么办？因为还在念。口念的时候“有妄有非”妄念不断，是非不断。</p>
<p>“念念若行”呢？“是名真性。悟此法者是般若法，修此行者，是般若行。”<strong>行是心灵的实践</strong>，因为人做事情都是心发动的，所以叫<strong>行</strong>就是<strong>实践</strong>。</p>
<p>“不修即凡，一念修行，自身等佛。”这个“一念修行”，我就想到一个例子，就是神会讲的话了 “<strong>一念相应便成正觉</strong>”。文化大革命当中说“狠斗私字一闪念”，抓住这个妄念来修。妄念是烦恼的根源，所以不要拒绝烦恼。他倒是我们修行的资粮，涨智慧的材料，天下若本无烦恼，要智慧干嘛？</p>
<p>于是下一段就来了，“善知识！凡夫即佛”，我们都是凡夫，但我们其实都是佛。</p>
<p>“烦恼即菩提”，烦恼就是觉悟，太有意思了。显然神秀当时不懂，神秀的偈句说 “身是菩提树，心如明镜台”，本来很干净啊，要擦灰，叫“时时勤拂拭，勿时慧尘埃”。要把我们的心跟烦恼隔开来，要把烦恼拒之门外。此刻惠能说 “烦恼即菩提”。这句话后来我们中国人口口相传，真懂这个道理的不多。因为烦恼是从心里生出来的，觉悟也是心灵的活动。心能生烦恼也能生智慧，就看你如何用，心的一种用法是生烦恼，什么用法呢？跟着外境走，那叫<strong>着境</strong>。心如果离境呢？另一种用法。说起来也是很分明的事情。所以底下的话很精彩的。“前念迷即凡夫，后念悟即佛”。看来凡夫与佛之间就一念之差，前念迷后念悟，<strong>一念之间凡圣顿易</strong>，由凡转为圣了，易就是改变了。<strong>一念之间凡圣顿易</strong>！</p>
<p>什么叫烦恼？前念着境，</p>
<p>什么叫觉悟？后念离境。</p>
<p>菩提就是觉悟。上午我们解释了<strong>三藐三菩提</strong>，三就是个正的意思，藐就是等级的意思。三就正等。三菩提就是正觉。叫正等正觉，<strong>三藐三菩提</strong>。这个三不是数量词。心经当中有<strong>阿耨多罗三藐三菩提</strong>，<strong>阿耨多罗</strong>的是无上，就无比的，无上正等正觉。<strong>阿耨多罗三藐三菩提</strong>。</p>
<p>所以我上午也谈到我们读《坛经》也不能奢望我们就悟了，但是我们应该有一个可以达到的追求——就是起正知正见。如何起呢？抓住妄念，你抓住了妄念去发现妄念的根源，你就觉悟，叫“烦恼即菩提”。</p>
<p>我们妄念多啊，多的一塌糊涂。我讲我自己跑到华师大一个小礼堂一看人山人海，我妄念就起来。咱怎么在今天的讲座中保持哲学王子的美誉？后来妄念不来了嘛。你去讲座就是讲座去的，你有一番道理想要告诉别人，大家分享，就是为这件事情去的，那叫正念，不叫妄念。一事当前，从小我出发，想这件事情马上妄念就起来，妄念起来事情就发生不好的变化。所以王阳明讲 “事变亦只在人情里”，人情的问题。</p>
<p>好，我们接着说下去。49页。</p>
<p>在解释了一<strong>摩诃</strong>二<strong>般若</strong>三<strong>波罗蜜</strong>之后，惠能做了一个小小的总结，“摩诃般若波罗蜜”是“最尊最上最第一”，为什么说他“最尊最上最第一”？6种波罗蜜，哪一种最上最尊最第一？<strong>般若波罗蜜</strong>。有6种度。这最重要的、最根本的就是<strong>般若波罗蜜</strong>。</p>
<p>如果离开<strong>般若波罗蜜</strong>讲度的话，前三种比如说<strong>布施</strong>，<strong>持戒、安忍</strong>能让我们福德，会得福报。你布施了帮助别人，你持戒了，还有你安忍了，不跟人争斗.也能忍受艰难困苦，这三种度其实并不解决根本问题的，它是能够成<strong>福德</strong>的，那叫<strong>福德资粮</strong>。六度我们已经知道了，前三度叫<strong>福德资粮</strong>，后三度：精进、禅定、般若，那叫<strong>智慧资粮</strong>。口袋里粮食要多，前三度是增加了我们的福德，<strong>福德资粮</strong>。后三种是增加我们智慧，叫<strong>智慧资粮</strong>。中国人总是不想走极端的，福德资粮要的，智慧资粮也要的，都要。那叫<strong>福慧双修</strong>。这两种资粮都要。在智慧资粮当中最高的是什么？不是精进，不是禅定，是<strong>般若</strong>！这个法门最大。</p>
<p>他说“无住无往亦无来”，住就是停留，他不停留，不执着些什么，也<strong>无往无来</strong>，就没有过去和未来，不在此间中。这叫<strong>三世诸佛从中出</strong>。什么叫三世？过去世、现在世、未来世。过去现在未来的佛都从里边出，你没有般若波罗密多，就没有通过般若度的话，你成不了佛的。大概最高叫菩萨，菩萨也有烦恼的，比菩萨更低的叫阿罗汉，我们知道心经怎么会说出来的，是观世音菩萨说。那么观世音菩萨是应谁的请求来说？舍利子，又叫舍利佛。当初也是释迦摩尼的一个大弟子，舍利佛，然后他就修成了什么阿罗汉的境界，但是没达到菩萨的，就向观世音提出请求。那么那一天佛陀在场，大家都端坐在那里，观世音菩萨去起身，向佛陀走去。合掌躬身，敬礼鞠躬，然后跟佛讲，舍利子有这个要求，我能不能在你面前跟他讲一讲菩萨的境界，释迦摩尼许可了。答应了。</p>
<p>然后先是释迦摩尼本人“行深般若波罗密”。这就是为观世音讲心经什么？加持。在他的护念，佛陀的护念和加持之下，观世音菩萨开口说话，“观自在菩萨，行深般若波罗密多时，照见五蕴皆空，度一切苦厄。舍利子。。。”，我跟你讲了，心经的缘起。所以惠能在这里会这么讲的，般若波罗蜜是 “最尊最上最第一”，你不达到这个度的话是成不了佛的。而《心经》不是讲佛的境界，《心经》讲的是<strong>菩萨境界</strong>。因为观世音讲了这一段心经就那么短，260个字，就让舍利子往上提升，提升到菩萨境界，你不到菩萨境界，你无法渡别人，你是自了，自己解决了问题，那叫阿罗汉。阿罗汉都是自了汉。就解决什么问题？解决自己的生死的超脱。所以修到阿罗汉境界的人一定知道自己什么时候走，这一点他做得到。这是佛教的一个基本的常识。所以说<strong>三世诸佛</strong>都从哪里来？从<strong>摩诃般若波罗蜜多</strong>里来，当用大智慧打破五蕴烦恼，尘劳。<strong>五蕴</strong>就是<strong>小我</strong>，五蕴有哪5个方面？</p>
<p>【学生：色受想行识】</p>
<p>对，色、受、想、行、识。我们的小我就这5个方面构成的。所以五蕴又叫<strong>五堆</strong>。为什么说<strong>堆</strong>呢？<strong>巢穴</strong>。色、受、想、行、识是小我的<strong>巢穴</strong>。我们就安居，我们就居住在这个里面的，居住在色、受、想、行、识里面的。</p>
<p>所以我们就叫<strong>五蕴</strong>，“打破五蕴烦恼尘劳”。五蕴就是我们的小我，我们执着不放的。我们感受到外部世界，叫<strong>色</strong>。我们感知叫<strong>色</strong>。有所感受快乐痛苦，这叫<strong>受</strong>。因为有了快乐和痛苦的区分，我们就要起愿望，要趋乐避苦，这个愿望起来就叫<strong>想</strong>。这个想要去实践它叫<strong>行</strong>、<strong>意</strong>，<strong>意</strong>要达到自己的目标，需要认知事物，叫<strong>识</strong>。分别是色、受、想、行、识，我们平时的小我就如此。就5个方面，各位想想是不是这样？色、受、想、行、识五个方面打破它，这叫“照见五蕴皆空”，打破它。烦恼从哪里来？我们的五蕴。烦恼。</p>
<p>第一<strong>五蕴</strong>、第二<strong>烦恼</strong>、第三<strong>尘劳</strong>，什么叫尘劳？<strong>劳就是做事情</strong>。人生在世怎么能不做事呢？不做事的人生不能叫人生，肯定的。但是做事情好好做没什么问题吧。你有两条腿就在走路，你有两条腿我偏偏不让你走路，无疑是对你的迫害。你有一个头脑就应该思考和学习，你有一个头脑，我偏偏不让你学习，不让你思考，也是对你的迫害。</p>
<p>那么天下的都劳没错，但是都是尘劳的多。什么叫<strong>尘劳</strong>？<strong>尘就是烦恼</strong>，<strong>带着烦恼做事情，这就叫尘劳</strong>，烦恼不就是尘嘛。天下有两类人，《红楼梦》最后一回最有意思的话是什么话？虽然后四十回是高鹗所续的，但是有许多精彩的地方，说空空道人看到石头上又增添了文字，实际上所谓增添出来的文字就是后说空空道人看到石头上又增添了文字，实际上所谓增添出来的文字就是后40回的意思，然后他又把它记下来，跟前面的东西都接好了，叫前80回后40回。那么空空道人就想要在人世间找到一个人，让他去传抄，留布于世。</p>
<p>那么空空道人就在天下找呢。找来找去，空空道人发现天下无非两类人。一类叫<strong>糊口谋衣之辈</strong>，一个叫<strong>建功立业之人</strong>，就两类人。一类人要成天在这里努力建功立业。还有一类人天天干嘛你？糊口谋衣。在两类人之外你找不到任何人，我读到这里心里蛮开心的想一想，然后想一想我王德峰属于哪一类呢？我想来想去，我肯定不是建功立业之辈。我应当属于另一类叫糊口谋衣之人。就这里了。这两类人当中谁最容易<strong>尘劳</strong>，或者一定在尘劳中——建功立业之人。</p>
<p>糊口谋衣未必尘劳，有个胃嘛，肚子饿了要吃饭我就得谋食。冬天天冷了寒冷了，我要谋冬衣嘛，这就是劳，但这是很正常的劳，没什么尘。你那个目标来了，要功要业，要跻身世界500强，那个劳叫<strong>尘劳</strong>，<strong>尘劳</strong>就这个意思。</p>
<p>好好地做事，好好地谋生，我跟复旦大学的本科毕业生也是做一个毕业典礼的讲话，我就会这么说，我们还是糊口谋衣第一要紧事，虽然不是第一等次，第一等次是学做圣贤，王阳明讲的事。但是第一件事一定是糊口谋衣，好好学佛，糊口谋衣去吧。你复旦毕业了还不能糊口谋衣算什么复旦的毕业生呢？但是一出门还没出校门，就想着将来建功立业，要成为社会精英，我说你们全错了。复旦不是培养社会精英的地方，复旦培养的是<strong>民族的脊梁</strong>。什么是<strong>民族的脊梁</strong>？第一，自己先糊口谋衣呀，<strong>能够在平凡的工作岗位上做出默默无闻的努力来推动民族的进步</strong>，这是复旦所要的人。2007年复旦大学研究生毕业典礼上的讲话，我是教师代表，当时就是上海许多媒体都在下面，复旦每开一次什么毕业典礼或者开学典礼都有媒体。当天晚上就有一个解放日报的记者打电话说，我听了你的演讲很感动，能不能把原稿给我，我说可以，后来第三天他们就登了。</p>
<p>我是破天荒第一次在讲出了复旦大学不要自以为是培养社会精英的地方。我的精神来自哪里？来自《坛经》。但现当代的年轻人都遗忘了这些东西，想着自己将来要建功立业，那就去尘劳去吧。然后建功，功未建成，业未立成，就觉得自己人生失败了。空空道人到处找呀，找来找去就两类人，这怎么办？谁去传抄呢？所以找到一个，在那个草案边上长睡不醒，此人就贾雨村。贾雨村是个很坏的家伙，但是后来他自己也是被朝廷抓了，因为他是当时的大贪官，犯了婪索之罪，后来正好遇到皇帝大赦天下。结果没治他的罪是递籍为民，就把他的官籍拿掉了，从此以后不能再做官，用今天的话讲双开。双开完了他才悟了。他到急流津，觉迷渡口。遇到了甄士隐最后一回，那么甄士隐已经是道家境界了嘛，然后双方有一个交流，在那里折手相谈。谈了之后，贾雨村从那，就没悟到佛这个层面，至少是进入道家思想，然后在那里长卧不起，睡得很长，这已经有功夫了，我们知道道教历史上有一个叫陈转的人，他连续睡几个月都没事情了。后来的空空道人就把这个人拖起来，怎么叫都叫不醒，后来终于把他拉起来了。贾雨村一看他说这些事情我早知道了，大概没错，然后你去找另外一个人吧，找谁？悼红轩里的曹雪芹先生，请他去抄，最后一回120回，读到这里，我蛮开心。就讲尘劳是什么意思？所以惠能这里三个要打破三个东西。有一个叫<strong>五蕴</strong>，一个叫<strong>烦恼</strong>，一个叫什么？<strong>尘劳</strong>。</p>
<p>“如此修行，定成佛道，变三毒为戒定慧”。哪三毒？<strong>贪、嗔、痴</strong>，这叫三毒。针对这三毒就是<strong>戒、定、慧</strong>，怎么对付贪？一个<strong>戒</strong>字。怎么对付这个嗔就是愤怒，恨别人？一个<strong>定</strong>字。怎么对待我们这个痴呢？来个<strong>慧</strong>字。“变三毒为戒定慧”。</p>
<p>然后再概括一下法门，波罗法门多么大。“我此法门，从一般若生八万四千智慧”，佛教习惯用大数字说话。“何以故？为世人有八万四千尘劳”，想当官的有想当官的尘劳；有想发财的有想发财的尘劳；要想成名成家的有成名成家的尘劳，当然没八万四千种之多噢，这是佛学喜欢用大数字的。</p>
<p>针对这八万四千种尘劳就要有八万四千种智慧。那么这个智慧是实践，就八万四千种法门，佛教教法门有多少？多了，八万四千种法门。都从哪里生出来？<strong>般若</strong>。</p>
<p>“若无尘劳，智慧常见，不离自性。悟此法者，即是无念。”<strong>无念</strong>我们后面再解释，不是什么念头都没有，什么念头都没有，不叫无念叫<strong>绝念</strong>，绝念是人死了呀。<strong>无念是指无妄念</strong>。</p>
<p>“无亿无着，不起诳妄。用自真如性”，用自己本有的真如自性，“以智慧观照，与一切法，不取不舍，这是见性成佛道。”</p>
<p>底下就谈《金刚经》的重要性，这个做法是跟着他师傅说下来的。禅宗从初祖达摩一直到四祖道信都把一本经典看得非常重要的是《楞伽经》。到了弘忍法师第五祖的时候，弘忍法师认为最重要的经典是《金刚经》。佛经浩如烟海，读不胜读。我们其实只要读一部就够了，终身受用。这部经就是《金刚经》，这是弘忍法师的看法。那么惠能从弘忍法师那里得衣钵过来，得佛法过来的，他也继承这个说法，就把《金刚经》看得最重要。</p>
<p>“善知识！若欲入甚深法界及般若三昧者”，<strong>三昧</strong>什么意思？我们后面要讲的，现在先放一放。“须修般若行，持诵《金刚般若经》，即得见性”。然后底下说明修般若法门是很不容易的事情。</p>
<p>第51页，“当知此经功德，无量无边，经中分明赞叹，莫能具说”。他听过《金刚经》，所以惠能知道《金刚经》里说了些什么，他说我现在不能一一道来。</p>
<p>“此法门是最上层，为大智人说，为上根人说。小根小智人闻，心生不信”。小根小智人听说《金刚经》的这种道理，我们凭借《金刚经》所讲的般若波罗密就能抵达彼岸，不信的，小根人不相信的。</p>
<p>“何以故“呢？他做了个比方，佛教许多的词都是比喻了。比如说根器。根性就是树根的意思，树根就是比喻。一棵树它要根扎的深，这叫上根；扎的比较短，比较浅，那叫小根。我们想想看这个比喻多么恰当。当冬天到来的时候，所有的树木都一样的凋零了，花叶凋零。在寒冷之中看上去都死掉了，但是当春天到来的时候，那些没有被冻死的一定是根扎的深的树。这个根扎的浅的树木恐怕再也不能活了。根扎得很深的树，它照样枝叶凋零，没关系的，到春天到来的时候再度花繁叶盛。关键就是根。所以王阳明也讲了，我们做的事情要从根基处入手的，培根是最重要的。不要事情刚开始做，就想着将来要长多少叶子，开多少美丽的花，结多少很好的果实。他说不要做叶想，不要做花想，只做一件事：<strong>扎根</strong>。所以这就是从惠能的思想那里来，从禅宗的思想那里来。</p>
<p>所以我说阳明是谁呀？儒家中的惠能。那么惠能在这里就讲人是有区分的，虽然都有佛性，但是要悟到佛性是不是要有慧根啊？那么慧根有深浅，深的叫上根之人，浅的叫小根之人。那么我们一般小根之人听到《金刚经》中的佛法总不能相信。最好要依靠别的手段、别的步骤、别的帮助。这种情况就好像“天龙下雨于阎浮提，城邑聚落”，雨下的实在太大了。然后小根只人全飘了。“系皆飘流，如飘枣叶”。但是同样的雨下到大海呢？那叫不增不减。“若大乘人，若最上乘人，闻说《金刚经》，心开悟解”。后来我发现惠能讲的话全对的。现在许多人都知道《金刚经》，自己也去读了，基本上读不懂。读不懂的就会请那些什么庙里的大和尚专讲《金刚经》，大家去听，那么也会听大学里的教授，专门研究佛学的专家去讲《金刚经》，可见自己读《金刚经》很难，我们在座的恐怕都有读过的，那些三句义你就搞不清楚。“如来说第一般若波罗蜜，即非第一般若波罗密，是名第一般若波罗密”。他来了。“如来说世界，即非世界，是名世界”，又什么意思呢？后来毛泽东有意思了，拿了《金刚经》的三句义说话了，毛主席有一个习惯，如果他主持中央工作会议，先开口说些闲话活跃一下气氛。那一天他就说了“”各位，就他的党委同志们，读过《金刚经》了没有？大家一脸的茫然，主席怎么今天提起《金刚经》了？毛主席就说了我是读过的，里面充满了辩证法，比方说：此人是赵朴初，即非赵朴初，还是赵朴初。党内同志仍然一脸的茫然。主席说心里想不跟你们讲了，开会。</p>
<p>《金刚经》难懂。所以惠能说要上乘人呐，最上乘人，“闻说金刚经，心开悟解”啊。</p>
<p>“故知本性自有般若之智”，马上就明白每个人都有般若之智。“自用智慧，常观照故，不假文字。譬如雨水，不从天有”。我忘了我上次讲过金刚经的三句义吗？我们略讲一下好吗？如来说世界，第一句话哦，就有这个世界的，第二句话即非世界，什么意思呢？别把世界看成是实体，本空。但是你停留在第二句话里仍然错了。是名世界。这是蛮愉快的事情，咱们参悟参悟。《金刚经》里面大量的这种句型，如来说世界。</p>
<p>有世界吗？有。但是我们千万别像西方人那么理解，世界是由实体组成的，西方思想就这样，西方哲学最初开始寻找实体。</p>
<p>西方哲学起步就是通过泰勒斯--西方第一个哲学家，泰勒斯说了句什么话？“水是万物的本源”，找本源就找实体，是西方哲学。后来在科学上继续找，通过物理学或者先是找到原子了。后来发现原子不本源，还能分呐。那么后来发现组成原子的是基本粒子。后来发现基本粒子也不基本的。现在据说是夸克，总的来说一路在找吧。西方的世界观就是实体的世界观，找实体的。</p>
<p>释迦摩尼不一样倒过来的。世界不是实体，所以先说有世界，马上说即非世界。世界不是由实体构成的，所有的佛教各个宗派差别很大，但是只要是佛教的一定是共同承认4个字，“<strong>缘起性空”</strong>。</p>
<p>你不承认“<strong>缘起性空</strong>”的话呢，你这个就是跟佛教没关系的。你那个宗派就不是佛教的宗派了吧？一切佛教宗派共同的出发点4个字，后面的其他的区别是后面的事情。</p>
<p>先为什么称为佛教？这4个字“<strong>缘起性空”</strong>。这个杯子存在吧？存在。它如何存在？他并没有一个自身的实体，它是各种条件聚合而成才有这个杯子。就种种因缘聚合而成，<strong>缘汇则生，缘离则灭</strong>。<strong>缘就是条件</strong>嘛。种种条件的聚合成立一个事物，但是这些条件一旦离散了呢？这个事物就没了。原先并没有杯子，是各种什么土、矿的材料然后加上其他的因缘，比如说火的锻炼就是烧窑，比如说瓷杯，在这些材料和烧窑的师傅的手中，把各种条件都聚合起来，一个杯子终于来了，然后他又要散掉，将来它没了。</p>
<p><strong>缘会则灭</strong>，万事万物都如此，你不要追问这个杯子本身的实体的存在，它没有。这叫<strong>万事万物</strong>，自性本空。事物都没自性的，就没有自己的实体性存在。所以<strong>性空</strong>两个字其实就是从<strong>缘起</strong>里面自然推出来的。你说事物都是因缘聚合而成的，就是它性是空了。所以这两个是从里面自然推出来，你讲<strong>缘起</strong>一定讲<strong>性空</strong>。好，有世界吧？有。但它不是实体，你说它不是实体，但是你把<strong>缘起</strong>能否定吗？<strong>缘起还是真实的</strong>。所以“<strong>是名世界</strong>”。“如来说有世界”，马上把它否定掉，就说它不是实体，“<strong>即非世界</strong>”，但是你否定了实体不等于否定了<strong>缘起</strong>。<strong>唯一真实的东西就是缘起</strong>，世界就是<strong>缘起</strong>。三句话来了。</p>
<p>我一直认为我们年轻的一代要早早得懂这个道理，要读读《金刚经》，然后会说三句义。这么多年来，我经常有机会参加我的学生，我的研究生，有的硕士生，有的博士生，他们结婚了，那么最后我们就邀请我去参加婚礼。我后来就最怕这个事情，为什么呢？他们总叫我做证婚人。你是新郎或者新娘的导师，那么就邀请你的同时说，王老师你能不能做我们这场婚礼的证婚人？我其实最害怕，为什么？平时我说话还算流利噢，但到了婚礼上做证婚时，我就不知道该说什么了，因为基本上都是套话。那么所以我打腹稿，我总是要打腹稿。比如说明天要参加婚礼做证婚的人，今天就在家里想着我说什么，总不能写下来那里去念吧？一念不像个教授，拿着一个写好的文字在那里读一遍，那算什么教授，不能念，要在肚子里打好腹稿上去。那么怎么打我总是一般来说第一要恭喜他们，祝贺他们喜结良缘，然后介绍一下男女双方，他们这么相多么配，多么相配。然后再完了接下去要说什么？要祝贺他们白头偕老。我想这些话全废话，很空的吧？但是我也没办法了，总得这么说。</p>
<p>还有一次我接到了一个邀请，也是我的一个博士生，他说他要结婚了，然后把一个请帖给我了，我很高兴，然后我终于发现他没跟我讲你要做证婚人，那天我就特别开心，没那个任务，也没打腹稿。来到了婚宴的大厅，找到了我的席位，一坐下来发现周围好几个都是认识的，那么大家真开心在那里聊天。然后婚庆公司主持人在台上讲话了，欢迎各位新郎新娘的亲人、朋友、嘉宾，大家欢聚一堂，今天是一个什么佬谁谁谁的幸福的日子，我们也都一样，这段话他们很会，说得很流利的。那么我也听着然后我们聊天，突然我听到我的名字了，婚庆公司的主持人，婚礼主持人说了，各位来宾，大家知道今天在座的有位特别的嘉宾，他是我们新郎的博士生导师，我们现在请他上来做证婚词好不好？全体鼓掌。我完了。腹稿根本没准备好，但人必须上去。我一面往台上走，一面心里想我说什么呢？没东西肚子里空空的，接过了话筒，突然灵机一动，想起《金刚经》的三句义了，于是我开口说了。第一句话，如来说你们是夫妻，掌声雷动，就如来说的档次比较高，掌声雷动之后，第二句话我来了，即非夫妻，全场沉默。大家在惊愕之中看着我，这个教授现在脑子进水了，即非夫妻啊。大家在一片惊愕之中，我第三句话来了，所以是夫妻。人们一样的愕然，你在说什么呢？突然有一个人，朋友举手了，我也不认识他。站起来王老师说的好，你送了一部《金刚经》给他们，我上来给你做个注解，他自告奋勇，我非常感谢他，他来救场的你知道吗？拿过话筒说：刚才我们的王老师讲的，第一恭喜你们今天喜结良缘，那叫如来说，你们是夫妻。第二句话，在提醒你们，你们进入了人生的一个重要阶段，叫婚姻。步入了婚姻的殿堂，你们从此之后将是朝夕相处，面对的就是柴米油盐的事情，你们彼此之间进入一个磨合阶段，在磨合阶段里边问题要出来的。王老师提醒了你们。你们不要以为我跟你打交道，怎么你是我娶来的妻子，原来是这样一个人，或者我嫁的丈夫居然是这样一个人，完全不符合我心中的理想。假如是这样的话，你们就要闹矛盾，闹矛盾闹得严重的嘛要出事情。你们别忘了，夫妻是个宝贵的缘分，这叫第三句话，所以是夫妻。这时候全场明白了。掌声起来。我非常感谢他。这个人是读过《金刚经》的，所以他知道我在说什么。这是佛家给我们的第一个智慧，叫“<strong>缘起性空”</strong>。年轻人相爱了，心里想着要找到理想的妻子或理想的丈夫。那么隔壁邻居那个女孩子向来对他很有爱意是吧？他也感觉到，但他对那个女孩子一点感觉都没有，他千里迢迢的巴巴的找来了一个他心目中理想的妻子，你知道吧？终于结婚了。结婚之后短短的一段时间发现他娶了谁？河东狮。然后他就非常后悔，如果这种后悔蔓延下去的话，结果会离婚。要离婚了。要离婚什么意思？就停留在什么？第二句话里——即非夫妻。千万别停留在第二句话里，还有第三句，那叫什么啊？是名夫妻，夫妻是缘。</p>
<p>我们不知不觉的心中有一个理想的实体，我应该有怎样的丈夫，我应该有怎样的妻子，这不是理想的实体嘛。拿心目中理想的实体来要求对方，他一定不符合你这个实体，不符合那你怎么办？结束了。理想实体的想法是错的。天下哪有一个男人天生是丈夫的？他成为丈夫是被他妻子做成的。天下哪有一个女人天生是妻子的？她成为妻子其实是被他的丈夫所成的吧。所以夫妻关系并不是实体之间的关系，是交互关系，那叫<strong>缘</strong>呐。彼此造成了对方的，我造成了你，你造成了我。你哪里可以拿出一个所谓理想的丈夫或理想的妻子，这个标准是要求对方，如果你觉得他是很不能让你满意的，其实你是这样一个丈夫或这样一个妻子，跟你没关系吗？肯定有关呐。你们走在一起是那个缘呐。我们不是要珍惜实体，不变的实体它本不存在，我们要珍惜的是<strong>缘</strong>。这就是金刚经讲的什么？<strong>三句义</strong>。不光是夫妻的关系，企业跟员工之间的关系也是如此。每一个企业家都想招到理想的员工，然后这员工进了企业之后，不久你就会发现原来他并不理想，毛病很多，你终于觉得这不是我们企业所要的员工，你怎么办？其实员工当初到你这个企业来的时候，也是心里想着你这个企业才是我要来的地方是吧？心中关于一个最好的企业的理想实体。走进了这个企业，干了一段时间之后都发现这个企业不像个样子，我不能在这里待下去了，他拿着心中理想的企业来要求实体的企业。其实企业和员工的关系也是缘起，天下没有理想的员工，天下也没有理想的企业。就看你们之间有没有缘，这是最重要的。我的儿子呀，跟我儿子同时代的同年的他们许多同学，当时都是上海外贸大学毕业了，那么我儿子出国留学了，他的一些同学也是成了我的好朋友。我们在他们毕业之前，我在跟他们毕业之前跟他们一直有交流，还经常参加我儿子的同学聚会，那么我聊聊天他们都很觉得很跟我能亲近。</p>
<p>后来我发现我跟80后没什么代沟，所以我儿子在海外，他们照样有时候邀请我去吃饭喝酒。那么我发现他们会告诉我，他们也仍然称我王老师，我已经跳了三次槽了，我说你说说看你为什么跳槽？说了一听我就知道了，心中有什么？他想要去的理想的企业的标准放在那里。后来我说你别跳了，你跳槽如果是出于某种原因这样一个原因，我会赞成的，什么原因？在这个企业待下去，你不再能发展了，你自己不能提高了，这个地方你就可以换人，到一个能更让你提高的地方去，我完全能够同意。但是薪水问题，企业的工作的环境，实际的条件怎么样，千万你不要这个要求。我告诉你天下乌鸦一般黑。你跳到哪里都一样，你要看一看你跟这个企业有没有那个缘，<strong>企业因你的工作而进步，你因企业而得到成长是吧？这个缘才最重要</strong>。然后跟他们讲三句义，如来说是企业，即非企业，是名企业，这就对了。所以三句义是通的噢，是佛家的基本世界观，也是基本人生态度。头脑中理解的是一件事情，在我们的生命情感中领会了他是更根本的事情。</p>
<p>我少年的时候就知道这四个字的叫“<strong>缘起性空”</strong>，我想想蛮有道理的。释迦摩尼的思想是有道理的，世界万事万物都不是实体，都是各种条件聚合而成，条件一旦分散，事物就没了。我觉得懂了。其实没真懂。他只是头脑中理解了这种世界观。<strong>“缘起性空”</strong>。什么时候真懂了？2000年我母亲去世了，2006年我父亲又去世了，当我父亲去世的那一刻，我突然明白了什么叫**“缘起性空”<strong>。我出生在这个家庭里面，我自然而然的认为我在这个家庭出生和成长的，我自然而然的认为这个家family应当永远存在。当我父亲去世的那一刻，我知道这个family没了，这时候我才深刻的领会了什么，真正的懂了</strong>“缘起性空”**，这种条件一旦离散没了。</p>
<p>我在复旦，我考取了复旦，78年，然后我87年又考回复旦读硕士研究生，90年复旦就让我留校了，复旦培养了我，还让我在复旦任教，实现了我这个渺小的人生的一点意义。我对复旦大学怀着深深的感恩之情。我在我的内心深处呼唤复旦万岁，但是我知道复旦万岁不了，它将来一定不存在。就像他过去曾经不存在一样。你要在根本上认识这个世界，从佛陀的眼睛来看这个世界就这样，万事万物终如此的。这个东苑宾馆也万岁不了吧？就像他过去不曾存在，将来也一定不存在一样，一切都是 <strong>“缘起性空”</strong>。你立足于这个根本的认识来看待自己的生活，这是个佛家思想的出发点。你不能说<strong>缘起性空</strong>，于是就彻底空了，什么东西是不能空的？<strong>缘起</strong>！这就是三句义。</p>
<p>所以我们想到这一层的话，我们真的是能想得开了，想得开不等于我们不做事。比方说我们做为人父母的，有了自己的儿女，儒家的思想首先在心中起来的。中华民族因为以儒家思想为根本，一定关爱下一代的成长，可怜天下父母心，最可怜的父母就是中国父母。但是中国人还有一个佛家的思想，我们跟儿女的关系是<strong>缘起</strong>罢了，今生今世有缘我们相会了。我做了父亲，你做了我的儿子，来世呢？我们将永不相见。事情就这样。</p>
<p>这样有了佛家的思想，我们中国人才能想得开。全在儒家里，我们太苦了，也太紧了吧？样样事情割舍不下，抓住不放呢。你有了**“缘起性空”<strong>的基本认识，你就知道你要珍惜你跟儿子的父子之缘，也就珍惜这一辈子，下辈子再也不见面。佛家讲三世因果就是讲我们这一世怎么来的，我们有空的时候再讲一讲，叫</strong>十二因缘**嘛，很清楚的。我们怎么来到这个世界又怎么走？这是学佛第一步要知道的三世因果。其实事情都这样。</p>
<p>所以有人的总结是总结的蛮好的，这是北大一个什么教授，我忘了他的名字，他最普通的话叫儒道佛三家的关系。他说儒家让人拿得起，道家让人放得下，佛教让人想得开。多亏我们有佛家的，还让人我们想得开，我们会关爱这个孩子，但是我们也能想得开，一切都是<strong>缘起</strong>。这一般说也就是说我们知道佛教的出发点，出发点就**“缘起性空”**，它不是一个简单的头脑中的认识，它是我们的生活的最基本的态度，这就懂了，否则没懂。</p>
<p>好，我们再看一段，把这段看完。所以大乘的人或者是如果还是最上层的人，“闻说《金刚经》，心开悟解，故知本性自有般若之智”，般若须要领会虚无吧，万事万物，自性本空啊。</p>
<p>“自用智慧，常观照故，不假文字”，佛经都是用文字堆积起来，但是真理不在文字里面。</p>
<p>“譬如雨水，不从天有，元是龙能兴致”，当时中国对于雨水的解释就是有龙呐。</p>
<p>“令一切众生、一切草木、有情无情，悉皆蒙润。“都得到了雨水的滋润。</p>
<p>“百川众流，却入大海，合为一体”。《道德经》里面就讲了吧？百川都归入大海这个意思老子也说了。</p>
<p>“众生本性般若之智，亦复如是”。现在禅宗把老子的比喻拿到人的本性上来说，我们的自性本性就像大海一样能纳百川。</p>
<p>小根之人听到这样的说法就受不，就是翻过来看52页，“小根之人，闻此顿教，犹如草木根性小者”，那根太浅嘛。“若被大雨”，好像被大雨淋到了。被就是一个接受。被大雨淋到了。</p>
<p>“悉皆自倒，不能增长。小根之人，亦复如是。元有般若之智”，其实小根之人虽然根浅，但般若之智跟大智人没什么差别。</p>
<p>“因何闻法不自开悟”呢？为什么你听了《金刚经》的话还不能开悟，有原因的。</p>
<p>“邪见障重”，这个邪见本来就有，障重是累世累积，积累出来的。</p>
<p>“烦恼根深，犹如大云覆盖于日，不得风吹，日光不现”。本来你就是太阳，但是现在被云遮蔽住了，需要风来把它云吹掉。</p>
<p>这个吹掉云的风是谁？“大善之声”。是佛经嘛。</p>
<p>“般若之智亦无大小”，智慧没什么大小的。</p>
<p>只是因为“一切众生自心迷悟不同，迷心外见，修行觅佛，未悟自性，即是小根”。许多人确实想修行，但从心外去求的。</p>
<p>“若开悟颠教，不执外修，但于自心常起正见，烦恼尘劳，常不能染，即是见性”。你看惠能在这里一方面说大多数小根之人不能领会《金刚经》的佛义佛理，但是小根之人不是没有希望。因为般若之智也都一样有的，只是说什么云遮蔽这个太阳，云太厚了，这个叫 “邪见障重”，所以需要帮助，帮助就是风来把云吹散了。这吹散的那一刻，阳光就照射出来，吹散的那一刻叫<strong>顿悟</strong>，所以强调是惠能在强调他所说的禅宗属于<strong>顿教</strong>，跟北派的神秀不一样，北派的神秀主张渐悟，南派的惠能主张<strong>顿悟</strong>。</p>
<p>“善知识！内外不往，去来自由，能除执心，通达无碍，能修此行，与般若经本无差别”。我们的修行就是般若经了，般若经在文字里边，然后让这些文字所说的意思成为我们的生命实践，我们的人生就跟般若经比之了。这话说得很非常好。</p>
<p>好，各位朋友，今天的课我们现在开始。我们昨天讲完了般若品，我们今天要进入疑问品。般若品当中的几个要点，我们再做一个回顾。在般若品里惠能首先讲了般若智我们每个人都本是具备的，这个般若智就是领会虚无的智慧。因为我们每一个人很快就会意识到来到这个世界上之后，很快就意识到自己必有一死，所以也就是领会虚无。面对这样一个必有一死的问题，就是一个终极关怀的问题。我们大概在孩提时代，第一次意识到自己必有一死的话，一定是恐惧，在理性上无法接受。我小时候就想过我是否能够例外？后来发现是无法例外的。于是这短暂的人生，哪怕是活到100多岁，在时间的长河里，过去是可以无穷追溯的，未来也是无限延伸。在这个时间的维度当中，有两个方向的无限性。我们把自己的生命时间放到这个维度上，他简直就是一刹那而已。于是就会想，如此短暂的人生，它的意义究竞寄托在哪里？因为对虚无有领会，才有生命的意义的问题提出来。假如我们就像基督教讲的，曾经在伊甸园中的亚当、夏娃没有被赶出伊甸园，可以没完没了的活着，我们就会想这个想那个，绝不会思考任何宗教或哲学的问题。所以释迦摩尼讲他的佛学，一开始面对的就是这个大问题嘛，在一个四扇城门分别看到生、老、病、死就领会到人生就是苦，并且被虚无包围着，要解决这个问题。我说这叫终极关怀的问题。终极关怀来到我们心中，也就是意味着我们真切的领会到虚无了，这就是<strong>般若智</strong>。</p>
<p>禅宗的祖师都讲这样一句话，“佛以一大事因缘而出世”。佛陀来到这世界上是为了一件大事情来的。什么大事情的呢？<strong>了生死</strong>——就是能面对死亡，领会到虚无的不可避免，这就是般若智，世人本自有之。这个问题如何解决？需要一个民族的宗教或一个民族的哲学。我还记得我小时候是毛泽东时代，毛泽东时代本身用一种思想来帮助我们每一个个人解决这个问题。当时就读雷锋日记，全国学雷锋，然后我们小学生也读《雷锋日记》，读到这样一条“人的生命是有限的，为人民服务是无限的，我们要把自己有限的生命投入到无限的为人民服务中去”。这话当时真的鼓舞了我。我是当时小学两年级的学生，确实想到过生死问题，没办法解决。雷锋帮我解决了，生命是有限的，但它的意义是可以成立的。这个意义不在这有限的生命本身中，而是把这有限的生命跟一个不朽的事业关联起来，那个不朽的事业就是为人民服务，这是解决终极关怀问题的一种方式。毛泽东时代结束了，一个理念的时代隐退了，生死的问题仍然成为每个人自己要去解决的问题。那么中国人还有一条路嘛，就是佛学。</p>
<p>般若品里的第一个要点就是叫<strong>般若智</strong>，我们本来都具备。只是心迷，不能自悟，“只缘心迷不能自悟”。先是讲出我们修禅宗的每个人自身有的根据，就是般若智。</p>
<p>第二个要点，就讲我们的人心本是妙性，“世人妙性本空，无有一法可得”。讲摩诃的时候，就讲第一层意思空，一个人心如果不空，他就没有妙性，灵敏没有了，创造性没有了。创造性的前提是心要空，你好像已经被什么东西武装起来了，你就逐渐的丧失创造性。从这个角度来理解，我们要保持我们的妙性，那种灵敏，一点灵敏那种灵觉，前提仍然是空。</p>
<p>第三个要点，不能停留在空里边，执着于空，又是一个烦恼，所以要<strong>空空</strong>。空空什么意思？能够包容万事万物，这叫真空。“自性能涵万法是大”，这就是摩诃的第二层意思。</p>
<p>然后就讲我们众生与佛的关系，众生是佛，“凡夫是佛，前念迷时凡夫，后念悟就是佛”。众生是尚未觉悟的佛，佛是己经觉悟了的众生，这个思想非常重要。在中国思想史上是第一次提出了众生平等。还有那句话非常要紧，“烦恼即菩提”，菩提就是正觉。我们在烦恼中才可能达到正觉，觉悟。</p>
<p>然后惠能就讲了什么叫真正的度，波罗蜜多，就抵达彼岸。那么先要说明此岸和彼岸的关系，用了一个很重要的比喻，此岸就是海面的波浪，彼岸就是不增不减不生不灭的海水本身。那么这个波浪起伏的缘故呢，就是我们着境，人生的处境不断的变化，有时候顺境有时候逆境，有时候苦境，有时候乐境，不断的变化，我们的心就被影响。所以起了波浪，种种的妄念起来，所以着境，就生灭起来，生生灭灭起来。“离境无生灭”就是抵达彼岸了。大致就这几个要点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="疑问品"><a class="header" href="#疑问品">疑问品</a></h1>
<p>那么现在我们进入疑问品。我们可以把书翻到66页，韦刺史又来了，“一日韦刺史为师设大会斋”，这跟大多数佛经一样，佛陀说佛法之前先用斋，“斋讫”，用斋完了以后开始说。</p>
<p>这里也是说韦刺史准备好了素斋，“斋讫，刺史请师升座”，来的人有官僚，有士大夫，有庶民百姓，“肃容再拜”。韦刺史开始向惠能提问题了，一共提了两个问题，然后惠能对这两个问题做了解释。所以这一品叫疑问品，这两个问题都蛮重要的。</p>
<p>“弟子闻和尚说法，实不可思议”，前面听了两次，都说还是不可思议，“今有少疑”，有一点疑问，“愿大慈悲。特为解说”，“有疑即问，吾当为说”。好，一个问题，第一个问题来了，你惠能所说的佛法是不是达摩大师的宗旨？因为禅宗初祖就是达摩，印度人来到中国，你继承衣钵。其实就成了第六祖，你说的佛法是不是跟达摩所说的一脉相承呢？就这个问题。惠能说“是”。</p>
<p>那么韦刺史又说了“弟子闻达摩初化梁武帝”，当初达摩在中国遇到梁武帝，梁武帝笃信佛教的，那么达摩就想度化他，讲要度化梁武帝，那么就有一番交流。梁武帝问达摩“朕一生造寺度僧，布施设斋，有何功德？”我这一辈子不知造了多少庙，供养了多少和尚，这功德大不大？就这个问题。达摩回答的很清楚“实无功德”，一句话就否定了，这不叫功德。在历史上记载这样一个事情，梁武帝听了达摩的话就很不高兴，所以两个人说话就不投缘。不投缘，各自就分开了。达摩也放弃了度化梁武帝的愿望，梁武帝也不会去干扰达摩，因为梁武帝本人是笃信佛教的。所以各自分开，各不相扰。韦刺史就拿这个典故，禅宗史上的典故来问惠能了。我没有明白达摩这话的意思，“愿和尚为说”。惠能回答得非常的明确“实无功德，勿疑先圣之言”，你不要怀疑达摩的话，“武帝心邪，不知正法。造寺度僧，布施设斋”，其实都是求福报，“名为求福，不可将福便为功德”，不能把这两者混淆起来。“功德在法身中，不再修福”。这句话在佛理上讲的非常精准了，非常准确。</p>
<p>为什么说“功德在法身中”呢？假如我们按照佛教，做好事情，布施设斋等等，也帮助佛教的发展，造寺庙，供养和尚，这样的事情只是修福而已。佛教讲我们的肉体叫色身，修佛是要把色身转为法身。佛教也认为我们做好事会得好报，那叫福报，这是肯定无疑的。你做过的事情都会有效果，都会报到你自己身上。这条原则叫<strong>已做不失，未做不得</strong>。这是屡试不爽的事情。你布施供养和尚造寺庙，帮助佛教事业的发展，这些事情都会得到福报，这是肯定无疑的。</p>
<p>我们现在中国当下许多人学佛，学的都蛮认真，也做了许多布施的活动，其实心中想的就是求福报，福报报在什么身上呢？报在色身上。富贵是肉体的享受，离不开身体。<strong>福德在色身中的，功德才在法身中</strong>。你追求现世的幸福，得福报，这都跟我们的肉体分不开的。但是修行的目标是<strong>转色身为法身，法身是不生不灭的</strong>。这听起来很神奇。法身究竟是什么？很神秘。其实法身就是与众生为一体的，就是<strong>法身</strong>。<strong>与众生为一体，这就是法身</strong>了。所以惠能的回答是直击要领，“功德在法身中”。换句话也就是说<strong>福德</strong>在<strong>色身</strong>中。我们要区分功德与福德，做好事得好报，那叫福报，那叫<strong>福德</strong>。</p>
<p>摆脱生死，超越生死，不生不死，与众生天下为一体，那叫法身，“功德在法身中”。底下惠能又进一步的解释，“见性是功，平等是德”，这一句话是特别特别重要。我们读《坛经》会注意到，惠能解释许多道理所用的语言上的方法，它也符合中国汉字的构造。</p>
<p>中国汉字的每两个字所组成的一个单词都可以拆开来说，然后再合起来。功德，先说何为<strong>功</strong>，再说何为<strong>德</strong>，“见性是功，平等是德”。<strong>自见佛性是我们的心灵所达到的境界，这叫功。拿这个境界来跟别人打交道，这叫德，<strong>打交道的原则是</strong>平等</strong>。这个德性就是人与人之间打交道的原则。</p>
<p>把功德拆开来，何为功？何为德？合起来叫功德。中国的汉字，除非现代汉语当中许多用来直接翻译欧洲语言当中的单词的那些字恐怕不能拆，不能把两个字拆开来说，还有一些比如说葡萄，是吧？你把葡和萄分开来，葡是什么？萄是什么？合起来这不通，葡萄两个字必须连在一起，这种词是不能拆的，但是大多数汉语的词都可以拆，而且先要拆了再合起来。</p>
<p>你比方说中国汉语当中有一个词，叫道理是吧？你要讲道理，道理这个词怎么解释呢？你先想想，你把它如何翻译成英语。你比方说两个中国人在吵架，吵得很凶，终于一个中国人愤怒的指责另外一个中国人，“你怎么好这么不讲道理”？</p>
<p>边上有个老外，听不懂汉语，但是知道这两个人在吵架，他很想知道这个中国人指责那个中国人说了一句什么话。假定我在边上，他请我翻译，我想这太容易翻译了吧，日常语言嘛。怎么翻？“你怎么好这么不讲道理”？我想太容易翻了，我就开始翻了。Why就是为什么。Why are you so？为什么你是如此这般的，是吧？Why are you so out of reason？假如我这么翻，不讲道理译成了out of reason。会怎么样？学过英语的朋友知道，out of reason的意思就是在理性之外， Why are you so out of reason？老外听懂了。</p>
<p>老外刚一听懂，我知道我犯错了。这个中国人指责另外一个中国人说你怎么好如此之般的不讲道理。并不是这个意思，并不是说你怎么如此这般的在理性之外，如此这般的违背理性的法则，不是这层意思。</p>
<p>我们现在中国人都知道的，说你不讲道理，并不是说你违背了理性的法则，没这个意思了。说你不讲道理是你违背了人之常情。你怎么好如此这般的违背人之常情呢？这才是中国汉语当中道理两个字的含义，绝不是理性的规则的问题。所以别以为道理这个词就可以现成的翻成欧洲语言，翻不过去的，真的翻不过去。还有我们拿“国家”这两个汉字来翻译英文当中的state，其实英文当中这个state里面有家的含义吗？没有家的含义，就是一种政府权力机构，这种state和市民社会的关系是契约。这个契约是什么？<strong>宪法</strong>。</p>
<p>在中国人心目中的国家，首先是家，一个大的家。这个国家权力机构其实对人民生活要承担伦理责任。这层意思在state里边有没有？没有的。所有许多的表达中国人对生活和社会的领会的汉语的词，是无法翻译成什么？欧洲语言。所以“道理”二字你怎么来解释？他其实这两个字合起来的。一个叫<strong>道</strong>，一个叫<strong>理</strong>，合起来叫<strong>道理</strong>。<strong>道</strong>是什么？<strong>天道</strong>。<strong>理</strong>是什么呢？<strong>一个事物存在的根据</strong>，叫<strong>理</strong>。一个事物存在的根据从哪里获得？从它符合天道这件事情上来获得。每一个事物它存在的根据就是它的理，这个理来自什么？<strong>天道</strong>。所以合起来叫什么？<strong>道理</strong>。那么天道在哪里？<strong>天道在人民生活中，在柴米油盐里</strong>，那叫<strong>人情</strong>。所以什么叫你不讲道理？这叫违背人之常情。你违背人之常情，你就背离天道。道理二字就这个意思。这种中国思想凝聚在道理这个词上，你如何能把它翻译成reason，翻译成理性？</p>
<p>这层意思我们在讨论大问题，就像我们最近在看《人民的名义》，有的人已经把西方思想放到心里去了，搞改革，要按照法律的理性，经济学的理性，reason，然后他真这么做了。结果背离了人民生活。这叫讲的是理性，不讲道理。你就讲理性，你就不讲道理。这是中国思想和西方思想的差别，这可是个大的原则的事情。所以我就不知道李达康后来会怎么样，李达康就是讲reason的，他不是贪官，讲reason。那么面对大风厂的事情应该讲道理。谁讲道理了？陈岩石。就是老的那个检察院的副检察长。他就是在道理里边，李达康在reason里边，事情就这样。</p>
<p>我们学哲学，无论学中国哲学还是西方哲学，它可不是空中楼阁。你学了哲学，有了哲学修养，你能够什么？一个最重要的体现是什么？你领会到我们说话的方式，它的含义，这可不是语言学研究，语法学研究。哲学讲的事情，要揭示这个时代，这个文明的真相是吧？那这个时代这个文明的真相隐藏在哪里？各位知道吗？隐藏在当下的人的语言中的，隐藏在当下人的说话方式中的，你就把这个说话方式拿出来一看，就知道今天是什么哲学。</p>
<p>我举个例子，我跟复旦大学的学生们做讲座，经常会做，有一次我做讲座就讲起这件事，我说各位在复旦大学读书有一种骄傲感，有一种自豪感是吧？这我能理解。</p>
<p>因为考进复旦真不容易，你们就觉得自己是天之骄子，将来就要成为民族的精英是吧？你们很骄傲，在不断读书期间有骄傲感，有自豪感，这是很好的事情。但是我要告诉你们一个不幸的事实，什么事实呢？你们毕业的时候走出复旦，你们是谁？你们是什么？你们叫什么？Human resource，人力资源。跟石油并列在一起。一个大的集团企业一定会有两个部，一个叫能源部，一个叫人力资源部。你们其实就是Human resource，人力资源。跟能源并列在一起的，就像我们对能源要进行质量的评估一样，专门有一个部门叫Human resource。人力资源部也要对你们做质量的评估，有一整套评估系统，它是管理科学的一个分支。</p>
<p>现在在Human resource这个领域里边还可以拿博士学位，然后到企业干嘛？做人力资源的事情，HR。这是我们时代说话的方式，以前不叫人力资源部。叫人事部。那是对的。讨论的是人的事情。现在不是讨论人的事情，你们是资源知道吧？讨论的是物的事情。在我们这个时代的说话方式的改变中透露了一个时代的真相，人的物化！是不是人的物化？学哲学就这么学的。你如果不相信马克思关于人的物化和异化的理论，你说这个东西我不大相信，太玄妙，未必有根据。</p>
<p>好，你不相信异化这个概念，不相信物化这个概念，你看看生活，你马上知道为什么先前称人事部，现在称人力资源部，你搞资本主义了呀，你搞资本主义一定把人物化呀，。哲学就在这里，你看到了吗？这是我们时代的哲学，。然后我们中国人学西方思想，接受西方哲学，然后把我们自己这个词改了，把这个词的意思改了，道理变成reason！我们犯了很大的错误！中国人讲的道理就不是reason！。</p>
<p>在这里看到中西哲学的差别吗？看到中西思想的差别吗？这种差别是根基上的差别，他就在语言中透露出来了。学哲到这个份上，你就知道哲学是涉及根本的学问。我只是举个例子来说明问题。为什么惠能要把功德两个字拆开来说呢？都可以拆开来说。</p>
<p>现在我们回到文本上来，功德先拆开来，“见性是功，平等是德”。**功就是我们的内心所达到的境界，这个境界叫见性。德就是我们跟别人打交道的方式，它的原则就是平等。**因为见佛性，所以就平等待人。</p>
<p>底下继续说“念念无滞，常见本性，真实妙用，名为功德”。“念念无滞”就是我们有一个念头起来，也许领会到佛性，下一个念头又跟着外境走，又遮蔽了佛性。这念念当中有断裂，有断裂。有时候我们是这么想，是想的很对的，环境一变化，事情一来对那个念头，妄念起来了，都断裂了。要“念念无滞，常见本性”，始终不断的根据佛性来做事情。“真实妙用，名为功德”，“内心谦下是功”。你见佛性了你就谦下，那么“外行于礼”就是跟人打交道是吧？那个“礼”就是打交道的规则。<strong>礼就是规则，法度</strong>。</p>
<p>荀子最讲究礼，儒家后来分了两个系，孟子一系，荀子一系。孟子主张<strong>以德治国</strong>，苟子主张<strong>以礼治国</strong>，<strong>礼</strong>就是人与人打交道的规则，那么“外行于礼”只有一条规则，叫<strong>德</strong>。德从哪里来？<strong>从见性中来</strong>。前者是功，你自见佛性，你就内心谦下，不会贡高我大，不会自高自大，“自性建立万法是功，心体离念是德”，一连串的说明。心之本体叫心体。平时支配我们的心全是假的，就是<strong>业识，小我</strong>，不是心之体。“不离自性是功，应用无染是德”功总是讲内心的境界，德总是说做事情跟人打交道，这两个方面合起来，做事情应用无染。就是从佛性的角度看到事物本来的意义，根据对事物的本来的意义的认识来做事情叫应用。他就不会染着，染着外境，这叫<strong>德</strong>。“若觅功德法身”，福德是色身。我们得福报就是我们的身体在享受，你要受这个福。锦衣玉食的，就是身体在受的福。功德是法身。“若觅功德法身，但依此作，是真功德。若修功德之人，心即不轻”，你说你在学佛，你在修佛，你就是在修功德。你如果是个修功德的人，你怎么好看不起别人呢？怎么好轻视别人呢？真正修功德的人“心即不轻，常行普敬”，普遍的敬重每一个人。假如不是这样，“心常轻人，吾我不断”，把自己看得很重要，这个吾我前面一个吾作动词用，把我当回事就是吾我，吾本来也是我的意思。吾我，前面一个吾就是作动词用了，把我当成个我了，叫吾我自大。</p>
<p>“心常轻人，吾我不断，即自无功，自性虚妄不实，即自无德，为吾我自大”。为什么会这样？因为把自己看得很重，把这个小我看得很重，常轻一切。“善知识，念念无间是功，心行平直是德；自修性是功，自修身是德。”<strong>修性</strong>是<strong>功</strong>，<strong>修身</strong>是<strong>德</strong>。修身什么意思？儒家的意思《大学》第一段先讲三纲领 “大学之道，在明明德，在亲民，在止于至善”。三条纲领讲了之后就讲八条目了。哪八个条目呢？“格物致知，诚意正心，修身，齐家，治国，平天下”。那么儒家讲的修身是指我们的身体吗？不是。修身之身，这个身是指<strong>你与跟你最亲近的人的关系，跟父母、跟兄弟姐妹、跟夫妇夫妻、跟子女，这个关系是最亲近的亲人关系，这叫身</strong>。<strong>修身就是修我们跟亲人的关系</strong>。怎样是合适的？你如果修身能达到，你这个家就齐了，你能齐家才能治理这个国家。治理国家的原则是文化的、精神的原则——教化。因为你行教化了，你才平天下了。中国人按照儒家的政治观念的来说，一个官员一个治理民众的人，治理百姓的人，第一个任务是什么？不是造福一方，第一个任务是教化一方，所以中国人的天下的观念是个<strong>文化的观念</strong>。那么碰到那些没有进入中国文化的少数民族其他民族，我们叫<strong>化外之人</strong>。将来如果化进来也在天下了。中国人没有西方的这种民族国家的观念，是天下的观念。好，那么我们就知道修身是什么意思了，不是修自己个人，这个个别的存在。个别的存在，用英语来说叫individual。这个概念individual，学过英语的朋友知道individual这个词应该翻译成什么？个体，个人。这个概念为中国思想所不能容纳。每一个人都在五伦之中，哪五伦啊？君臣、父子、夫妇、兄弟、朋友是不是五伦？五种伦理关系。一个人不是君便是臣，不是父便是子，不是夫便是妇，不是兄便是弟，不是朋便是友。在这五伦之外，你还是一个个人，这算什么意思呢？有没有这样的个人？没有呀。在五伦之外谈一个individual，在中国思想看来是不可思议的事情。我们只要活在这世界上，一定处在于他人的关系中，这与他人的关系最基本的，无人能逃脱的——五伦。比方说今天说君臣能逃脱了是吧？我们结束了帝制，没有皇帝了，对。</p>
<p>原来意义上的君臣关系真的是没有了，但现代意义上的君臣关系仍然存在。这个君就中华民族。这个臣就是你是这个民族的一个成员，你走到天涯海角你都知道自己是中国人。我们作为民族的个别成员与这个民族的关系，就是今天的所谓臣和君的关系。你也逃脱不了。所以庄子也讲，天下有大戒二：一<strong>命</strong>也，二<strong>义</strong>也。一个命是逃不掉的，无所逃于天地之间，一个叫<strong>命</strong>。还有个叫<strong>义</strong>，大义凛然的义。这个<strong>义</strong>有几个方面？五个方面，君臣，父子、夫妇、兄弟、朋友。你说你把自己，把这五伦关系撤掉，你还有一个individual，没有的！所以这个修身的身并不是individual。这个身不是individual，是我们跟亲人的相互关系。我们要把这关系修好，这叫<strong>修行</strong>。</p>
<p>所以“自修性是功，自修身是德”，什么叫修身？把自己见佛性的境界用到跟最亲近的人的关系上去，这叫<strong>修身</strong>。孟子讲父子有亲，君臣有义，夫妇有别，兄弟有悌，朋友有信，五种基本价值。你达到了叫修身修好了。所以惠能也是这么说的，有儒家思想做基础，把佛学中国化。有儒家和道家两个方面的思想做基础，才完成佛学中国化，中国化先要中国自己有智慧才中国化，“功德须自性内见，不是布施供养之所求也，是以福德与功德别”。明确了，区分<strong>福德</strong>与<strong>功德</strong>。中国大多数佛教的信徒，其实严格意义上就是修福德的人。我们到了寺庙里恭恭敬敬地拜佛，烧香拜佛，许愿。其实就是为了世俗的幸福。那个普陀山，观世音菩萨的道场，每年高考之前那里热闹非凡，凡是孩子要参加高考的，很多人就到普陀山去烧香了，要许愿，如果考中了呢别忘了还愿，求的就是福德。“武帝不识真理，非我祖师有过”。惠能把这个问题回答了，这个回答是非常重要的。我们要知道，佛教讲因果，缘起，就是因缘，连续不断，连接不断，有因必有果。那么修福得福报是真的。叫修福善利强，善利，有这个好处的。那么这个善利会得报的，先报其善，但是不善的业仍然在，恶业并没有消掉，也不是修福能消的，修福有真实的效果、结果，那就得福报，但是恶业没消掉，不善的也仍然在，所谓罪还在，终当报也。不修功德，恶业无法消。人身上都有恶业的，佛教这个道理讲得非常彻底的，所以人要忏悔的。</p>
<p>你这个人做人，几十年做人，没做过任何坏事，在道德上大家一致的认为是个大善人，这个人如果走了的话，他家里的亲人仍然要为他忏悔。为什么？他这一次被抛到世界上来，就表明有恶业的，否则你解脱生死了，你怎么会来的？每个人都有。一个道德上十全十美的人照样要忏悔的，后面有一品叫忏悔品。然后亲人为亡者做佛事帮助他忏悔，帮助他消罪，然后超荐，就这个意思。</p>
<p>所以佛教把这个事情讲得分明了，你比方说这辈子我贫贱是吧？那么我做了许多好事，我们每每说在做功德，这日常语言不准确的，其实是在说做福德，福德以后可能产生一个可能的效果，当世没报下世报了是吧？这辈子贫贱下辈子富贵。富贵归富贵，业没消掉啊，而且未必幸福了。这辈子贫贱的苦，下辈子受富贵的苦，富贵也是一种苦，另一种苦。这种苦的这个性质和程度是当初你贫贱的那一世没料到过的。</p>
<p>比方说马云，富贵吧？苦不苦呢？除非他已经成佛了，我想他也是苦的，他这种苦是我王德峰还没资格受用呢。位高权重之人，甚至政治局常委的高官厚禄，苦不苦呀？苦的很呐。富贵就一定是幸福吗？不，它也是一种苦。这叫<strong>业</strong>没消掉。所以一定要区分<strong>福德</strong>和<strong>功德</strong>。所以我昨天讲六度当中前三度是<strong>福德资粮</strong>。不解决根本问题的。后三种叫<strong>智慧资粮</strong>，消业的。那么要讲到平等，真难，实在难的很。</p>
<p>禅宗告诉我们，任何一个人都有佛性，每个人都有佛性，所以每个人都应当被尊重，但是人与人之间差别真的很大，你周围打交道的人难免会遇到这样的人，笨一点倒也算了还坏，那叫既笨又坏。你每每想到这样的人，心中就一定起了轻视之心。所以我王德峰向来不敢说自己在修行，因为修行的第一步是<strong>普敬</strong>。普遍的敬重每一个人，我就问我自己你做到了吗？你做不到这第一步，后面几个程序几个环节你就别说了，你有多大的境界啊，修佛得到了怎样的这个程度，阶梯，次第，后面怎么样怎么样，别说了！先说第一步，平等，做到吗？真难！当我想到曾经跟我打交道，或者现在还在我周边的某些人，既笨又坏啊，行径恶劣。你一想到他这种行径，你就难免什么？起了轻视之心，这个念头一起来我马上又知道，噢，不对了，还是不对，真的是很难的。</p>
<p>我不知道在这里讲过我的中学同学的故事吗？那个修佛很精进的人呐。改革开放30年当中，他也抓到了千载难逢的历史机遇，挖到了第一桶金，他是上海一家连锁店的老总。那么他就有一幢很好的别墅，从小跟我在一个弄堂里长大，我们叫发小，关系非常好。有一次我就去造访了，为什么呢？我们现在到这个年龄的人经常怀旧，那么怀旧就会想起中学老同学的聚会，那么我就到他家里去商量我们同学聚会的安排。我走到他别墅，四层楼的啊，门口就被他的佣人拦住了。他说他现在此刻正在做功课，你要等他一下，后来我就跟他的佣人讲，你知道我是谁吗？我跟他从小在穿开裆裤的时候一起长大的，就在穿开档裤的时候就是朋友了。我们是老邻居，老同学。好，那个佣人就放我进去了。因为我要看一看他是怎么做功课的。</p>
<p>那个别墅很豪华，在一个地方辟了一个小佛堂，有窗口的，我走进小佛堂的窗口往里看，他正在大拜——五体投地的拜。那个大热天的空调也不开。我看他拜得大汗淋漓，我心里不禁起了敬佩之心，那么虔诚。他时间没到还要拜，到了时间才能站起来，但他也知道我来了，但我必须等他，他就拜，终于时间到了他站起来了。跟我说的第一句话就是某人的是非，这个人怎么不行。我马上就跟他说了一句话，你刚才白拜了，你刚才这个叫体育锻炼。因为我跟他从小就是朋友嘛，我们说话没忌讳的，我直截了当，我说你刚才叫体育锻炼，白拜了。</p>
<p>他说你这什么意思？我说我们为什么要拜佛？并不是我们所拜的佛像是神灵，这个佛像要么泥土造的，要么木头造的，要么石头造的，要么某种金属制造的，他只是个偶像，那么我们为他拜干嘛呢？而且一定要五体投地，拜的时候头要碰地板干嘛？就<strong>把自己这小我彻底放下</strong>，放到地上去，就是为了这件事情。如果每天拜的话，就是每天提醒自己放下<strong>小我</strong>，一直放到地面上去，就这些事情。</p>
<p>你刚才说别人是非嘛，白拜了。他脸有点红了，他说你怎么知道的？我说你读过《坛经》吗？他说没读过。我说我建议你以后读了《坛经》再拜。我跟他之间说话非常直率，小时候还彼此指责，彼此对骂，但是友谊蛮深的。所以我就是直截了当跟他讲这个道理，所以要做到不轻视他人真难。</p>
<p>你要不轻视地位比你低的人，其实比较容易，因为你有优越感，你有种居高临下的感觉，好像有一个怜悯之心。你要不轻视比你地位高的人更难，细想想是不是这样？温家宝到你企业来参观了，当时他是总理，你认真吧？非常认真。准备好了所有接待的仪式，整个过程设计的非常精心的，为什么？你要恭恭敬敬的接待这个总理呐，他是总理来了。你对他全套的接待过程都是恭敬有礼，你真尊重他们吗？未必。</p>
<p>你一面在恭恭敬敬的接待他，心里一面在想，你看你这个总理做到现在，国家经济被你搞成这个样子。你尊重他只是为了什么？他是政府总理，你希望从政府总理那里得到一个对你企业的肯定性的评价。无非是为了这件事。你真尊重他吗？未必。</p>
<p>要去尊重那个地位比我们高的人，每每更难。我们心里有不服气呢。如果我做总理做的会比你好呢？事情就这样。所以普敬是非常难的事情。我们细想想啊，我一直认为要么不修佛，修佛就要彻底，彻底就是从第一个环节开始——<strong>平等</strong>，就从这里开始。就像我昨天讲的是吧？有的人犯下了极大的过错，不光是道德上不能认同他，法律上还要制裁他，把它关起来。以免他继续危害社会，要判他的刑。面对这样的人，你仍不可轻视他。因为他佛性在的，<strong>永不轻视任何人</strong>，这禅宗的原则。所以，惠能在这里对功德做了解释，最重要的八个字，“见性是功，平等是德。”</p>
<p>拿起手中的手杖打他一下，打完了以后问他你痛还是不痛？神会回答的很有意思“亦痛亦不痛”，也痛也不痛，就是亦痛亦不痛，玩这个逻辑技巧了。惠能马上来说，“我也亦见亦不见”。那么这下神会就急了，因为他是真心想问的，你见性还是不见性，如果你见了，告诉我如何见性。这是个真切的问题。但是你那个技巧一玩，亦痛亦不痛，他来了句亦见亦不见，他终于露出马脚了。</p>
<p>这个神会底下问了一句“如何是亦见亦不见呢？”，这就真心露出来了。你要问。惠能就跟他讲，你刚才说亦痛亦不痛，是时间上的先后，就先前痛后来不痛。其实亦痛亦不痛应该是什么意思呢？你说你不痛是假的，因为我打了你，你是血肉之躯，你说你不痛是假的，所以痛，但是心中不起恚恨，你不恨我。我的棒打了你，你肉体是痛的，你说痛，然后心里没恨我，这叫不痛。然后我那个亦见亦不见什么意思呢？<strong>常见自己之过错，不见他人之是非，这叫亦见亦不见</strong>。讲到这里神会服帖了，再拜，愿做他的徒弟，要皈依他。这一则对话蛮有意思的。你用了很多时间积攒了一大笔钱买了高级轿车，比方说奔驰，你才开了三天，被人偷走了。你痛不痛？肯定痛。你说不痛是假的，因为这钱你不是偷来的是吧？你积攒了很久，终于买下了你梦寐以求的那一辆高级轿车，现在被人偷了，才开了三天。你肯定痛。如果你同时愤怒到什么程度？希望真想抓住窃车贼把他打死，这叫心里痛了！双重损失，前者是<strong>物质的损失</strong>，后者是<strong>精神的损失</strong>。应该想起谁呀？惠能说的亦痛亦不痛，什么意思？肉体痛，心中不恨，这就对了。我真不希望你把我的车拿掉是吧？但是你既然拿掉了，我也不恨你，就算我为你买的，你需要就可以了。要达到这一点难。一个人做了坏事，这个坏事伤害了你是吧？你就把这个<strong>坏事</strong>变成了这个人叫<strong>坏人</strong>，这一转是转不过去的，人做的事情有是非的，但是人没有是非。请注意。说不见他人之是非，他人所做的事有是非，他做了非议的事，你别把非的标签贴到他头上，这个叫<strong>坏人</strong>。这个标签是不能贴上去的，这是一个非常重要的认识。</p>
<p>我们永远不要把好人坏人这样的标签贴到别人头上去。别人做事情一定有好坏的区别，有善恶的区别，有是非的区别，这真的，这只那个事。他做了坏事是他得了病，你帮助他就是帮助他治病，而不是把坏人的标签贴到他头上。所以惠能那句话就能理解了，<strong>常见自己的过错不见他人的是非</strong>，他人无是非。</p>
<p>一个人做了那么多坏事，被关起来判刑了，它只是前念迷叫凡夫，他会悟的，一旦悟了他就是佛。你怎么好把坏人的标签贴到他身上，贴不上去。很难！我们自然而然的把一个做坏事的人列为坏人，他做了坏事不等于他是坏人，人没有坏，他佛心在。但是我们不可能这么想，做坏事的就是坏人。</p>
<p>那么这个道理其实是不通的哦，做坏事的为什么是坏人？他只是有病，好像你是医生是吧？遇到了病人了。这个病人生的病，根据你几十年的临床经验都无法处理，那你很认真是吧？国家查了各种医学文献，晚上都加班在家里，把医学文献统统翻过一遍以后，西方的医案当中也没这个先例，你真不知道该怎么对付这个病是吧？你终于愤怒了，跟这患者说你怎么生这么难弄的病，你再这样生我也生个给你看看。可以吗？不可以。你是医生啊，你就是帮助人治病的呀。那个人做了坏事就是凡夫迷了嘛，你帮他治这个迷的病，而不是说你再这样我也这样。他能飞我也飞，医生跟病人说你生这病我也生一个给你看，没道理。</p>
<p>想明白这一点，我们该怎么跟人打交道，就在根子上解决了一个问题，永不轻视任何人。我们要纠正人家做的错事，但是不要把做错事的人看成是坏人。你们如果真心的没这么看，你跟他打交道就是合适的，这叫<strong>度人</strong>。</p>
<p>什么叫度人啊？世界上没有救世主，别人也救不了我，也救不了别人，但是彼此可以度的。</p>
<p>怎么个度法？我举个例子。你是企业家，你是企业的第一领导者，第一把手。那么企业某员工犯了过错，为了自己个人的一点私利，损害了企业的利益。这个事情要纠正吗？要纠正。如果大家都这么做，企业就别生存了，对不对？错的、坏的，事情坏事情错，纠正，你怎么纠正？你把他找到你办公室来，你对他的态度是什么？你别以为把一个坏人找来了，要训斥他。他是佛你知道嘛？尚未觉悟的佛。就这件事。你真是非常的尊重他的，这是内心的。然后你告诉他这件事为什么是错的。为什么是错的？而且必须纠正，但是你仍然十分的尊重他，不是假的，不是虚假的。在你面前听你说佛法的就是佛，你现在跟他讲这件事做错了是吧？就是在跟他说佛法你知道吧？你在跟谁说佛法？跟佛，你怎么个说法呢？善知识，他就是善知识呀。</p>
<p>你如果这样的跟他打交道，这样的把这个道理跟他讲清楚，然后你说按照规则你要受到惩罚，你真要受到惩罚，那么这个惩罚会影响你的生活的话，我会注意到这一点，我会帮助你的，但这件事情必须这么做，你仍然是我们企业的员工，也会成为一个非常好的员工。你就这样跟他打交道，你叫度他，也在度自己，把仇视他人的心消解掉，也在度自己——度人即度己。怎么个度法？就在与他人打交道的方式中度的，<strong>打交道的方式就是度</strong>。这是我把我对惠能这个“见性是功，平等是德”的理解说了一遍。我们读《坛经》就是要把生活读进去，然后再领出来，然后成为我们自己的生命实践，就是这部经了。所以疑问品回答第一个问题，很关键的问题。什么叫功德？回答这个关键问题，修佛就是为了功德嘛。</p>
<p>既然读过《坛经》了，从此往后我们不断的要注意到是否能够<strong>普敬</strong>，说起来容易，做起来难。就像我昨天跟这位学友讨论，就是旧习难改。习惯了，向来如此。要根本上改那叫转呐，“转识成智”，这个转难吗？很难。第一步就从<strong>平等</strong>入手，就从<strong>平等</strong>入手。</p>
<p>那么多佛教的宗派，那么多修行的法门，中国人最有意思的地方是把释迦摩尼那些繁琐的说法要化繁为简。这是中国人最了不起的贡献之一，就佛学中国化，要化繁为简。种种修行的法门，中国人最后把它概括为三个门：<strong>戒、定、慧</strong>。还有更进一步的概括，天台宗，两扇门：<strong>止、观</strong>，叫观门，止门。那么我们先说普遍被接受的戒定慧三个字，一切修行的佛法不出戒定慧三种，离戒定慧没有佛法，佛法之间的差别再多，最后都可以概括到<strong>戒、定、慧</strong>。</p>
<p>那么禅宗同样要讲戒定慧，那么禅宗讲的戒是戒轻视他人，这就是禅宗讲的戒。不是成荤，戒酒，戒偷盗，当然最好不要偷盗，但这些不在根本上解决问题，在根本上解决问题是平等的对待任何人，<strong>普遍的敬重每一个人，这是最根本的戒</strong>。</p>
<p>所以疑问品的主题是什么？第一个主题就是戒，讲了戒以后接下去要讲定和慧，所以第四品是定慧品。所以，如果我们问惠能如何讲戒定慧？在疑问品当中讲了<strong>戒</strong>。在定慧品里面讲<strong>定、慧</strong>。</p>
<p>我们看疑问品最后的一个《无相颂》，我们先看第一句就知道了。78页，78页来了一个颂。</p>
<p>第一句 “心平何劳持戒”，禅宗讲的戒是<strong>心平</strong>，就是普敬一切。<strong>平等</strong>是<strong>德</strong>，这就是禅宗讲的<strong>戒</strong>。<strong>定</strong>与<strong>慧</strong>放到第四品里讲。好，我们翻回来，把这段看完了。“念念无间是功，心行平直是德，自修性是功，自修身是德。善知识！功德须自性内见，不是布施供养之所求也，是以福德与功德别。武帝不识真理，非我祖师有过。”</p>
<p>第一个问题回答了。回答了韦刺史的第一个问题，就是说了禅宗讲的成是什么了。那么疑问品的第二个问题，就是当时中国有许多人学佛了，佛教在两汉之际进入中国，在西汉末年东汉初年，然后经过好几个世代开始在中国普及起来。当时净土宗蛮盛行的，就念佛往生西方。所以我们看第70页，第二个问题提出来了，韦刺史又问了“弟子常见僧俗，念阿弥陀佛，愿生西方。”念阿弥陀佛，愿生西方修的是净土宗。然后他就要问了“请和尚说，得生彼否？愿为破疑。”我们真能到西方净土那里去吗？希望你和尚跟我讲一讲，这就是第二个问题。</p>
<p>我们刚才看了这个疑问品，这个惠能对韦刺史的第一个问题的回答，就如何是功德。回答就是“见性是功，平等是德。”区分了<strong>功德</strong>与<strong>福德</strong>。后来中国人的基本态度是两面都要，就<strong>福慧双修</strong>，福报也要的，修福；那么修慧，修慧是一个功德的事情，修慧不是脱离现实生活的修慧，智慧就是实践的，所以<strong>福慧双修</strong>。</p>
<p>好，我们看第二个问题来了，就是我们能否真的到西方净土呢？那么多人修净土宗，天天念“阿弥陀佛”，要往生西方。惠能回答了，在70页上，“使君善听”，你好好听，“惠能与说。世尊，”，就是佛陀，“在舍卫城中，说西方引化”，佛释迦摩尼是说了西方的，“经文分明，去此不远。”西方净土离开这里不远，如果我们要<strong>相说</strong>的话，就是着相的，用名相来说，叫<strong>相说</strong>，那么就变成空间的距离了“落论相说里数”，那么叫十万八千里了。这把西方净土理解为空间的远方，相隔十万八千里，这叫<strong>相说</strong>，着了相的说法。其实呢？十万八千是 “身中十悲八邪，便是说远”，远就是远在我们每个人身上有<strong>十恶八邪</strong>，所以我们就跟西方净土隔开了，所以要把十万八千里理解为什么？我们身中的<strong>十恶八邪</strong>，然后如果我们说西方净土很远，空间的远方，那叫下根之人。说近那叫<strong>上智</strong>。</p>
<p>底下又说“人有两种，法无两般”，佛法只是一种，人有两种。区分在哪里？<strong>迷</strong>和<strong>悟</strong>有差别。“见有迟疾”，有的人长久的见不了佛性，有的人一下子就见了。“迷人念佛求生于彼，悟人自净其心”。迷人天天念“阿弥陀佛”，心中想的是到西方净土去，悟的人呢才知道<strong>自净其心</strong>才是根本。</p>
<p>“所以佛言：‘随其心净及佛土净’。”这是一个非常基本的道理。什么道理呢？我们曾经讲，如果我们把这世界看成是尘世，充满了灰尘。他就不干净了。尘世与净土这个区别，两者对立了。</p>
<p>那么要请问这个世界上的灰尘是指什么呢？<strong>烦恼</strong>。那么烦恼从哪里来呢？从<strong>心</strong>里生出来。你如果觉得这个世界上到处都是烦恼，那叫<strong>尘世</strong>，心里出来的，这个世界本身无所谓什么干净和肮脏。只是你心中生出烦恼，这世界到处都是烦恼，到处都是灰尘。假如你转了一转，这个世界非常美好，问题的要点在这里。</p>
<p>我们看这个世界到处是苦恼，到处是麻烦，心的问题。如果我们的心换一种用法，生出的是<strong>智慧</strong>，这个世界非常美好。所以<strong>净土</strong>和<strong>尘世</strong>这个区分来自心，这一点一定是最根本的道理。</p>
<p>那么有时候我们比方说在现实世界中，我们觉得到处都是苦恼的东西，让我们心烦意乱的事情，然后听音乐了，假如你一个人静静的在那里听非常好的音乐，你会觉得这世界非常美好，人生多美。然后音乐结束了，又回到现实世界中了。于是我们就觉得伟大的艺术作品只是暂时的麻醉了我们。我们终得回到现实世界中来。那么，其实这个事情正说明什么呢？伟大的音乐作品让我们的心在这段时间内发生了改变。我们看到世界美好的东西，从艺术作品里面走出来，又进入了我们的心所生出的种种烦恼的事情。假如我们在艺术作品的欣赏中所感受的生活，就是我们在日常生活中的心的话，这不就是净士吗？你衣衫褴楼，你是贫寒之人，不等于这世界不美好。你腰缠万贯，豪华的别墅居住在里边，它里边充满了烦恼。什么叫<strong>尘世</strong>和<strong>净土</strong>？<strong>境由心生</strong>啊。</p>
<p>你的<strong>心</strong>是净的，那叫蓬荜生辉。你的心不断生烦恼的，宫殿如同监狱。所以释迦摩尼那句话好，“随其心境即佛土净”。</p>
<p>“使君东方人”，你韦刺史跟我们大家一样，中国人在印度的东面。只要你心净即无罪，“但心净即无罪”。“虽西方人”，就是说印度人，这时讲的西方就印度。“心不净，亦有愆”，<strong>愆</strong>就是<strong>过错</strong>。</p>
<p>“东方人造罪”，造罪，他怎么办？“念佛求生西方”。那么如果西方人造罪呢，“念佛求生何国”呢？所以它不是一个空间的问题。</p>
<p>“凡愚不了自性，不识身中净土”，不知道净土就取决于自己。“愿东愿西”悟了的人呢？“悟人在处一般”，到哪里都一样。</p>
<p>于是又来一句话，“随所住处恒安乐”。学佛的人一定要记得这句话“随所住处恒安乐”。不管你到哪里，环境如何的有差别，全看你的心。你心净，那么到哪里都是安乐。我们的家在哪里？在我们的心里。心安是家，无论你走到哪里。从一个好的环境，通常我们说的好和坏，好的环境到了一个不好的环境，我们大受影响，其实家在哪里呢？在你心里。</p>
<p>“使君心地但无不善，西方去此不遥”，离开这里并不远。</p>
<p>“若怀不善之心，念佛往生难到。今劝善知识先除十恶，即行十万，后除八邪”又过了八千里，都是一种通俗的形象的说法。</p>
<p>我们身上有哪十恶呢？我们看注释，它列出来很清楚。其实就是<strong>身业，口业，意业</strong>，一共合起来十种恶。<strong>杀生、偷盗、邪淫</strong>叫什么？<strong>身业</strong>。</p>
<p><strong>妄语，两舌，恶口，绮语</strong>，这叫四种<strong>口业</strong>。<strong>妄语</strong>就是说假话骗人，<strong>两舌</strong>就是搬弄是非。恶口就是骂别人，恶语相加。<strong>绮语</strong>就是乱人心智的那些杂秽语等等。按照佛教的绮话的说法，我看许多宋词都是<strong>绮语</strong>，叫男女欢爱。所以《红楼梦》里的惜春，一个非常重要的特点是她不喜欢诗词歌赋，不在文学里。文学要把人情呐，委婉曲折地抒发出来，表现出来，爱爱、恨恨、思念等等。那么在佛家的标准这些全叫<strong>绮语</strong>。柳永绮语写的最多。那么都叫<strong>口业</strong>。<strong>口业</strong>有四种。</p>
<p>然后还有三种<strong>意业</strong>，佛教要求很高，你没做事情你动了念头，也就是业了，叫<strong>意业</strong>。<strong>意业</strong>是三种：<strong>贪、嗔、痴</strong>。</p>
<p>三种<strong>身业</strong>，四种<strong>口业</strong>，三种<strong>意业</strong>，合起来叫<strong>十恶</strong>。八邪底下列了，就与八正道相反。邪见相对于正见，邪思维相对于正思维，邪语相对于正语，邪业相对于正业，邪命相对于正命，邪方便等等，邪念，邪定一共<strong>八邪</strong>。</p>
<p>然后惠能就说我们身上的十恶八邪才是我们跟西方净土的距离，我们除了十恶便行了十万，除了八邪就过了八千里。</p>
<p>“念念见性”，我们回到70页，“念念见性，常行平直，到如弹指。”弹指之间我们就到了西方净土，“便睹弥陀”，弥陀就是阿弥陀佛。因为释迎摩尼说佛法也讲，西方净土谁等着我们？三圣。第一圣就是阿弥陀佛，还有一个观世音菩萨，还有一个大势至菩萨，三者合起来叫西方三圣。为主的就是阿弥陀佛。所以弹指之间就到了西方净土，就能见到阿弥陀佛。</p>
<p>好，我们再翻过来看，第73页，“使君”，就是你韦使君啊。</p>
<p>“但行十善，何须更愿往生？不断十恶之心，何佛即来迎请？”哪有阿弥陀佛来迎请你呢？</p>
<p>“若悟无生顿法”，这个要说明一下净土宗。净土宗修行的目标非常简单，就是往生净土，怎么会往生净土？你能够悟到我们本无生，佛教就是要解脱生死嘛，无生即无死。我们以为我们活着，其实我们没活着，即无生。向来比较了各种宗派，就有这样的话说了，叫净土<strong>方便</strong>，就是<strong>方便法门</strong>。密宗<strong>殊胜</strong>，密宗修行中它有特别的优点，叫密宗<strong>殊胜</strong>，有特别的优势。</p>
<p>净土宗呢叫<strong>方便</strong>。那么修净土宗的人的一个基本信念是按照净土宗的说法的，就是我们没有别的什么能耐，我们就坚持念“阿弥陀佛”，几十年如一日，这样就可以仰仗佛力，横超三界，往生西方，这时候并没有悟，到了西方那里条件比较好，这时候在那里听佛说法，这叫花开见佛，悟无生，终于明白了，本无生也就本无死。不是说当下能悟了，而是净上宗在今生今世让我们修行，就是通过不断的念佛就获得佛力，依靠佛力我们就横超三界，这是净士宗的说法。</p>
<p>那么密宗就是修神通，所以他的目标是“即身成佛”，有了神通了。那么禅宗是 “即心即佛”。区别就在这里。</p>
<p>惠能讲禅宗，就是强调这个心，要断了<strong>十恶</strong>之心，“西方只在刹那”之间。然后惠能底下说你们想看吗？想要看一看西方净土吗？“惠能与诸人移西方与刹那间，目前便见，各愿见否？”</p>
<p>大家都踊跃的说好，“众皆顶礼云：‘若此处见，何须更愿往生？愿和尚慈悲，便现西方，普令得见’。”</p>
<p>好，我们看惠能怎么把西方移过来给我们看。“大众！世人自色身是城”，我们想一想，我们每个人都有肉体，不叫色身嘛？你要把肉体想成是一个城堡，城堡就有门呀。一共有几扇门？六扇门。前面五扇是眼、耳、鼻、舌，其实还有一个身，眼耳鼻舌其实应该加一个身，眼耳鼻舌身是门，向外通的吧？接触外部事物，叫外有五门，叫前五识。那么内有意门，第六扇门。我昨天讲是吧，通过第六识——意识，把前面的五种感觉材料做出一个外部事物来，事物就叫<strong>法</strong>，所以加起来就六门。六门的能力叫六根，眼耳鼻舌身意也是六根，对应外部的<strong>六尘</strong>，色声香味触法。我们中国人不讲六根清净嘛，六根清净的说法就来自佛教。假如六根清净我们不就是法身了嘛。那么如何可能六根清净呢？不是六根自己能清净，也不是六根自己不清净，全是心造成的噢。你说眼耳鼻舌身意有什么过错呢？我有眼情就得看东西吧，我有耳朵就得听声音，它没有什么过错，我有一个胃就会饥饿，因为饥饿我就有食欲。食欲是坏的吗？不好不坏。倒是如果你没食欲你要慌了，你不想吃东西了，还了得，出大问题了。就欲望本身没过错，六根无所谓清净不清净。有六根就有六种需要，六根不清净是谁造成的？<strong>心</strong>。</p>
<p>所以底下说 “心是地”，城堡里的地。地上居住的是<strong>佛性</strong>。那叫王，“王居心地上，性在王在，性去王无”，王是主宰，佛性是主宰，所以叫王。那么佛性在哪里呢？在我们的心上面，我们要通过自己的心才能见佛性的。假如我们的心见了佛性，我们的六根就是<strong>清净</strong>。</p>
<p>“性在身心存，性去身心坏”。如果我们不性，不在我们的心上，身心都坏了。身心都坏了，正是这样的。我们的5种感官感觉他都指向不好的东西。</p>
<p>这个人的感觉跟动物的感觉区分在哪里？</p>
<p>人的耳朵是能够辨别音律的，能听得懂音乐，人的眼睛能够欣赏美丽的风景。这叫感觉的人性。按照佛教来说叫感觉的佛性。假如佛性不存在，或者你的心不见自己的佛性。</p>
<p>你的五官感觉，都是返回到动物的感觉。你不能欣赏音乐，你也不能欣赏绘画，美丽的风景。你的饮食也不是人类的饮食，那叫<strong>茹毛饮血</strong>。</p>
<p>这个道理惠能没直接讲，我来发挥。什么叫性去身心坏，坏在哪里？音乐也听不懂了，无法欣赏，无法欣赏使人之间美好的东西。男女之间的爱情也是人世间关好的东西，佛性一去不叫爱情，叫单纯的性欲。如男人到妓院里走，那就身心坏了。那么就在污浊的尘世折腾，所以惠能说：“佛向性中作，莫向身外求。自性迷即是众生，自性觉即是佛”。</p>
<p>好，那么底下就讲西方三圣了，<strong>慈悲</strong>，我们心中有慈悲，我们就是<strong>观音</strong>了。<strong>喜舍</strong>，我们总是乐于帮助别人，那叫<strong>大势至菩萨</strong>。<strong>能净</strong>，我们自性清净的话，那叫<strong>释迦摩尼</strong>。即西方三圣也不能把本师释迦摩尼略掉不可以吧？所以释迦要提吧？“能净即释迦”，佛陀啊，最后提到西方三圣当中最主要的一—弥陀，“平直是弥陀”，我们不要把观世音菩萨，大势至菩萨，释迦摩尼佛或者阿弥陀佛，都看成是神，等待我们去找到他们，其实他们就在你身上，是这个意思。</p>
<p>你是观音，你是势至菩萨，你是释迦摩尼佛，你是阿弥陀佛，为什么是？因为你<strong>慈悲</strong>，因为你<strong>喜舍</strong>，因为你<strong>能净</strong>，因为你<strong>平直</strong>。所以佛教其实是无神论者，佛教是无神论的。</p>
<p>基督教、伊斯兰教才是有神的，基督教有上帝，伊斯兰教有真主。那么我们人为什么总在尘世之中折腾呢？总不能在净土呢？“人我是须弥”，人我别那就是<strong>须弥山</strong>。“邪心是海水，烦恼是波浪，毒害是恶龙，虚妄是鬼神，尘劳是鱼鳖，贪嗔是地狱，愚痴是畜生。”佛教讲六道轮回。</p>
<p>那么这个轮回是讲给老百姓听，讲给这些凡夫众生听，引起我们的恐惧警惕，不要轮回到什么？不能落到什么地狱道、恶鬼道、畜生道。其实，我们的日常生活不断地在<strong>六道轮回</strong>。昨天还觉得自己活得那么好，叫天堂，今天就觉得进入地狱了，我们一直在轮回，其实全是我们的<strong>心</strong>。</p>
<p>有人开玩笑说，喝酒的过程恰好也是六道轮回。对，喝到最开心的时候叫心甜意洽，那是叫天堂，然后继续喝。然后那种妄语，恶口全来了，然后得罪了人，他也醉的糊涂了，然后痛苦万分，进入地狱，就叫轮回。</p>
<p>所以惠能用了许多形象的话，将我们的人我别、我们的邪心、我们的烦恼、我们的毒害、我们的虚妄、我们的尘劳，我们的贪、嗔、我们的愚、痴。</p>
<p>“善知识！常行十善，变十恶为十善，天堂便至，除人我，须弥倒。去邪心，海水竭；烦恼无，波浪灭；毒害忘，鱼龙绝。”觉悟到自性如来，放大光明，外照六门清净，什么叫六门清净？六根清净？六门又称为什么？六根。六根清净，能破六欲诸天。你看注释第13条，什么叫三界？注释第13条，摆出来了，佛教<strong>有欲界、色界、无色界</strong>，这种三界说法。那么我们现实世界都属于<strong>欲界</strong>，欲界里边有六个道，六道轮回都是在欲界中的，欲界往上走叫<strong>色界</strong>。</p>
<p>人体的肉体欲望被消解掉，然后欣赏美好的东西，听美好的音乐叫<strong>色界</strong>，已经是精神性的东西，但还有感性的东西，音乐绘面这叫<strong>色界</strong>，到<strong>无色界</strong>连这个都没了，<strong>纯粹精神</strong>。所以这叫三界。然后，哪怕是无色界你还是在轮回里边生生死死的。所以要恒超这三界，一界有六重天。底下这些说法我们自己可以看，说的比较的繁琐，其实大致知道就可以。</p>
<p>“能破六欲诸天”，我们回到正文，“自性内照，三毒即除”，三毒就是<strong>贪、嗔、痴</strong>，“地狱等罪，一时消灭。内外明彻，不异西方。不作此修，如何到彼？”世界本来美好，但我们却发现他是尘世，充满了烦恼，<strong>全是因为我们的心有那么多，有人我，有邪心、有烦恼、有毒害、有虚妄、有尘劳、有贪嗔、有愚痴</strong>，这一切都除了，世界就是美好的，就是<strong>净土</strong>，当下叫<strong>娑婆世界</strong>，我们的心一变，就是<strong>西方净土</strong>。</p>
<p>“大众闻说，了然见性。悉皆礼拜，俱叹善哉！然后，一起念到，唱言：‘普愿法界众生，闻者一时悟解。’”</p>
<p>这是疑问品对第二个问题的回答，西方净土在哪里？如何到达？就在我们心上。随其心净，即佛上净。就在我们心上。</p>
<p>然后疑问品最后第三个问题，不是提问，而是惠能说了。说什么？在家修行。天下人都出家了还了得，人类社会马上就停下来了，大家不再繁衍后代了吧。所以对大多数人来我们都应该是在家修行。所以惠能就要讲在家修行的道理了。他说：“善知识，若欲修行，在家亦得，不由在寺。”并不一定要到寺庙里去出家，“在家能行，如东方人心善；在寺不修，就如西方人心恶。”现在在家修行的人不少的，在寺不修的人很多，是披上了袈裳了，但他们并没有修。所以现在有人的判断，佛教又进入了这样一个阶段，就是佛教在中国越来越成为居士的佛教。对，你要皈依三宝。第三宝叫<strong>僧宝</strong>，你都找不到。所以居士将来在中国佛教界将会越来越重要，因为他们认真修行了。佛教在中国的未来一定会发生变革，这是肯定的。当然这个变革是怎么个变法，跟执政党有直接的关系，我就不能多说，说了政治上不正确。现在各地的寺庙的方丈最后的任命权是谁？政府，宗教民众委。一个修为很好的和尚未必做得了方丈，这是普遍的事实。所以那些做方丈的和尚心里很明白，不能没有政府这个靠山。那么当然这样太平也就太平了。其实我们最不需要防的是佛教，佛教你让他腐败他就好了。最要防的是基督教、伊斯兰教。基督教叫背后西方势力，伊斯兰教叫什么民众矛盾。佛教其实不应该怕，其实佛教本意就是跟政治要脱离的。我们读到《坛经》护法品这篇就清楚了。朝廷皇帝带着圣子来，要请惠能到北面去，惠能就讲身体不好，托疾，就托自己身上有疾病，辞谢了朝廷的邀请，这个是一条原则。那叫<strong>法王不让人王</strong>。惠能是法王，皇帝是人王。法王不认可，我跟你分开，佛教的原则。所以这里我就有点感慨了，惠能说的多对 “在家能行，如东方人心善：在寺不修，如西方人心恶。”，你已经在寺庙里修了，条件很好，你偏偏不修。“但心清净，即是自性西方。”既然惠能提出来在家修行，那么韦刺史就问了：“在家如何修行？愿为教授！”怎么修？在寺庙怎么修规矩都清楚。第一要守戒，你如果是比丘戒，那是戒很多。比丘尼的戒比比丘戒更多，我们普通的居士们就受五戒可以了。比丘尼要守具足戒，那么规矩也多。你怎么个修就在寺庙里好好修。在家如何修？又没有出家，还承担着对家族的责任。父子兄弟姐妹，夫妇，有儿有女。惠能就来了一个颂，用这个无相颂，把在家修行的十个要点，十个方面都说出来了。在家修行哪十个方面我们就看这个颂。</p>
<p>第一，“心平何劳持戒”，就讲了一个平等的原则，在家修行第一步，要做到的事情—<strong>普敬</strong>。<strong>见性是功，平等是德。</strong></p>
<p>第二个是 “行直”。行直是什么？叫<strong>直心直行</strong>。行直就是这个意思。什么叫直心直行呢？就像《维摩诘经》里面讲的 “直心是净土，直心是道场”。什么叫直心呢？我们不要字面上简单理解，就是心直口快，说话直率，不是这个意思。直心是就做事情心起来没算完，一个小孩掉到井里去了，你一看到如此的情景，儒家讲，孟子讲什么叫直心呢？我们不要字面上简单理解，就是心直口快，说话直率，不是这个意思。直心是就做事情心起来没算完，一个小孩掉到井里去了，你一看到如此的情景，儒家讲，孟子讲怵惕侧隐之心，油然而生。<strong>怵惕就是惊恐，侧隐就是同情</strong>。一个小孩掉到井里去了，你看到了会不会惊恐？一定惊恐。会不会同情？一定同情。这个心念一起来你就去救他，你千万别转弯，一转叫转念，就想一想我去救他会给我带来什么样的后果，是好的结果还是不好的结果开始想，这样一想叫转念。救还是不救？儒家，宋儒就讲<strong>初念</strong>是什么？</p>
<p>“初念是圣贤，转念是禽兽”，千万不能转。儒家讲这个道理，宋儒讲这个道理，其实就是先前有了禅宗，就叫“直心是道场，直心是净土”。</p>
<p>好多年前我们中国人都知道一件事的，就广东佛山市小悦悦倒在血泊中。18个路人经过了，都看到了，都想了一想救还是不救，结果都决定不救。</p>
<p>18个路人经过，后来还是谁救的？一个老太太，普通的老太太，很贫穷的老太太，把小悦悦抱到医院里去了，已经耽误了抢救的时间。在医院里还挣扎了差不多一天的时间，第二天才走的。</p>
<p>这个消息传过来，我听到了报道。第一个反应，广东佛山这个地方在那个时候不是人的世界。佛性是真正的人性，他们都转念了，18个路人都转念了。佛教讲，尤其是禅宗讲<strong>心、佛、众生</strong>三无差别。</p>
<p>什么意思呢？我打个比方，假如你一个人静静的在你的书房里看书，突然你的左面的耳朵痒了，你的手就伸上去挠了一下，自然得很吧？非常自然，不假思索。并没有发生这样一个过程，耳朵痒了，自己没办法解决问题，于是向手提出了请求，那么手就考虑了一下帮还是不帮？然后最后决定帮，上去挠了一下，有这种事情吗？没有。当然在生物学当中可以得到解释，耳朵是一种器官，手是另一种器官，这两种器官差别大不大？非常大。</p>
<p>那么耳朵这种器官出了问题，他自己解决不了问题了，要用另外一个器官来帮助他，叫手上去挠了一下，怎么会做到这一点呢？把两个不同的器官，一个叫耳朵，一个叫手，连为一体的是<strong>神经系统</strong>。佛教讲人类社会，众生之间差别大不大？就像耳朵和手的差别一样大，但是把众生连为一体的是<strong>佛性</strong>。佛性人人具备，人心一起来，本性一起来就按照佛性做事情，<strong>心、佛、众生</strong>三无差别，就这个意思。</p>
<p>所以叫“直心是净土，直心是道场。“禅宗讲的直心就是儒家讲的<strong>初念</strong>。<strong>初念</strong>发动你就去做，你不要转，更不要三思而行，三思而行完蛋了。当然在今天的中国这件事情变成很困难的事情。地球上有其他的民族，如果知道有一个民族叫中华民族，他在他的电视台上公开讨论一个问题，讨论一个老人倒在地上该不该扶？他们一定会非常惊讶，这难道是个问题吗？</p>
<p>但在今日中国社会中可真是个问题，还非常现实。包括我王德峰在内也想过，如果我遇到了我正在想，扶还是不扶呢？其实它本不是个问题。为什么它本不是个问题，<strong>心、佛、众生</strong>三无差别。一个素未平生的老人倒在地上，你走过来肯定把他扶起来了，还有什么问题呢？在中国倒要考虑了，而且还在电视台上讨论的。你看这个社会的病症到如此的地步。于是就有人，有朋友问我，你说了这个问题，我问你怎么解决？我说没有别的解决的办法，我们依靠法律先要认定，我不是把他弄倒的人，我不是肇事者。据说要拿起手机先把这个场景先拍好，边上还有证据，然后我们再去扶吧。这一切都不解决问题。关键是倒下的老人，你扶了，他说是你弄的。这很可怕。这样一个老人的心出了大问题了，你怎么办？你的心还是佛性主宰的。你面对一个看不到不幸的心，你怎么办？我说这一个办法，你还是去扶他。那个朋友就说了，这怎么可以呢？我说没办法。这个恶因恶果的链条总要有一个人去把它断掉，是没有别的办法。你去把恶因恶果的链条中断了，是通过你中断它，你会付出代价，那叫<strong>舍身取义</strong>，别无他法。一个民族的病到了这个程度了，没有别的办法，<strong>舍身取义</strong>吧，这个是要大无畏的，否则不是人的世界。</p>
<p>我们就活在动物世界里，还比动物世界更糟糕。因为动物的吃饱了也就算了，你到非洲去会看到狮子和羚羊一起散步，你惊讶了，怎么可能？很简单，此刻狮子饱了，它吃不下来就跟羚羊一起散步，人不是的，明明吃饱了，还得把多下来的羚羊统统抓起来，放到仓库里，还唯恐其不够多，就这样。</p>
<p>所以人最可爱，也最可恶，可恶会到禽兽不如。当然这个民族遇到了这样一个阶段，这样一个病症如此深的阶段，希望也就来了。中国人的一句话说的对，“不撞南墙，不回头；不到黄河，心不死”。快到了，我认为。所以惠能一开始就讲了第一条，心平普敬一切，这就是戒。</p>
<p>在家修行第二条：“行直何用修禅？”，就在生活中坐禅了。</p>
<p>第三条就是儒家的来了。中国儒、道、佛三者合流是到了宋明的时候，那么这种儒、道、佛三者合流的一个趋势，在惠能这里已经来了。因为大家在家修行里没有摆脱父母和儿女的关系，你有没有摆脱你对整个民族的责任吧？你出家了这些都了断了嘛。逃了君臣的关系，也逃了父子的关系。但是你在家了修行了，你这些都不逃了，你不逃儒家的话你就懂，所以就把儒家的原则引进来了，恩则孝养父母，你在家修行，你就不能把儒家撇开，这是这话说得对的。第三条就是<strong>报恩</strong>。</p>
<p>第四条：“义则上下相怜”，上下下来什么？兄弟，姊妹之间，要<strong>守义</strong>，守住这份义。也是儒家的原则。</p>
<p>第五条：<strong>让</strong>，就辞让。又是儒家的原则。什么情况一定要辞让？人有尊卑吧？有。社会地位有高低，你有你的上级是吧？你也会有你的下级。上下级关系，上司下司之间是不是尊卑？原则是让，让则尊卑和睦，这叫<strong>辞让</strong>。</p>
<p>孟子讲的辞让之心，人皆有之。辞让之心起来，那个<strong>礼</strong>就来了。这全是孟子的思想，惠能把它吸收到佛教里来。我们都记得孟子讲人性有4个善端：侧隐之心，人皆有之，羞恶之心，人皆有之，辞让之心，人皆有之，是非之心，人皆有之，侧隐之心，仁之端也，<strong>端</strong>就是<strong>根源</strong>。</p>
<p>仁、义、礼、智的这4个方面的根源都在心里的。所以侧隐之心，仁之端也；羞恶之心，义之端也；辞让之心，礼之端也；是非之心，智之端也。现在惠能提到一个<strong>礼</strong>了，<strong>礼</strong>就是<strong>辞让</strong>。上下级关系，社会地位的高低，那你是无法否认的。总有领导者和被领导者，那么就有了尊卑了。但是尊卑的关系不是等级压迫的关系，上级可以压迫下级，不对的。他的关系应当是<strong>让</strong>。这是第5条。</p>
<p>第六条，<strong>忍</strong>，别人伤害了你，无论是用语言伤害了你，还是用行为伤害了你，你要<strong>安忍</strong>，安忍是度的一种，不失实践安忍，<strong>安忍波罗蜜</strong>，你如果能忍则众恶无喧。后面的不好的事情也就结束了。从你这里中断的。基督教把这个东西讲得更彻底了，别人打你左面的耳光，你把右面的也让他打，听上去太荒谬，但是它的原则是不要以恶报恶，是这个意思，要在你那里中断。</p>
<p>那么佛教也有这层意思，要安忍。我小时候读那部小说叫《悲惨世界》，我们大概都读过或者看过的电影吧？冉·阿让是因为偷了一个面包就被判了苦役。抓起来，服苦役，他逃了几次都没成功。后来有一次他逃出来了，他心头带着对整个社会的仇恨，要报复这个社会。他逃出来之后，走到那个地方正好遇到米里哀这个主教。米里哀主教是基督徒，他还是主教的，他就接待了这个冉·阿让。</p>
<p>主教家人都觉得这个人形迹可疑，面目凶恶，这种人不能接待的，但是主教还是按待了他，给他饭吃给他床睡觉是吧？吃饭的时候不是用了那些银的餐具嘛，等主教一家人都睡熟了之后，冉·阿让就起来了，他老早动了这个心。等主教家人都睡熟了之后，他就拿了一个布袋，把那些主教家里的银餐具通通装到布袋里拿走了。</p>
<p>第二天早晨起来主教家人发现一整套银餐具就没了，都只怪这个主教。叫你别接待这个人一看就歹徒，你偏偏给他吃给他睡，你看偷了我们的东西。主教说他需要。正在这时候看到了警察押着冉·阿让走过来，因为警察发现此人形迹可疑，又发现他布袋里面有银餐具，方圆几里之中也就是主教家里有银餐具，所以一定是他偷的，把他压到主教那。主教看到冉·阿让被警察押过来了。主教上去怎么说的？冉·阿让，我的兄弟，你还忘了，我还送你一对银独台，你忘了拿，吩咐家人把一对银烛台马上拿过来，交到了冉·阿让手中。这时候警察就没办法了，只能放了冉·阿让。这个主教叫米里哀主教，把一对银烛台交到冉阿让手中的时候在他耳边轻轻的说了一句话，冉·阿让，我的好兄弟，我赎买的是你的灵魂，把它交还给上帝。雨果是浪漫主义作家，他接下去写什么？这句话一说出来，冉·阿让头晕眩了，晕眩了一下，然后很快地镇静的自己。心里想着我要报复整个社会的决定不能改变，他继续走了。后来在荒野上的时候遇到个小孩，这个小孩是穷孩子，天天干给人家通烟囱，烟囱时间长了不是就灰堵塞了，他来通，通了就赚几个铜板，今天收获比较大。这小孩扛着一个小梯子，然后左手在弄他今天挣到的铜板，结果一个铜板掉到地下来，滚到冉·阿让脚边，冉·阿让正坐在一块大石头上，冉·阿让看到一个钢板滚到他脚边，它本能一般的一脚踩住它，这小孩急了，奔过来摇着他的腿。先生，这是我的铜板，求求你给我，然后让对他怒目圆睁，大吼一声，滚！这小孩吓得魂落魄散，落荒而逃。</p>
<p>雨果又写了，在这一刻当中冉·阿让看到了自己狰狞的面目，然后把自己狰狞的面目跟米里哀主教慈善的面容做了一个比较。在这比较当中一道阳光射进了冉·阿让的心。人们后来发现第二天，发现有一个人朝着米里哀主教的家里跪在那里。这个人跪了整整一夜，这个人就是冉·阿让。后来他从此一生行善，这是《悲惨世界》小说。我当初少年的时候读了这部小说，我心里就生了很大的疑惑，为什么？我们从小受的教育是什么？有两篇寓言故事读过吧？</p>
<p>《农夫与蛇》、《东郭先生》，这两个寓言故事都是在告诉我们，我们不能以德报恶的，以善报恶不行的。你必须跟他抗争，否则你就像东郭先生一样可怜，像农夫一样的可怜。《悲惨世界》雨果所写的这段故事动摇了这个原则，我究竟应该跟哪一种原则走呢？这是个大问题。人世间恶恶相报，那个链条就断不了了，要以恶抗恶，以暴力对付暴力。这就是《农夫与蛇》和《东郭先生》的寓言给我们的原则。</p>
<p>但是雨果给了另外一种原则。我心里就觉得雨果的原则不可靠。我想起了基督教讲的，人家打你左边的耳光，你把右边的也让他打。我想这还了得，结果打烂了，这怎么行？后来才明白有道理，伟大的宗教精神都是如此。在现实的历史上实践过。一个例子，美国上世纪60年代发生非常严重的事情是白人对黑人的迫害。3K党听说过吗？抢掠烧杀黑人，恶行是令人发指的。</p>
<p>后来终于爆发一件事情，什么事情？有一个黑人的中年妇女坐公交车,上了车又明明有座位，不让她坐，因为这个座位边上是白人，这个座位是不能让她坐的。结果公交车到了站头下来以后，黑人妇女直奔报社，跟报社的编辑讲了这件事情。结果这家报纸第二天就把这个消息公布了，这是个导火线。</p>
<p>实际上美国当时已经遍地干柴，黑人兄弟已经极其愤怒了。这件事情一发生，然后大规模的集会，这时候黑人完全有理由拿起武器跟白人战斗,那叫以暴抗暴。就在大型聚会上出现了一个伟大的宗教家牧师——马丁路德金，在那里发表了他的演讲。演讲的标题叫“I have a dream我有一个梦想”。排比句啊。牧师是个演讲的能力非常强大，这个声音银铃般的声音。然后一句句话说出来：我有一个梦想，有一天白人的妇女跟黑人的妇女可以同坐一辆公交车公共汽车；我有一个梦想，有一天黑人的孩子可以跟白人的孩子同在一个学校里念书；我有一个梦想，有一天白人和黑人团结起来，共同建设上帝赐给我们的这块土地。排比句。许多白人在集会的现场听的，都流下泪来。</p>
<p>然后马丁路德金呼吁全体黑人放下武器，发动了<strong>非暴力抗议运动</strong>。这件事情很伟大，他阻止了美国的再次分裂，否则林肯的事业将毁于一旦，美国又要爆发内战。林肯不是解放了黑奴吗？发表了黑奴解放宣言，然后结束了南北战争。所以美国的统一再度的被维持了，靠什么？宗教精神，马丁路德金。</p>
<p>还有一个例子就是圣雄甘地。圣雄甘地领导了印度最大的当时最大的叫国大党，领导国大党干嘛？要从英国殖民者手中赢得印度的独立，他发动的运动叫<strong>非暴力不合作运动</strong>，不用武器的。因为他是佛教徒。经过坚持不懈的斗争，非暴力不合作运动，终于英国人撑不住了。</p>
<p>印度独立就在眼前，这时印度的国大党的党内同志就跟圣雄甘地讲，我们马上要赢得独立了。独立之后的印度第一大党就是我们这个党，他应当执政。后来圣雄甘地说了句什么？一旦印度独立了，国大党马上解散。为什么？佛教的原则，佛教的原则是不参与政治。现在是为了印度的独立，他参与了，独立实现了，政党解散。因为政治一定包含他的阴暗的一面，叫<strong>暴力</strong>。所以圣雄甘地的原则就很清楚。这个例子说明什么？宗教精神在人类历史最关键的时刻起到了巨大的作用。我现在认为巴以冲突是没完没了的。联合国安排什么国际和平的路线来解决巴以冲突，这是不可能的。暂时的和平是准备下一次的战争。巴以冲突，阿拉伯中东的这些冲突的最终解决需要一个伟大的宗教家，或者在以色列哪里，或者在巴勒斯坦那里产生，他才能真正实现民族的和解。什么国际政治的理性安排根本没用。联合国在这件事情上根本是一个空架子，有什么用？他解决不了这种仇恨。</p>
<p>我们期待一个伟大的宗教家，21世纪是什么世纪？不是科学的世纪。19世纪到20世纪是科学的世纪，21世纪是哲学和宗教的世纪。我相信这一点，因为当代人类所面临的问题已经不是科学所能解决的问题。</p>
<p>两个问题：一个是核能，一个是恐怖主义。21世纪人类面临的最大问题是两个。我把它比喻为鱼骨头，在喉咙里，如在喉，咽不下去也吐不出来。哪两根鱼骨头？一个就是核能的利用，哪怕是和平地利用核能，都是不允许不可以的。据说现在技术保证了绝对安全的使用核能，这根本是谎言。为什么？人类是会犯错误的动物，这种错误一旦发生，其后果是不堪设想的，是无法挽回的。就像福岛核危机是吧？一个海啸，一个地震，好了核泄漏不得了，更何况核武器。</p>
<p>今天地球上各个核大国拥有的核武器，如果一起拿出来用，人们计算过它的当量，它的能量可以把地球摧毁17次之多。核能怎么解决？只有那些有智慧的民族才知道，在本国的国土上不允许建立任何一个核电站。德国人就宣布了，日本是有50座核电站的。</p>
<p>第二个就恐怖主义。恐怖主义是对现代国家本身的否定，那是民族之间的冲突。所以亨廷顿上世纪末写的那本书叫《文明的冲突》，不幸被他言中了。他说21世纪的国际关系的主题就是文明的冲突。对西方文明构成最大挑战的文明是伊斯兰文明。</p>
<p>结果2001年911事件，如果我们把2001年看成是21世纪开局的一年，那么这个开局开得很不妙。911恐怖主义袭击，直到今天你们看恐怖主义袭击是影响了整个欧洲和美国，包括影响中国。于是各个国家都在反恐这件事情上结成了神圣的联盟。你在国际政治的语言当中提出，我在反恐的话，你一定政治上正确了。各个国家之间制度的差别和意识形态的差别不重要了。只要你是反恐，别的国家就必须支持你。恐怖主义是另外一根鱼骨头，你都不知道怎么解决。</p>
<p>好。所以我想21世纪是哲学的和宗教的世纪。科学已经走向完全的技术化，所有的一切科学的发明和创造其实都不是发明创造，是技术的。按照人们的需要所做的新的复制。你现在去看诺贝尔奖的获奖奖项，没有一项是真正的创造的，哪有创造？一个科学创造的伟大时代已经结束了。一个技术的时代普遍的盛行，就这个时代就技术主义。科学通过他的技术日益进入我们的日常生活。经济学的最重要的分支叫金融学，也技术化，进入我们日常生活。我说经济学已经堕落为工具理性，他们发明各种金融工具是吧？还进入日常生活，一切的政治、经济、社会、生活等领域都要用这些工具了。</p>
<p>所以这是个技术主义的时代，一个思想的时代已经引退了。但是这些问题是不能解决的，金融工具发明的再多、使用的再多，它只是表明了什么？它没有导向世界经济走向和谐与稳定，而是伴随着金融工具地不断使用，使国与国之间普遍展开的贸易战争、货币战争乃至军事对抗，以及一国内部的不同利益集团的政治和经济的博弈。</p>
<p>所以我就嘲笑今天的经济学家，你们就是技术化的东西了，你们这种技术的不断地发明和使用，就金融工具经济调节工具的使用，其实无非表明了整个经济的不安稳，和他的冲突不断。。中国也是一样。所以我是宏观的讲，21世纪人类生活的主题，他已经不是科学能对付的了。一个是宗教，一个是哲学，对中国来说是哲学，对其他民族是宗教。</p>
<p>所以。读到这里我就发表这些感慨，所以惠能就叫忍呐，是“众恶无喧”。对。我们今天的人不可能忍。资本的原则就是竞争的原则，而且这种竞争并不是所谓在市场平等当中和平展开的。它是属于以最先进的军事力量做后盾，今天人类的武器的竞争是空前规模的，我们中国人也不想输给别人。不断地要把尖端武器显示给世人看，这叫今天讲叫秀肌肉是吧？</p>
<p>那么连北朝鲜都来这么干，他的阅兵式里面导弹是真假的不知道，很厉害的阅兵，然后他也要准备搞核武器。那么朝鲜半岛危机就来了，危机背后是几个大国之间的博弈，事情就是这样。</p>
<p>我们在如此的世界，用佛教里的话叫末世呀，末法时代。那么我们如何自处于这个世界，想想还是学佛吧，没有别的办法，比方说以儒家为主，我就会天下关怀，但是我王德峰天下关怀没你资格，你就等待。等谁呢？等习大大，等了急了怎么办呢？别急，稍安勿躁，修佛吧，事情就这样的。所以我们就来都谈经了。</p>
<p>我们上午已经讲到疑问品的最后一个问题，就是回答如何在家修行。绝大多数人都是在家修行，只有极少数的人出家。出家是带着使命。</p>
<p>有使命的人才出家，这个使命就是传扬佛法，其实也不是主观选择的结果。所以惠能说，修行在家易得，不由在世。人生无处不是道场，我们就在日常生活中修。昨天我们讲般若品最后无相颂，里边有这样4句：佛法在世间，不离世间觉，离世觅害提，恰如求兔角。佛法就在现实世界中的脱离现实世界去寻求觉悟好像是想要兔子长出两只角来一样荒谬。</p>
<p>那么如何在家修行呢？有一个无相颂，我们上午讲了，其实讲了在家修行的十个要点，第一个，真正的<strong>持戒</strong>，持的是什么戒？戒轻视他人。是“心平何劳持戒？”</p>
<p>第二点讲的是<strong>行直</strong>就直心直行，直心是道场，直心是净土，也就是儒家讲的初念，不可转念。</p>
<p>第三个要点就是<strong>报恩</strong>，儒家的思想，因为在家修行就不脱离日常生活。在五伦之中，那么儒家的道理就得遵循，第一个报恩，就兄弟姐妹的关系叫守义，义则上下相连。就社会等级的不同，地位的尊卑的关系而言，有一个原则叫<strong>让</strong>，让则尊卑和睦。再下面一个要点就是忍让，安忍，“忍则众恶无喧”，这个世界上种种的罪恶要平息它，必须有人能够忍。</p>
<p>我们上午就谈到这里，讲到宗教精神，佛教的和基督教历史上曾经有过的那些伟大的宗教家，比方说马丁路德金。</p>
<p>然后我们底下再看“若能钻木出火，淤泥定生红莲。”钻木出火，淤泥红莲。我们知道莲花是佛教的象征，莲花是出污泥的。也就是我昨天讲到的真谛和俗谛不能截然分开。我们既然在人世间修了，在这个社会中修，我们就只要真俗不二，要<strong>俗中得真</strong>。第七个要点，<strong>俗中得真</strong>。不是拒绝世间法，而是把世间法和出世间法统一起来。</p>
<p>第八个要点“苦口的是良药，逆耳必是忠言。”这是普通老百姓都会说的话，良药苦口，忠言逆耳。惠能也把它列为在家修行的一个要点，这其实是非常重要的。我把它概括为闻诽自明。常人的习气是喜欢听到好话，听到别人说自己的好话，不喜欢听到别人说自己的坏话。一个修行的人应该明白，别人说你的坏话，不管是说的正确，还是说的错误，都是好事情，应当欢迎的。人最难的是<strong>自知之明</strong>。</p>
<p>人贵有自知之明。因为我们有自知之明我才贵，不是因为别人吹捧我们，赞美我们才贵的。<strong>我们的贵就来自自知之明</strong>，这是最重要的。</p>
<p><strong>闻诽自明</strong>这条道理，惠能把它作为在家修行的一个要点，人做事情，在这世界上做事情要做的比较成功，比较有价值，需要对立面。我们有一个天真的想法，做事情也要顺利，而没有敌人。想错了。</p>
<p>其实中国道家的思想，你读老子的《道德经》，他就非常强调这一点。一个是老子认为世界上的事物始终在变化，中国思想都承认的，儒家也承认。中国的《周易》书名的易字就是变化，变化是世界的本质，宇宙的真相。那么什么是变中的不变呢？一切的变化所遵循的共同的法则是不变的。这个共同的法则是什么？又是老师讲的那句话：”反者道之动”。”反者道之动”这句话用今天我们能理解的普通的语言来说，<strong>一切事物都必然的走向自己的反面</strong>。</p>
<p>万事万物的变化都是<strong>道</strong>起作用，那么<strong>道</strong>让万事万物如何变化——走向自己的反面。<strong>高</strong>的要走向<strong>低</strong>的，<strong>贵</strong>的会走向<strong>贱</strong>的，<strong>贱</strong>的也会走向<strong>贵</strong>的，<strong>直</strong>的道走向<strong>弯</strong>的，<strong>弯</strong>的走向<strong>直</strong>的。所有的事物一定会走向自己的反面。</p>
<p>老子的思想深深的进入了中国老百姓的内心的。我们这个民族有一个非常大的优点是什么？即使在最黑暗的时候，最艰难困苦的时候，仍然对未来有信心。为什么？<strong>反者道之动</strong>。<strong>反者道之动</strong>这个道家的基本思想也让我们这个民族在辉煌的时候成功的时候保持了必要的警觉。那么如果一个事物你希望他长久一点，根据反者道之动的法则，就一定要让这事物有能力包含自己的对立面，这个事物才能长久。这是道家的智慧。现在被结合到佛家的思想中来。一个人做事情要做的比较成功，需要它的对立面——敌人。我们天真的愿望就是做事业一要顺利，二无敌人。如果真这样的话，这事情做不大，做不出它的价值来，真实的意义了。所以我们应当欢迎我们有对立面，有人的批评，甚至不正确的批评。比方说诽谤，倒是帮助我们自己认识自己，叫<strong>闻诽自明</strong>。</p>
<p>西方有一个故事很好玩。说两个强盗一天在一起走，路过一个广场，在广场上有断头台，其中一个强盗就跟另一个强盗讲，这个世界上没断头台多好，这个断头台让我们总是很恐惧是吧？另一个强盗跟他讲，你错了，我们要感谢断头台，因为如果没有这个断头台的话，多少人要干我们这一行。他们都吓跑了，所以我们干了。这个很有意思的小故事。它说明什么？说明困难是我们的恩人，敌人是我们的老师。</p>
<p>一个事物要保持得长久一点，就要有能力包含自己的对立面。资本主义要继续存在，就必须能包含它的对立面--社会主义。如果资本主义没有能力包含它的对立面社会主义，它马上就要死的。</p>
<p>我们把老子的思想从各个方面来运用你就看到了，假如没有非市场经济的因素，比如说社会福利也好，包括失业者的人，离开生产过程的人，你当然不用市场原则了。你无偿的给他生活质量，这不就社会主义。如果一个搞资本主义的国家，它没有这一条，它的资本主义能下去吗？不可能。能存在下去吗？</p>
<p>98年中国闹了大洪水，特大洪水。那个时候上上下下都紧张了，后来甚至准备荆江大堤决堤来泄洪。如果一泄两个省淹了，当然保全了更重要的省份。还好。叫洪峰安全度过是吧？这是一大幸运。我印象太深了，98年那段时间我晚上看电视，基本上天天看得到什么赈灾的文艺晚会。赈灾的文艺晚会上都有许多集团企业来捐款吗？我看了一下估摸了一下，当时真的来捐款的，拿很大的牌子上面是个支票，多少金额。基本上是国营企业，私人企业非常少。</p>
<p>我的第一反应就是中国改革开放以来，新生的民间资产阶级根本没达到觉悟。看上去这件事情是没有强制性，是吧？慈善的事业，请有钱人出来捐款，这是慈善的事业，你可以不做。其实是资本主义要保持自己继续存在所需要的社会和平环境的必要成本。各位同意吧？假如成千上万的灾民无家可归，他们到哪里？到城市。比方说到上海或者其他城市，这些城市准备好了足够的就业岗位吗？没有。然后他们要吃要喝。钱在哪里？在银行里。巧了，资本正常运行所需要的社会和平的环境就消失了。这时资本增什么值呀？资本就死了。</p>
<p>资本主义要能存在，必须包含自己对立面社会主义。社会主义的基本因素是资本世界存在的基础。你不能把这基础铲掉，资本主义的经常性的循环是产业结构调整，有时候以剧烈的危机的方式发生的，生产相对过剩，如中国产能过剩之外，大量的钢铁工人下岗。你怎么办？很简单，无偿地给他生活资料，这里没有什么市场交换，完全就是社会主义的。你不给他们怎么办？这批人活着，他们可是人。在经济学家当中看不到，在生产过程之外的人，经济学是看不到的。但这些人经济学家虽然看不到，他们是人活着呐，这些人将交给社会主义，事情就是这样。</p>
<p>所以中国中小企业家这个阶层，30年改革开放是经历了一个逐步成长的过程。欧洲的资产阶级经历了巨大的历史阶段，我们看到了特别以北欧为典型的社会福利国家是吧？福利国家，就充分承认社会主义因素。为什么？不是他们读了《坛经》。不是的。是19世纪到20世纪风起云涌的工人运动，那是斗出来的。一部马克思的《资本论》没有敲响资本主义的丧钟，但是敲响了资本主义的警钟。他们没有老子的智慧，但是生活教育了他们，斗争教育了他们。中国本有老子的智慧的。所以一个事物要长久一点，就必须有能力包含自己的对立面。</p>
<p>方方面面都是如此。我有一次应邀为我们复旦大学还搞了一个老年大学，就退休的教职工上各种课，那么钢琴课、绘画课，那么他们蛮有意思，有许多都是教授退休了嘛，没事情干了嘛，本来搞计算机的，好多搞数学的，现在来学绘画了，那么他们还得听听哲学的课。</p>
<p>复旦的老年大学的校长就邀请我做一个讲座，我说现在老年人都喜欢听听中国的国学。那些老教授们，那么讲什么？我就说那么就讲道家吧。一个人到了60岁以后应该有道家的境界。好，我就去讲道家了，我知道他们最关注的是健康。那么我就讲讲道家的原则，我说现在我们都活得小心翼翼的，各种保健品养生的经验，不断地在互联网上传来传去，是吧？其实道家的养生的精神是第一条<strong>无为</strong>。</p>
<p>无为体现在我们的养生当中是千万别增添任何人为的因素。比方说以人类的饮食做例子，我说有8个字：已饥方食，未饱先止。肚子饿了才去吃饭，吃饭不要吃到十分饱就停下来。这是一个原理，跟他们讲讲，吹吹牛了，聊聊天很开心。我说现在市场上充塞了各种各样的名目繁多的保健品千万别去玩，不管里面有没有骗子，是另外一件事情，他不是骗子，你也别玩，也不须吃那些东西，全叫<strong>人为</strong>的。<strong>人为</strong>两个汉字加起来就是一个字叫<strong>伪</strong>，那叫<strong>造作</strong>。</p>
<p>第二条原则也是来自道家的，我们要健康的前提是要包含疾病，你别以为你身体什么病都没有你就很高兴，那是比较危险的事。我们民间都有一个比喻，硬的扁担又硬又直的扁担会怎么样？断的。什么扁担长久？弯扁担。你有病是好事情你知道吧？你千万别每年一体检就不得了了，吓死了。这个指标不对了，那个指标坏掉了，然后我怎么还能活多久？后来完了拼命的搞，还要锻炼，明明70岁了，跑步跑，跑什么跑，你老了就老了。你让他衰了，衰老了是正常的。然后他让他弯，你有能力包含疾病你就长寿了，底下全鼓掌了，他们觉得豁然开朗。</p>
<p>我说这个不是我的，是老子的思想。他们就很开心，要学道家了。千万别跟着西方的科学精神走，最好是七八十岁还能马拉松的。那可能吗？个别人可能做到，不要学习。一个身体十分强壮，什么病都没有的人突然就走了。有多少长寿的人其实是带病延年，同意吧？这就是道家的原则。你能包含<strong>健康</strong>的对立面--<strong>疾病</strong>。</p>
<p>道家的思想可以运用到方方面面的，我们中国人本有的智慧的。那么会惠能在里讲的是人与人打交道，有人诽谤你，有人毁你，有人反对你。不管正确还是错误，你改自己的非就可以了。<strong>闻诽自明</strong>。我们年轻的一代也应该早一点懂得这个道理，现在都希望一帆风顺，大学一毕业就很快的成为社会精英，成功人士，都做着这个梦。要记得。困难是我们的恩人，敌人是我们的老师。“苦口的是良药，逆耳的是忠言。”你别管别人说这个话是不是出于真诚的帮助你，你别管这个也不知道，你听到了要高兴。</p>
<p>下面又有一个要点叫“改过必生智慧，护短心内非贤。”每个人会不知不觉的护自己的短，在别人面前扬自己的长，那叫扬长护短。其实呢正好错了。智慧从哪里来？不是读书读出来，因为智慧是实践，什么实践？<strong>改过</strong>。“改过必生智慧”。人没有改过的能力，他不会有智慧。更高明的一点的人，慧根比较深的人，是别人的过，他也来体会，也能自己避免，那就是智慧。我们通常是别人的过，我们看过就好了，还好我没有。说不定你就会有。Who knows？所以这也是现下修行的一个方面。我们时常的改正自己的过错，智慧自然地就生出来了，这叫<strong>改过生智</strong>。</p>
<p>最后一点，第十点，“常行饶益”，十戒当中有一戒叫<strong>饶益有情戒</strong>。佛教把这讲的太有意思了，我们说戒这个戒还有一个戒是什么？你必须经常帮助别人，这也是戒的一条。如果人力所能及的范围当中能帮助别人却不帮助别人，这叫犯了<strong>饶益有情戒</strong>。所以惠能把这个也作为在家修行的一个方面，“日用常行饶益”，<strong>饶</strong>就是<strong>丰富</strong>，<strong>益</strong>就是有<strong>益于他人</strong>，这样的人成道有希望，不是简单的施钱就能成道的。</p>
<p>所以说成道非由施钱。施钱当然是好事情，那叫财布施。但别忘了，“常行饶益”也是根本，有的人自己穷得很，也没什么钱能分给别人，他就不能布施了吗？我们随时可以帮助别人。只要我们发现了这一点。这就是在家修行了。惠能用无相颂说了在家修行的十个要点。想起来我们都能做到，真正十个要点当中最难做到的是第一个，**心平。**这是第一个最最难做到的。**普敬。**永不轻视任何人，这是最难的。**行直。**也能做到是吧？只是今天这个充满病症的社会已经难了，。你能“直心是道场“吗？你能“直心是净土”吗？你能不转念吗？你是初念之圣贤，有点难了，后面讲报恩守义，一个正常的社会都应该能做到。<strong>辞让，安忍，俗中得真，闻诽自明，改过生智，常行饶益</strong>。一共十个方面。他没有说在家修行要做什么必要的功课，每天的早颂，早晨的功课颂经，或者什么，他也没说这些具体的。当然也不反对。他所说的在家修行的功课就是这十个方面。疑问品这样我们就读完了。</p>
<p>回答了三个问题，所以叫疑问品。</p>
<p>一个问题：什么是真正的功德？</p>
<p>第二个问题：如何抵达西方净土？</p>
<p>第三个问题：如何在家修行？都做了回答。</p>
<p>对第一个问题的回答记住8个字：见性是功，平等是德，这叫<strong>功德</strong>。对第二个问题的回答，记住这句话，释迦牟尼所说的：随其心净则佛土净，即佛陀净，心净周遭世界就是净土。</p>
<p>第三个问题的回答就是十个方面。好，我们现在进入第4品，定慧品。</p>
<p>我们讲过这个第一品行由品是交代了这个惠能从弘仁法师那里得法传衣，得法传衣的事情的源由所以叫行由品。</p>
<p>那么第二品，要将禅宗传统的基本原则说明禅宗是般若法门，修智慧的。</p>
<p>那么第三品其实做了一个最重要的说明是什么呢？就戒定慧当中的戒我们刚刚读了这个疑问品，中国僧人把修行的法门，那么多修行的法门归纳为戒、定、慧三学，这是中国思想的特征。要化繁为简，一切离开戒、定、慧的佛法都不是佛法，一切佛法都不离戒、定、慧，有些佛法专门是讲如何戒，有些佛法讲什么禅定什么定的入定等等。还有讲慧，如何领会佛理然后运用到生活中去。所以所有的都可以概括为戒、定、慧三学，那么更有下一步的概括是中国的天坛宗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定慧品"><a class="header" href="#定慧品">定慧品</a></h1>
<p><strong>戒定心不乱</strong>曰<strong>定</strong>，这就是<strong>定</strong>。然后<strong>定</strong>之用就是<strong>慧</strong>，就那么简单。这里边这个智慧没有什么有一个智慧读本，让我们去学一共有150条智慧，因为这个<strong>慧就是定的，是自然的妙用</strong>，叫<strong>定体意用</strong>。听上去空不空，好像很空，不空的哦。举个例子，凡是在历史上做出丰功伟绩的大人物，这种丰功伟绩来自哪里的？是什么东西的结果，是他的知识技巧的丰富来的吗？不是，是他的<strong>定慧</strong>来的，从他的<strong>定慧</strong>中而生。</p>
<p>比方说毛泽东，我们又举例子，以毛泽东为例子，他无疑是大政治家，无疑是大军事家，而且是在战略的层面上的。解放战争三年就打完了。解放战争刚开始的时候，国民党的军队和共产党的军队比一比吧，谁强谁弱？那是非常鲜明的对比。虽然经过抗日战争这段时间，共产党的军队在延安得到了长足的发展，比红军长征刚刚结束的时候强大多了，但是跟国民党几百万大军是不能比的，更何况国民党几百万大军还有美式装备。所以蒋介石是充满信心的，几个月里边解决中国问题。</p>
<p>他发动的，撕毁了重庆谈判的双十协定，因为他充满信心，他干了。在大军压境的面前，在考验谁呢？在考验毛泽东。因为毛泽东的领袖地位已经在延安整风之后确立好了。毛泽东怎么办？定了。这是非常关键的，叫<strong>见境心不乱</strong>，这是最根本的。那个智慧也不是什么从《孙子兵法里》学来的。</p>
<p>有人当时就问毛泽东，“你打仗成功率很高。你是读了《孙子兵法》的吧？”</p>
<p>毛泽东沉默了一下，这是真实的对话，跟那个人问了一句：“你知道《孙子兵法》有几条？&quot;</p>
<p>那个人一时答不出来，后来毛就笑了，你都没读过《孙子兵法》？问我读过吗？你问问题不要随便问，然后毛泽东我是没读过《孙子兵法》，如果打仗先要读《孙子兵法》的话，怎么打呢？</p>
<p>所以我们体会毛泽东的做法，第一，<strong>实事求是</strong>。敌强我弱，你必须承认，你来我就得让。胡宗南军队扑向延安，毛泽东放弃了延安，你来吧。毛泽东的原则是什么？其实就是一个诚字。我们只知道兵不厌诈，其实不知道真正用兵贵在什么——<strong>诚</strong>。人家诈你，你上了当原因是什么？你不承认，然后你跟人家打，你不断的用诡计骗人家，你以为这种担保成功吗？你也别把别人当傻子，所以根本的原则是承认自己是劣势，对方是优势，然后化全局的劣势为局部的优势，这都是个<strong>诚</strong>字。你几十万大军进来，我根本不能跟你打阵地战的是吧？我跟你兜圈子了吧——运动战。运动战就在兜圈子过程当中，我可以随时随地有可能造成局部的优势。毛泽东是特别强调的，集中优势兵力打歼灭战，要几倍十倍于敌人的兵力，我几个师扑上来，只吃掉了一个团。可以的。这是担保胜利的事情。饭要一口一口的吃的，仗要一仗一仗的打，慢慢的就发生根本变化了，消耗敌人的有生力量，不要守住那一城一池不放，蒋介石傻就傻在这里，占领一座空城很开心。我让给你的。战争就要消灭敌人的有生力量的，怎么消灭？我一下子消灭你，不可能。化局部的全局的劣势为局部的优势，这种叫慧，慧来自哪里？**见境心不乱。**你一看强大，我弱小，心里慌了吧，一乱没慧了，这里没什么具体的什么兵法在教毛泽东，无非定慧而已。一个例子。</p>
<p>我们别把智慧搞错了，以为是那种成功的经验和技巧，然后我们一样样的学就有了智慧，他不是智慧，智慧源于定。慧是定之用，就没具体内容的。你别把它分开来。又要学定，学了定之后再学慧，还是先学慧后学定，都错了，<strong>定慧一体</strong>。我们最难做到的就是定了，因为见境就乱，有几种乱法，第一种<strong>侥幸</strong>，我比你好像强大，我有一个机会了，又乱了。又一看不行，我陷入困境中了，心又乱了，完了。</p>
<p>做大事业者从来不是心存侥幸的，因为本来就不心存侥幸，就<strong>实事求是</strong>的，心就定了，什么处境的变化都不至于乱的。由于这一定在那里做了体了，方法自然来，那叫慧，<strong>慧就是定的妙用</strong>。历史上的例子很多。毛泽东总喜欢举这种例子的叫以小胜多，以弱胜强。历史上有好几次包括淝水之战之类的都是强大的被弱小的战胜了，为什么会这样？定慧呀！这个道理其实讲出来是天下都能明白的，偏偏都做不到，为什么？<strong>心不定</strong>。</p>
<p>我们刚才把毛泽东整个战略思想讨论了一下是吧？无非化全局的劣势为局部的优势呀，就这件事情。这不是实事求是吗？这不就是心定吗？我说一定要通过一个军事指挥家的技巧来胜利，毛不建立在这个基础上。毛就讲的集中优势兵力，十倍甚至百倍的兵力消灭它，你不可能不消灭它。你十倍于他怎么会不战胜它，十倍几十倍于它，就这么干的。每一次局部优势造成了就是成功的消灭了敌人。后来这个速度是惊人的快，每天的战报又下面多少个旅，以旅来为单位来计算，消灭国民党多少人的，全是这么集中优势被你干掉了。</p>
<p>那么还有一个定是指什么？理解中国的政治，战争是政治的延续，一个军事家如果不懂政治他也失败。蒋介石说了一句话，后来毛泽东听到了就笑了，蒋介石说了句什么话？谁在中国控制了这五个城市，谁就控制了全中国。哪五个城市呀？武汉、上海、广州，南京、北京，谁控制了这五个城市，谁就控制了全中国。毛泽东微微一笑说了一句话：谁得了农民的心，谁就得了天下，清楚吧？中国是农业大国吧，你得了农民的心了，你就得了天下。哪是你蒋介石说的五个最重要的城市控制在手里？这都是定慧。“谁赢得了农民，谁就赢得了天下。”毛泽东的原话，我举这些例子，无非来理解，当然跟佛教的目标一点关系没有，佛教的目标是修行，修行就是为了解脱生死，那么要讲定慧，但是精神是一致的，逻辑是一致的，<strong>定是体慧是用</strong>，别从这个里面找文章，大概有哪些内容叫智慧？没有。其实就是定的用。而定的主题是什么？定的内涵是见境心不乱，就这个道理。</p>
<p>这样我们对定慧一体就做了一个说明。这个慧是实践，不是口上说的理论。</p>
<p>应事也，<strong>以本心应事</strong>，是佛家的最关键的一个定慧关系。</p>
<p><strong>以本心应事</strong>，而不是以小我之心来应事，这就是<strong>定慧一体</strong>了。那么底下讲一个非常重要的意思了，叫“一行三昧”，定要定到什么境界？“一行三昧”，定慧一体达到什么境界？达到“一行三昧”的境界。梵文当中有一个词叫 Samadhi。</p>
<p>我用拉丁话的写法，咱们不是这么写的，我也不会，拉丁话叫 Samadhi。汉语怎么翻译？找不到合适的词。找不到合适时只能音译，这叫实事求是，不要牵强附会。用音译的方式把它译成汉字，“<strong>三昧</strong>”。也有翻译成“<strong>三摩地</strong>”的，到后来通用的还是<strong>三昧</strong>。也有翻译成“<strong>三摩地</strong>”的，读音上好像更接近了。“<strong>三摩地</strong>”，但现在通行的是“<strong>三昧</strong>”</p>
<p>在汉字当中找不到对应的词，只能用声音来音译，这表明什么？中国思想中缺这一块。所以你就没词语。那么现在要说了这<strong>三昧</strong>究竟是什么境界？</p>
<p>【入定（听众语）】</p>
<p>入定是其中的一个方面。也有人把它理解成入定的，但是只是一个方面。那么也有这样解释的是这样一种精神状态，叫高度集中，专心致志，那叫三昧。都还是没说到。我来说一说。</p>
<p>什么叫<strong>三昧</strong>？我们拿艺术创作做例子，一个艺术家的创作，他的作品的过程当中必有一个阶段，不经过这个阶段而创作出来的作品不是真正的艺术作品，而只是工艺品。那么整个创作过程终于进入这个阶段，这个阶段后来西方人用了一个词来表达的叫inspiration。翻译成<strong>灵感</strong>。</p>
<p>其实inspiration翻译成灵感也是翻的不是很恰当，是后来才形成了译法，一开始也是找不到合适的词。西学东渐进入中国，近代史上，然后就遇到了西方人讲的inspiration，怎么翻？当时也用音译的。叫“烟士披里纯”。就看近代文献上还有什么叫inspiration，“烟士披里纯”。我一看到蛮好，我也抽烟的啊。后来发现这个音译的人家搞不明白是吧？终于不知道哪一个学者说，译成灵感吧，因为灵感来源于inspiration，其实也不够妥当，inspiration其实就是一个艺术家进入灵感状态是什么意思？创作的第一阶段肯定没有灵感，这个阶段是非常苦的。艺术家想要做创造一部作品，他心心中有创作冲动起来了，创造冲动起来，什么叫创造冲动？比方说郑板桥啊，讲他怎么画竹子，有一段话是这么写的：“江馆清秋”，他住在一个江馆里，“江馆清秋晨起看竹&quot;，早晨起来走到外面看竹子，看到了现实的竹子、竹林，“烟光绿茵，雾气皆浮动于疏枝密叶之间”。</p>
<p>看到现实的情景了，早晨起来看到竹子。“烟光绿茵，雾气皆浮动于疏枝密叶之间，胸中勃勃遂有画意。”画意来了，创作冲动起来，他就预感到他将要创作一部作品，这幅竹子的绘画作品。创作冲突起来他就要画，创作冲动就是他胸中有竹子。通过眼中看到的竹子，胸中起了画意，叫胸中之竹。胸中之竹推动他去画出实际的一幅画来，如果画成功叫手中之竹，底下他就说了，“遂磨墨展纸”，把墨磨好了，把宣纸展开了，落笔创作开始了，倏作变相，创作过程不断在变。</p>
<p>此刻手中之竹亦不是那胸中之竹，最后化成手中之竹。于是他就讲了三种之竹。眼中之竹，那就是客观的人人能都看得见的现实的竹子。胸中之竹就是他画竹子的画意，对未来作品的审美意向有一个预感。在预感的推动之下，他创作过程展开，创作过程并不是把胸中之竹简单的搬到宣纸上去，没有这个事情。创作是个探索的过程，终于画完了手中之竹，又不是胸中之竹。</p>
<p>那么这个创作过程当中有一个非常重要的阶段，先前是非常努力，到后来突然不需要努力了，为什么？Inspiration来了？灵感起来，这时候这个艺术家才思蜂拥而来，无法阻挡。艺术家在此创作过程当中不可置疑地情不自禁地完全投入的创作。</p>
<p>这个过程是什么呢？这个灵感也不知道什么地方来的，只要进入这个状况，艺术家跟这个他所创作的作品融为一体了。这个艺术家往日的艺术学习，艺术训练所积累起来的创作的手段、经验、趣味、个性，现在统统用了这个作品诞生它自己所需要的<strong>器官</strong>。这个艺术家成了作品诞生的<strong>器官</strong>。这叫<strong>灵感</strong>，叫inspiration。</p>
<p>在最初的创作阶段，他的艰苦表现在哪里？作家、艺术家作为主体，面对着有待他创作的课题，叫作品。主客二分。他就在这种努力当中，非常痛苦，但是这个痛苦不会白白地过去，他正在准备着samadhi（三昧），准备着三昧，终于进入了三昧，什么叫进入三昧？艺术家跟他所创作的作品融为一体，没有主体与客体的区分，此刻这个艺术家就是这个作品本身，这状态就叫<strong>三昧</strong>。</p>
<p>一个艺术家，这个小我所具有的个性、它的趣味、他的创作的经验、得到的训练的技巧，通通被这个作品用来什么，展开自己的器官，艺术家成了器官了。在这种状态下，西方人用了一个词叫inspiration，梵文当中那个词叫samadhi。我们后来译成<strong>三昧</strong>。艺术创作是一个例子。</p>
<p>按照佛家的精神，人生就应该在三昧中，“一行三昧”。做任何事情最好的状态就是<strong>三昧</strong>。比如说你是个企业家，创办企业，你跟这个企业有区分。你是创办这个企业的主体，这个企业是你的一个作品，主客二分。这个境界不行的，但它是必要的最初阶段。终于到了什么时候啊？你这个企业家就是这个企业本身了。你跟它之间没区分，这时候的企业是非常成功的，你没有一个作为主体看待着企业这个客体，关心着它后来的结果，没有这东西。</p>
<p>艺术家进入灵感状态，就是三昧状态的时候，它也是这样，他并不是说我已经知道我这个作品将成为什么，不知道的！要创作全部完成之后，他看着艺术作品发呆了。这难道是我创作的吗？经历过这个三昧状态的作品才不是工艺品，才是真正的艺术作品。</p>
<p>因为工艺制作这个过程说明每一个工匠啊，制作这个工艺作品啊，其实都预先知道他要做成的是个什么东西。艺术创作与工艺品的制造、制作的区别就在这里。</p>
<p>真正的艺术创作是什么意思呢？直到创作过程完成之前，这个艺术家永远不知道这个作品是什么。举一个例子啊，托尔斯泰写《安娜卡列尼娜》这部长篇小说，动机哪里来？那一天黄昏，托尔斯泰坐在自己的书房里，在他那个围手椅上进入假寐的状态，半睡半醒的。突然他发现眼前飘着一个女性的形象，这个绝代的佳人向他回头一望，双眼充满了哀怨。托尔斯泰被他看到的这个形象惊醒了，这形象是幻象。那托尔斯泰就知道了，这是我一直在想要塑造的一个人物。她这样的就来了，这叫创作冲动起来了，我一定要写出这个人物。这个绝代佳人，她为什么那种深深的哀怨生活在那里，要把它展开。于是托尔斯泰的那部《安娜卡列尼娜》的小说开始创作，他不把这部小说写完，他是不能明白这个主人公安娜是什么人，创作的过程就是探索的过程。于是有一天，托尔斯泰的家人突然听到了从托尔斯泰的书房里传来的什么，嚎啕大哭的声音，惊动了家人，大家一起奔过去，看出了什么事？走进去看，托尔斯泰在这里嚎啕大哭，家人问他：怎么回事？他回答说：安娜死了。怎么死的？卧轨自杀的。那么家人就劝他了，你既然这么难过就别让她死。老托尔斯泰回答说：我已经看清楚了，她一定死，而且一定是卧轨自杀。</p>
<p>这说明什么？说明真正的艺术创作并不是预先设计好的。整个创作的过程就是探索的过程。随着这个探索的过程的展开，某种必然性一步一步的被艺术家体会到了，到这一步他就知道安娜必死。而且他是文学家，不是抽象的必死，而且一定是以卧轨的方式死了。</p>
<p>所以我们千万别误解了，艺术创作好像一个工艺制作过程一样，先构思好了，已经知道了结果，最后把它写出来。不！构思和探索是同步的。构思的过程同时就是创作的过程，就是个探索的过程，探索只是到了这样一个阶段，他才知道全部的必然性，而不是随心所欲，主观的随意性，到了这个阶段叫<strong>三昧</strong>。</p>
<p>我们人生在世做事情也应当达到这个<strong>一行三昧</strong>，就我们这个事情为什么这么做？你没有你跟你所做的事情的区分。进入这种状态，你就是这件事情本身。samadhi。我费了很大一段话来说明什么叫samadhi。小的事情，剥一个橘，太简单了，也应当三昧。<strong>事情没有大小，你就投入到这件事情本身中去，你自己就是这件事情本身，没有你跟这件事情的区分。</strong></p>
<p>禅宗主张这样的境界。这就是<strong>三昧</strong>。所以底下惠能就讲：“善知识一行三昧者，与一切处行住坐卧”。行就是行动起来，住就是停留下来。坐还是卧？“常行一直心是也”。这件事情要做，直行起来，你就投入这件事，你别去想这件事情会给你带来怎样的有利或者不利的结果，你就把自己跟这件事情区分开来了吧？一区分开来嘛，好了，主客二分，一行三昧。小孩子掉到井里去了，你恐惧了、同情了、惊恐了，你去救他，此刻你就是救孩子这件事情没有你跟救孩子这件事情的区分，这叫<strong>三昧</strong>。</p>
<p>所以引用了《净名经》，《净名经》就是《维摩诘经》。因为维摩诘这个梵语的意思就是净名，所以这个经有两个名称是吧。一个用音来译的，叫《维摩诘经》，一个把意思译出来，叫《净名经》。《净名经》云：“直心是道场，直心是净土&quot;。</p>
<p>维摩诘啊，当时是跟佛陀是同时代的，他是个大居士，在家修行，结果也修成了菩萨，叫维摩诘菩萨。</p>
<p>那么他的经文里面有这句话，叫“直心是道场，直心是净土。莫心行谄曲，口但说直，口说一行三昧，不行直心”，这时候是口上说说而已，没有真的进入到这三昧的状态，“但行直心，于一切法，勿有执着”。“迷人着法相，执一行三昧，直言常坐不动，妄不起心，即是一行三昧”。</p>
<p>那个我刚才讲的郑板桥那段话说：“江馆清秋，晨起看竹，烟光日影露气，皆浮动于疏枝密叶之间”。这段话最后（让我们）想到的是什么？他说‘胸中勃勃遂有画意。‘因而磨墨展纸，落笔修作变相，手中之竹又不是胸中之竹也。总之，意在笔先者，定则也。任何艺术创作都是先有什么？意在必先这个前提，这是肯定的。但是；“趣在法外者，化机也”。独画云乎哉！。</p>
<p>这句话真的太有意思了，非常高度的概括了艺术创作的本质。比方说你书法创作。你要写一个字，是吧？你是书法家，落笔之前心中有意吧？我要写出一个怎样的字来？那个意象来了。所以当我们面对一张白纸的时候，跟一个艺术家、画家面对一张白纸跟一个书法家面对着白纸不一样的啊。我们只是看到一条什么东西都没有的白纸，这个书法家在走在他的宣纸面前，上面已经有东西了啊，已经有东西了！在他的心中的那个意象，你才下笔的啊，叫意在笔先者，定则也。但下一笔就是创作开始了吧，写出来的那个作品啊，无论是绘画还是书法，他的那个审美的趣味。都不是什么？你以往你所学习的定法所能规定的，所以“趣在法外者’。这叫<strong>天地造化之机</strong>。艺术创作是如此，惠能这里说，人生做事情也是这样：但行直心，与一切法勿有执着。</p>
<p>以艺术创作为例子，一个艺术家的成长过程是不是学了许多法？师傅教的。你在那一个画派里边，你再那一个书法派里边，你的师傅就把这个，他那个家术交给你了。每一个画派都有一套家术传给你，但是你别把这套家术啊执着不放，那你成不了有独创性的艺术家，你这不过是复制你的老师。</p>
<p>所以真正的创作叫 ‘趣在法外趣在法外’的前提是你要进入<strong>天地造化之机</strong>呢。如何进入<strong>天地造化之机</strong>呢？那就是<strong>三昧</strong>呀，放下一个作为艺术家的小我，人生做事情的也复如此，但行直心，行直心的时候，就放下<strong>小我</strong>，就不会执着于<strong>法</strong>。</p>
<p>所以这句话就明白了，“但行直心。与一切法，勿有执着。迷人着法相，执一行三昧”着什么法相呢？哦比如说禅定，有禅定的方法，执着了吧？然后他说他怎么执着这个表面上的一行三昧呢？‘直言常坐不动，妄不起心，就是一行三昧’。错了！‘作此解者，即同无情’。哦你以为打坐就是心不动，那么你跟石头一样，石头就无情了，草木、石头、瓦石都是无情之物。按照佛教，动物才是有情的。你空心静坐的话，你跟石头没有差别。这叫 “即同无情”，做这种想法的人，这叫“障道因缘”。妨碍了你入佛道。</p>
<p>叫&quot;障道因缘”。这是非常，这个断然决然地认为禅宗的修行要坐禅，坐禅别去相信那一套定法。生活中无处不在坐禅，语默动静都是坐禅。就是说于一切处，行、住、坐、卧，常行一直心，这就是坐禅，这叫<strong>一行三昧</strong>。</p>
<p>“善知识，道须通流，何以却滞”我们执着与法相，佛法教我们的方法，那叫停滞了，阻断了道德通流；”心不住法，道即通流，心若住法，名为自缚“若言常坐不动，是只若舍利弗。舍利佛就是舍利子，心经里边都提到，舍利弗是当时是释迦摩尼的一个大弟子啊，呃说他智慧第一诶！蛮了不起的啊。但当初他有一个过程吧，修行的过程有一个阶段啊，他就长坐不动啊。有这样一个故事，就舍利弗自己安静地坐在这个树林里边常驻，后来被谁发现了？维摩诘。维摩诘就去批评他了。“却被维摩诘呵”指责他了，你这个是错的。</p>
<p>这个事情就很像后来的马祖道一被谁点醒的？怀让。怀让禅师是在惠能那里得到了印可的，后来惠能就跟怀让讲啊，将来从你底下出一个马驹啊，要踏下天下了。我先告诉你你别出去说，就从你底下会出一个了不起的禅宗祖师。后来果然如此，这个人叫马祖道一。马祖道一当初修行有一个阶段很像舍利弗。天天在那个寺庙里边怎么坐，坚持不懈地坐在那，一动不动。后来怀让知道了，怀让怎么办？怎么点醒他？你天天在那坐，我就在你庙门口天天磨砖。后来被这个马祖道一发现了就问：怀让，你磨砖干嘛？怀让跟他讲，我要磨砖让它变成镜子，磨砖成镜。诶，那个马祖这也奇怪了，砖如何能成为镜子呢？变成一面镜子。怀让马上跟他讲：坐如何能成佛呢？一句点醒了他。</p>
<p>这里的情况也是如此，舍利佛当时一个人静静地坐在树林里边打坐呢，一动不动的样子。维摩诘就跟他讲，你坐是坐不成佛的。一个道理。</p>
<p>“善知识，又有人教坐”教我们怎么打坐，说什么呢？</p>
<p>“看心观静，不动不起，从此置功”就从这里下功夫，</p>
<p>“迷人不会”迷人都不懂，都跟着学了，</p>
<p>“便执成颠”。哎有的时候打坐变成什么，走火入魔，</p>
<p>“如此者众”，这样的人太多了。</p>
<p>“如是相教，故知大错”，彼此教啊，怎么做啊怎么做。大错。</p>
<p>定慧品后面还有一段讲这个顿教和渐教的区分问题，我们休息一下再说。</p>
<p>各位，我们继续啊。我们读这个定慧品。，前面讲到这个定慧一体。然后又讲这个一行三昧。讲了这个三昧是怎样一种境界。</p>
<p>然后我们就翻到第86页。这第86页之后，就讲这个禅宗的最高法门——就是般若法门，以什么为宗呢？<strong>无念为宗</strong>。</p>
<p>他先说：‘善知识！本来正教，无有顿渐’，就佛法本身没有顿和渐的区分；‘人性自有利钝’。人有差别，有的人根性大利，快；有的人根性不利，迟钝。‘迷人渐修，悟人顿契’。<strong>契</strong>就是默契，<strong>悟</strong>就是<strong>我们的心灵与虚无的默契</strong>，一下子契合了，这就叫<strong>顿悟</strong>了。‘自识本心、’’’’；‘自见本性，即无差别’。所以顿渐的区别只是假名，只是因人而异而产生的区别。好，底下就来讲这个。禅宗作为般若法门，这个法门的最高原理是‘无念为宗、无相为体，无住为本’。无念是什么？无相是什么？无住是什么意思？底下说了，无相并不是否定事物有高低贵贱。你那个LV包比我这个包真实价格昂贵得多，质量也好得多。那个宝马的小汽车要比大众啊，那小汽车要好得多，这个相是真实的。无相不是否定这个差别。</p>
<p>底下说：‘无相者，于相而离相’承认有这个相，但不停留在这个相里，这叫<strong>无相</strong>。有相但不停留，停留叫住相或叫着相， ‘于相而离相’，这叫<strong>无相</strong>。</p>
<p>无念呢并不是什么念头都没有了，‘于念而无念’就不执念。无相就是不住相，于相离相；<strong>无念</strong>就是不执念。住相执念。</p>
<p>于念而无念，底下说什么？无住是什么？‘人之本性’。这个人之本性怎么解？有不同的解法，不同的理解啊。其实我认为呢，人之本性应该讲‘人生之本性’，加一个‘生’字，这就比较能够通了。<strong>无住</strong>者，人生之本性。为什么这么讲？人生如旅程啊，整个就是一个旅程嘛，你没办法停留在什么事情上，要承认这一点。我们每每做不到这一点，我们曾经有过的欢乐的处境啊，乐境、顺境，我们就想它永驻不变。其实人生无常，要彻底的承认这一点，这就叫<strong>无住</strong>。</p>
<p>承认这一点，我们就有一个很重要的人生、很好的人生态度来了。就底下说的：‘于世间善恶好丑，乃至冤之与亲，言语触刺欺争之时，并将为空，不思酬害，念念之中，不思前境’，这对我们是一个非常重要的提示。我们在人生的道路上，是吧？每每要遇到好、丑、善、恶……种种的区分，我们跟人家，跟人打交道，也会有人是伤害了你叫冤家；有人帮助你，叫亲，冤之与亲。然后你要争斗，言语触刺，大家彼此的这个愤怒起来，然后就把“言语触刺欺争”，这些事情很快就会空掉的，他停不下来的，并将为空！你想到这一点，你就不思酬害。哎人家当初得罪了你，伤害了你，你不要耿耿于怀，这些东西很快就空了。</p>
<p>无住是人生的本性，人生就是不断的一个旅途嘛。那些事情当时你很难过、很愤怒，跟人家争吵、言语触刺，事情都会很快就空掉了。回过头来多少年过去了，回过头来看，还有意义吗？没有意义了，在当时呢很认真，要知道“并将为空”，所以“不思酬害”。</p>
<p>我以前住在淮海路的，上海的淮海路。淮海中路，那个弄堂里边石库门的房子，公用的面积就是那个厨房啊，这个洗手间啊，就抽水马桶啊都是（公用），这个水龙头啊，就两个龙头。那么这个（楼）层面上就好几户人家。那么当时我们都是要工作的，是吧，我太太也要上班下班，回到家里嘛，那么你们都是退休的人嘛，你们能不能在我们上班的人回来之前，你们先把你们的活干了，不要占据这个水龙头不走，那么底下我们做饭、做菜、洗衣服的水没有啊。当时条件比较差，不像现在一家一户都很清楚，那么时间长了就会引起什么不高兴，不高兴嘛就争吵起来。当时争吵得蛮厉害，彼此都视若仇敌啊。后来我们搬家了，我搬到了复旦附近啊。回过头来会想念这些邻居的，然后再到淮海路啊再去探望他们，他们看到我们也是非常的高兴。一切一切的不愉快都已经过去了，不用耿耿于怀。</p>
<p>后来我就想，当时吵得那么厉害干嘛？“并将为空”，我们应当“不念前境”吧。以往过去的事情你还耿耿于怀干嘛？所以惠能说，人之本性是<strong>无住</strong>啊。所以应当这样的态度，善、恶、好、丑这种区分很快就过去了。冤家还是亲人也过去了，曾经有过的争吵、欺争，这些并将为空，不要放在心里，‘不思酬害，念念之中，不思前境’。</p>
<p>如果我们还是忘不了过去，这叫 ‘若前念今念后念，念念相续不断，名为系缚’实际上就我们被束缚住了，我们被过去绊住了手脚，我们应该向前看。这话很简单啊。也是个很通透的道理。</p>
<p>所以一个学佛的人，要善于夺境啊。当初那件事情发生了，多少人纠结于其中，争执于其中。你也在其中，你试试看能否把它夺了。我们在自己的生活和工作的经验当中，我们会有这样的体会。有一件事情当初发生的事，大家都觉得不得了的大事，都参与其中，纠结不已、争执不已。多少年过去了，回头再看这件事有意义吗？它老早烟消云散。</p>
<p>假如你当时就在其中，你能不能试试看，把他夺了啊？就像惠能跟惠明讲，惠明要夺回那衣钵嘛。后来这个惠能就只能把衣钵放在石头上，自己躲在草丛里嘛。惠明追上来了，惠能就在草从里跟他讲，‘这衣你搬不动’。惠明不相信，上去搬，果然搬不动。惠明跟草丛里的惠能说了：‘我不为衣来，我为法来’，我归根到底是为了求佛法而来的。那么这话说的好了，惠能就从草丛里蹦了出来，就跟惠明讲：你要听佛法是可以的，现在请你坐下。那么他就坐下了。然后惠能就跟惠明讲：‘屏息诸念’。叫他把各种念头都放下来，这等于叫他打坐。‘良久’，过了很长一段沉默的时间，慧明就开口说话了，两句话说下去，第一句话：‘不思善，不思恶’。你为什么要夺回衣钵？我知道的，你不能容忍我这个尚未出家的人啊，当时惠能还没有剃度出家，弘忍法师没收他做弟子呢，怎么好拿着弘忍法师的衣钵就走了？违背了佛教最起码的道德标准，这叫善恶的区分。</p>
<p>惠能知道他心里怎么想。所以第一句话跟他讲：‘不思善，不思恶’。今天的争执是毫无意义的。不是善恶的区分，不是在家还是出家的区分，而是谁能够担当传扬佛法的大任。所以第一句话来了，就把这个境给他夺了，我们的争执有意义吗？因为惠明也不是为了自己要把衣钵夺回来，惠明心里很明白，自己也没有资格得衣钵，这件事他清楚，只不过是他不能容忍什么？惠能拿了衣钵就走，违背道德标准。所以惠能第一句话就比较厉害了，很厉害，把这个境给夺了。</p>
<p>所以我们学一点佛学，经常要试试看，大家都在争执于其中，纠结于其中。这个境你也在其中，这个境有意义吗？试试看能否把它夺了。能夺的，你就先把它夺了，你就率先悟了。</p>
<p>所以惠能在这里说，这些东西很快都会过去的，并将为空。你不要念念不断的。念念相续不断，就是被过去束缚住了手脚。这叫<strong>系缚</strong>。‘于诸法上，念念不住，即无缚也’，也没有什么束缚着你‘此是以无住为本’。看清楚，人生就是这样。一切发生了，它很快就会过去。不要耿耿于怀，人生本来就是无助。</p>
<p>‘善知识！外离一切相，名为无相。能离于相，即法体清净’，（此是以无相为体），这叫以无相为体。</p>
<p>然后再看境：‘善知识！于诸境上，心不染，曰无念。于自念上，常离诸境，不于境上生心’。<strong>无念</strong>不是没有念头，没有念头叫<strong>绝念</strong>。<strong>无念</strong>是指什么呢？不于境上生心。于境上生心，就是妄念起来。哦这是顺境，我不能没有它；这是逆境，我马上摆脱它，这叫<strong>于境上生心</strong>了。其实顺境和逆境的区分来自我们的心，境由心生，心起了妄念，就区分了顺和逆了，顺和逆。</p>
<p>谈恋爱的时候，这种事情是最明显的啊。某两个人相爱了啊，然后那天晚上吧他们就手拉着手压马路去了是吧，开始倒蛮开心的，温言侃语、花前月下，后来不知道因为什么缘故，两个人口角起来，最后在很不开心的情况下分手了。大家回去睡觉。在这种情况下，你回去呢一下子还睡不着。恋爱中的情况，就这样啊，把刚才跟他相处的那一段时间，从头到尾像放电影一样放了一遍啊，究竞问题出在哪里？我们最后怎么会如此不欢而散的呢？但是后来想明天要上班啊朝九晚五的啊，所以赶快睡吧。第二天早晨一醒来心境就不好，不好了呢就去上班。这一天明明是阳光灿烂，然后你走到办公室，你就觉得许多（忧郁）周围灰蒙蒙一片呢，你在等待他的短信。9点钟没来，9点半还没来，但是你没办法，你忙着各种活呢。10点半还没来，11点还没来，11点半突然一个短信就来了，你打开手机一看这个短信，往日的温言款语又来了。就在这一瞬间，你突然发现今天阳光特别的灿烂，每一个同事似乎都向你露出了微笑。你变了吧？变了，境由心生啊。什么叫顺境？什么叫逆境？不是客观的，我们以为这个境界是客观的，顺境是客观的，逆境也是客观的，其实都是<strong>心</strong>生的。</p>
<p>你说：啊，由于某一个交通事故，某人受了伤，折了一条腿。这是逆境了。那么健全的人呢都好好的，顺境之中。天知道！你还得生活，你在一个残疾的情况下继续生活，这个人以后的人生是不是永远黯然无光了？不是的。你仍然可以活得有滋有味。上帝帮你关了一扇窗，一定帮你开另外一扇窗。一个人四肢健全，有钱有地位、有高级的别墅，他的境就是顺境吗？所以要想得明白啊。</p>
<p>我对<strong>境由心生</strong>的体会从哪里来？老早就知道这句话，<strong>境由心生</strong>。觉得能够理解，但是总不太相信啊，顺境与逆境的区分是那么客观的。比方说啊我认识一个中国富豪排行榜上有名字的富豪，我们已经相处了十几年了，彼此也算是朋友，大家都很忙。这个人名字我就不说了啊，这个人是大名鼎鼎的，不是郭广昌啊，但他也在富豪排行榜上有他的名字。在上海的是一个很大的集团，运作着几十亿的资产呢。当时是富豪排行榜上有他的名字，今天还排得上不我不知道，我们交往十几年，大家都很忙。但是但凡有空我会想到他，他也会想到我。一个电话打过来，今天晚上有空吗，有空就喝点酒，聊聊或者喝茶，就这样交往了十几年。我对他的生活处境非常的了解。他什么生活处境？他但凡有一个愿望要去实现的话，它能动员各种社会资源，甚至一部分政治资源，上海市政府都会出面帮助他。我一看这简直叫呼风唤雨啊！</p>
<p>我拿他的处境跟我王德峰的处境做了个比较，比较的结果是鲜明的：我什么处境呢？在大学里做教师，每年年终要填两份表格，一份是教学工作量表，一份叫科研成果表。一年两个学期你上了多少门本科生的课？多少门研究生的课啊？学生对你讲课的质量是如何打分的一一填上去。这张表刚填好，另一张就要来了。学术成果表、科研成果表。一年里边你在核心期刊上发表了多少篇学术论文？又在权威期刊上发表了多少篇？像复旦大学这个地方，一般期刊还不算数，要权威和核心。假如我王德峰连续三年这两份表格都填的不合格，结果会怎么样？我被送到人才交流中心去的，这就是我的生活处境。我把我的这个生活处境跟我那个朋友，富豪的朋友做了比较之后，我发现我的人生算是失败了。后来想一想，没关系，中国人那句话说得好，‘比上不足，比下有余’。</p>
<p>比方说我家里用的那个钟点工。她的处境就比我差了吧？她什么处境呢？也就是四川人在上海做钟点工，她的丈夫在广州打工，她孩子在家乡，父母代管着，就这样一个处境。一家三口一年最多有一次团聚的机会，有时候她过年都不回去的。我跟她讲，过年你怎么好不回去呢？你儿子在家乡想着你呢？她说我也想着我儿子，但是我不敢回去。我说为什么？你要知道我回去过一次年，会把我在上海做钟点工一年的积蓄的一半用掉。我说不至于吧？她说是真的。回到家乡要给父母带礼物啊这种东西，这是应当的，叫孝敬，是吧？那么这个乡里谁家出了什么喜事啊？红白喜事你一律的要参与，礼钱你就要送上去，看到人家的孩子要发压岁钱，这样一弄嘛，一半的收入就没了。更何况如果我在上海过年期间不回去，我做钟点工工资要翻倍，我还不舍得放弃这个机会。我说这怎么行？天伦之乐，不可放弃呀！这就是她的生活处境，我把自己的生活处境跟她这个处境做了比较之后，我心里安了很多，人生就这么比较出来。这个有一年我印象很深啊。那年冬天特别的冷，那一天特别的冷，我在复旦大学参加一个学术座谈会，这会还开得很长，从下午1点半一直开到5点半，总算结束了。我从会场里出来，我就接到我太太打给我的电话，跟我讲：今天外面特别的冷，你早点回来吧。我已经把晚饭做好了，赶快回来吃饭。那么我就很高兴，骑着自行车回去啊。我就复旦北区的校门出来，骑着自行车沿着那条路叫五东路。哎，往家里骑，骑着骑着我就看到路边站着一个人，这个人面前有一个很大的炉子，这个炉子上有一大堆红薯，我一看知道了，是烤红薯卖红薯的小贩。我发现他在寒风中瑟瑟发抖，这一天真是特别的冷，但是他眼门前那一大堆红薯没卖掉，我心里就在想，他恐怕此刻不能回去，一天的任务尚未完成，一天的生计尚未有着落，所以他必须坚持在这里。而我王德峰呢却可以马上回到家里，去吃那热气腾腾的晚餐。比较之下，我侧隐之心油然而生，我一口气买了他8个红薯。我心里想，我多买他一个红薯，就可以让他早一点回去。</p>
<p>我提着这8个红薯回家了，一路上心里边有自豪感。当然这自豪感呢，也未必是错。我确实是帮了他一下，有一种道德上的满足感，这叫布施吧。但是我一面有这种自豪感，道德上的满足感，同时还有一份优越感。我心里想，我毕竟是教授，他毕竟是小贩，我才帮得了他。这种优越感是什么感觉？我回到家里吃饭，坐下来吃饭，想着想着我发现我根本上错了，我在向他布施啦，但布施的同时我有份优越感，似乎我是居高临下的帮了他一把是吧？这叫<strong>有相布施</strong>。《金刚经》强调的是<strong>无相布施</strong>。人与人之间经常需要互相帮助，你看到他需要帮助，你就帮了他一把，你不要有优越感，你不要想着我正在布施呢。我居高临下，这叫<strong>住相布施</strong>，我本应当<strong>无相布施</strong>。</p>
<p>试想一下，某一天，有朝一日，我王德峰这个教授就需要帮助，而在这个场合，也唯有这个小贩帮得了我。他看到了这一点，他就帮了我一把。当一个这是在一个小贩在向教授布施。当他向我在布施的时候，他会不会住相？他一定无相，假如他住相的话，他就不帮我了。反正你是教授，比我地位高得多，本事也大得多，我何必帮你。他没这么想，他只是看到了我需要帮助，同时发现唯有他才帮的了我，他就帮了我一把，这就叫<strong>无相布施</strong>。</p>
<p>所以怎么看我们自己的人生处境呢？顺境和逆境的差别，苦境和乐界的差别，全是由心所生出来的。所以惠能在这里讲：‘于自念上，常离诸境，不于境上生心’，这是<strong>无念</strong>的意思。千万别把<strong>无念</strong>看成是百物不思，‘（若只百物不思），念尽除却，一念绝即死，别处受生，是为大错。学道者思之！若不识法意，自错犹可，更误他人；自迷不见，又谤佛经。’。这就大错了。所以要立无念为宗。底下说了：‘善知识！云何立无念为宗？只缘口说见性迷人，（于境上有念，念上便起邪见）’有一帮迷人，嘴里说自己见了佛性的，却于境上有念，念上便起了邪见，要趋利避害，要趋顺避逆，要趋乐避苦。这些全是邪见。“一切尘劳妄想，从此而生。自性本无一法可得”，这是一个根本的道理。人世间茫茫的海，人生之海，没有什么东西可以拉来做依靠的，这叫<strong>自性本无一法可得</strong>；‘若有所得，妄说祸福，即是尘劳邪见’。所以按照惠能的意思，我们也不应当去算命的啊。然后算命先生跟你讲祸、讲福啊，这叫妄说祸福啊，这都是尘劳邪见。</p>
<p>‘故此法门立无念为宗。善知识！无者，无何事？念者，念何物’。这句话关键了啊，也是把无、念两个字分开来说明吧？就像前面把功德两个字是吧，拆开来，先说功，见性是功，后说德，平等是德。现在也把无念这个词两个字分别说。<strong>无</strong>是什么意思？‘无者，无二相，无诸尘劳之心’。</p>
<p>那么<strong>念</strong>是什么意思？‘念者，念真如本性，真如即是念之体，念即是真如之用’这个等会儿再说，我们现在去看到了，先说无，再说念。合起来叫无念，不是说无是动词念是他的宾语，动宾结构，不是的。</p>
<p><strong>无</strong>是什么？<strong>无二相</strong>。很明确啊，种种的妄念来自哪里呀？来自二相，就是来自区分。利与害、成与败、得与失、祸与福、利与害，苦与乐、顺与逆，一对一对的啊。是与非都是一对一对的。那么我们在二中了。这一对一对的二元对立当中，我们就有一个趋向是吧？要趋利避害，要趋乐避苦、要趋顺避逆，这就是<strong>尘劳</strong>起来。我们做事情带着这样的区分来做，二相的区分来做，都叫<strong>尘劳</strong>。那建功立业之人都在尘劳之中，你要那个功要建成啊，那个业要立成呢，尘劳起来。你糊口谋衣嘛，没什么尘劳，人活着就要对付这个肉体的，肚子饿了要吃饭呢，天寒冷了要穿衣呢，这叫糊口谋衣，也没什么尘劳可言。你在糊口谋衣的同时，想着有朝一日成为百万富翁才好。尘劳要起来，尘劳都是二相造成的，我们做了这种一组一组的二元对立，这叫<strong>二相</strong>。</p>
<p>要知道佛法是<strong>不二法门</strong>，不二之法，你无了二相，你就没有妄念，没有妄念所起的念全是<strong>正念</strong>。为什么？这个念是来自什么？<strong>真如自性</strong>。是真如自性起念，这就对了。</p>
<p>他说‘真如自性起念，非眼耳鼻舌能念’。这话对。眼耳鼻舌会有欲望。肚子饿了，你就想吃东西。口欲嘛；肚子饿了，然后看到食物了，口内分泌的旺盛了唾液，这不叫<strong>念</strong>。念不是我们的眼耳鼻舌能生能起的，起念都来自真如自性啊！</p>
<p>‘真如有性，所以起念’。什么叫<strong>真如</strong>？<strong>真</strong>就是<strong>不假</strong>，<strong>如</strong>就是<strong>不倒</strong>，合起来就是‘真即不假，如即不倒’。我们从佛性出发看万事万物真实的意义，如其所示的领会他，如其本来的领会，它叫<strong>如如</strong>。如如之心，即是真实。合起来叫真如。</p>
<p><strong>真如</strong>就是我们的佛性。上海有一个庙叫真如寺啊，就是拿这个来命名的。</p>
<p>所以我们的真如自性起念，假如把真如拿掉呢？‘（真如若无），眼耳色声，当时即坏’。什么叫当时即坏？就是我先前讲的，人的感觉、属人的感觉、人性的感觉，没了，我们退化为动物的感觉，这个眼、耳、鼻、舌、身不再是人类的感觉了。</p>
<p>‘善知识！真如自性起念’如果我们从真如自性起念的话，“六根虽有见闻觉知”，并不影响我们，眼、耳、鼻、舌、身、意，叫六根，获得外部事物：色、声、香、味、触、法，这叫有见闻觉知。因为我们六根本身不能起念的，起念是真如自性起念，如果是真如自性起念，六根虽然染了外尘吧，其实不染，这叫‘不染万境，而真性常自在’。于是就如那个经文中所说的，这个经是《楞伽经》。楞伽经里边有一句话叫‘（故经云）：能善分别诸法相，于第一义而不动’。这两句话，先看什么叫<strong>第一义</strong>。第一义其实就是前面那句话，“不染万境，而真性常自在。”这就是第一义，第一义是<strong>究竟</strong>。佛理的意义啊，最高的，究竞的，就是这句话，“不染万境。而真性常自在”。</p>
<p>我们先前都说过了，我们的种种念头如海面的波浪起起伏伏呢，这叫现实的人生。这个海面、水面为什么有波浪起伏？因为有风吹的吧，风吹了就叫外境来了吧，你被外境影响了，你就波浪起来了，外境来了，你不要染着，你始终在你的真性之中。真性就是真如自性，那叫<strong>常自在</strong>。</p>
<p>这是佛法的、佛理的什么第一义，于<strong>第一义而不动</strong>，你才能善分别诸法相。事物之间的差别是真实的，你也能区分。但区分的时候不停留在这种区分上，这样呢，就把<strong>无念为宗</strong>的道理讲透了。</p>
<p>所以修禅宗就是修<strong>无念行</strong>啊，行是实践。禅宗这种修行的法门最高的宗旨就是<strong>无念</strong>。无念就是<strong>无二相</strong>，<strong>念真如自性</strong>，合起来叫<strong>无念</strong>。这是讲到根本了。我们要知道我们妄念的根源，妄念的根源就是在二之中。</p>
<p>其实道家的思想已经说明了这种，已经给了一个前提来理解佛学。老子就是非常反对你执着于两端的啊。比方说祸和福对立嘛，他说不对立，你的祸兮福之所倚，福兮祸之所伏。祸福转换，在一种福当中却隐藏着祸，那叫表面的幸运，背后隐藏着祸患。你以为他只是福，你忘了他的对立面就在背后隐藏着。然后你遇到了祸，你只知道他是祸，不知道什么？福会从中来呢。<strong>塞翁失马焉知非福</strong>。你在道家的智慧里，你就要破除二元对立了吧。那么把这个破除二元对立的道家思想运用到什么？理解佛陀的思想中去，这叫以老庄解佛。</p>
<p>佛学的中国化的第一步其实不是儒家，是道家的思想做基础，用老庄的智慧来领会佛法，这是第一步。所以我们感到非常惊讶的就是惠能其实是很通道家的思想，所以就强调了不二法门。利害得失这种二元对立都是错的，都是错的。中国人有这个智慧，未必是读书人。我印象很深的啊，就是我在工厂里干过3年半的工人。我75年中学毕业到一个全民所有制的工厂做工人，电焊工。我的师傅年纪已经蛮大了，我大概还没有满资的时候，他也就退休了。文化也不高，有时候我们聊天，那时候工作也比较闲嘛，一天8小时，大概做3小时活就干完了，然后坐下来就吹牛聊天。有一次不知道讲到一件什么事情，具体的事情我忘了，但那句话我印象太深了。我师傅跟我讲，他说：小王啊，当时就称我小王，我才19岁呀，小王啊，你要知道，世界上的事情有利必有弊，有弊必有利，你别只看到利的一面，也别只看到弊的一面。弊的背后就是利，利的背后就是弊。哎哟我觉得有道理啊，一下子很好的启发了我。回头一想，道家！再看看《道德经》吧，老子都说过这些话。</p>
<p>所以中国人的智慧啊是一种传承，以不知不觉当中啊，进入我们老百姓的思想。一个人在人生当中有所阅历的话啊，再想起这些话马上就通了。当时19岁的我呢，只是觉得，哦，启发了我，并没有真懂。现在60多岁，60岁了哈，全明白了。但是我们很容易只看到其中一端，看不到他的另一端。同样在这个事情上，所以不可执着。一执着，按照禅宗讲，妄念就起来，妄念一起来就尘劳来了，尘劳就是带着烦恼干事情了啊，根源在这里。于是定慧品就讲到这里结束了。<strong>定</strong>什么意思啊？<strong>见境心不乱</strong>。那就定了。不要染着这个外境嘛。</p>
<p>这就是定慧品。主题就是<strong>定慧一体</strong>，无念为宗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="坐禅品"><a class="header" href="#坐禅品">坐禅品</a></h1>
<p>那么讲到定慧，就自然要讲后面一个大的题目，禅宗嘛，要坐禅。惠能如何理解坐禅呢？因为向来，在惠能之前，禅宗已经开始传播了嘛。许多人是认认真真坐禅了嘛，坐禅嘛，有一套方法呢。这个惠能隐居了三五年，到处东躲西逃的，是吧。后来15年之后，终于他觉得应当时候到了啊，应当出头露面了吧，在广州法性寺出头露面的时候，他就讲了那句话，“不是风动，不是幡动，是仁者心动”。那个广州法性寺方丈印宗法师不是正好在说《涅繁经》嘛？听到这个人说了这句话之后，就知道此人不是一般人了，必有来历。就猜想他是从黄梅东禅寺黄梅那里来，所以就跟那个惠能讲，这个黄梅的衣钵是不是传给你了？因为惠能准备出来，就说不敢，就承认了。</p>
<p>承认了以后，印宗法师就问他第一个问题，是什么？就弘忍法师把衣钵传给你的时候，不是要教你们如何指授，有何指授？什么叫<strong>指授</strong>？他怎么教你坐禅的？因为禅宗都感兴趣这件事情。就禅宗向来就是说通过坐禅才能见性成佛嘛，那么坐禅怎么个坐法这是关键。恐怕弘忍法师五组是把这坐禅的密法交给你了，你现在既然出头露面了，那你能不能告诉我，弘忍法师教你怎么坐禅的呢？就有何指授。</p>
<p>惠能怎么回答的？‘指授即无’没有的，‘惟论见性，不论禅定解脱’。那印宗法师就很奇怪了，觉得很奇怪了，禅宗怎么好不讲这个禅定解脱呢？一切的佛教宗派都追求那个解脱吧解脱生死吧，通过什么方式来解脱呢？坐禅就是禅定了？其实禅定波罗蜜是六度当中的一种而已，有比<strong>禅定波罗蜜</strong>更高的波罗蜜的，叫<strong>波罗波罗蜜</strong>。所以惠能就讲清楚了，没有教我如何坐禅、如何入定，没这件事。</p>
<p>印宗法师当然觉得太奇怪了。然后惠能就跟他讲，只论见性啊。弘忍这个人就是这么讲话的，不论禅定解脱，那么如何见性。那么他说佛法是<strong>不二之法</strong>，这里行由品里都有的，我们简要回顾的啊。然后还得回答一个问题，你惠能主张的顿教啊，如何看待坐禅这件事？于是就自然有了第五品，坐禅品。</p>
<p>我们看一段啊，这个翻到第94页。</p>
<p>“师示众云”，惠能又说了，又讲开示了，‘此门坐禅’，禅宗这个法门坐禅，‘元不着心’。这个‘着’字不对，有好多版本都用了一个‘着’字，其实呢是一个‘看’字，“元不看心，元不看境”。这个考证啊，我曾经推荐过一个版本啊，就是上海古籍出版社出的《坛经》，丁福宝做的看境，这就对了，就是不是‘着’字，是看。‘元不看心，亦不看净，亦不是不动’。把‘着’字改成看‘若言看心，心元是妄’。你如何看这个心呢？这个心就是个小我之心啊，其实就是五蕴啊。</p>
<p>‘知心如幻，故无所看也。若言看净’。你坐禅就是一看心二看境，然后身体不动了。</p>
<p>那么‘若言看净，人性本净’。那我们的佛性本来就是清净的，‘由妄念故’妄念如遮盖太阳的云啊！‘盖覆真如，但无妄想，性自清净’。</p>
<p>底下说‘起心看净，却生净妄’。你要去看净了，你起的又是个妄念，这叫净妄。纯粹的干净啊。‘妄无处所，看者是妄’，这话对。</p>
<p>假如我们看净，那么自性本来清净，那么看净者又是谁呢？去看那个本来清净的佛性啊，自性。那么看者就不是这个自性本身了吧，自性是被看的。那么看者又是谁呢？显然是妄了吧，又是个妄。</p>
<p>又想起神秀的几句了，神秀说这个：‘时时勤拂拭，勿使惹尘埃’。前面说：‘身是菩提树，心如明镜台’，心如明镜台的是他干干净净的来，但是要沾染上灰尘呢，怎么办？擦吧，不停的擦。那么我们不免要问神秀一个问题，擦灰者是谁？马上就推出荒谬的东西来了。你要另设一个擦灰者吧，你自己的心本来干净，不用擦，你要去擦，谁来擦？在心之外另有一个东西来擦，有吗？没有，西方人有，叫上帝，上帝来拯救我们这个有罪的灵魂，对啊，那西方人弄出来的，中国人没有，中国思想中没这个东西。</p>
<p>所以坚定的相信自性本自清净，无所谓看，如果要看，谁看呢？‘看者是妄’，对了。</p>
<p>‘净无形相，却立净相，言是工夫’。有许多人修佛修得很认真，你也不能不敬佩的啊，但是这种人的毛病在哪里啊？着了净相。着了净相的人呢，也很难跟他打交道，你知道吗？他严格的很啊，他眼中是搁不了一粒沙子的。我们许多人跟他打交道，我们的行为都有毛病的，是吧。他一看就不对了，不对了嘛，他不理会你或者批评你了，久而久之人家就敬而远之，咱不跟你打交道。这个人叫着了什么净相。着了净相，（他）也在二之中，有干净和肮脏的绝对的区分，这怎么行？人家有过错。是的。为了一点私利，不好，道德上不可能那么纯洁，但是那点私利也是柴米油盐的事嘛，你也能够包容，只不过你你这个做法不好，我跟你讲是吧？但是你对他这个自己利益的追求，你也不要彻底否定，柴米油盐人人要对付它。天道在哪里？<strong>天道就在柴米油盐里</strong>呀！ </p>
<p>所以中国的思想在这一点上是非常健康的，它不像西方人要另一个理念的世界啊，把它跟现实世界对立起来。然后拿理念来比照现实事物，每一个现实事物都是对理念不完善的模仿，都是有缺陷的，于是这个世界要改造，柏拉图理念论。中国人从来没有改造世界的想法，中国人主张天道在人民生活中，所以《中庸》里边就讲 “极高明而道中庸”啊。中国哲学思想说出来的真理呀，高明的很呐。但他绝不脱离<strong>庸常的生活</strong>，极高明，达到极致，道就是实践啊，这个道是动词，道中庸，就是在人民生活中实践的。</p>
<p>所以不能<strong>着净相</strong>。所以惠能他也吃饭吃菜吧，跟猎人在一起吧。猎人那个锅就是肉锅啊，里面全是烧肉的，他没办法，他不能吃肉的，但他也得煮那个菜吧，就这一个锅，他把菜放到肉汤里了是吧？一个猎人就笑起来，你怎么这样呢？你不是修行的人嘛，要吃素嘛。惠能怎么回答：“我但吃肉边菜”。就这样，假如真没素菜，它也得吃肉吧？也得吃。所以没有这种非常明确的啊坚硬的区分，干净与肮脏，真谛与俗谛，不能这么区分的。</p>
<p>所以先破一点，讲坐禅的道理的时候，先破除一点。坐禅不是看净，不是看净，也不是不动。但有的人就立了净相了，怎样的是干净的，怎样的是不干净的，把它立好，净无形象。哪还有一种明确的标准，拿来不断的衡量，一把尺度啊就把这一量，这叫肮脏啊，这叫干净，没的。‘作此见者’有这种见解的人叫 ‘障自本性，却被净缚’，被这个净束缚住了。</p>
<p>然后再讲那个不动是什么意思？‘善知识！若修不动者’，坐禅不是讲究那个不动嘛？‘但见一切人时，不见人之是非善恶过患，即是自性不动’。所以别搞错了，不动不是身体不动，什么叫禅定？惠能讲得非常简洁明了，也通俗易懂，就不要去见他人的是非善恶过患，你一见他人的是非好恶，你的自性动了。什么叫不动？是自性不动，不是身体不动，自性不动的体现是<strong>不见他人之是非好恶</strong>，这条原则。</p>
<p>其实我们在这个社会中生活啊，让我们的心经常要动的一个非常重要的方面是<strong>人际关系</strong>。我们人际关系当中的苦恼每每来的是哪里呀？我们跟他们打交道，跟某人打交道、这些人、那些人打交道当中，发现他们许多的<strong>是非、好恶</strong>。然后我们就心里就跟着这种事情走了嘛，不断地在动，我们也不动，要清净。你这样做到就能清净了，你否则永远没完没了。哪有天下你遇到的人全是让你觉得很好的，干干净净的、很正直的啊，你真希望永远跟这些人打交道。世界上有这种事情吗？各色人等啊。你要坐禅的功夫就花在这里，日常生活中坐禅。</p>
<p>然后我们就不会被这个人际关系所扰了。人际关系让我们心里的喜怒哀乐都起来的原因是什么？就是看见他人是非、善恶呀。就这种事情，你多想想自己有什么过错，别去管他人的是非，他人的事情有是非，人没有是非。只要走这条原则，你就心很定，自然清净。</p>
<p>中国社会、中国文化有一个很大的毛病，要通过禅宗来清洗，什么毛病啊？<strong>内耗</strong>！到现在恐怕都没有解决，大家一起做一个事业蛮好嘛，这个事业许多坎坎坷坷，来自哪里呀？每每不是来自这个事业的对立面，而是来自一起做这个事业的人际关系<strong>内耗</strong>。西方人有这个好处的，因为他们基督教一千多年的时代嘛，人都从家族的关系当中被拉出来了，进入一个团体的个人，进入团体中的个人，在上帝面前大家平等。一千多年前，基督教的教化啊。父子之间在家里叫什么？叫家族关系吧，父子关系；父子到了教会里面他们就不是父子了，叫教友。</p>
<p>西方人搞资本主义有一个前提的啊，资本主义起来就个人主义原理嘛，要有独立的个人吧，独立的个人怎么形成的？不那么简单，不是观念改变了就行。中国社会向来是家族本位的社会。那么西方最初阶段也是家族本位的社会，因为人总是出生在家庭里的吧，父母生养的，也是家族本位。但是经过中世纪一千多年基督教时代，这个时代就把个人从家族中拖出来了，纳入到一个团体，叫宗教团体——教会。这一千多年的时间训育了欧洲人，然后这个宗教团体解体了吧？中世纪晚期教会瓦解，这些人从教会出来了，从团体中出来，进入<strong>个人本位</strong>的社会。</p>
<p>我们没这个中间阶段，那么我们的家族也在解体之中，但是没有经过什么团体中的各种这个驯化啊，这就进入了今天的社会，无所适从！不是独立的人格，而是<strong>利己主义的个人</strong>。然后做事情，以前凭家族的力量，是吧？现在家族解体了，凭借什么？<strong>熟人关系</strong>。今天中国社会叫熟人的社会。不是讲那个理性的规则吧，西方人是经过一千多年的基督教时代才做成的这件事。</p>
<p>所以中国人呢就这样一个社会的这样一个历史阶段，造成的一个很重要的病症，就是这个病症。西方人可以按照<strong>契约的精神、理性的法则</strong>打交道，你要好也好，坏也好，是也好，非也好，我不管。咱们在这个规则里边做事情就好了，我要说你是好人还是坏人干嘛呢？你做的不对，是有那个契约原则在，就用那个规则在嘛就好了。</p>
<p>中国人不是这样，所以中国人总是内耗，所以禅宗来帮助我们清洗这个东西。不要见他人之是非善恶。中国人最喜欢讨论别人。到现在还是，网上也是，人家明星的事情关你什么事？离婚了又结婚了，你起劲得不得了啊，说这个人好，说这个人不好，大家议论纷纷。干嘛？人家的private life（私生活）关你什么事？你管好自己的事吧！你要检查自己的过错，不见他人之是非，我们现在吃惊得不得了。后来有人告诉我，这里边也有商业利益，专门有电视频道专门时尚频道，上海啊。那个时尚频道一天到晚要把那些明星拿出来说事情，还请他们出来，他们也愿意出来说自己的私生活，我说为什么？他们说他们要保持什么这个影响力，社会关注程度。居然是这样的。我就觉得蛮奇怪，其实应该还明星一个宁静吧，他们也宁静不了。</p>
<p>所以这些事情就是我们读《坛经》，就看到惠能就讲了，什么叫坐禅呢？<strong>生活中坐</strong>！一个最重要的事情就是<strong>自性不动</strong>。什么叫<strong>自性不动</strong>？<strong>不见他人之是非好恶</strong>，那叫<strong>自性不动</strong>。他说‘迷人身虽不动’，他坐禅做得很好哦，身体不动。但是只要他一开口，打坐刚结束，‘开口便说他人是非长短好恶’，你这打坐不是白打了吗？‘与道违背，若看心看净，即障道也。’说得分明，也通俗的啊，对我们很有启发。</p>
<p>‘行亦禅，坐亦禅，语默动静体安然’。行就是做事情，做就定下来了，静下来、没事做，都是禅。<strong>语</strong>，就说话；<strong>默</strong>，就是不说话。动、静，无论什么状态，语默动静体安然，这个<strong>体</strong>就是<strong>心体</strong>，<strong>心体不动</strong>。永嘉对坐禅做了这个说明，并不是把我们的生活分为两块，一块是坐禅，一块是日常实践，做区分就不对。坐禅的时候心很定了，终于静下来了，坐完了之后呢，又不对了。就像这个94页最后一段说的，‘善知识！迷人身虽不动’他在坐禅，坐完了 ‘开口便说他人是非长短好恶’。这样就叫‘与道违背’。你在坐禅的时候看心、看净，然后坐禅结束了呢，开口便说他人是非，就分开来了。</p>
<p>其实我们在日常生活当中，始终在坐禅，都在坐禅。坐禅要达到禅定，禅定的标志是什么？<strong>真正的禅定你就在做事情的时候定</strong>。啊我们现在忙得不得了啊，这个时代是节奏很快的，你越到大城市越如此，哪里定得下来是吧？你能不能在大都市的现代生活当中能定呢？可以的。禅宗的意思就是身忙心不忙。<strong>身忙心不忙，这叫坐禅</strong>。一天到晚上我忙得要死，睡眠时间大概也就四五个小时，这样的忙人也是有的，你怎么办？没办法，你要承担许多责任啊，要做许多事情啊。我们想到的是身体要补药了，吃这个吃那个来维护身体健康，其实更重要的不是吃什么补药来维持自己身体，而是心。心要定，叫身忙心不忙。这个道理呢是蛮重要的、蛮基本的啊，所以有些老百姓的俗话呢说的蛮对的啊：做事情做不死人的，气要气死了。气是心里的事情。你忙的要死不会有问题的，你只要心定啦，你的喜怒哀乐不合适了，你要出事情。这句话有道理，禅宗的道理做做不死人的，气要气死人的。我们的问题是心出问题啊。这个身忙心不忙，不要倒过来身不忙心忙，这个道理。</p>
<p>所以他这里很有意思，那个人还坐着呢，但他是迷的。坐禅很认真，刚坐好就说人家是非，开口说人家是非，就他心乱了。这个人好，这个人不好，恨这个人。你心就在乱的，这个坐禅不是白做了。他人无是非，这是一个前提条件。我们讲戒的时候就讲这个道理，<strong>事情有是非，人无是非</strong>。这一条要守住，就是戒了，最难守住就是这条。那个人做了坏事，因为这个坏事是他做的，就把这个坏字用到这个人身上去了，叫坏人。其实没坏人的，有坏事无坏人，要守住这一条的，这一条是做到、达到了，不得了！你永远不会去恨一个人，你恨一个人你自己就心乱了，谈什么定呢？就没办法定了，但是要把这个道理想透啊！变成我们的生命情感，这是难的。因为我们是自然而然把做坏事的人等同于坏人。我们心中就起了恚恨，一起恚恨，那就是乱了。</p>
<p>所以与人打交道是难的。最难那个难在区分好人、坏人，这件事是错了。这是根本的。人都有佛性，做了大恶事的人，佛性也还在的。我们跟他打交道，照样打交道。我们如果要度自己就是度他人。度他人的意思就是向他指出这件事错了，但是你仍然尊重他。就做到这一点。为什么要尊重他？现在是有病，叫迷了。<strong>前念迷是凡夫，后念悟就是佛</strong>，放下屠刀都立地成佛了。有一个根本的这个认识啊，在心里，别忘了那就好了。</p>
<p>我们心乱就乱在跟人打交道这件事情上。所以惠能在这里突然说了，看上去很突然，讲个‘身虽不动，开口便说他人是非’，为什么要讲这句话？就在告诉我们什么叫坐禅。这些大思想家，像惠能啊，说话不随便说吧，必有缘故啊。在讲坐禅的时候，为什么讲不能说他人是非呢？这叫真坐禅呐。不说他人是非，又没把他人看成是非，就不区分人的是非，只区分事情的是非，你才定了。着了净相的人，就最容易说他人是非，他也许自己是道德品德、是品行端正的人，这没错，但他要说他人是非，他立了一个净相。你看第二段讲的多好：‘善知识！若修不动者’，什么叫不动啊？‘但见一切人时，不见人之是非善恶过患，（即是自性不动）’就叫<strong>自性不动</strong>。</p>
<p>所以我说我的标题叫**《人生态度》<strong>，这叫人生态度。不是实际上身体不动，坚持不动两个小时，不是这个意思。<strong>心不动</strong>，人生态度的改变是最根本的。人生态度不改变，老觉得周围的环境在跟自己作对呢。什么叫环境？就人际关系。在单位有单位的人际关系，在家庭里边有家庭中的人际关系。老觉得不舒服，环境在跟自己作对呢，哪有环境跟你作对？没有任何环境跟你作对。我说这环境是</strong>人际关系**，所以这是事情的根本。</p>
<p>我在这里引用一首诗啊。南台和尚当时也是唐朝的一个和尚，蛮有意思，写了一首诗，看看有道理。他也讲坐禅呢：‘南台静坐一炉香，终日无心（原为凝然，不是无心）万虑忘’。</p>
<p>南台和尚说他的修行啊，就是这样的。坐在那里静坐，点一炉香。达到什么境界呢？“终日无心万虑忘”。我为什么能达到这个境界呢？不是因为我做了那么多巨大的努力啊。细心除妄想，不是的。你这样努力没用的，心还不断地动呢，妄念还不断地起呢。其实，我能达到这境界，就最后一句话，“只缘无事可商量”。很有道家境界了。中国人把佛学中国化的前提是什么？一个儒家，一个道家，尤其是道家起了很大的作用。中国人一开始接触到佛陀的思想的时候许多不懂。后来发现用老子和庄子的学说可以理解的，叫以老庄解佛。那么道家的境界在这个南台和尚这首诗里边就很显然地出来。在这里道家和佛家的思想是相通的，因为道家最反对人为嘛，<strong>无为而无不为</strong>。</p>
<p>人类生活的幸福都来自天，人类社会，人类生活的麻烦和苦恼都来自人自己呀，所以要尽可能拿掉人为的因素。那么彻底一点想，就是南台和尚讲的，你以为天下的事情可商量？其实没什么好商量的。你明白这一点，种种的妄想就自然没有。</p>
<p>那个定慧品里边讲，“自性本无一法可得，若有所得，妄说祸福，即是尘劳邪见。”看这句话啊，回顾一下定慧品。87页上，第2段的第2行。“自性本无一法可得。”这句话的道理呢，也就是说我们在这人世间没有任何东西可以依靠的，我们好像得到了什么，其实没得到它。现在有的人说这个道理：你说道家的思想很重要，这个要放得下吧？道家教我们放得下。</p>
<p>有三句话，<strong>儒家教我们拿得起</strong>，能担当责任，道家教我们放得下，<strong>佛家叫我们想得开</strong>，是吧。那么他们说放得下，前提是先要有东西，然后才说放得下。你都没东西谈什么放得下，先要有东西可放下。这样的解释听上去很有道理。但是佛家讲得更彻底，你以为你有东西，没有的，你并无所得。也就自然没有什么放得下放不下的问题，本无所得，这更彻底了。好像我们要达到道家的境界啊，按照那种解释，先得有所成就啊，然后不被获得的东西所束缚，然后我们就放得下了。其实你根本没得，这才是根本的认识。</p>
<p>“自性本无一法可得。”你如果说有所得，那叫妄说祸福啊，若有所得自然要妄说祸福，要算命了，我能得什么？所以按照佛家的看法，那些算命先生都叫妄说祸福呢。就比道家好像更近一层啊。如果是妄说祸福，即是尘劳邪见。</p>
<p>所以就是从定慧品的这一层意思，我们就可以看得出来，南台和尚这首诗有道理。“只缘无事可商量”。也就是我们曾经讨论过孟子讲人生总有求啊，有两种求，人都有追求。</p>
<p>一种是“求则得之，舍则失之，是求有益于得，求在我者也”。</p>
<p>还有一种求叫“求之有道，得之有命，是求无益于得，求在外者也”。</p>
<p>我们大多数情况就是第二种求。求是有方法的，但得还是不得由命的，但我们不知道，我们就求吧。其实求在外者。</p>
<p>比方说你办一个企业，第一种求是什么？你不办这个企业就不存在，办了这个企业就存在。存在了就对社会生活做一点贡献，“求则得之，舍则失之”，你不办企业，你对社会没贡献。“是求有益于得也，求在我者也”。</p>
<p>但是如果你办企业，是求第二个种求，求他成为这个市场舞台上的强大的企业。这个呢，“求之有道”，你到那个大学里读管理科学去了，读MBA、EMBA，那是有方法教你的啊，怎么提高你企业的经济效益，一整套方法。究竞得还是不得呢？企业的强大有命的。我们大概但凡在人世间做过一点事情的人都会有体会。比方说企业会争取一些订单吧，然后你就去谋划，然后你在谋划的时候，你就在计算着自己将来应该有多大的效益，有多大的利润，究竞得还是不得你所期待的那个利润，你以为全出自于你的正确谋划和严谨的实践。我们都这么想的，叫“求之有道”，正确的企划。这个严谨的实践，然后最后得了这份利润，这个利润终于被作为你的获得物到手的话，其实在你之外，<strong>这是有命的</strong>。我虽然没做过企业。在其他的人生领域里边，道理都一样。</p>
<p>所以孟子的这个意思呢就是儒家的意思，还有老庄的意思。这两个方面的智慧让我们中国人把佛学中国化。</p>
<p>第一，要知道成败得失，这种事情没什么好商量的，不归我们管。如果是这么想，如南台和尚讲的，当然是<strong>万虑无妄</strong>。妄想什么都不起来。所以这个坐禅品呢前面一部分破除了以往对坐禅的一个理解，这种理解呢导致一种错误，就是把生活分两块，这两块是各不相干的，其实这个坐禅也就白坐了。站起来便说他人是非，就是身体没动，心已经站起来了，心已站立。这是破除以往对坐禅的种种的解释。</p>
<p>第二，后面部分就讲真正的禅定。我们看，95页上。“何名坐禅，善知识？此法门中，无障无碍，外于一切善恶境界，心念不起，名为坐”。身体不动，心念起来就根本没坐。虽然身体不动，心念不起才叫做坐。在什么事情上心念不起呀？<strong>善恶境界</strong>。好的不好的，种种的外境。在这种外境面前心念不起，这就叫坐。“内见自性不动，名为禅。何名禅定？外离相为禅，外不乱为定。外若着相，内心即乱。外若离相，心即不乱。本性自净自定，只为见境思境即乱。”本来我们是定的，也是干净的，这是因为见境，思境就乱了。“若见诸境心不乱者，是真定也。”最后一段，“外离相即禅，内不乱即定。”又重复了这句话，可见这句话重要。禅是什么？<strong>离相</strong>。定是什么？<strong>心不乱</strong>。<strong>外禅内定</strong>就是<strong>禅定</strong>。《菩萨戒经》云：“我本元自性清净。”惠能虽然不识字，但听经听得很多，听了就记住叫过耳不望，能读书的人叫过目不忘，他过耳不忘。所以这句话马上就引用了，“我本元自性清净。”“善知识！于念念中，自见本性清净，自修、自行，自成佛道。”于念念中，你在日常生活中就在种种念中了，就是在日用常行当中，有一个<strong>基本的人生态度叫****无住离相</strong>，这就是自修，自成佛道。充分说出了禅宗的最高的自性。这个自性很难建立起来。这就是坐禅品，蛮短的，主要就是两大段。解释了坐禅之后，惠能还得说明整个佛教修行他那个功课。这样我们就进入了第六品。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="忏悔品"><a class="header" href="#忏悔品">忏悔品</a></h1>
<p>忏悔品的主题叫自心忏悔为主题的禅宗功课。这是完全进入佛教来讲事情。什么叫完全进入佛教？就是按照佛教的根本目标，修行的根本目标就是就是<strong>摆脱生死的苦海</strong>。世人生死事大。这是弘忍法师跟那帮弟子们讲，在那个行由品里边有，把众弟子们叫到身边，因为弘忍法师觉得自己真是要解决一个问题，衣钵传给谁？自己年岁大了。把众弟子们都叫到边上，第一句话就跟他们讲“世人生死事大，汝等终日只求福田，不求出离生死苦海。自性若迷，福何可救。”这句话我们都读过了，行由品里讲。就你们这些人啊，跟我学佛那么多年，一天到晚在干嘛呢？求福田。种福田求福报，把这个当成是佛教的修行。不求出离生死之苦海，自性若迷，自己的本性看不到，福何可救。福何可救什么意思？做善事得福报，佛教承认的啊。那个达摩认为梁武帝造了那么多庙，供养了那么多和尚，不叫<strong>功德</strong>，但叫<strong>福德</strong>。这是真的。</p>
<p>佛教不论什么宗派都承认因果。<strong>已作不失，未作不得</strong>。我们后来所受的都是我们曾经做的。我们有了富贵也是我们曾经所做的而得的<strong>福报</strong>。今世的富贵来自前世所做，所以它是因果不断。已作不失未作不得，所以福报是真的。但是你得到福报，福报就能救你吗？，不能救你。</p>
<p>什么叫救？<strong>消业</strong>。恶业还在，罪业还在。罪业不是因为你得了福报就消掉的啊，得福报并能消罪业。这是一个基本的佛教认识。修福有好处。得福报也是真实的。但他不能消罪业，就这个意思，这叫<strong>福何可救</strong>。你得了福报，仍然不能出离生死之苦海，在这件事情上不能得救。比方说这辈子做了好多好事是吧？做了<strong>布施</strong>，<strong>布施</strong>六度啊，六种波罗蜜，前面三种全是<strong>福德</strong>，第一叫<strong>布施</strong>，第二叫<strong>持戒</strong>，第三叫<strong>安忍</strong>，那叫<strong>福德资粮</strong>，并不是<strong>功德</strong>。后面三种叫<strong>精进、禅定、般若</strong>。后三种是<strong>智慧之粮</strong>。你<strong>得了智慧之粮才能消罪业，才能摆脱生死</strong>，所以分得很清楚。这辈子贫贱，但是由于做福德做得多，下辈子有富贵，不假。但富贵不解决根本问题，下辈子的烦恼恐怕比这辈子更多。</p>
<p>所以这是一个根本的问题。就我们就是佛教本身来说，他的目标就是<strong>消业</strong>，累世累劫的罪业要把它消了。我们不管自己信不信这个目标，但是我们就佛教来说，它就是个目标。正因为佛教有这个根本目标，它才有一个非常重要的观念，是中国思想中本来没有的，叫<strong>罪</strong>。犹太教思想就是以一个<strong>罪</strong>字作为关键词。当时轴心时代，公元前五世纪，有四个民族打开了四种思想和智慧的境界。<strong>一个是中华民族儒家和道家，一个是古印度释迦牟尼的学说，一个古代希腊的哲学，还有一个古代以色列犹太思想</strong>。其中有两种思想和智慧的境界里边并不存在罪的观念啊，一个是中国的<strong>儒家</strong>、<strong>道家</strong>没有罪的观念，一个古希腊苏格拉底、柏拉图哲学也没有罪的观念。另外两个思想境界都有罪的观念，犹太教是最明显的。首先讲<strong>原罪</strong>，人都有罪，释迦摩尼也讲人有罪。中国思想当中本来没有罪的观念，只有<strong>过错</strong>。所以罪这个观念起来就有忏悔的事情要来。中国人在佛学中国化之前，中国人没有忏悔的观念。你看，按照佛教，假如一个亡者他生前没做过任何坏事，简直是十全十美的，在道德上无可指责。即使这样的人，他去世之后，他的家人也要帮他什么做佛事，帮他忏悔。这是毫无疑问的事情。我们想这么一个好人啊，伟大的无产阶级革命家，杰出的共产主义战士，走过了光辉的一生。按照佛教要帮他忏悔的，还是要忏悔。他是有罪的。你想这是一件什么样的事？佛教讲的道理很清楚，他如果罪业消了，他怎么会又被抛到这个世界上来呢？又来折腾这一辈子呢？就是罪业嘛。所以我们又来到这世界上，这一辈子几十年过来折腾了很多，爱爱恨恨，烦烦想想。种种的苦恼、欢乐、痛苦不断交替，不就是罪业在的证明吗？否则你不会这么来，你如果罪业消了，你如果再来到这世界上，那叫<strong>乘愿再来</strong>，带着使命完成了之后就走，那叫自由了。你并没有自由，所以你又被抛到这个世界上来了。那么这样的人走了，哪怕是一生的好人，照样要忏悔，就这个原故。那么犹太教所说的比较简单，人有原罪。佛教的思想进入中国然后被中国化。之后，这个观念就起来了，但这个观念并没有达到一种普遍的程度。</p>
<p>今天中国的佛教信仰者多的不得了是吧？可以说每一个老百姓多少都信佛的，他已经成了我们的文化习俗。这个大年三十晚上要去烧头香，那个龙华寺的头香的票是很很贵的啊，你还弄不到。那么到了大年除夕晚上的时候，上海龙华寺门口警察多得不得了，因为那里人山人海，你看都像信佛嘛，要烧头香嘛。中国那么多人，不知道有多少庙，是吧？比方说孩子要高考了，要到普陀山去了，到普陀山去嘛去许愿了。如果考好了，考成功了，要还愿吧？别忘了再到普陀山去一下。那么这一切对佛教的信仰呢里边根本没有任何罪的观念，就是求菩萨保佑的。忏悔的意思，从来没有。但佛教本来就有一个忏悔作为佛教修行功课的主题。我们其实有罪。</p>
<p>所以这第六品的名称，定为<strong>忏悔</strong>二字，这就表明禅宗功课以忏悔为主题。那么然后忏和悔两个字。先分别说<strong>忏其前愆</strong>。<strong>悔</strong>呢？<strong>悔其后过</strong>。这个分别有两层意思。<strong>忏</strong>是指<strong>对以往的过错</strong>，意就是过错。<strong>悔</strong>是指向<strong>未来</strong>的，要避免以后再犯，悔其后过。合起来叫<strong>忏悔</strong>。这样我们就进入了忏悔品。忏悔是修行的前提。就是按照佛教的这个最严格的目标来讲，一个人如果没有忏悔，他不能说自己进入了修行。求福田得福报，跟消业一点关系都没，罪业没消嘛。如果你把消罪业看成是修行的根本目标，那么修行的前提就是<strong>忏悔</strong>。</p>
<p>这事情说起来是蛮大一件事啊，后来西方思想当中有一个叫卢梭的，也懂这个道理。人世间最大的问题不是出在我们做事情的知识经验是正确与否，人世间最大的事情是我们的心所起的<strong>愿望</strong>。卢梭是法国大思想家。所以这个在这些中西思想的境界的核心处就有相通的地方。那么我们如果不谈佛教的修行倒也罢了，一谈修行一件事情很根本，就是承认自己有罪业。既然承认了有罪，就得忏悔，<strong>忏悔</strong>是核心的环节。</p>
<p>我们上午已经进入忏悔品的讨论。前面行由品、般若品、疑问品，疑问品讲出了禅宗所认识到的、所理解的<strong>戒</strong>，<strong>戒定慧</strong>。所以第四品就是定慧品。然后禅宗一定要讲清楚坐禅的道理，所以第五品就是坐禅品。何为禅定？<strong>外离相即禅，内不乱即定</strong>，合起来叫<strong>禅定</strong>。<strong>于相离相</strong>，不是否定相。相是客观的，但不停留在相中，这叫<strong>于相离相</strong>，这就是<strong>禅</strong>了。那么什么叫内不乱？<strong>见境心不乱</strong>，这就是<strong>定</strong>了，合起来叫<strong>禅定</strong>。在我们日常生活中，每时每刻都能做，“行亦禅，坐亦禅。语默动静体安然。”这话说得好，是永嘉禅师所说。讲了坐禅之后呢，就得讲这个佛教所有的宗派都共同承认的，就是人有罪。罪的观念，由于佛学经过中国才传到中国思想中来，本来中国思想中没有罪的观念，罪和错误是不一样的，<strong>错误是可以纠正的</strong>。有一种错，一旦发生了就无法挽回，那叫<strong>罪</strong>。不是一般的<strong>过错</strong>。</p>
<p>我回顾我自己啊，最初领会到罪的观念就是一部小说叫《牛虻》。小时候读过，一位意大利作家写的，后来传到中国。那个蒙泰尼里主教啊，我们如果读过这个小说的人应该知道，这个人物他有一个私生子。天主教的主教本来就不能结婚的是吧？更何况他居然有一个私生子。这个私生子就是这部小说的主人公，后来取笔名叫牛虻的，少年时候他的名字叫亚瑟。他的生身父亲是他崇拜的神父，他并不知道这神父是他的亲生父亲。后来这件事情才暴露出来，这让一个虔诚的、相信天主教的年轻的亚瑟非常痛苦。后来他要自杀，当然没死。飘泊的南美洲历尽苦难，然后再返回意大利。他加入了一个党派了，要争取意大利的独立。那么回到意大利之后呢，他精神上不断地跟谁战斗呢？就跟他的父亲蒙泰尼里主教。其实他又深深地爱着他的父亲。蒙泰尼的主教面对这样一个事情，他非常痛苦的。他一辈子没办法解脱这件事。后来牛虻不是被抓起来了嘛，因为领导意大利独立运动，后来被抓了，抓了以后就是死刑啊，要被枪决。等那个牛虻被枪决了之后，蒙泰尼里主教就疯了。我少年时候读这部小说，第一次意识到人类社会当中有一种错误是不可犯，这就叫<strong>罪</strong>。蒙泰尼里主教一生不能摆脱的东西，那种痛苦。</p>
<p>这个罪的观念呢，就是最初由佛陀的学说传到中国以后，进入中国思想。有罪就得解决问题，没有别的方法。在佛教看来，第一步就是<strong>忏悔</strong>。我们上午进入忏悔品之前，先说一件事，也就是在那个疑问品里边讲清楚的道理，就是梁武帝造那么多庙，供养那么多和尚只是福德，不叫功德，会得福报，但不能消罪业。那么上午也讲到六度，就是六种<strong>波罗蜜</strong>，<strong>波罗蜜</strong>去渡有六种度的途径，就是<strong>布施、持戒、忍辱</strong>前三种，<strong>精进、禅定、般若</strong>后三种。那么前三种叫<strong>福德之粮</strong>，后三种主要是<strong>智慧资粮</strong>，所以智慧才能消罪业。就我们转识成智的话。我们布施啊，持戒啊可以得福报，这要做一个区分。</p>
<p>所以中国思想后来在对佛教的认识呢就形成这样一句话，叫<strong>福慧双休</strong>。修佛要修得福报，但智慧也要修啊，那要消罪业，合起来叫<strong>福慧双休</strong>。那么修智慧要有一个真正的出发点，那叫<strong>忏悔</strong>。人类追求真理的动力是什么？<strong>痛苦</strong>，不是一般的<strong>烦恼</strong>。人类始终以痛苦为代价寻求真理。我们要进入智慧，是因为遇到痛苦，<strong>小烦恼</strong>用<strong>知识</strong>来处理。今天我们这个民族再度的想要重返思想和智慧中去，是因为这个民族遇到大痛苦，那就要修慧了，道理是一样的。我们整个这个民族要忏悔，我们在其中的每一个民族的成员也要忏悔。我上午就讲到了，那么多口业造好了是吧？什么时间就是金钱，效率就是生命。什么谁致富谁光荣，谁贫穷谁耻辱。笑贫不笑娼，全是<strong>口业</strong>。这叫<strong>罪业深重</strong>。所以佛教是彻底的，要求我们坦率地面对我们本有的罪业。然后我们提到，一个人这一辈子是在道德上无可指责的好人，他走的时候，他的家人还得帮他<strong>忏悔</strong>，然后<strong>超度</strong>，原因就是这个。我们如果没有罪业，我们怎么会又被扔到这世界上来啊？再折腾这几十年呢？佛教说因为有罪。这样我们就知道为什么第六品被称为忏悔品。这个佛教的功课这样5个环节是吧？<strong>传香、忏悔、发愿、皈依、成佛</strong>这5个环节当中，特地的把第2个环节拿出来做主题，就是这个缘故。大多数中国人都可以说是信佛的，所以我们要烧香许愿。佛教成了中国文化的一个方面，但大多数中国人并不忏悔。所以真正的修行，不是种福田求福报，所以弘忍法师对他的弟子们都不满意。“世人生死事大，汝等终日只求福田，不求出离生死苦海。自性若迷，福何可救。”得福报并不能救我们，因为罪业未消。</p>
<p>那么一切罪业根源在哪里？这可是大的哲学问题。你到非洲去，你会居然看到如此的场景：狮子和羚羊一起散步。为什么呢？因为狮子吃饱了，吃饱了他就跟羚羊一起散步。人吃饱了会太平吗？不太平。我不知道我在这里讲过没有，就是圣奥古斯丁。西方有两个大思想家写过同名的书《忏悔录》。一个是中世纪教父哲学的开创者圣奥古斯丁，他有一部著作就叫《忏悔录》。后来又来一个人，他也写一部《杆悔录》，这个人是谁呢？卢梭。所以西方有两部《忏悔录》。这个圣奥古斯丁。怎么会写忏悔录的呢？他小时候少年的时候，他把邻居家院子里的那棵梨树上的梨子统统摘了偷回家去，满树的梨子都摘下来偷到家里去。他做完这件事他非常惊讶。他突然觉得很奇怪，我怎么会做这等事情？我只有一个胃，大概三五个梨子吃下去就饱了，为什么要把别人家一棵梨树上的梨子全摘回去？他开始思考这个问题，因为他是思想家。他在少年这时候发生的这件事，一辈子没忘。当他思考这个问题的时候就在思考人类罪恶的根源，人间为什么会有罪恶？总得说明根源吧，动物界没罪恶的啊，你看那个动物世界，那个凶猛的野兽吃掉这个另外的动物，这件事你看上去也蛮残忍的，其实这不叫罪，它是自然现象，叫生物链。那个狮子在生物链条上居于比羚羊高的位置，那么羚羊就做了他的食物是吧。这就是自然现象，没什么罪啊。人间有罪恶，当然要把圣奥古斯丁对这个问题的讨论啊。全部讲出来的话，要费很多话，这是蛮深入的思考。</p>
<p>简单的说就是，圣奥古斯丁就讲上帝造人，那么人跟上帝之间就有一个关系，这个关系是什么关系？教父哲学是神学家开始思考的，上帝是不朽的，不朽的也就是不在时间中。当我们谈论不朽的东西，就说它是超时间的，他不在时间中。上帝造人，人却是时间性存在。那么时间性存在意味着什么？我们活着的每一个当下，一方面有过去，一方面有未来。我们对过去有回忆，我们对未来有筹划。然后奥古斯丁就问：上帝造人为什么让人在时间中呢？如果人不在时间中，也就超时间了，也就不朽了啦。上帝为什么偏偏造一个速朽的人类呢？每个人必有一死，为什么？然后他讨论时间了。他说过去就是曾经真实，但已不存在。那么未来是什么呢？未来是可能真实，但尚未存在。这两段都不存在。过去已不存在，同意吧？我们回不到过去，他曾经真实但已不存在，未来是可能真实但尚未存在。好，两面都不存在。那么当下存在，那么当下是指什么呢？是不是指今年？。。。。。。</p>
<p>那么整个环节的次序有先后，第一步是<strong>传香</strong>。我们把书打开，第98页。说那一天许多人又来了，“时，大师见广韶洎四方士庶，骈集山中听法，于是升座告众曰：来，诸善知识！此事须从自性中起。”就是佛教的修行啊，要从自性中起来。</p>
<p>“于一切时，念念自净其心，自修自行，见自己法身，见自心佛，自度自戒，始得不假到此。”如果我们明白修行的含义，下修行的决心才不虚此行。</p>
<p>“既从远来，一会于此，皆共有缘。”我们今天能够聚集于此，聚集一堂啊因为有缘的。</p>
<p>“今可各各胡跪”就是当时印度那些地方那种跪的仪式，实际上就半跪的。“先为”我先给我先给大家传香。这个香前面用了一个定语的，叫<strong>自性五分法身香</strong>，然后再向大家传授无相忏悔。一共有五分香。我们中国人都很熟悉，到寺庙里第一件事敬香，敬香一般不是自己来，那当然现在都自己点了香，实际上是法师和尚点好了传给你，我们如果参加过佛事是肯定这样，不是自己点。先由住持法会的和尚点好了香传给我们，所以叫<strong>传香</strong>。现在我传香给你们了，惠能这么讲。这个香不是那个物质的香。其实是<strong>心香</strong>。</p>
<p>他说有五个方面。“众胡跪。师曰：“一戒香、二定香、三慧香、四解脱香、五解脱知见香。”这叫五分香。就立修行的5个方面的信心，<strong>传香</strong>是修行的信心。一个人做事情先要立信心。</p>
<p>第一个方面的信心就是<strong>戒</strong>。<strong>戒</strong>是指什么？我们上午也讨论过，在禅宗，尤其是惠能的南派的禅宗看来，这不是恪守戒条戒律。而是<strong>心地无非</strong>。那么无非关键是无人我别。无人我别就会不轻视任何人，<strong>平等才是戒</strong>。“心平何劳持戒？”，疑问品最后的无相颂第一句话，普遍的敬重每一个人，这就是<strong>戒</strong>了。所以他这里讲“自心中无非、无恶、无嫉妒、无贪嗔、无劫害，（名）这就是戒香”。嫉妒、贪嗔、劫害都更源于我执，也就是根源于人我别。</p>
<p>那么第二分香就是<strong>定香</strong>了。我们已经知道<strong>定</strong>是指什么了，他再说一遍，“睹诸善恶境相，自心不乱，名定香”。那么慧呢？”“自心无碍，常以智慧观照自性，不造诸恶；虽修众善心不执着。”我们行善也没有相，就好像《金刚经》讲的<strong>无相布施</strong>。我们在做好事，心中不要想着我正在做好事呢。慈善家们然后得一份那个证书，这就是<strong>住相布施</strong>啊。人与人本来需要互相帮助。地位最高的人会帮助地位低的人，地位低的人也能帮助地位高的。那么地位低的人看到地位高的人需要帮助，他发现了这一点，那么他就帮了他一把，这个地位低的人就不可能住相，假如他住相他就不帮了。你本事比我大的多，地位比我高得多，何必我来帮他？他没这么想。但是地位高的人帮助地位低的人呢，上上人能去帮下下人，每每有优越感，有一种居高临下的感觉，这已经住相了。所以他这里说“虽修众善，心不执着，敬上念下，矜恤孤贫，名慧香。”我们曾经讲过，现代心理学讲智商是吧？测量我们智力水平的高低呢有一个量化的方法，基本单位叫<strong>智商</strong>，但是佛学里边不讲智商的问题，讲<strong>根器</strong>，就是慧根的深浅。那么慧根无法测量，但可以判断，怎么判断？<strong>大智慧就是大悲悯</strong>。大悲悯不是指这样一种悲悯，就是跟我亲近的人，曾经有利于我帮助过的人，然后我看到他受难，我去帮他。你见到什么素味平生的路人，你看到他的处境，你同情他，去帮助他，这叫<strong>悲悯</strong>。大悲悯就是大智慧。<strong>智慧</strong>跟<strong>悲悯</strong>是统一的，一个毫无悲悯之心的人，他就远离着智慧。所以这就是<strong>慧根</strong>的判断，所以惠能在这里讲，矜恤孤贫，这就是<strong>慧香</strong>。</p>
<p>第四分香叫<strong>解脱香</strong>。什么叫<strong>解脱香</strong>？说的很具体的，“自心无所攀缘，不思善，不思恶，自在无碍，名解脱香。”人与人之间的关系都是<strong>缘</strong>，有时候我们想攀缘。谋求有利于我们的人际关系，这就是<strong>攀缘</strong>。人与人交往自然而然因缘分而来，没有那缘分想去得那个东西叫<strong>攀缘</strong>。现在不是有个概念叫<strong>人脉</strong>。想要建立人脉，也就是<strong>攀缘</strong>。所以他讲的蛮彻底的。不要分好坏。</p>
<p>这个香不是物质的香，叫<strong>心香</strong>，“此香各自内熏，莫向外觅”。不是向外面去求。传香传好了，也就是第二步来了，叫<strong>忏悔</strong>。这个禅宗讲的忏悔是<strong>无相忏悔</strong>，换句话说就是有<strong>有相忏悔</strong>、<strong>无相忏悔</strong>，要做区分。<strong>有相忏悔</strong>是<strong>就事论事</strong>。</p>
<p>就像我以前喝酒，那当然我现在也喝酒，喝酒喝多了，自我意识的监控被解除了。当着教研室许多同事大家聚会喝酒，说某一个人你写那么多文章，你少写一点，那叫生产学术垃圾。然后说你要达到像我们现在研究马克思哲学的境界，你还要三五年恐怕都不够。就这么说了啊，他也在场，大家都在。第二天醒来来来，老早忘了，那叫断片。有同事打电话给我，你知道你昨天说了什么？电话里告诉我，你昨天酒喝多了，说这样的话。那个打电话给我的是我好朋友。我听到了以后心里很难过，很后悔啊。以后怎么见这个人？咱们都是一个教研室的同事。后悔不已呀。就想从此不能喝酒，酒要乱性，要下一个戒酒的决心。这是忏悔了吗？是。这叫<strong>有相忏悔</strong>。好像问题出在喝酒这件事情，其实问题并不出在喝酒这件事。我后来明白了酒恐怕是难戒。问题是我喝了酒醉了，为什么说这样的话呢？因为心里本来有，心里本来就轻视了这个人，你酒喝醉了，喝得再醉，你心里没有的东西你不会说的，因为没东西好说，你心里有才会说的。问题出在心啊。心里想，讲的事情倒也真实啊，这个人还是我们复旦大学哲学系引进的人才，复旦大学校方花了50万把他引进来。进来了就是写手啊，每年的这个发表量很高，那么我也比较关注嘛，叫人才来了，咱们教研室引进人才，看看他的文章，实在不堪一读。心里就觉得不对啊。实际上这是我的问题，你不能要求每一个来研究哲学的人都是真懂的。不管怎么样，这是个职业啊，你也捧着碗饭，人家也捧这碗饭，凭什么你能捧人家就不能捧这碗饭？境界会有高低，这是真的。愚者千虑，还有一得呢。你不能说他的，每一句话都是废话，你王德峰的文章每一句话都是好的，也必有一失嘛。想清楚了，大家都在捧这个饭碗嘛，你不能说只能允许你捧，不能允许别人捧，这是我心里的问题。</p>
<p>立刻想起了禅宗，惠能告诉我，永不可轻视任何人。这个心的根源解决掉了，我照样喝酒，也照样醉。再也不会有这种话说出来，因为心里没这这件事。心里没这件事，这是最重要的。所以<strong>忏悔</strong>就分了两种。现在惠能要授的是<strong>无相忏悔</strong>。<strong>有相忏悔</strong>叫<strong>就事论事</strong>，<strong>无相忏悔</strong>是<strong>消除罪因</strong>，要把根源找到。</p>
<p>所以底下说“今与汝等授无相忏悔，灭三世罪，令得三业清净。”</p>
<p>三世哪三世？<strong>过去世、现在世、未来世</strong>。</p>
<p>三业哪三业？<strong>身业、口业、意业</strong>。</p>
<p>三业要清净，业也不都是坏的。不清净嘛才叫<strong>恶业</strong>。我们要说话就在造业，我们身体有实践、有行为，也在造业，我们的念头也在造业，我们只要活着就有行动，就有意念，也就有言语，始终在造业。问题是不要造恶业，</p>
<p><strong>身业</strong>的恶，就是<strong>杀生、偷盗、邪淫</strong>，</p>
<p><strong>口业</strong>的恶就是<strong>妄语、两舌、恶口、绮语</strong>，</p>
<p><strong>意业</strong>的恶就是<strong>贪、嗔、痴</strong>。</p>
<p>要令三业清净。这个说法的过程是很认真的，用我们今天的话讲起来颇有仪式感。</p>
<p>我们翻过来，101页。叫大家一起念，“善知识！各随我语，一时道”惠能开始领：“弟子等，从前念、今念及后念，念念不被愚迷染。从前所有恶业、愚迷等罪，悉皆忏悔，愿一时销灭，永不复起。”这是第一段。他念了大家就一起念。</p>
<p>第二段，“弟子等，从前念、今念及后念，念念不被骄诳染。从前所有恶业、骄诳等罪，悉皆忏悔，愿一时销灭，永不复起。”</p>
<p>第三段。“弟子等，从前念、今念及后念，念念不被嫉妒染，从前所有恶业、嫉妒等罪，悉皆忏悔，愿一时销灭，永不复起。善知识！已上是为无相忏悔。”我前面那个酒后讲人家的例子叫骄诳。我刚才讲我自己的例子，曾经骄诳，要把这个罪因消了，我现在喝酒也会喝醉，再也没有这等事情。这是因为要解决这个罪因嘛。</p>
<p>他前面第一段是叫我们忏悔那<strong>愚迷</strong>，第二段是忏悔那<strong>骄诳</strong>，第三段忏悔<strong>嫉妒</strong>。三段念完了，说善知识，以上就是<strong>无相忏悔</strong>。我们知道三世罪啊，我们过去、现在、未来的罪概括为三种罪因。哪三种罪？<strong>愚迷、骄诳、嫉妒</strong>。</p>
<p>我们先看<strong>愚迷</strong>，<strong>愚迷</strong>是指什么？<strong>愚迷</strong>不是人笨啊，有的人很聪明，但是非常愚迷。<strong>住法着相念境，<strong>这叫</strong>愚迷</strong>。</p>
<p><strong>住法</strong>就抓住那个事物不放。有的人贪财，贪财贪得最厉害的，比如说儒林外史里边的严监生，走之前最后一口气就咽不下去，实际很难过的啊，赶快咽下去，走吧。他还走不了，只有边上一个小妾明白他心思，为什么啊？多点了一根灯草，那两根多了一根，那个小妾明白他心思，把其中一根的灯草掐灭，他总算心定了走了。住法住的太厉害了吧？有的人收集各种东西也是住法。太过分吧？抓住不放，最后不也是人家的嘛？天下之公器呀。</p>
<p><strong>着相</strong>，相就是事物的高低贵贱的区分。你的心就跟着这种区分走了，叫<strong>着相</strong>，也是愚迷呀。</p>
<p><strong>念境</strong>，境有进有区分啊，顺境、逆境、苦境、乐境。忘了一条<strong>境由心生</strong>。你以为人生的顺境和逆境的区分是客观的，哪有客观的，是比较出来的。我跟那个摆地摊的小贩一比，我觉得我的人生处境不错，教授吶。那么我跟富豪排行榜上的富豪们比一比呢？我觉得我的人生失败了。每年年终要考核呢，两张表要填。教学工作表，科研成果表，连续三年这两张表填的都不合格，被送到人才交流中心去了。那么我跟富豪一比，他们那些人简直可以呼风唤雨。什么事情搞不定呢？用钱搞得定的，用钱搞定你就不叫事，在我来看呢，是这么大的事，如果换做他，轻轻一抹就没了嘛，你看差别大不大？其实人生的幸福顺境全由我们的心生出来，逆境也由我们的心出来。两个青年人恋爱了，一个是装潢工，一个女的叫钟点工，他们的人生失败了没有？没有。他们永远不可能到豪华的饭店里面吃鲍鱼鱼翅，他们每天傍晚聚会的时候就手拉着手吃夜排档去了。这不是逆境，这是顺境。境由心生，你念境了就出问题了。</p>
<p>这三个方面就叫<strong>愚迷</strong>。</p>
<p><strong>骄诳</strong>呢，又一种罪因。就是我高人低，这叫<strong>骄诳</strong>。我高人低，就叫傲慢。那么倒过来叫<strong>嫉妒</strong>，人高我低。前面是我高人低的得意，那叫<strong>骄诳</strong>，后面是人高我低的失意。<strong>嫉妒</strong>。天下人的通病啊。佛教就是清晰地向我们指出天下人的通病，并且把它说成是罪业之原因。所以要从根子上入手，消除这三种罪因：<strong>愚迷、骄狂、嫉妒</strong>。从根子上入手的忏悔，那叫<strong>无相杆悔</strong>。有许多人都会忏悔，但是如果忏悔只是一种恐惧造成的，叫<strong>畏于因果</strong>。也算是有境界的了，畏于<strong>因果而忏悔</strong>。现在时下这种人也不少是吧？然后他得到庙里去的，要做好事呢，怕自己得了这个富贵担不起，承担不了，那么去做做布施的事。也要做做忏悔，那叫畏于因果。这当然是已经是一个境界了。</p>
<p>为因果我们才会去忏悔的，名与法空才会诚恳的忏悔。见到一切事物的虚妄不实，不去执着于他，这样就罪业的根源消掉了。名与法空还有一层更根本的道理，法空事物是生生灭灭，归根到底没有自性哦。比如说这个杯子没有它自己的实体性存在，一切事物都是因缘而生。<strong>缘会则生、缘离则灭</strong>，叫<strong>缘起性空</strong>4个字。这是相信佛教、进入佛教的第一个前提，就是采取了佛陀的世界观，这个世界不是实体性存在，这个杯子此刻是存在的，并不是依赖它自己的本性，是各种条件聚合让它称其为杯子，这些条件一旦离散，它就不是杯子，它就没了。</p>
<p>万事万物总如此。复旦大学培养了我，又让我留校，后来终于在复旦做了教授，我感恩复旦，心中要呼唤复旦万岁！复旦万岁不了，他将来一定没有，就像他过去未曾有过，一样的。这是非常彻底的，也叫<strong>名</strong>与<strong>法</strong>空。</p>
<p>但是有一样东西在，因为你知道法空你才知道因缘的真实性，那你才会诚恳忏悔。为什么？过去做了的事情老早消失了是吧，消失归消失，有东西留下来，什么东西呢？<strong>业力</strong>。业力在流转那。</p>
<p><strong>名</strong>与<strong>法</strong>空就两层意思。第一，<strong>万事万物没有自性存在</strong>，第二<strong>事情消失了，业流出来了，业流传了</strong>。所以我们要<strong>忏悔</strong>。这是消业的消罪业的第一步，<strong>忏悔</strong>。还有讲到神通哦，我们总不能理解。佛教讲6种神通，我们为什么没有神通？因为我们在总在事物当中，我们陷入诸法，就万事万物，我们不可能把它看空掉。</p>
<p>如果把事物看空掉的话，因缘你看清楚了，这叫<strong>神通</strong>。你比方说现在还有没有这样的真正的禅宗祖师，我真不知道，也许有。但是几乎很难找到。有真正的禅宗祖师的那些时代。</p>
<p>士农工商你无论是其中哪一个阶层的人遇到大麻烦大苦恼，政界的也好，商界的也好，或者其他的你到禅宗寺庙里去，跟那些禅宗祖师交流，你把苦恼告诉他，他完全可以身居山中，从不了解人世间当下许多事情，只要你告诉他这份苦恼，他就会跟你指点一下，你就觉得很奇怪吧？而且指点出来的事后证明是真的。那么我们不免说他神通了，原因是他法空啊。</p>
<p>具体这件事情是怎么样的，他未必一定要知道。但是你告诉他你曾经做过什么，他马上就知道后面的因缘，就点给你听。包括这个蒋介石哦，在佛教界他最认谁？太虚。蒋介石第一次下野的时候，那么就回宁波雪窦寺，带着他的结发妻子，请太虚法师给他的妻子讲那个《心经》，讲完《心经》，太虚跟蒋介石就一起散步，这时候蒋介石就下野了。</p>
<p>那么蒋介石就问太虚，我后面会怎么样？太虚跟他说两年之内你有双喜临门，就跟他讲。他蒋介石当时还觉得很奇怪，我哪有双喜临门？他说第一要结婚了，第二东山再起，重返政坛，后来都应验。</p>
<p>太虚当然知道蒋介石是做什么，正在做什么，已经做下什么事他心里全明白。这个故事还不够典型，因为太虚对当时的时事政治也是有所了解，一个身处山中的禅宗祖师他并不了解。不像今天还有互联网网上查一查，最近发生什么事，他只要你告诉他你做的事，你现在的迷惑是什么？他必告诉你后来的结果，这个叫<strong>神通</strong>。</p>
<p><strong>修神通就是要达到法空</strong>，无论你是什么修法。密宗，长一点要修几十年，悟性高的修个几年闭关来了，就法空啊。<strong>法空</strong>他才能看到他过去现在未来的区别是没有的，他突破时间也突破空间，一无时间的障碍，二无空间的障碍。因为他领会到的全是因缘本身，这就是神通。就是我上午写了18个是 “已做不失，未做不得”。做了必有后面的得，好的坏的不管。未做不会有，所以叫“未做不得，已做不失”。所以这就是神通之所以是神通啊，因为<strong>法空</strong>。</p>
<p>我们都不法空的。我们谈论的因果都是事物与事物之间的因果关系，他们谈的因果是成其事物、败其事物的<strong>因缘</strong>，明白这个区分吗？自然科学讨论的因果全是实体性的事物之间的相互作用，叫科学讲的因果关系。佛家讲的因果关系不是这个东西，而是让事物生生灭灭的那个<strong>缘</strong>。不是此事物碰到彼事物把它弄倒了。我手推这个杯子，杯子倒了，这叫什么？自然科学讲的什么？因果关系。佛家讲的因果不是这个东西，那是让事物成败，成、住、坏、空的那个——<strong>缘</strong>。所以这就是我们至少要了解哦，我也没想通，这是琢磨过的，就知道因果。佛家讲的因果是什么？所以无相忏悔，就是名与法空，才知道那个事情虽然没了，业力在那。就像佛教告诉我们的佛陀告诉我们，这个人从过去世到现在世到未来世那叫12支，无名，行、色，无明心是前世，在前世然后这个业力在再度把我们投入到什么这世界中来。</p>
<p>那么投入的第三个正式投入时间叫<strong>识</strong>，<strong>阿赖耶识</strong>最先到。然后识来了，<strong>名色</strong>来了，名色就是精神和肉体两方面来了，然后<strong>六入</strong>，六入就是有了六扇门了六根了。然后后面也有的排下去一种一共叫<strong>十二因缘</strong>，描述了过去世现在世未来世，就是业力。所以我们这辈子来到世界上来，并不是刚出生的时候并不是除了一个小动物别无其他，有啊，有的是<strong>业力</strong>。然后就规定了这辈子做人，干什么事？什么特征？跟其他的为什么千差万别？因为各自的业力不一样。习大大的业跟我王德峰的业真不一样，所以习大大事我做不了，我的事习大大也做不了，各自有来历。所以这就是那个讲<strong>名</strong>与<strong>法</strong>空的道理。<strong>法</strong>是空了，<strong>缘</strong>没空掉过，从未空掉过。就这样看世界，业力始终在流转，于是修行的目标就是消罪业。</p>
<p>讲了无相忏悔之后呢，他下面还有话，把忏和悔两个字分开来讲，然后再合起来。先说一个“忏”字。“云何名忏？云何名悔？”这就是101页最后一段。什么叫忏？什么叫悔？“忏者，忏其前愆。从前所有恶业、愚迷、骄诳、嫉妒等罪，悉皆尽忏，永不复起，是名为忏”。那么什么叫“悔”呢？“悔其后过”，就防止未来。“从今以后，所有恶业、愚迷、骄诳、嫉妒等罪，今己觉悟，悉皆永断，更不复作”，这叫悔。合起来叫“忏悔”。</p>
<p>“凡夫愚迷，只知忏其前意，不知悔其后过。”以往的事情有了不好的结果，会“忏”的。但是不能杜绝于未来，这叫不能“悔”。因为不悔的原因呢，前愈没有灭掉。</p>
<p>“前意不灭，后果又生。前愆既不灭，后过复又生，何名忏悔？”这哪里算得上忏悔呢？</p>
<p>“善知识，既忏悔已”，忏悔这件事做好了，</p>
<p>第二个环节，“与善知识发四弘誓愿”，现在要发4个愿，4个宏大的愿。“各须用心正听”：哪4个愿？一个是<strong>度众生</strong>，一个是<strong>断烦恼</strong>，一个是<strong>学法门</strong>，一个是<strong>成佛道</strong>。就4个愿。</p>
<p>度众生、断烦恼、学法门、成佛道，四大弘愿。</p>
<p>发愿这件事情非常的要紧。因为佛教有一个基本思想是<strong>愿力</strong>，唯有<strong>愿力</strong>才能消<strong>业力</strong>。愿力不起，业力无法消。人在许多事情上会自我欺骗的哦，唯有发愿这件事情一定是真诚的。这是你在发愿，在发愿这件事情上，人都不会自我欺骗。</p>
<p>我上午讲到过一个法国的思想家，启蒙思想家卢梭。卢梭认为在这个世界上除了一样东西，其他东西的价值都是相对的。唯有什么一样东西是绝对的善，绝对的价值，这就是我们善良的愿望。除了我们善良的愿望之外，人世间所有的事物的价值都是相对的。</p>
<p>这个思想激发了另外一个人，一个德国人叫康德。康德一生的思想分了两大阶段，第一个阶段是科学主义者，康德当时认为科学最有最具有最高的价值，因为它可以增进人类的福利。所以康德回顾自己当初的思想：我致力于科学的研究，我瞧不起无知的平民。因为他认为科学能够造福人类。他说后来是卢梭纠正了我。假如我们遇到一个无知的平民，但他品质端正，愿望善良，那么我们在这样的人面前，我们的身体不向他鞠躬，我们的心灵向他鞠躬。</p>
<p>科学的价值只是相对的，比方说爱因斯坦发现了E=MC2，这在物理学上是一个重大的进步，就质能转换公式。那么一点点的物质，质量很小，质量叫M但它所包含的能量是要乘于什么？光速的平方叫E=MC2。不得了。这是他发现的，C就是光速了，M就是质量，E就是能量。</p>
<p>当这个公式提出来的时候，实际上原子弹已经在理论上发明了。后面的事情就是技术的事情。如果没有E=MC2就不可能有原子弹，也不可能有核发电站。核能并没有被人类所认识到，这是科学的进步，但这科学的进步有没有绝对的价值？没有。</p>
<p>我们可以用E=MC2造福于人类。比如说核磁共振，帮助人去诊断疾病的。我们也可以用E=MC2危害人类，那就是核武器。我们究竞用E=MC2这个公式做什么事情？取决于<strong>人心</strong>。它是用来造福人类呢，还是毁灭人类呢？这科学没有绝对的价值，它的价值是相对的。</p>
<p>今天这个世界上的核大国所拥有的核武器，人们计算过，如果统统拿出来使用它的这个当量哦，可以把我们的地球摧毁17次之多。那么直到今天只用过一次了。第二次世界大战末了的时候，美国人放了两颗——广岛、长崎，让世人看到核武器的可怕。现在没有再度用过。请问是什么制止了这一点？<strong>人心</strong>啊。人心善良的意愿，是世界上的绝对的价值。除此之外，没有什么绝对的价值。</p>
<p>卢梭指出了这一点，所以康德说卢梭纠正了我。然后康德就把他的研究中心转移了，不是去关注那科学，而是关注这世界上善的可能性，要把它论证出来。这就是卢梭的思想，在这一点上跟佛陀的思想相通的地方。所以佛教认为发愿，愿力才能够消除业力。我们内心真诚的愿望起来，它是一种真正的力量，所以发愿就非常关键了。</p>
<p>其实后来儒家也是得禅宗的启发，特别是王阳明，就讲那个《大学》，不是“三纲领八条目”吗？“三纲领”就是“明明德、亲民，至于至善”，这叫<strong>三纲领</strong>。“八条目”就是“格物、致知、诚意、正心、修身、齐家、治国、平天下”<strong>八个条目</strong>。</p>
<p>王阳明认为这“八条目”当中哪一条最关键？<strong>诚意</strong>。诚意是关键，这就是意愿的事情。王阳明后来用四句话概括的：“无善无恶心之体，有善有恶意之动”。意一动起来了，就心发意了，这是一部最关键的，结果的意就可以两种：一种叫诚意，一种叫不诚意。按照中庸的那句话叫“不诚无物”。</p>
<p>天下的事情要做好了，前提就是<strong>诚</strong>。不诚世界上没事情做得好。<strong>诚</strong>是意愿的事情。所以佛家讲发愿是<strong>愿力消业力</strong>。那么儒家讲<strong>诚意</strong>，思想是一致的。这王阳明还打了一个比喻，他说杀人须从咽喉处下刀哦，这很可怕的比喻。意思说我们修养最关键是什么？咽喉处是什么？<strong>诚意</strong>！这是关键入手处。事情来到面前，你去做此事，第一步就是<strong>立诚</strong>，这是关键。这叫咽喉处。写一篇文章也是的。所以中国人讲修辞立起诚。文章要写的好，当然要修辞，修辞本身不是目的，修辞立起诚。</p>
<p>所以这个佛家讲发愿，儒家讲诚意，卢梭讲善良的意志是能实现唯一的价值，绝对的价值，思想是同一个。意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。这《大学》里讲的话，那么就把它发挥一下，那么王阳明发挥就抓住诚意不放了。在王阳明看来，整个《大学》的中心思想是<strong>诚意</strong>。《大学》之后不是有部《中庸》吗，《中庸》的中心思想是<strong>诚身</strong>，<strong>诚意</strong>而后<strong>诚身</strong>，<strong>诚身是实践</strong>。这顺带说就《四书》，这《四书》的顺序可不能颠倒按照时间上的顺序，第一步应该是《论语》，孔子的《论语》。那么孔子的一个弟子叫曾子写了《大学》，传授给谁呢？传授给孔子的孙子叫子思。那么子思又做了一本书，叫《中庸》，传授给谁呢？孟子。那么按照这个时间顺序的话，《四书》应该第一本《论语》第二本《大学》，第三本《中庸》，第四本《孟子》，由孔子而到曾子，《大学》来了，由曾子而到子思《中庸》来了，尤其是涉及到《孟子》，子思是孟子的老师，所以孟子的思想对《中庸》有大大的发挥。那么这个时间顺序来看，是说应该这么排列了，其实不是。</p>
<p>第一本一定是《大学》，</p>
<p>第二本一定是《中庸》，</p>
<p>《论语》排到第三本，</p>
<p>《孟子》第四本。</p>
<p>这个顺序是中国世世代代的文人修身养性的经验的总结，可不是随便说的。</p>
<p>那么为什么《大学》第一本呢？<strong>诚意</strong>啊，诚意是它的主体，所以《大学》被称为初学入德之门。入门啊。一个人到了15岁，必须读《大学》的。孔子说的有道理，15志于学。15岁之前不是不学，学的是小学。小学是识字算术，酒扫应对，各种礼仪的学习，包括射箭、音乐。15岁之前。一个人到了15岁就要进入大学。大学就是大人之学，就学做君子，这叫小学、大学。那么大学第一本书就是《大学》，大学就大人之学。</p>
<p>那么首先要“大学之道在明明德，在亲民，在止于至善”，那就来了。那么大学是初学入德之门，道德的德，入德之门。那么《中庸》叫孔门，孔子的学派叫孔门，孔门传授心法，这话是程颢所说。借用了佛家的话了，孔门传授心法，传授心法不就是禅宗的语言吗？所以有了禅宗才有后面的宋明新儒学嘛。北宋五子，北宋5个大思想家，其中有两个是兄弟是吧？程颢。程颐。周敦颐、张载、邵雍、程颢、程颐，叫北宋五子，五大思想家。</p>
<p>那么程颢就认为《中庸》是孔门传授心法。心法这禅宗的话吧，禅宗就传心法。所以读了《大学》之后就要入了门了，第二本就是《中庸》，有了《中庸》，得心法之后再去读《论语》。因为《论语》是语录题，孔子论道从来不脱离实际的事情的，所以《论语》你要读懂哦，到时要有两个基础哦，一个《大学》一个《中庸》。因为孔子总是不断的跟他的弟子们讨论具体问题，在讨论具体问题的时候把那个道理说出来。所以中国人做学问有一个传统，叫古人不着书。不像今天的学者老师要写哲学专著，学术专著，古人不著书。古人未尝离事而言理，不脱离实际的事情来谈那个道理。离事而言理，专门做抽象的哲学著作。</p>
<p>所以读《论语》你要读懂它，并不简单，所以要打个基础。中国人说半部《论语》治天下，你只要读半部就可以做官了。你还准备读懂一部，要治两个天下？所以要进入《论语》，就是能够实践了啊，能够治国了，前提是《大学》、《中庸》。所以这个次序就这样来的。然后走向《孟子》，孟子提出了人生最高成就叫 “吾养吾浩然之气”。他后来就发挥成陆象山讲的“吾心便是宇宙，宇宙既是吾心”。这就是我顺带讲《四书》的次序有来历的。</p>
<p>多少年来中国教育的经验总结，中国教育的主题是哲学，解决人生的问题。教育的首要目标是让人作为人而成其为人。专业的教学是让人成为某种人，成为工程师，成为医生，成为金融家，这叫<strong>让人成为某种人</strong>。让人成为某种人之前，必须<strong>让人作为人成为人</strong>。中国教育的主题。现在把这个主题放掉了，都指向让人成为某种人。现在是然后再补课，现在80后都开始补课了。补课就是自己明白了，然后提出“三观”问题，“三观”正还是不正了，这是顺带说。</p>
<p>那么我们回到这件事情上来就是发愿，发了四个弘愿：“众生无边誓愿度，烦恼无边誓愿断，法门无尽誓愿学，无上佛道誓愿成”。四大愿望，我们一般发愿都是小愿，那么修佛那个修行啊，修行的意志，<strong>发愿就是修行的意志</strong>，这叫最高的善良的意志。</p>
<p>这四大宏愿都是大乘佛教的精神。小乘佛教就没有度众生这个愿望，大乘佛教，所以后来印度人印度的学者也是感慨得很，他说佛教传入中国，那才有真正有了大乘的气象。那么传入到东南亚只是小乘的气象，气象不同啊。第一个愿就不得了，众生无边誓愿度，并不是说我要去做救世主，而是众生的罪过也是我的罪过，众生的烦恼也是我的烦恼。是这样一个境界，这个愿力很大的，这个愿力足以消业力。</p>
<p>我们讲到忏悔品的佛教功课的第四个环节。第三个环节，就是发愿。四大弘愿，就是<strong>度众生、断烦恼、学法门、成佛道</strong>。我们讲了愿力才能消除业力。发愿是非常根本的，人世间唯有善良的意志才具有绝对的价值。</p>
<p>四个方面，第一个方面就是度众生。我们看102页，第二段先说了，哪四个弘愿？要“四弘誓愿”，在这个四个弘愿前面都加了限定词的。<strong>自心和自性</strong>。从本心出发，从自己本有的佛性出发来发愿。</p>
<p>第三段102页上第三段，惠能讲，大家都知道“众生无边誓愿度”，大乘佛教的精神。那么大，既然这么说，且不是惠能度，不是我来度你们，没有一个人可以做救世主，救世主的观念是西方基督教的观念。</p>
<p>最初就是从犹太教那里来叫米塞亚，米塞亚就是救世主，后来发展到基督教上帝。中国思想佛学中国化，包括佛陀本来的思想都是 “自性自度”，世界上没有救世主，所以他说不是惠能来度。那么大善知识，像惠能这样的大善知识只是来启发我们，所以他当时得了佛法，在弘忍法师那里悟了之后，弘忍法师继续考验他，怎么考验他的呢？</p>
<p>就是不是在九江那里一个驿站，驿站边上一个渡口。弘忍法师为惠能准备了一艘船，叫他连夜过江，往南面走。到了船上之后呢，弘忍法师来摇撸了。那么惠能就跟弘忍法师说，应该我来摇槽啊，你是师傅嘛。这个弘忍法师就说了一句和应当是我来度你嘛，所以我摇槽。这是一语双关，继续考验着惠能。我是你师傅，所以我来度你，不应该如此吗？惠能马上知道了他在考验我。惠能的回答是没有悟的时候师傅来度我，如今已悟我自度，叫“自性自度”。这句话说出来，弘忍法师才放心了，你是真懂了。也是惠能要让弘忍法师放心，我以后哪怕历经磨难，你都不要为我担心，我自己能度了，所以叫“自性自度”。所以这里惠能就讲：“善知识，心中众生，所谓邪迷心，狂诳心、不善心、嫉妒心、恶毒心，如是等心，尽是众生”。</p>
<p>其实我们人人都有。别以为别人都不行，自己行，别人有过错不是我的，其实呢，都有。有些事你没做，不等于你在这种场合上不会做。你比方说中国近代史上有一个人破坏了两次中国的变革——袁世凯。那么我们都说袁世凯不好，一个坏了戊戌变法，二窃夺了辛亥革命的成果。窃夺了总统的宝座，还想恢复帝制。近代史上如果没有袁世凯多好，中国的近代变革就要顺利的多。我们都近代史都会有感受。</p>
<p>其实认真的一想，袁世凯不是从天上掉下来的，正好中华民族不幸，在近代变革的关头来了一个袁世凯，不能这么想。袁世凯是中国文化精神的产儿，我们身上都有袁世凯的影子。今天只要中国文化精神没有发生根本的变革，我们身上都有袁世凯的影子。至于我王德峰没成为袁世凯的原因是什么呢？没有在历史进程的关键时刻处于一个最有利的地位。我做不了这件事。而已。所以鲁迅先生说的对，他说我当然会解剖许多病症，但我往往更严于解剖自己。他说我从来不能做青年的导师，我就害怕我身上的毒素毒害了青年人，这都是真实的话，这种精神就是大乘佛教的精神。</p>
<p>就像今天中国也是这样，我们说官场腐败，官场能够腐败的原因是什么呢？就像恩格斯那句话说得对“一个政府的卑劣，可以通过他的民众的卑劣来得到辩护”。是这样的。</p>
<p>所以鲁迅先生不管是在他用他的杂文抨击了当时的封建官僚和旧式文人，他同样揭示了国民性。什么叫中国人，冷漠的看客，所以塑造了一个阿Q的形象，所以众生的罪过也是我们自己的罪过。我们就在众生之中。今天我们都在中国这个社会中，哪怕我们在以为自己可以独善其身，其实也难免沾染上这个社会的病症。你再洁身自好，这个是当下社会的病症，你一定会有。这就是一种彻底的态度。所以禅宗的一个基本原理叫<strong>心、佛、众生</strong>三无差别。</p>
<p>所以看到别人犯了过错，不要认为自己未从犯，就以为与自己无关，其实自己完全可能犯，就这么一个道理。所以神秀的偈句的另外一个毛病就是把众生的烦恼推至门外，我只要自己干净就可以了。“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃”。把众生的烦恼拒之门外，这不是大乘佛教的精神，众生的烦恼也是自己的烦恼，众生的罪过也是自己的罪过。</p>
<p>比方说今天中国社会种种的病症，你也躲不了，然后也影响我们每个人的生活。但凡有一点能力的把孩子送到国外，那么在国外了之后呢，学成了之后有国不肯归，因为我们这社会有问题。所以年纪轻轻的父母很早的就空巢了，这个烦恼是整个民族的烦恼，你也在其中。这是不正常的民族生活。我只要举这是一个例子而已。在如今这个社会人人自危，老人倒在地上该不该扶都成了问题，你也躲不了，撇不开。所以大乘佛教的精神就明确了，“众生无边誓愿度”，但不是说你去做救世主，度自己就是度众生，<strong>一边是度自己，一边就是度众生</strong>。</p>
<p>所以应该这样来概括，众生之过即自之过。所以叫<strong>心中众生</strong>，所以叫<strong>自心众生</strong>。众生就在你心里，别把他分开，这叫<strong>自心众生</strong>，不能分开的。所以底下就是说“何名自性自度”？即是心中是我们自己的心里面有的邪见、烦恼、愚痴众生，众生就在你心里的。</p>
<p>“将正见来度，既有正见，使般若智”，就是用<strong>般若智</strong>。</p>
<p>“打破愚痴迷妄众生，各各自度。邪来正度，迷来悟度，愚来智度，恶来善度。如是度者，名为真度”。</p>
<p>我们记得巴金有一个建议的，成立一个“文革”博物馆。当然现在没做这事。巴金的建议是什么呢？就是要让我们在文革十年动乱当中，所有人做过的那种事情啊，证据都存放在那里，大家去看，来提醒自己。巴金在这个文革结束之后写了《随想录》，在《随想录》里边巴金不断的来忏悔，其实巴金在这个“文革”当中他没做过坏事。他到是受害者，但他在忏悔。这是佛家精神的体现。</p>
<p>不要把文革动乱，文革的灾祸全部归结为一个人叫毛泽东，推到毛泽东身上大家就没事情了，不是这样！毛泽东犯了错误的，他后来自己也明白，他说他一生就是七分成绩、三分过错，他说我现在还没走，大概可以一般来说盖棺论定吧，我现在棺还没盖，但是总可以论定的。他就说了“三七开”，他自己说自己“三七开”。那么三分过错里边必有一项是——文革。随着林彪事件出发生之后，他就知道失败了。</p>
<p>“913事件”之后他就知道失败了，还有一个过就是“大跃进”，失败之后许多人饿死了，毛泽东心里很明白。毛泽东第二个过错就是错误的发动文革，错在哪里？在这件事情上他不如鲁迅心里明白，毛泽东说“群众是真正的英雄”，百姓是圣贤，他说我把问题交给群众，文革来了。他没想到这个民族本来就充满了恶业，恶业未消呢。你这个文革一旦发动，那就要打开潘多拉的盒子。所以巴金认识到这一点。大家来看，我们各自自己来看，在文革中自己做了些什么大家来看吧，巴金自己没做坏事情，没伤害别人，他是被伤害的，他也忏悔，这就是佛教的精神。这样我们就能理解这个度众生，就是众生之过就自生之过。所以惠能说自心众生啊，这种彻底的态度唯佛教有，后来阳明心学也继承了。</p>
<p>我们再来看第二个，就<strong>断烦恼</strong>。烦恼来自哪里？来自虚妄思想。这就是105页，第一段。“烦恼无边誓愿断”，如何断？“将自性般若智，除却虚妄思想心”。自性般若智，一个是自性般若智，一个叫虚妄思想心。我们平时的心全叫虚妄思想心。</p>
<p>关于般若智我们曾经在第二品“般若品”里面讲了是什么智慧？领会虚无的智慧。领会虚无一定名有法空。这种智慧叫<strong>般若智</strong>最高的智慧。你不名有法空，不领会虚无，你一定有虚妄思想。执着于法，要打破。因为我们总是着法着相念境，这些全是虚妄思想。烦恼就是不如意哦。我们如果把<strong>如意之心</strong>，求如意的心换一换，那叫<strong>如如之心</strong>，这是问题的要点。**莫求如意，但是如如。**烦恼从我们心里生，我们心里怎么生出烦恼，因为求如意，结果不如意，不如意就是烦恼。</p>
<p>这个行由品里边记载了弘忍法师那段话，那段话是弘忍法师跟谁讲呢？跟神秀讲。神秀做了那个偈句之后，弘忍法师一看就知道一定是神秀做的，然后私下里把神秀叫到方丈室，跟他讲“汝作此偈，未见本性，只在门外，未入门内”。然后底下跟他谆谆教导一番，其中有这样的话，“一真一切真，万境自如如。如如之心，即是真实”。这句话很要紧。</p>
<p>就是你神秀搞错了修行，以为就是擦灰，不断的把我们的心跟烦恼隔开，这如何隔得开呢？所以还是从本心上入手吧，本心上入手叫“一真一切真”。这一真就是我们如如之心，即是真实。然后万事万物它真实的意义才向我们呈现。我们那个求如意的心去看事物，事物的意义都是虚假的，就这个道理。所以断烦恼从根源上说就是<strong>莫求如意，但是如如</strong>。如如就是如事物的本来去领会它，叫如如之心，不是从各小我的角度来理解事物。在这里惠能讲的比较简略。</p>
<p>讲第二个弘愿，就讲了这一句话“除却虚妄思想心”。所谓除却虚妄思想心，就是把如意之心放下，求如意一定是虚妄。事情总不如意或现在如意，将来马上不如意，还是要如如之心。这是讲这个第二个愿。</p>
<p>第三个愿，就是“法门无尽誓愿学”。学法门，如何学呢？不是从知识的角度来学。不是把佛经的经门列出来，一条又一条，这就叫学法门了，<strong>学法门是实践</strong>。所以惠能说“法门无尽誓愿学”，如何学？“须自见性”，自见本性，“常行正法，是名真学”。所以学法门就是常行正法，做事情就是行，<strong>行</strong>就是<strong>实践</strong>。做任何事情都要在正法中。这一点也被阳明继承。</p>
<p>阳明解释<strong>格物</strong>怎么解释的？不是去观察那个竹子，曾经一度王阳明认为朱熹的那个方法是对的哦，因为有一个娄谅跟他讲，学做圣贤是有方法的。王阳明的愿望就学做圣贤了，有路可走，怎么路呢？<strong>格物</strong>。</p>
<p>先第一步格物，然后他就相信了是吧？然后阳明就格竹子了是吧？格了7天7夜的，没从竹子里边看到天理，到格出一身的病来。后来才知道这个错，不对。所以他把格物后来理解为什么？阳明认为<strong>格物</strong>就是<strong>正事</strong>。<strong>物</strong>就是<strong>事情</strong>，<strong>格</strong>者<strong>正</strong>也，<strong>格</strong>的意思就是<strong>正</strong>，是个动词。格本来是确是这个意思，你比方说我们要翻译，假如你要翻译英文的文献，翻译的工作不能天真的以为就是你识了那些单词的含义，知道这些词的词义，然后这个句子呢就是这些词义的连接。那么你边上有一本英汉词典，翻译不等于把这句子所构成的每一个单词在词典里面找到了词义，把它连缀成句子，不是这样的。</p>
<p>词典上说出了这个词的词义，你无法照搬到你翻译的那个句子里去的。这个词在这句句子当中应该表达为什么意思？你要格的，要格义，这叫<strong>格义</strong>。因为任何句子任何一个单词总出现在句子中，任何一个句子总出现在他的上下文中，所以翻译难也就难在你要格义上，这叫格义哦。<strong>格</strong>者<strong>正</strong>也，这个词的含义不是从词典当中搬上你的翻译的译文里面，而是在上下文当中要把它格出来。</p>
<p>我们举个例子，我们学过英语的朋友大概我们问这句是什么意思，假如有一句句子说是The chair is blue，你把它翻译一下，我就给你这个句子，你译译看，The chair is blue。太容易翻译了吧？这张椅子是蓝色的，未必哦。chair却还可以表示主席，blue也表示忧郁的，那个忧郁症那个忧郁。</p>
<p>所以这就是完全可能是主席此刻很忧郁，他究竟是说这个做椅子是蓝色的，还是主席是忧郁的？你没有context（上下文）怎么行？the chair什么意思？blue什么意思？你要把它格出来，这叫<strong>格义</strong>。格义的依据在哪里？上下文，The context。假如一篇文字是这么写，说多少人聚在那里叫meeting开会了，突然出现一句句子叫The chair is blue。难道突然讲开会的事情，突然讲到椅子是蓝色的吗？就不可能了。在如此的上下文里边，the chair is blue一定是组织这个会议的主席此刻忧郁。你在上下文里就判断出来了，这就叫<strong>格义</strong>。</p>
<p>一个事情上来了，同样道理，你要做事情，也要在The context里边<strong>格义</strong>的，天下的事情没有孤零零的事情，总在一个时期一个时代的The context的里面。所以阳明就叫我们正事，<strong>格物就是正事</strong>。哦，要明白这个道理。</p>
<p>比方说你做官，那么做官要行使权力，这件事情该怎么做？此刻你的权力在你手里，你这件事该怎么做？你不能脱离时代和社会的Context，你就在这个生存场里边，你格它的义，你才知道怎么做这件事。格物就是正事。时代发生了很大的变化，就context发生了根本性的变化。毛泽东时代就是49年开始的毛泽东时代，前30年吧，好，79年改革来了是吧，整个时代发生了翻天覆地的变化，context就变了。</p>
<p>今天为官者跟毛泽东时代的时候，计划经济时代的为官者，时代环境差别大不大？极大。要格义了吧？要正事了。现在正事的这个正不知道如何正，我说做官的话，问题还继续存在，争论继续展开，怎么办？等待我们的习大大指出一条路来，今天干部该怎么做？</p>
<p>阳明认为我们先自己正事，我不知道在这里谈过《人民的名义》吗？</p>
<p>各位看过这部电视剧吧？我们就讲讲今天的公务员叫干部官员，干部如何正事、如何格物。那个大风厂是吧，跟山水集团是不是签了一个合同，因为大风厂缺乏资金，资金链断了。他急需要资金，于是跟山水集团签了一个贷款的合同。那个山水集团准备贷一笔款子给大风厂。合同是这么定的，我借钱给你要有抵押品，这个抵押品是大风厂的股权，做了贷款的抵押品。如果在合同规定的期限里边，你大风厂还不了这份款，那么你抵押品就收归山水集团，就这件事。结果大风厂没能还贷，于是按照合同，这个合同有法律效力，大风厂的股权归谁所有？归山水集团。这就意味着大风厂被必须关掉，这里另有所用，这块地、这个厂的东西，由山水集团来决定怎么使用。</p>
<p>于是发生劳资冲突，工人们组织了护厂队。第一，他们不能接受自己失业的处境。第二，不能接受许多任务人都买了大风厂的股权，这个股权是那些工人半辈子的积蓄。买了股权，当时动员他们买股权的是老检察长陈岩石，陈岩石当时是为考虑工人的利益，就在大风厂改制的时候，跟他们讲你们工人也要买一点股，维护你们的利益。</p>
<p>好，事情就这样发生了，劳资冲突展开了，护厂队成立了，公司都做好了。手中举着火把和汽油，面对着警察。然后推土机都来了哦，我们看过这个情景了，那么我们注意两个人物。一个是达康，李达康，达康书记来了。</p>
<p>达康书记带着什么来了？带着reason，我们用英语来说是最恰当的。我们学过英语的朋友知道这个是什么？“理性”。带着理性来了，带着两方面的理性：一个是<strong>经济学的理性</strong>，一个是<strong>法律的理性</strong>。李达康认为大风厂马上关掉，这个合同是符合法律的，山水集团把这块地方拿下来了，完全符合法律，而且山水集团的发展有利于整个荆州市的GDP增长。李达康不是个贪官。他以荆州经济发展为己任，这真实的啦。他要求GDP增长。然后他判断这件事情，这就是他的格物哦，带着理性来了。带着reason来的。</p>
<p>又来一个人，他没带着reason这个词，他带着两个汉字“<strong>道理</strong>”，这个人就是已经退休了的老检察长陈岩石，这是李达康万万想不到的事情。平息这场迫在眉睫的危险—一实际上大风场里边有一个仓库啊，油库，一旦点燃了火来，要爆炸的，那事情大了。陈岩石来了，站在工人一边，“你们的推土机要开过来，就从我身上压过去”。看到这个电视情节吧，然后有人搬了个椅子，他就坐在那里，后面全工人，面对着推土机。李达康认为陈岩石你不对的。陈岩石告诉李达康你不对的。是两种什么东西在对抗？一个叫reason，一个叫道理。</p>
<p>这两个词是无法互译的，你不能把reason译成道理的，你也不能把道理这个词翻译成reason，为什么？他无法通译。</p>
<p>我们要了解这一点很简单，假如有两个中国人正在吵架，越吵越凶。其中一个中国人最愤怒的指责另外一个中国人，“你怎么好这么不讲道理？”，边上一个老外听不懂汉语，但他很想知道这个中国人指责那个中国人究竞说了句什么话？假定我王德峰在边上，那么老外就请我翻译，“他说了句什么？”我心里这太容易翻了，叫everyday English日常英语。太容易翻，又不是很复杂的句子是吧，好。我就翻了。想想看我怎么翻？Why就是为什么，Why are you so为什么你是如此这般的Out of reason？我就这么翻了。</p>
<p>这个中国人指责那个中国人，“你怎么好这么不讲道理？”，我一翻英语，Why are you so out of reason？老外听懂了。他刚听懂我就知道我翻错了。这个中国人指责另一个中国人说“你怎么好这么不讲道理？”，并不是这层意思，并不是说你怎么还如此这般地在理性之外，你怎么好如此这般的违背理性的法则，是这种意思吗？绝不是这层意思。中国人说令我一个中国人说另外一个中国人不讲道理，不是这种意思，而是你怎么好如此这般的违背人之常情。是这个意思吧？</p>
<p>我们今天的中国人说话也是这个意思，你要讲道理什么意思？你不能违背人之常情，“道理”二字其实是无法翻译成欧洲语言的。它是两个字，然后再合起来是一个单词是吧？一个字叫道，一个字叫理，合起来才叫道理。</p>
<p>理是指什么？<strong>一个事物存在的根据，叫理</strong>。任何一个事物存在的根据从哪里获得？从<strong>天道中获得</strong>，合起来叫道理。那么天道是什么？天道在哪里？<strong>天道在人民生活中，在柴米油盐里</strong>。中国思想就是这样，中国思想没把天道推到彼岸世界，像柏拉图那样叫理念世界，天道在彼岸，现实世界叫此岸。那么天道就是一个超感觉的彼岸世界中的理念。这不是中国思想，这是西方思想。</p>
<p>所以我讲到中国思想的一个重要特点是极高明而道中庸，中庸就是庸常，<strong>庸常就是人民生活</strong>。</p>
<p>为什么说人民生活就是庸常？就是柴米油盐啊。那么多任务人半辈子的积蓄，就被你一纸合乎理性的合同，合乎法律理性的合同拿掉了。这怎么可以？李达康带着reason来了，陈岩石带着道理来了，你站在哪一边？就两种格物，做事情就是<strong>格物</strong>，叫<strong>正事</strong>啊。这个正在哪里？是不是冲突来了？你说李达康错了，真不能这么说，他又没私心，但李达康有未来吗？咱真不知道。《人民的名义》如果拍第二部，李达康将走向哪里？中国当下的政府官员们将走向哪里？就这件事。</p>
<p>《人民的名义》这部电视剧艺术价值不高，但他很现实。因为他展开了这个现实引起我你如果站在GDP增长一边，你必须站在企业家一边。</p>
<p>但是我们又是一党执政的吧，既然是一党执政，是不是人民生活是你的根本责任？你又站在哪一边？来了，事情真来了。我们都不知道怎么为人民服务了，因为人民至少区分两大部分吧，一部分叫<strong>资产阶级</strong>，一部分叫<strong>无产阶级</strong>。时代真变了吧，那个Context变了吧，于是正事也就是格物的事情交给了我们每一个人。</p>
<p>那么惠能的回答叫“法门无尽誓愿学”，什么叫誓愿学？怎么学法门？不是现成的知识告诉你，这叫“常行正法，是名真学”。《人民的名义》提出了许多现实的问题，编剧无法解决他，这是正常的。编剧导演都无法解决他，他的好处就是把他扯开了让大家看，就这个好处。看了以后引起观众的思考，我们都在其中，都在当下中国社会。</p>
<p>再比方说祁同伟自杀引起多少人的同情。为什么引起同情各位知道吧？草根！对，祁同伟就是当代当下中国社会中的什么于连，读过《红与黑》就知道了，于连不就是草根吗？他要往上走啊，最后呢上断头台吧。祁同伟是做了恶的哦，就是前反贪局局长被他设计的一个车祸，这不是要灭人吗？这个恶本不该被同情吧？但是那么多人同情他原因是什么呢？79年改革开放起步，全体中国老百姓人人都做着发财的梦，难道祁同伟就没资格做这个梦吗？当然有资格做。但他是草根，好，爬到一定程度完蛋了。</p>
<p>所以他在自杀之前呼喊了一句话 “没有人有资格审判我”。他为什么喊着说这句话？这句话一喊出来，引起许多人同情啊，就这个道理。所以《人民的名义》这部电视剧的优点就在这里。那些人物都有意思了。所以我们讨论我们如果学一点哲学，学一点佛学，再来看这些电视剧，心里很明白。格物就是正事，正事如何正？用我们的自本心来正，不是私下的各种不同的价值标准，正不了的。法门无尽啊，学不完的。誓愿学呢，如何学，“常行正法，是名真学”。</p>
<p>荣耻出于良知，所以我们的本心，他说你去写什么？讲到这一步我没办法推了，写了一篇，后来他就发表了标题就是荣耻出于良知。大家看了有人写信给新民晚报说这篇文章是讲“八荣八耻”讲的最到位的，这编辑告诉我的。实际上这时我就提出心学，心学的重要性。常行正法是来自心啊，所以这叫自性法门。所以惠能总加个自性，自性法门无尽誓愿学。法门来自自性，不是外界外部的规定。</p>
<p>那么最后一个宏弘愿就是无上佛道誓愿成，惠能怎么说这个愿呢？他说“既常能下心，行于真正，离迷离觉，常生般若，除真除妄，即见佛性；即言下佛道成，常念修行誓愿力法”已经提出愿力法了。</p>
<p>整个四个愿都是什么愿力？唯愿力能消业力，叫愿力法。那么成佛道的这个弘愿，其实就是常能下心，常念修行，这八个字可以概括的。</p>
<p>什么叫<strong>下心</strong>？<strong>天下之心</strong>。把自己放到最低，我们有时候做得到，什么时候最做得到？自己陷入极度的困境之中的时候。比如说某人得了绝症，都知不知道自己能否得救啊？住在医院里，这时候他看周围的人，每一个人都比他优越。连医院里的护工，平时也看不起人家，连护士都没到的这个地位。此人此刻在如此的绝境之中，他看到护工他都恭恭敬敬的。他觉得他帮我一把，我就感恩戴德，这叫<strong>下心</strong>。</p>
<p>我们偶尔会有<strong>下心</strong>，在这种时候最容易有。一切所谓以往的光环权势金钱圈子化为乌有，周围的人个个都比你强。在这种情况下你就是下心，但是能非到到这种极端的状况中才有此下心，不应该这样。平时就应该<strong>下心</strong>，就是常能<strong>下心</strong>，每个跟你相遇的人，你要知道他真了不起，你不能跟他比，你要常这样想，所以惠能说话真实真切的很。他说成佛道是常能下心。否则你成什么佛道？</p>
<p>那么常念修行是什么？<strong>终极关怀</strong>。就把人生当成修行，人生以人生为修行，这就叫常念修行。所以八个字常能<strong>下心</strong>，<strong>常念修行</strong>，这就是<strong>成佛道</strong>了。成佛道没有他途，就这条路。那是非常非常彻底的啊。所以我看那个《吴法宪回忆录》，自己是没坐过牢无法先坐牢了，后来上下卷的回忆录，下卷我最喜欢看，他写了好多篇幅，大概有半本是在牢狱中的经历。</p>
<p>他平时多厉害，那是关进来之前空军总司令啊，地位多高啊。所以他刚刚关进去的，他自己是如实说下来的，一看那个看他的人算什么东西？就连级干部了。还有一个什么团长算什么东西，他居然对我这样的颐指气使，他很不舒服都写下来了，你算什么东西？心里就在想现在你到对我这个脸色？当初如果我做空军总司令时候我见到你不是低三下四吗？如今我要对你低三下四了。这是最初的感受都记录，吴法宪他真诚，他终于真诚了，把他在狱中的经历都写下来，我看了以后非常感动，他后来对人家那些狱卒给他一点点帮助，他就感谢得不得了。</p>
<p>他说他们是好人，其实他们都是好人，最后的结论就是全好人。我发现正印证了是这里讲的常能下心了，但我发现吴法宪悟性不高，他被关进来才常能下心。当然我们的悟性也不会比吴法宪高多少，也到那个时候才有下心。所以这就是我对惠能讲第四个宏愿的体会。你看他说常能下心，行于真正，离迷离觉，也不要讲<strong>离</strong>和<strong>觉</strong>的对立，也不要讲<strong>真</strong>和<strong>妄</strong>的对立，你只要<strong>下心</strong>就可以了，就<strong>见佛性</strong>了。常生般若，<strong>般若就是领会虚无的智慧</strong>，你领会虚无还不下心吗？你以为你有所依靠吗？没有的。</p>
<p>所以我曾经讲禅宗最有意思的地方就是你跟他交流，禅宗祖师他就用话逼你的。那一来一去全是机锋，这些机锋把你逼到无退路。你还回他一句，好像你还有什么可以支撑你的东西。他马上一句话过来，把你这个支撑东西拿掉了，终于到无力支撑的时候，你悟了，是这样的事情。</p>
<p>所以我曾经讲禅宗最有意思的事情就是通过跟我们的对话，取代我们做十年牢，就是这个意思。你被关进去了，判了10年徒刑，你一进这个牢狱你就知道了。平时你所依靠的一切都不在边上了，你曾经有权利，你曾经有钱，你曾经有亲人的帮助，朋友的帮助，这一切都不在边上，你面对的全是如狼似虎的狱卒，你还得活你。你的立足点在哪里？你明白了，10年关好了就应该悟了。10年放出来你还没悟，这10年牢真白坐了。</p>
<p>那么我们大多数人没资格坐牢，那么怎么个悟法呢？禅宗说话更硬，逼你呀，所以后面会有机缘品，我们会讲到第七品就机缘品，你看那些对话多精彩，就是逼你，让你无退路，才可能悟的。就这个道理。所以我们常人迷嘛，没有那种处境就了就悟不了。那么在这种处境当中，你才可能悟，才能知道下心是什么意思。</p>
<p>我们昨天已经进入忏悔品，也就是第6品。在行由品、般若品、疑问品、定慧品、坐禅品之后，来讲这样一个坛经当中讲这样一个主题，就是禅宗怎么看佛教的功课？佛教修行的功课。佛教的所有宗派都有这样5个环节——<strong>传香、忏悔、发愿、皈依、成佛</strong>。同样惠能也要说一说，按照他们南派的禅宗，怎么看这5个环节？第6品以忏悔做主题，就表明对禅宗修行功课的核心的理解。</p>
<p>就如他在疑问品里说，达摩讲梁武帝并没有<strong>功德</strong>，而只是<strong>福德</strong>。本着这一个精神，修行的根本目标，就是要消罪业。人都有罪，我们昨天讲这是中国思想中本来没有的观念。有一种错误，它属于罪。所以消罪业成了修行的核心，也是修行的前提。大多数人恐怕是修福报，种福田，修福报。但是修福报是不能解决生死轮回，不能消除业力。所以忏悔品就以忏悔为主题来说禅宗的功课。</p>
<p>所以我们昨天讲了第一个要点就是说忏悔是修行的前提。如果没有忏悔，不能谈得上修行，讲了这层意思。那么区分了<strong>有相忏悔</strong>和<strong>无相忏悔</strong>。有两种忏悔，人有时候确实会忏悔，犯了过错自己懊恼，那么每每是<strong>有相忏悔</strong>，所谓有相是就事论事，没有追究，没有寻找那罪业的根源。</p>
<p>惠能只说了三个罪因，哪三个罪因呢？<strong>愚迷、骄诳、嫉妒</strong>。我们昨天做了讨论，这三种罪因的揭示是非常根本的事情。天下人的通病，一<strong>愚迷</strong>，二<strong>骄诳</strong>，三<strong>嫉妒</strong>。</p>
<p>我们都可以反省自身的有没有<strong>愚迷</strong>？有没有<strong>骄诳</strong>？有没有<strong>嫉妒</strong>？</p>
<p><strong>愚迷</strong>是指<strong>驻法</strong>，<strong>着相</strong>，<strong>念境</strong>。愚迷不是愚，不是笨，不是愚笨的意思。有的人非常的聪明，但其实又非常愚迷，既住相又着相，既住法又着相又念境。第二个罪应就是骄诳，因为人我别的缘故，把自己不断的拿出来跟别人比，倘若发现别人比自己低，心生傲慢，这叫骄诳。如果发现别人比自己高，心生嫉妒，这就是第三种罪因，人高我低的失意。前面骄诳是我高人低的得意。</p>
<p>那么无相忏悔就是要追究自己过错的根源，追问罪因，然后提出了一个诚恳的忏悔，就是<strong>名于法空</strong>。我们会畏于因果而忏悔，但是按照禅宗来看，名于法空才会诚恳的忏悔。</p>
<p>法就是万物，万法就是万事万物，要领会到万法皆空。万法皆空，业力不断。我们曾经做的事情业是法，做完了他就没了。这事情没了，不等于没东西流转，留下来，那业力留下来。昨天我们讲了诚恳的忏悔，是因为领会到<strong>万法皆空</strong>。然后一个忏，一个悔，分别是两个字。<strong>忏</strong>是忏其前愆，就以往的过错；<strong>悔</strong>是悔其后过，预防将来。他说许多人能够忏其前愆，但不能悔其后过。这是对昨天讲忏悔这个主题的一个回顾。</p>
<p>然后按照顺序讲了，先讲传香，再讲忏悔，这是忏悔品的一个顺序。传香是树立修行的信心。惠能讲禅宗的原理，都在前面加自性二字。所以所传的香也是<strong>自性法身香</strong>，有5个方面，叫五身香。</p>
<p>第一个方面就是<strong>平等</strong>，叫<strong>戒香</strong>。<strong>戒香、定香、慧香</strong>，前面3个方面，<strong>戒</strong>是主题就是<strong>平等</strong>。<strong>定</strong>就是<strong>见镜心不乱</strong>，叫<strong>定香</strong>。第三身香是<strong>慧香</strong>，<strong>慧</strong>是<strong>实践</strong>。我们在定慧品里已经了解了，定慧本是一体。但是我们还是分别说了，一个叫定，一个叫慧。那么他们的关系是什么呢？定是体慧是用，叫<strong>体用</strong>关系。定是慧之体，慧是定之用。</p>
<p>第4身香是<strong>解脱香</strong>，重点在于“自心无所攀缘”。在人生的海洋当中我们并没有救命稻草可以捞，要彻底的认清这一点，“自心无所攀缘”，这叫解脱。解脱并不是把人世间看空了，还得回来，还有一个入世间法。所以第5身香就是<strong>解脱知见香</strong>。我们人生在世要应付许多的事情，必须学习，广博的学习，这叫知见。但是前提是解脱，先出世而后入世，这样一个态度，这就叫<strong>解脱知见香</strong>。我们要在自己的生命实践当中来印证佛理。</p>
<p>传香讲了之后就是讲<strong>忏悔</strong>，忏悔我们已经重点的讲了，忏悔之后就是发愿。因为发愿是愿力，叫愿力法，唯愿力才可消业力，我们昨天做了讨论。西方近代思想家法国的卢梭也认识到这一点，所以按照卢梭的思想，人世间只有一样东西是绝对的价值，那就是我们人心善良的愿望，其他的事物的价值只是相对的。</p>
<p>我们举个例子，爱因斯坦提出了E=MC2的公式，这叫质能转换公式。他在理论上已经发现了核能了。后来技术上只要做到，原子弹真来了，当然核发电站也来了。我们用爱因斯坦这个E=MC2这个公式做什么事情？可以造福人类，也可以灭绝人类。所以E=MC2这个公式只有<strong>相对的价值</strong>。我们拿E=MC2来造福人类，这是人心善良的愿望，这才是<strong>绝对的价值</strong>。卢梭的思想跟佛教的愿力的思想是相通的。所以发愿就是修行的意志。发愿有四个愿，叫四弘誓愿，一个是<strong>度众生</strong>，一个是<strong>断烦恼</strong>，一个是<strong>学法门</strong>，一个是<strong>成佛道</strong>，四大愿望。<strong>度众生</strong>并不是去做救世主，度自己跟度众生是一致的，一边是度自己，一边就是度众生。众生之过，也是我们自己的过；众生的烦恼，也是我们自己的烦恼，大乘佛教的境界，这是第一个宏愿。</p>
<p>第二个宏愿，也就是要断烦恼，如何断？就是要转变我们的心，把求如意的心转为如如之心，概括为这样8个字，“莫求如意，但是如如”。就像弘忍法师当初跟神秀讲的，“一真一切真，万境至如如”，如如之心即是真实，因为烦恼就是不如意。我们把求如意的心改了，转变它，转变为如如之心。如其本来的对待一切事物，而不是从小我出发，求这个事物如自己的意，这种转变是转识成智的第一步。佛教说千道万的道理--佛法，归根到底要完成一个转，叫<strong>转识成智</strong>。就是<strong>心的用法的改变</strong>。我们的心通常的用法就用出烦恼来，我们转变一种用法就用出智慧来，烦恼和智慧都是我们心里生出来。</p>
<p>烦恼是意识的结果。我们平时的心是意识，业造成的识。这业力把我们再次投入这世界。所以一个人出生最先到达的是八识当中的阿赖耶识。因为阿赖耶识又称为种子识，这个种子都是前世乃至再前世种下的东西。所谓三世因果这个传递呀，就是种子识的传递。我们说轮回转世，是什么东西在轮回呢？就是我们的<strong>阿赖耶识</strong>，它里边积累着过去的业，叫种子。</p>
<p>所以我们出世的时候，最初来到我们最初到达的就是阿赖耶识，死亡的时候最后离开的也是阿赖耶识，携带着今世的种子，又要准备下一次投胎，投胎了。这是佛教的说明。我们的眼耳鼻舌身都已经不发挥作用了，在弥留之际慢慢它就没了是吧？最后意识也没了，末那识也没了。最后一个走的——<strong>阿赖耶识</strong>。</p>
<p>我们说我下辈子还做人，我们提的每每是末那识，末那识就是这个小我。其实下辈子已经不是这个东西。我们这辈子的<strong>末那识</strong>不断的行动，那个种子识叫<strong>阿赖耶识</strong>，又被称为仓库，就在仓库里面全种子。那么<strong>末那识</strong>就是这个<strong>小我</strong>，他忙得很，从仓库里边搬出种子来，叫有种子而现行一一就是当下行动。但行动并不是不产生东西的，又产生新的种子，又通过<strong>末那识</strong>把它运回到仓库中去了。</p>
<p><strong>末那识</strong>就是从仓库里出来又回去来回的跑，仓库有一扇门，这扇门跑进跑出的就是<strong>末那识</strong>，所以我们这辈子所做的事情叫现行了，然后又变成种子，叫由现行而种子。由种子而现行叫<strong>受业</strong>，接受我们先前的业，由种子的现行。由现行而种子叫<strong>造业</strong>，新的种子也做出来了，那么它就规定了我们下一次，所以这就是<strong>阿赖耶识</strong>，又称为<strong>种子识</strong>，他最先到来，最后离去。一个轮回就是由阿赖耶识这条线构成的，这是佛教告诉我们的事情呐。</p>
<p>那么我们没办法向佛教要求证据是吧？它不是科学，只能来领会。三世因果，十二因缘都讲了这个事情，我们做一个说明。所以我们这个意识，就是我们这个小我，要把它转，转成本心，本心生的是智慧，这叫<strong>转识成智</strong>。所以断烦恼的意思就是把如意之心转变为如如之心。</p>
<p>那么第三个宏愿，也就是<strong>学法门</strong>。法门无尽，如何学？惠能的说法叫常行正法，就做事情，做事情在道义中做，这叫<strong>正</strong>。做事情，按这个事情本来的意义来做它。我们昨天说阳明深受禅宗的影响，所以把朱熹解释的格物转变为正事的理解。<strong>格</strong>者<strong>正</strong>也，<strong>物</strong>者<strong>事</strong>也。<strong>格物</strong>实际上就是<strong>正事</strong>，这显然是受惠能的影响。</p>
<p>惠能说学佛法门，不是学那么多修行的知识方法。法门无尽，常行正法就是真学了。在我们生命实践当中正事。我们昨天对正做了一番讨论。今天我们每个人都在自己来回答一个问题，如何正事？在一个变动了的时代，原先的正，正法似乎大家都公认，那么长行正法即可。但是由于我们讲时代的语境的转变，就context，昨天讲，前30年比如毛泽东时代，后30年改革开放时代，整个时代的语境发生根本的变化。所以我们重新该得领会何为正法？如何正事？</p>
<p>最后一个宏愿，就第4个宏愿就要<strong>成佛道</strong>，主要的意思就是<strong>常能下心</strong>。我们对下心做了说明，平时很难做到，就谦下之心。我们在极端的困境中自然会有下心。昨天我们讨论了这事，我们在平时顺利的时候，每每不会有下心，不会有谦下之心，没有谦下之心就谈不上成佛道了。</p>
<p>所以8个字来讲成佛道这个愿，哪8个字就是“常能下心，常念修行”，常念修行这4个字是说什么呢？是指人生的一种终极关怀，把人生看作是修行，以人生为修行，这叫常念修行。这就是4个愿，发此誓愿叫<strong>愿力法</strong>，愿力法它比其他什么都重要。因为人在发愿这件事情上不会自我欺骗，这个愿是你自己发的，所以它是种力量。</p>
<p>然后我们今天接着昨天说下来，讲这第4个环节，就是<strong>皈依</strong>。一个“<strong>皈</strong>”字，可以用归来的归，也可以用什么？这样一个字——“皈”，发音也是归，意思一样。我们中国人对佛教有一些最基本的了解，比方说皈依三宝差不多人人都知道。哪三宝？佛、法、僧，三宝要皈依。皈依是修行者的家。我们向来有家，但这个家大多指的是血缘关系的亲情所形成的家，用英语来说叫family。但是我们的心灵每每是无家的。那些真皈依的人，比方说我就会羡慕，因为他们有家！皈依是一件重大的事情，真心学佛的人首先找到自己的家，有的人就把皈依的形式也看得很重，皈依了某一个和尚大和尚，某一个法师，他心灵就有寄托感，这就皈依的实际的意义。</p>
<p>我们的家并不是那个豪华的别墅，我们的亲人朋友之间的关系，这叫family，他也是生生灭灭，也符合<strong>缘起性空</strong>四个字。所以我们的家究竞在哪里？我母亲00年去世，后来06年我父亲又去世了，在我父亲去世的那一刻，我真知道我曾经天真的认为，天然的认为应当永远存在的那个family没了！在这一刻我才真正领会了一切佛教宗派，由之出发的那个出发点叫<strong>缘起性空</strong>四个字。你这时候才领会到了。以前说知道有这句话，也能理解，<strong>理解不是领会</strong>。我出生在那个家庭里，我自然的认为这个家应当永远存在着。但在2006年那一刻我就知道了，没了！深深的领会到<strong>缘起性空</strong>四个字。</p>
<p>于是我们就在想我们的家在哪里？于是佛教徒就来，叫<strong>皈依</strong>了。所以皈依就是修行者的家。有家你才心定啊，常人总是如此嘛。那么皈依有三个方面，我们就称为皈依三宝，<strong>佛宝、法宝、僧宝</strong>。那么现在来看惠能怎么说这三皈依，皈依三宝。</p>
<p>我们把书翻到105页第二段。</p>
<p>“善知识，今发四宏愿了，更与善知识授无相三皈依戒。”在三皈依前面加了<strong>无相</strong>二字了，这也是禅宗的特色。讨论<strong>无相</strong>，<strong>有相</strong>和<strong>无相</strong>的事情是金刚经的主题。所以自从弘忍法师以后的禅宗祖师，都把《金刚经》看成是禅宗最重要的一部经典，所以总是讲<strong>无相</strong>。他们念出来的偈句，也一般都称为<strong>无相颂</strong>，总有<strong>无相</strong>二字。我们有相皈依那就麻烦了。比方说你皈依佛，佛在哪里呢？释迦摩尼老早圆寂了。我们何处去找到他皈依呢？所以要<strong>无相</strong>。皈依法是不是就是捧着那几部佛经不放？那又叫<strong>有相皈依</strong>。佛法是宝，佛法就在经文中了吗？捧着经文不放，这叫<strong>有相</strong>，应当是<strong>无相</strong>。</p>
<p>还有<strong>皈依僧</strong>，现在基本上都是有相皈依，我们真找到那师傅了，我们相信了他，我们皈依了他，还有仪式，这都是<strong>有相</strong>。惠能主张<strong>无相</strong>，所以叫无相三皈依。佛是什么？<strong>佛</strong>就是<strong>觉</strong>。<strong>法</strong>是什么？<strong>法</strong>就是<strong>正</strong>。<strong>僧</strong>这个和尚是什么？<strong>净</strong>，干净的净所以无相三皈依他是这么说的，“善知识！皈依觉，两足尊；皈依正，离欲尊；皈依净，众中尊！”关于两足尊、离欲尊和众中尊，我们等会再说。</p>
<p>我们先看下去，“从今日去”，从现在开始。</p>
<p>惠能说我们应当“称觉为师，更不皈依邪魔外道”，佛教之外的那种皈依叫邪魔外道。</p>
<p>“以自性三宝常自证明。”在三宝前面，就佛、法、僧三宝前面冠以<strong>自性</strong>二字，实际上皈依三宝就是皈依我们自己的<strong>自性</strong>了。</p>
<p>“佛者，觉也；法者，正也；僧者，净也。自心皈依觉，邪迷不生，少欲知足，能离财色，”这叫“两足尊”。人站在这世界上，就像人是两足动物一样，用靠两只脚站着，这两足是怎么呢？一个是<strong>福</strong>，一个是<strong>慧</strong>。我们确实不能没有，比如说财产吧，财物是养身之资呀，你穷的叮当响就谈不上福了吧？还有一件事情叫色，就男女。没有男女的关系，社会不可能延续。所以男人与女人的情感那叫<strong>色</strong>。<strong>转财为福，转色为慧</strong>，这就是两足尊了。财色两字对生活最重要。</p>
<p>我们的日常生活，这个《孟子》里边告子讲的那句话也是对的，孟子同意“食色性也”，人的天性。食就是食物，要吃东西。“食色性也”，这里边没什么恶的。肚子饿了要吃饭。你有一个胃有食欲，这有什么错呢？人有性别——男人和女人，对异性有追求，这又有什么错？<strong>天性</strong>呀，把这两个性拿掉，人类社会不存在嘛。</p>
<p>那么佛家怎么讲这件事情？他要说转的。<strong>转财为福，转色为慧</strong>。这可是非常真实的事情。我们有<strong>财</strong>，我们也有<strong>色</strong>，不等于有<strong>福</strong>有<strong>慧</strong>。无财无色怎么了得？有财有色呢？可能是<strong>愚迷</strong>、<strong>贪婪</strong>。所以讲到觉悟这件事情呀，就我们皈依佛就是皈依觉。解决一件什么事情呢？<strong>面对财色的态度</strong>。所以那句话我们回顾呀，<strong>自心</strong>皈依<strong>觉</strong>。</p>
<p>那叫邪迷不生，少欲知足。“能离财色”这就是“两足尊”了。哪两足？一个<strong>福</strong>，一个<strong>慧</strong>。这<strong>福慧</strong>哪里来？由<strong>财色</strong>转过来。<strong>财</strong>是<strong>福之资</strong>。<strong>色</strong>是<strong>男女爱情</strong>——<strong>慧之引</strong>，这是我的领会。佛教要教我们如何面对财产和面对男女爱情，这两件事要回答。因为这是人生当中，日常生活人生的最基本的两件事，没有财，我们如何养生呢？财是养生之资呀。共产主义还没实现呢。共产主义一天不实现，人类社会就有货币嘛，就有一个财字嘛，或土地，或货币，这是福之资。共产主义实现了之后还是有男女的，只要有男女就有爱情，过去的人有爱情，现在的人有爱情，将来的人也有爱情，这就是人类社会嘛。所以禅宗怎么看待这两件事，基本的事情。</p>
<p>我们财产无论多少，并不是财多了福就多了，我们不能没有财，财少的时候叫<strong>贫</strong>，财多的时候叫<strong>富</strong>。如何把贫或富转化为福呐，真正的福叫安贫安富，这才成了福了。不能安贫叫贫贱难耐凄凉。不能安富是什么意思？富贵不能乐业，这是孔子说的，“不仁者不可以久处约，不可以长处乐”，<strong>约</strong>就是节约的约字，表示<strong>贫贱</strong>。快乐的<strong>乐</strong>字，表示<strong>富贵</strong>。<strong>不仁者</strong>就是<strong>心没安好的人</strong>，怎样的生活处境都没用，贫贱难耐凄凉，那叫不能安贫；富贵不能乐业，那叫不能安富。这叫左也不安，右也不安。</p>
<p>财会惹祸。因为你没安呐！安贫安富财就变成了<strong>福</strong>了。这里有儒家思想的。我们中国人把佛学中国化的基础是什么？我们本有儒家和道家的智慧嘛，那才能中国化嘛。所以正确的看待<strong>财</strong>、<strong>色</strong>二字，是学佛的人必须充分认识到的事情。</p>
<p>我们再问一个问题：安贫容易还是安富容易？【学生：安贫容易】</p>
<p>对了，安贫容易。其实安富更难。安贫乐道还能做到。安富乐道呢？难了。不能安富，财就是祸。祸福就转换了吗？也有不能安贫的，于是也是祸，叫人为财死，鸟为食亡。人为财死嘛，就是不能安贫呀。两种情况都有，但是我自己体会后者更难，安富更难。财倒是很多了，离开福越来越远了，财不多的时候倒蛮有福的噢。</p>
<p>这种事情我们是改革开放30多年看的多了。你冷眼旁观这世界，改革开放30多年的中国世界，你看看就知道了，安富真难。但是现在也有很多不能安贫的，当然我们说，如果这个社会严重的贫富分化，社会正义的消失，我们为社会重建社会正义而奋斗，没问题的啊。但个人尽可以参加重建社会正义的努力，但个人对自己的财产状况应该什么？安贫。这两者不应该是背离的。就是我们接受了佛教，我们就不为社会正义奋斗了，好像这两者一定冲突。</p>
<p>我又想起《人民的名义》，塑造了一个人物，这个人名字给他起得非常好，叫王文革。为什么叫文革？工人就这个样子的。你看受到文化大革命影响，王文革是工人领袖。他领导着带领着复厂队，到后来干什么呢？劫持人质。最后劫持了那个老检察长，后来我想这是剧作者丑化工人运动的领袖。你们想想工人领袖是什么料？瞧，王文革吧，这个用心何其毒也。这是我的自己的评价，各位听听过去。</p>
<p>但是我是领会到这一点的，就编剧有意识形态倾向的，工人领袖就一定就是王文革吗？我王德峰就不能做工人运动领袖了吗？以前工人运动领袖不就知识分子到工人群众中去组织工会吧？我想我如果做工人运动领袖的话，我绝不是王文革为了自己那个股权的事情劫持人质，那太丑陋了。我安贫，但我可以做工人运动领袖，我的意思就这意思，他并不冲突。我可以安贫，这个展开一下就是这个意思。</p>
<p>皈依觉什么意思？<strong>转财为福，转色为慧</strong>。爱情是最有意思的，人情冷暖至极致，无非男女爱情。有爱的能力，爱的力量的人一定是有慧的啊。因为爱情不是人事，不能把它还原为生物层面，那叫性欲的满足。不，爱情是把生物性转化为社会性。那是<strong>慧</strong>！如果这一次转不成呢？那么我们就呈现在动物般的欲望中了。那叫红楼梦里面讲的肌肤烂淫之辈。警幻仙姑说谁呀？说宝玉这个人不得了，好，古今天下是吧？第一淫人！然后宝玉吓了一跳。第5回啊，宝玉初游太虚幻境，警幻仙姑接待了他，跟他讲我之所以喜欢你这个人，因为你是古今天下第一淫人。是宝玉吓了一跳，他说我平时就不大听父母的话唉，不好好用功读书，这倒是真的。至于淫字，我年纪尚小，不知淫之为何物啊。</p>
<p>警幻仙姑说非也，你那个淫可是别人很少有的，叫<strong>意淫</strong>！这时候中国汉语当中没有爱情这个词的，爱情这个词语出现在汉语的词汇系统当中，是因为翻译英文或者欧洲文献才有的。翻译love。一生的爱情，在此之前汉语中并无爱情，爱情二字。所以曹雪芹也没发明这个词，用了这样一个词叫“意淫”。我们一看还是蛮熟的，一个淫字，其实很高妙的境界。</p>
<p>警幻仙姑说这意淫二字，“只可心会不可口传，只可神通不可语达”，何等境界，就无法用言语来表达的。只可心领神会，叫只可心会，不可口传，只可神通，不可语达。我一看到这样的话，我知道了。曹雪芹的红楼梦是第一部认真地讨论爱情境界的小说。在这之前有《牡丹亭》、《西厢记》根本没把爱情的境界讲出来。这爱情啊，是让我们引出我们智慧来的事情，那可了不得。我们年轻的一代都要进入这座伟大的学校叫爱情。爱情是座伟大的学校，我们的下一代应当在这所学校里边成长，最后毕业。我们为人父母的不要害怕自己的孩子Fall in love——坠落爱河，然后我们就为他担心你。这种担心是完全不必要的。</p>
<p>我们每个人都得经历这所学校，而且最好失恋过。失恋让男孩子强大，让女孩子聪慧，这是我的基本认识。所以当我第一次发现我的儿子失恋的时候，我很高兴啊，我知道他成长了，他会强大起来。爱情肯定是冒险的，你随时可能被抛弃你知道吗？这是好的事情，叫慧之引呐。你要转就可以了。<strong>转色为慧</strong>。父母是怎么看待孩子的恋爱的呢？马上就想到结婚了。结婚倒是件俗事，都知道贫贱夫妻百事哀，要有物质基础嘛。红楼梦把这件事情也点出来了，宝玉跟黛玉的关系叫<strong>木石前盟</strong>，宝玉跟宝钗的关系叫<strong>金玉良缘</strong>。</p>
<p>你看婚姻就是要金玉的。你哪怕不多要那么一点点吧，才叫良缘，叫婚缘。爱情是朴素的，淳淳朴朴，他叫<strong>木石前盟</strong>，不参任何一点人为的、功利的意思在里边，掺一点，掺杂一点点功利的意思在里边，它已经不是love了，不是爱情了。</p>
<p>我们应当希望我们的孩子爱过一次，我们别把我们所谓人生经验投放到他们的恋爱这件事情上去。时下的家长们恐怕都犯这个病，但害怕自己的孩子恋爱了，一旦恋爱知道了，马上问对方是谁？家庭出身如何？门第怎样？就一连串问题来了。那你是讲婚姻的事情，这是另一码事。不能因为这另一码事把这一码事给否定掉了。</p>
<p>我们说在爱情当中被抛弃的一方是悲剧，还是抛弃别人的一方是悲剧？那个没爱的能力的人，他没真正的爱，他是不幸的。那个真正的爱的人，后来离开了这个爱，他是幸运的。我们要改变我们对这个事情的态度。我们从自心出发，这禅宗的原则，我讲过这些话，同意者寥寥。</p>
<p>所以时下我一直觉得80后90后蛮可怜的。我们曾经enjoy love，我们50后enjoy love，写过多少情书你知道吧？那一个认真呐。那个纸一定要很好的信纸，写个三页，然后我在大学读书的时候呢，我们班上总有一个人是负责，轮流的负责到开信箱去的。那么下午4：30我就在寝室里等着，他搭着一大堆东西来了，我马上上去看有我的吗？看了老半天没我的，心里的一种失落。第二天继续看，那时候通讯可不方便，一封信终于到手了，就那么两页纸，我不知道看过多少遍呐。这让我一个礼拜是幸福，洋溢在幸福感中啊，那就是love。现在他们都不会写情书的，发短信的。</p>
<p>——“侬（你）想我吧？”</p>
<p>——“我在想了”</p>
<p>结束了。</p>
<p>杜甫说“烽火连三月，家书抵万金”，我们应该说情书抵万金。那个等待有时候，过尽千帆皆不是，他就是怀疑，我跟他约错地方约错时间了没有？</p>
<p>现在这种事情不存在的，一个短信发送了</p>
<p>一—“侬（你）在啥地方？</p>
<p>”哈哈哈~~~</p>
<p>我们说现代科技信息手段多好，没什么好。深层有质的情感消失了，这就是惠能讲，皈依佛什么意思？皈依觉，皈依觉是什么意思？与财色，“能离财色”，与财离财，与色离色。就像那条原则叫<strong>欲相离相</strong>一样的道理。其实财色都是必要的东西是吧？生活中的必要，但是我们不能陷入其中，与财离财，此才就转化为福了。与色离色，此色就转化为慧了。<strong>福慧具备</strong>这叫<strong>两足尊</strong>，就这个意思。</p>
<p>“少欲知足，能离财色”，不是不需要财色，千万别误读了。惠能叫我们活在这世上一不要财，二不要色，这怎么可能呢？因为大多数人没出家的，大多数人必须在家修行。全体都出家，全体人类都出家，人类社会就没了是吧？繁衍就结束了。但是真出家人一不要财二不需要色，这是真的。因为他是给我们树立一个榜样，人能做到这一点，他们的使命是做我们的教师，少数人有这个使命，绝大多数人没这个使命，惠能也是带着使命来的。由于他带着把佛学中国化，为禅宗奠定基础的使命，完成一次佛学革命。让参禅的活动从少数文人的精神活动的小圈子里边解放出来，让禅宗注入了老百姓的内心深处去。他带着这个使命来，所以他必须三岁时父亲去世，他必须不识字，显然带着使命来。如果他识字，有很多的文化知识，他就是文人了。他就完成不了佛学革命。他必须是普通人，劳苦民众当中的一员，砍柴火卖柴火为生，又是文盲。可见他带着使命来。我们绝大多数人没有这个使命，所以惠能在疑问品里跟我们讲在家修行，<strong>人生无处不是道场</strong>，这就对了。</p>
<p>那么出家人当然一不要<strong>财</strong>二不要<strong>色</strong>。不要财干嘛？他托着那个钵呢，托钵嘛就讨饭，一切真和尚都行乞嘛。但这个钵呢不能太大，就这么一点点，一个小钵，人家把饭放进去，你吃了今天死不了就可以了，过午不食嘛。现在这个钵大了。我在复旦的校园看到穿袈裟的人你知道吧？</p>
<p>然后我上前去问他，我说“你是哪个庙的？”</p>
<p>他说“什么什么庙。”</p>
<p>我说“你到复旦来干嘛？”</p>
<p>“读MBA。”</p>
<p>我愣了一下，我说“你们和尚还要学管理科学吗？”</p>
<p>然后我笑了，我说“你们那个庙的钵太大。那个钵里的饭多的要管理的程度。”是这件事。他听了有点尴尬的样子。</p>
<p>我说据我知道佛陀的钵很小，他装满饭就吃完就结束了，然后开始说佛法了。你体大的要派你来学管理科学，就那个饭多到要管理的程度，就这个意思。是不是有点荒谬？后来我想算了，我不要说话这么直率，一下子打击了他的自信心。他是方丈派来的，他是监院——当家当中第一把手。庙里边有这个制度嘛，方丈底下有当家吧，第一当家叫监院，要让他来学管理科学，他离了财不行了，就是这个意思。和尚一不要财二不要色是吧？财不需要，为什么？众人给供养他就可以了，他就托着个钵嘛就可以了。</p>
<p>那我们在社会中不能无财无色，这是肯定的。那么<strong>跟财色之间要有一个自由的关系，这叫与财离财</strong>，所以这个财，因为你能<strong>与财离财</strong>的缘故，财无论多少都是你的福了。因为你能<strong>与色离色</strong>的缘故，男女爱情成了你智慧的引，引出你智慧来。这就是第一个<strong>皈依</strong>。</p>
<p>不是皈依释迦摩尼，他已经圆寂了，归于我们自身本有的觉，buddha这个词，就梵文了。我们翻译成汉语叫佛了。buddha这个词本意就是<strong>觉悟</strong>，佛就是普通人，一个觉悟了的普通人，所以皈依<strong>佛</strong>就是皈依<strong>觉</strong>，皈依budklha就是皈依<strong>觉</strong>了，这话完全是对的。</p>
<p>然后第二个皈依就皈依<strong>法</strong>，他说叫皈依<strong>正</strong>，如何是皈依<strong>正</strong>呢？关键是下面一句话，自心皈依正。我们看到这一行。“念念无邪见，以无邪见故，即无人我贡高，贪爱执着，名离欲尊”。这里边最关键的是<strong>去掉我执</strong>，那你就皈依法了，皈依<strong>法</strong>就是饭依<strong>正</strong>，我们为什么不正？因为我们有一个<strong>小我</strong>把它看得十分重要，每个人都无限珍惜自己这个<strong>小我</strong>。不断的拿出来跟别人比，发现别人比自己高心生<strong>嫉妒</strong>，发现别人比自己低心生<strong>傲慢</strong>。其实我们真的想一想，我们不断拿出来跟别人比的我是自己的本来面目吗？不是。</p>
<p>所以那个惠能让惠明悟就两句话说下去，第一句话叫“不思善不思恶”。第二句话是“正于末时”，就正当此时此刻，哪个是明上座本来面目，这一问问得好，把惠明这个<strong>小我</strong>给他夺掉了，你明上座不是你的本来面目，你当初还是四品将军也不是你的本来面貌，所以我问的是你的<strong>本来面目</strong>，就把这个<strong>小我</strong>给它拿掉。后来惠明这两句话说下来他就悟了。所以这个<strong>皈依法</strong>就是这个意思，不至高亲人，叫无人我贡高，这样的就是叫离欲尊，因为这个<strong>小我</strong>抓住不放，种种的欲求，没完没了，因为你不断把自己跟别人比。</p>
<p>第三个皈依。皈依<strong>僧</strong>，现在都是要到庙里去找和尚皈依的，在惠能看来不必，现在确实也不必，假和尚蛮多，当然也有真的，我们不能一概而论，要实事求是。但是最重要的是皈依<strong>净</strong>。干净的净。“自心皈依净，一切尘劳爱欲境界，自性皆不染着，名众中尊。这就叫众中尊”。你自己就是尊了，你有自性清净之心，你自己就是僧，就是那个和尚了，和尚当然是众中尊了。</p>
<p>底下我们看下去，“若修此行，是自皈依。凡夫不会，从日至夜，受三归戒；若言皈依佛，佛在何处？若不见佛，凭何所归？言却成妄。”你说我皈依佛了，你又没找到佛，你还说自己皈依不就是妄语吗？还是皈依自己本有的觉吧。</p>
<p>“善知识！各自观察，莫错用心，经文分明言自皈依佛，不言皈依他佛。自佛不归，无所依处。”我们每个人怀里都揣着一个宝，就是<strong>佛性</strong>。学佛不要到外面去求。有一个和尚远道而来，不就是找谁，找马祖道一吗？这个和尚后来也是成了禅宗祖师，叫大珠慧海，大珠慧海来到了马祖道一的庙，马祖道一问他，你到我这里来干嘛？他说求佛法。马祖道一跟他说，我这里什么东西都没有，你放着自家宝藏不顾，抛家散走，何必如此？那么大珠慧海就惊讶的很，哪个是我惠海的自家宝藏呢？打住，把马祖道一立刻回答，汝今问我者即汝宝藏，汝今问我者即汝宝藏，就是你的宝藏，这句话一说出来，慧海言下大悟，这也是一个公案。禅宗公案当中一条，讲这件事，马祖道一回答的非常有意思，你放着自家宝藏不顾，抛家散走，到处寻寻觅觅的，干什么？所以慧海很疑惑，什么是我自家宝藏？即君问我者。你刚才不是问我要佛法吗？这如此提问者就是你的宝藏。为什么这么说？慧海到马祖道一这里来求什么？是求财吗？是求权利吗？他既不是来求财，也不是求权力来的。他倒是来求佛法来的，生出求佛法的心，那个心是佛性呀。假如你本无佛性，你可能求这个可能求那个，偏偏永远也想不到要求佛法。我们一旦有了求佛法之心，我们马上就证明了自己有宝，有宝藏。</p>
<p>我们求财有根据的。身体要活在这世界上，财是养身之资，有根据的。我们求权力，求权力也有根据，因为社会分了等级，你要么被人支配，要么支配别人，你选择了，是吧？也有根据。那么你来求佛法也有根据吧？有！这根据不在社会中。你要活在这世界上求财，根据就在社会中，财富是以货币来表达的，你要求权力也在根据也在社会生活中，因为人有等级区分，你要求佛法根据一定不在社会中，在哪里？在你心里，这就是你的自家宝藏。所以惠海言下大悟。</p>
<p>所以惠能说自佛不归，自己本有佛，却不去皈依，无所依处。底下又来一段今既自悟。今天既然自己悟了。</p>
<p>各须你们各位，“各须皈依自心三宝，内调心性，外敬他人，是自皈依也”。这叫<strong>自皈依</strong>。在我看来这句话太好了，是用佛家的语言说了一个什么事情呢？要我们树立，自己树立道德主体，独立人格，用佛家的语言说的话，你把佛家的语言拿掉变成阳明，就这个意思。阳明心学就这个意思。树立<strong>独立的人格</strong>，用佛家的语言阐述的叫<strong>自皈依</strong>，家就在你心里。皈依不是找家吗？皈依是修行者的家，这家在哪里？在你心里。心安是家，这样的人叫<strong>内调心性</strong>，<strong>内调心性</strong>正好可以让阳明现成接过去的。心学就这样，心性之学，宋明儒家两派都是讨论心性问题的。所以儒家到了宋明的时候就儒家的学说就叫<strong>心性之学</strong>，只是在心性之学这个主题上有两派之争了，一个说<strong>心即理</strong>，一个叫<strong>性即理</strong>，性即理是谁的主张？程朱理学，心即理是谁的主张？陆王心学。所以宋明新儒学就是心性之学，在这次禅宗通过惠能已经说了内调心性，外敬他人。中国人都能做到这一点的话，那叫真正的近代社会来了，遍地都是<strong>独立的人格</strong>，因为每个人都<strong>自皈依</strong>，就这个意思。那惠能了不得，用佛家的语言说出了将来宋明新儒学的主题。</p>
<p>宋明新儒学的主题就是树立独立人格，解决中国文化的一个长久的病症，叫主奴关系的文化。王阳明说，我们每一个中国人，无论是贩夫走卒，还是引车卖浆者流，都要做收拾精神，自作主张的大英雄，这就是阳明心学的主题。如果阳明心学真能在中国大行天下，今日是中国社会不会是如此这个局面，所以我们说禅宗为宋明新儒学做好了思想准备。禅宗通过惠能用佛家的语言说出了树立道德主体独立人格的要求，这叫<strong>自性三皈依，自皈依</strong>，所以他这句话很重要了。内调心性，外敬他人。这样就把这个皈依这件事情说明了。</p>
<p>我们刚才已经讲了，佛教功课的第四个环节——<strong>皈依</strong>，现在讲最后一个环节一一<strong>成佛</strong>，成佛的环节就是<strong>顿悟</strong>。患能是禅宗南派的领袖，禅宗北派的神秀主张渐悟，所以叫<strong>北渐南顿</strong>。</p>
<p>这个问题一直在讨论，在禅宗的修行以及对禅宗的学术研究，一直在讨论渐悟和顿悟的这个问题。惠能主张顿悟，许多人觉得不可思议，觉得还是神秀的比较可靠，能渐渐的悟，怎么可能一下子<strong>悟</strong>呢？其实从这个道理上讲，我们把“<strong>悟</strong>”和“<strong>知</strong>”区分开来的话，“<strong>知</strong>”确实是循序渐进的增长，但“<strong>悟</strong>”不等于“知认知的活动是积累，毫无疑问，而且还在循序渐进。比方说你学物理学，那本教科书就是如此，你必须从第一章开始，前面几章没搞清楚，后面几章你不会懂。认知的过程就是这样一个渐渐的积累过程。但是“悟”不是这样，为什么？“<strong>悟</strong>”是无所得。</p>
<p>我们曾经讨论过“<strong>悟</strong>”和“<strong>知</strong>”的区分，“<strong>悟</strong>”的活动没有能悟和所悟的区分，“<strong>知</strong>”的认知活动有能知和所知的区分。我们都有认识能力，我们叫能知的主体，我们发挥我们的认识能力去获得那份客观的知识。比方说牛顿三大运动定律，你发挥你的理解力，理解了它，这三大运动定律就是你的所知，所以叫<strong>有所得</strong>。但“<strong>悟</strong>”的活动并不是这件事情，并不是好像某样东西在某一个地方，等着我们去悟到它。“<strong>悟</strong>”不是这样一件事，假如有一样东西在那里等着我们，我们终于悟到了它，这就不是“悟”了，这就是认知了。牛顿三大运动定律，的确是在那里，等待着每一代年轻人在学习的时候，终于认知了它——有所得。“<strong>悟</strong>”不是这样的，“<strong>悟</strong>”是<strong>无所得</strong>，“<strong>悟”是我们的心灵与虚无的默契</strong>；与虚无默契，你有什么得？那叫nothingness，<strong>虚无</strong>嘛。所以，没有什么渐悟，有渐知，但并无渐悟。今天悟了一点，明天悟得比今天更多一点，没这种事啊。</p>
<p>许多人学佛就陷入这个误区，他们彼此之间还比较：谁<strong>悟</strong>得更多一点。是不是有个比较啊？我有许多中学同学，都学了好十几年的佛了，他们彼此会讨论，然后说：你这个不对，我做个道理给你听。他说了以后，那个人很激动：哦，你比我悟得高。有高下之分了。我说：这个跟悟一点关系都没有，就是你的佛学知识更多了，就这个意思。这跟悟有什么关系呢？悟，就是要么悟了、要么没悟啊。没有从少到多这样的过程，你要么悟了、要么没悟。</p>
<p>所以我们必须承认的倒是修是渐渐的修，但没有渐渐的悟，<strong>渐修</strong>、<strong>顿悟</strong>。顿悟嘛，就是文革当中有一句话是这么说的，叫“灵魂深处爆发革命”啊，这就顿悟了。这句话说的很好的，说出了悟的这个事情。第一、它不是头脑的事情，是灵魂的事情，认知活动是头脑的事情，所以要积累。从知道得少到知道得多，头脑的工作。悟是灵魂。灵魂就是生命情感，生命情感的升华。升华，本来是个物理学概念，从固态越过液态，直接气态就樟脑丸嘛，不经过液态了，直接气化，越过液态变成气态，这一步叫升华。<strong>悟</strong>，就是生命情感的升华，并且一下子来，叫爆发，而且是革命，而且是灵魂深处的事情。</p>
<p>所以我曾经跟那些我的中学同学，他们学佛那么精进啊，我说<strong>精进波罗蜜</strong>，称得上；但最终要得<strong>般若波罗蜜</strong>，般若波罗蜜就<strong>悟</strong>啊。读佛经那么精进，可曾流过泪，我就这么问他，他说没流过。我说你没流过，肯定没悟过。</p>
<p>读佛经不是头脑在读，是把我们心灵的生命感受放到经文中去，放得进去，这一段你就懂了呀；再把它拎出来，那叫悟啊。读佛经要不求甚解。甚解嘛，是学术研究；有学者专门研究金刚经啊，写了著作啦，那叫<strong>佛学</strong>，不叫<strong>学佛</strong>。我们读佛经就是要创造一个条件，手机关了、家里电话线拔掉、这段时间没有人送快递就可以了。那你就静下心来读吧，一行、一行的读。口诵心行，口在念诵、心跟上去，不是头脑跟上去，心跟上去，这叫<strong>口诵心行</strong>。口诵心不行，叫小和尚念经，有口无心。口诵心行，读着、读着，突然！<strong>心生法喜</strong>。那种无以名状的<strong>悲欣</strong>之情，起来。这段，你真懂了。那是生命情感的升华，这就是我们跟佛经的关系，所以惠能主张顿悟。</p>
<p>然后，我们跟佛经的关系，究竟是什么关系呢？第七品里有，第七品叫机缘品。我们先做一件事就是成佛，成佛的起点就顿悟，悟了之后该怎么办？还要修吗？也是个向来讨论的问题。有人主张：不必修了，你已经是佛了嘛，还修什么修？</p>
<p>其实要修，惠能也主张要修，就不能退转，必须保任、不退转。<strong>保任</strong>、<strong>护念</strong>，以免退转。护念很重要的，有时候菩萨也护不了，需要佛帮助他。我们都知道。</p>
<p>这个境界有三层：第一层叫<strong>阿罗汉</strong>，阿罗汉往上走叫<strong>菩萨</strong>，菩萨再往上走是<strong>佛</strong>。我们知道佛经当中最短的一部经是《心经》，为什么有《心经》呢？就是那一件事情，舍利子啊，舍利子这个人其实很了不起的，是佛陀的一个大弟子，后来被称为智慧第一。在当初他只是阿罗汉境界，连菩萨境界都没到，所以他就去请求观自在菩萨——就是观世音菩萨：你能不能帮我提升？观世音就答应他了，但是观世音心里也没底呀，他想把舍利子提到菩萨境界，这件事情要得到释迦摩尼的认可，能不能做？</p>
<p>那一天，佛陀坐在那里，饭吃好了，底下那么多人等着。观世音上去，先对佛作礼，作完礼之后，就提了一个请求：舍利子跟我讲，能不能讲一讲菩萨境界？佛陀答应了，然后佛陀先做一件事，行深般若波罗蜜多。给谁呀？给观世音护念。在佛陀的护念之中，观世音开始说话了，许多人听，其中最重要的就是舍利子在听，因为观世音跟舍利子说话。我们都背得出来的260个字，在佛陀的护念之下：</p>
<p>“观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。舍利子，色不异空，空不异色，色即是空，空即是色，受想行识亦复如是。舍利子，是诸法空相，不生不灭、不垢不净、不增不减。……”不就来了嘛，最短的一部，260个字，这个心经讲完之后呢，舍利子进入了菩萨境界，所以心经就是<strong>菩萨境界</strong>。</p>
<p>菩萨也没有充分的把握，菩萨还有许多烦恼，没有达到无漏，不是无漏智嘛。杨老师跟我讲，有人问<strong>无漏智</strong>。<strong>无漏</strong>就是<strong>所有烦恼都没有</strong>，<strong>漏</strong>就是<strong>烦恼</strong>。那么，有一个菩萨达到了佛的境界，他不想做佛，哪个谁啊？地藏王，因为菩萨是要渡人的一—“地狱未空，誓不成佛”。地藏王，他其实就是佛的境界，这是佛家讲的3种境界。</p>
<p>那么，这绝不是虚言啊，绝非虚言。我们以为学佛仅仅是精神上的活动。其实他的目标当然是精神活动，通过精神活动最起码达到一个目标，叫“<strong>了生死</strong>”。阿罗汉就是了生死，了生死可真的，我们现在都不行的，不知道自己什么时候走的，以怎么个方式走也都不知道的，有可能被送到什么ICU—一插着各种管子呢、还有心电图呢、呼吸机，挣扎着还不知道什么时候走。</p>
<p><strong>阿罗汉</strong>是什么？好好的就知道什么时候走了。这件事情至少做到，已经到阿罗汉境界了。其实每一个出家的和尚，经过一段时间在寺庙中修行，应当达到，如果达不到，他即是假的。未必能指望每一个出家的和尚都达到菩萨啊，但起码应当达到<strong>阿罗汉</strong>。寺庙里以前基本都是，现在不是，很少了，那些和尚知道自己什么时候走。</p>
<p>上世纪90年代，龙华寺就有一位——九十几岁，突然跟那些弟子们讲：明天我要走了。你是说：你瞎讲的，你看你面色红润的。他说：别说，我要走了，我知道，别来打扰我，你们就做一件事，记下来，我现在也有一点钱嘛，和尚都有一点财嘛，怎么安排？你们记下来，哪些到我家乡去给谁谁谁、哪些你们做什么事情把它用掉；然后还有一件事情，打一桶水到我寮房里，我沐浴，明天第二天上午九点半之前别进我的房间。后来就有人汇报到宗教局，宗教局干部就认为必须把他马上送到医院，明天要走了，这怎么可以？后来又有一个大居士劝这个宗教局干部：别送他到医院，我们要尊重他。后来宗教局干部总算同意了。第二天九点半，那些弟子把他的房门打开了，走进去一看，他坐在他的蒲团上已经走了，那叫圆寂。坐化圆寂，都知道的，这就真和尚啦，我们不知道他是否达到菩萨的境界，但是我们已经判断出来——<strong>阿罗汉</strong>。</p>
<p>我不是在这里讲过嘛，未必一定要出家哦，我们弄堂里，我讲过吧？就是那个老太，孤老太嘛，修几十年净土宗啊，修到阿罗汉。有一天到水房里打水，那时候有老虎灶嘛，现在没了，上海老虎灶多啦，每条弄堂都有，到老虎灶打水，跟老虎灶主人讲：“我这是最后一次来打水”。老虎灶主人说：“为什么”？她说：“我要出远门了”。那么老虎灶主人也不在意了。上海，移民城市，说出远门，一般理解为回乡探亲，就这件事，所以大家都不在意。3天之后，消息传来，这老太太因为3天没出门了，邻居终于受不了，破门而入，因为她孤老——一个老太太，进去就看她坐在她的床上，早已坐化。她去打水的时候好好的。所以未必一定要在丛林里修啊。</p>
<p>修成阿罗汉的人有，就知道自己什么时候走。南华寺的一个和尚，在外面院子里边讲佛法，边上有一棵大树，正好这一段讲完了，他是往那个大树上一靠，跟弟子们讲：我走了。果然就走了。大家再上去看，已经走了。他把这段经文讲完，手往那个大树上一扶啊，走了。所以这就是讲悟嘛，没有悟过的人，是不可能的！这件事。</p>
<p>我们都不知道自己什么时候走。所以，现在跟我年龄相仿的、我许多中学同学就修，其中一个是讲得最老实的话，他说：德峰啊，我是修得蛮晚的，现在还要努力修。我说，为什么。我就图一件事情，好走，要走得好，别的事情我已经不在乎了，就怕走得不好。他问我来得及的不？我说：我想应该来得及的吧。那你也很虔诚，你真的修了。好走不容易的啊！</p>
<p>所以按照这个惠能的理解呢，这个修行的过程分了两大阶段指向这个涅槃的境界。第一阶段叫解悟。这解悟阶段，两件事情都很重要。一个要读佛经的，因为佛陀说了那么多话就是来开导我们的，佛自己不需要这些话，就是来帮助我们的。所以在佛经的帮助下，还有一个，要有大善知识，禅宗祖师这样的人物，因为我们是小根之人啊，绝大多数人都小根之人。没有佛经和大善知识的帮助，我们基本上很难，那么这个阶段就解悟，但现在佛经是在的啊，大善知识不知道哪里去找，以前都找得到。</p>
<p>像那个电视剧，看过吧，《天道》。那个主人公是从欧洲回来啊，金融学专家呢，然后在中国股市上炒，资本市场上弄一把，后来那个事情很危险，他心里发慌，到庙里去了。山上那座庙，那个老和尚接待了他，老和尚根本不懂什么资本市场这类事情，就几句话的对话，那个人心里明白了，错了，直到下面该怎么干。这就是大善知识在帮助他。那个主角是王志文演的，这个电视剧非常好看的，本来叫《遥远的救世主》，变成电视剧取名叫《天道》。很值得看，反映了改革开放30年，前一个阶段中国社会的突出的矛盾，非常值得看。里边有3个人自杀，各有原因的。好，我们不讲。</p>
<p>那么，解悟这个阶段，到什么时候，突然结束了呢？这一刻叫<strong>顿悟</strong>。在这个阶段当中，我们需要大善知识和佛经的帮助，这叫<strong>解悟</strong>。一般我们知道佛教的基本常识，我们修行有四个字：<strong>信、解、行、证</strong>。起点是<strong>信</strong>，不信不行的。然后<strong>解</strong>，<strong>行</strong>就是实践，在实践中证悟，印证佛理。信解行证，信是起点，这一点很重要。我母亲就是信佛，但是不识几个字，解放以后才扫盲啊，在我父亲的帮助下识了点字，但是一天到晚，口中念念有词的那个佛经的经文。后来，我就有一次，我小嘛，我就问她，我在中学的时代，大概，我问她：你念的这些你懂吗？她说不懂。我说不懂你念什么？然后我要嘲笑她。父亲后来非常认真跟我讲：你不能嘲笑她，你是知识太多了，你跟她的区别是，她有信，你没有信。就那个信念的信，你没有，你不能跟她比的，他说。当时，我父亲非常认真地批评了我，你要你母亲跟你讲一大堆佛学知识呢，她是不懂的，她有个信字你没有啊。所以，这很重要。所以，后来我就明白了，什么叫“知识越多越反动”，就是我们很难信了。因为知识多了，倒不如知识少的人，他就信啊。信是起点，信解行证，那么解悟，终于顿悟，这一刻叫<strong>顿悟</strong>。</p>
<p><strong>顿悟</strong>之后，修行继续，进入第二阶段叫<strong>证悟</strong>。证悟的时候，一不需要佛经的经文，二不需要大善知识，因为你顿悟了，已经悟了。但是还要一一<strong>保任</strong>，还要<strong>护念</strong>。怎么<strong>护念</strong>，怎么<strong>保任</strong>？<strong>用你自己的生命实践来印证佛理</strong>，这就叫<strong>证悟</strong>，要实证的。这就是一个按照禅宗，南派禅宗所理解的，当中一个关键环节：<strong>顿悟</strong>。</p>
<p>好，现在我们就来看惠能怎么说？我们看105页啊，最后一段。“善知识，既皈依自三宝竟”，这件事做好了。</p>
<p>“各各志心”，各位都要专心致志。</p>
<p>“吾与说一体三身自性佛”，开始讲成佛的境界了。成佛的境界，按照佛教就是说一体三身佛，就是成佛的境界有三个方面。</p>
<p>“令汝等见三身，了然自悟自性。总随我道”，叫大家跟着他一起讲，这就很有仪式感了是吧？</p>
<p>“于自色身”，色身是什么？肉身，我们的肉体，佛教叫色身。“于自色身，皈依清净法身佛”，就是<strong>转色身为法身</strong>。</p>
<p>“于自色身，皈依圆满报身佛；于自色身，皈依千百亿化身佛”，那三身佛，我们知道了，一个叫<strong>法身</strong>、一个叫<strong>报身</strong>、一个叫<strong>化身</strong>，这叫三身嘛。</p>
<p>“善知识，色身是舍宅”，我们都有的肉体，这个身体只不过是<strong>舍宅</strong>。“不可言归”，谁要皈这个色身？<strong>道教</strong>。道教就是守住这个“舍宅”不放的、修长生不老，不就抓住这个色身、这个舍宅不放嘛，要皈依这个舍宅，这是道教。佛教认为“不可言归”，我们的肉身，你怎么好皈依它。所以，佛教就嘲笑道教，你们那些叫守尸鬼，守住这个尸体不放，叫守尸鬼。</p>
<p><strong>道家</strong>不是这个境界，道家到了庄子，根本放弃身体的，“天地与我并生，万物与我为一”，那个《齐物论》里讲，但是<strong>道家</strong>的思想倒启发了那个<strong>道教</strong>了，道教开始逆天道而行了，你追求长生不老，不就逆天道嘛，这是<strong>道教</strong>。但是，道教有贡献，要实事求是啊。我们中医，有许多养生的方法，是从道教中来。道教在求长生之术的努力当中，也增加了许多中医、中药学知识，这也要实事求是，包括气功。因为道教分了两个阶段，第一阶段是练外丹，吃死人了。那个丹，仙丹，据说练出来了，后来不是吃死人了嘛。改了，改练内丹。什么叫练内丹？就气功啊。道士养身术，蛮好的。好，这个我们不去讲。</p>
<p>在佛教看来，“色身是舍宅，不可言归。向者三身佛，在自性中，世人总有”，本来大家都有。</p>
<p>“为自心迷，不见内性，外觅三身如来”，到外面去求，</p>
<p>“不见自身中有三身佛。汝等听说，令汝等于自身中，见自性有三身佛。此三身佛，从自性生，不从外得”，先说这个道理，不是真有三个身啊，其实是一体三身。这个一体是<strong>自性</strong>。所以，<strong>法身</strong>、<strong>报身</strong>、<strong>化身</strong>都从<strong>自性</strong>中出。</p>
<p>好，我们翻过来，然后他分别说，在109页上，他开始分别说<strong>法身</strong>、<strong>报身</strong>、<strong>化身</strong>。先看他怎么说法身。</p>
<p>“何名清净法身佛？世人性本清净，万法从自性生。思量一切恶事，即生恶行；思量一切善事，即生善行。”我们的行为都是<strong>心</strong>发动的，生命实践都是<strong>心</strong>发动的，就看你怎么思量了？用儒家的话，就是<strong>意要诚</strong>，这是关键。意是心之发动。</p>
<p>“如是诸法在自性中，如天常清，日月常明，为浮云盖覆，上明下暗。”我们平时的生活就是这样。</p>
<p>“忽遇风吹云散，上下俱明，万象皆现。世人性常浮游，如彼天云。”我们没有悟的时候是什么？我们本来光明的日月被浮云遮盖了。</p>
<p>什么叫<strong>悟</strong>？他比喻了“忽遇风吹云散”，忽就是突然，那就是<strong>顿悟</strong>的意思，一下子风吹云散了，这样上下就俱明。可见，这个成佛的第一个环节叫<strong>顿悟</strong>，这里说明了。</p>
<p>“善知识，智如日，慧如月，智慧常明。”惠能说佛法，跟大众讲他自己也是大众中一员，所以说话就是通俗简单。</p>
<p>“智如日，慧如月，智慧常明”，把那个日和月又合起来了，叫<strong>明</strong>。</p>
<p>“于外着境，被妄念浮云盖覆自性，不得明朗。若遇善知识，闻真正法”，就是我讲“解悟”阶段，要有大善知识帮助嘛。</p>
<p>“闻真正法，自除迷妄，内外明彻，于自性中，万法皆现”，万事万物的真实意义向我们的佛性呈现了。</p>
<p>“见性之人，亦复如是”，这就叫清净法身佛。顿悟我们记得清净法身佛了，本来有，只是被浮云遮盖了。</p>
<p>惠能讲那个禅宗的，南派的禅宗也是16个字，整个禅宗的大纲是16个字 “教外别传，不立文字，直指人心，见性成佛”。那么，禅宗的南派——顿教，讲顿悟的，又是16个字“菩提自性，本来清净，但用此心，直了成佛”。这个“直了”，就是顿悟。</p>
<p>那么在顿悟中，法身佛来了，他马上就有另外两个效用了。我们翻过来看，这一段，我们可以略过，就是讲法身佛意味着什么？意味着自性皈依、皈依自性。</p>
<p>底下讲报身。110页上第二段，圆满报身。</p>
<p>“何名圆满报身？譬如一灯能除千年暗，一智能灭万年愚。莫思向前，已过不可得”，不要老是想着过去的事情，耿耿于怀，那些都已经过去了。</p>
<p>“常思于后，念念圆明”，要向前看就是，向未来。</p>
<p>“自见本性，善恶虽殊，本性无二”，我们的<strong>行为</strong>有善有恶，但<strong>本性</strong>是没有二的。</p>
<p>“无二之性，名为实性，于实性中，不染善恶，此名圆满报身佛。”这就让我们想起王阳明四句教的第一句“无善无恶心之体”，不就是圆满报身嘛；然后，善恶来自意之动啊，“有善有恶意之动”。然后，报身究竞什么意思呢？再看下一段。</p>
<p>“自性起一念恶，灭万劫善因”，累世累劫的善因，都被你的“一念之恶”灭掉了。</p>
<p>“自性起一念善，得恒沙恶尽”，恶业之多，多得如恒河沙数一般多啊，只要“一念善”起来，都除掉了。</p>
<p>“直至无上菩提，念念自见，不失本念，名为报身”，所以<strong>报身</strong>其实讲得是消除了一切罪孽，这叫圆满报身。</p>
<p>那么，报身之后要讲化身，化身叫“千百亿化身”，我们先看惠能怎么讲。</p>
<p>“何名千百亿化身？若不思万法，性本如空。一念思量，名为变化。”本来我们是空，但是我们活在这世界上，要应世，应世必有思量，思量一起就变化来了。</p>
<p>“思量恶事，化为地狱，思念善事，化为天堂；毒害化为龙蛇，慈悲化为菩萨”，全因我们的思量而起，因思量的不同，结果是不同的。</p>
<p>“智慧化为上界，愚痴化为下方”，上界下方是指六道，上面三道、下面三道。下坠恶道，就是<strong>地狱、恶鬼、畜生</strong>，下面叫下方。</p>
<p>“自性变化甚多，迷人不能省觉。念念起恶，常行恶道：回一念善，智慧即生，此名自性化身佛。”<strong>化身</strong>的意思是<strong>应世</strong>。我们不得不应接人世间种种的事情，事情一起来，我们的思量就会变化。</p>
<p>这个千百亿化身，佛教喜欢用大数字。三千大千世界、恒河沙数，都是大数字；十恶八邪、八万四千种法门等等，都是大数字。千百亿化身，千百亿是大数字，有道理。人活在这个社会中，我们的角色不断在变化。你到商店里买东西，你叫顾客；如果你也开了家商店，人家到你商店里买东西，你是店主。你曾经是某人的儿子，那么某人是你的父亲，你是儿子；然后你又生了个儿子，你又变父亲了。你做学生的时候，那人是老师；后来，你也教别人了，别人成了你的学生，你又成老师了。我们的角色是千变万化，每一种社会角色都应当是在智慧中担当社会角色。</p>
<p>比方说，今天中国社会，一个很大的问题是大家没安全感。你要吃东西，去买的吃的东西不可靠。但是你如果是做服装的呢，结果人家穿了你的服装不可靠。就不断在循环。我们在这世界上，应当是千百亿化身佛，不管是承担怎样的社会角色都要有<strong>佛性</strong>，这就是千百亿化身佛的意思。</p>
<p>“自性变化甚多”，为什么自性变化？因为应接不同的事情。“迷人不能省觉”，做顾客的时候，防备着这个店主；自己做店主的时候，在欺瞒顾客。大家都轮流来啊。那么媳妇熬成了婆，当初自己做媳妇的时候，受到了婆的压迫；后来自己也成了婆，有了自己的媳妇，用同样的方式来对待自己的媳妇。其实全部应该改变。儒家讲“己所不欲，勿施于人”。你无论是怎样的社会角色都应该是佛性的呈现，这样叫千百亿化身佛。</p>
<p>其实道理并不玄妙，就这个意思。一体三身，一体就是自性。悟了，那叫<strong>法身</strong>：然后继续修念、护念，那叫<strong>报身</strong>，因为你修念、护念，你就把一切罪恶、恒河沙数般的恶业都消掉了，这叫<strong>报身</strong>；然后应对不同的人世事，那叫<strong>化身</strong>。这就叫<strong>一体三身</strong>。这个化身意思呢，后来宋明儒家，特别是陆王心学也吸纳进来，那个阳明讲的话是对的，叫<strong>事变只在人情里</strong>。</p>
<p>关键是个“<strong>情</strong>”字。我们如果没有生命情感没什么事情。事情就是心事，<strong>心外无事</strong>。那么事情千变万化。我们要解透啊阳明讲的心外无事。事情都是形式，心外没什么事的。叫你去做一件事，你就去做了。没什么事情。但是一旦有事情要说，马上心事来了：这件事情做砸了该怎么办，我的名声受到损害；这个事情我费了很多努力，对我有什么好处？又是一个事，事变只在人情里。</p>
<p>好多年前，2007年，我接到校长办公室一个电话，校办主任打给我，他说：我们校领导啊，校长他们都说，今年的研究生毕业典礼，请你王老师作为教师代表发个言。这件事情来了你知道吗？我马上知道它的分量了。</p>
<p>第一，校长看得起我，我可以作为堂堂复旦大学那么多教师的代表在毕业典礼上发表演讲。在复旦大学发表演讲，意味着什么？每年的开学典礼、毕业典礼，上海重要媒体都在场，电视台、解放日报通通在场。你那个演讲刚刚做完第二天就见报了，事关复旦大学的名声。你那个毕业典礼上的演讲，这个水平要很高的，咱行不行？心里发慌啊。事变来了。只在人情里你知道吧？后来我就跟校办主任讲，我说我明天答复你，我能不能做这个演讲，做还是不做明天告诉你。心里折腾啊，为什么？第一，我被看得起了吧，那么多教授，大概我被认为是大牌教授了是吧？你才有资格上去讲呢？</p>
<p>第二，我讲的不好怎么办？我完蛋了。那个闲思杂虑一起起来，那是没办法。心定一定。想想，这叫心思啊；然后，又想起王阳明了，关键是意诚还是不诚。<strong>诚意</strong>啊，这是关键。又想起惠能了，叫<strong>思量</strong>，思量了啊。后来我怎么想呢？我是这样想，我既然要去做一个演讲，不管是什么场合，你要去做演讲的前提，你真有话要说，这是最根本的。我王德峰真有话要跟大家讲吗？跟那些行将离开复旦的毕业生讲吗？假如我真有话我得想一想，这些话以前人家讲过吗？如果讲过的，我没有什么新鲜的意思要讲，这就不必讲了，那叫老调重弹，有什么意义呢？如果我真有话要讲，而且这个意思是别人没讲过，而且我认为很重要，应当跟我们毕业的研究生们讲一下。我就定下心来，那叫<strong>诚</strong>来了。所以，读阳明心学要实践。此刻，是最重要的实践当口。《传习录》，关键一个<strong>习</strong>字这个当口。这个时候，此处不用功什么时候用功？还学什么心学？一个<strong>诚</strong>字，先想，坐下来心定了。想想，真有话要说。而且这些话，前人没说过，以往没说过，写下来一共3条：</p>
<p>第一，我们的研究生们别误会了，你们一走上社会，马上急切地想要成为社会精英。你们向来听说过了，复旦大学是培养领袖的地方，叫leader，你们就认为自己应当做社会精英，复旦大学就是培养社会精英的一所高校。你们错了，我心里想。复旦大学不是培养社会精英的地方，是培养<strong>民族的脊梁</strong>。第一层意思写下来，我相信没人说过。因为，复旦大学向来自诩颇高啊。我们每一个复旦的学生都应该志存高远，不得了你知道吧？第一件事情，<strong>民族的脊梁</strong>。</p>
<p>第二件事情，不要急于求成。我们复旦的学生可以<strong>在一个平凡的岗位上默默的工作，以自己的真实的努力来推动民族的进步</strong>。第二层意思。</p>
<p>第三层意思，我们复旦大学的研究生应当有所创造，而创造的根基在传统中。我们要有一个家，并且在一个传统中扎下根来，才会产生一切本质的和伟大的东西。</p>
<p>三层意思写好了，然后写初稿。我是不敢即兴演讲的，因为这样一个场合太隆重了。我平时说话还蛮流利的。在这种场合的时候，你说错了的话，很不好。对不起复旦大学的，对不起那么多毕业生，你这个演讲也可能他们记一辈子，所以我就不敢脱稿了，我得写。第一稿写完了，我就扔在抽屉，我想一想明天再看。明天看的时候，仿佛在看别人写的东西。</p>
<p>第二天拿出来一看，我三层意思没讲清楚。你有话要讲不等于讲得出来这个意思啊。修改了吧？修改。修改叫什么？修辞啊，就是文学的功夫要上来，文学为了啥。修辞不是美，<strong>修辞立其诚</strong>。你有那个诚字，不错的。我刚才讲三点意思，值得讲吧？那个<strong>诚</strong>字，有的，你立得起来吗？我们自己可以试试看，你有一层意思很好，你写下来。写完你过了段时间看，没说出来嘛。好像说出点什么又丢失的更多。修改，这就修辞来了，是为了把这层意思，完整地、彻底地、明晰地真讲出来了，让人明白。第二稿，再扔两天。因为，有一个礼拜的时间。再回头一看，说的比上次好点，意思是说出来了；但是好像还不够，还不够清晰。没有别的目的，要把这个“诚”真立起来，让人接受了、让人感受到并且明白了。第三稿……后来，我想差不多了，我要说的三层意思已经说得很分明了，大家不会听不懂。上去讲……讲完了以后，当天晚上，我就接到一个电话，是我本科的同班同学。他现在不在复旦哲学学院，在社会学系，在那里做教授。我们本科同班的，他突然打个电话给我，他也当时坐在下面听的，电话里非常激动：“德峰啊，我没想到，你很有文学才能；我以前总觉得你会思辨啊，哲学思辨，你是很行的，但是文字表达功夫，你这么好，我没想到，我们都很感动，你知道吧？我们社会学系的研究生毕业生，走出这个毕业典礼之后，在路上就说，哲学系王老师那个话好，那些话都不会忘记的啊；你什么时候会有这种文学才能的呢？”他就问我，我说，我没有文学才能，这个演讲在文学上有价值吗？他说有。我觉得很惊讶啊。其实后来就明白了，实际上，我真修辞啊。这修辞不是为了让我的辞藻华丽，而是为了把那份意思真说清楚，才不断改变说法；最后，第三稿“<strong>诚</strong>”了。然后，他们读的时候，觉得非常有力量。第三天，《解放日报》就发表了；然后我再去看，哎呦，还不错啊。我说我这个过程，就举一个例子啊，并不是我在自吹自擂啊，后来就收到我的一个演讲集里去了。《解放日报》给了它一个标题叫，好像是这样一个标题，叫《真正的伟大属于心灵》，假如我没记错的话。我本来的标题是《做我们民族的脊梁》，这就是我对复旦大学的定位啊。</p>
<p>实际上，许多教授听了之后，就觉得我们向来不是培养社会精英的地方吗？我们要争取成为什么？把复旦大学办成东方的耶鲁。这是我们的口号。什么叫耶鲁大学？美国一流大学吧，耶鲁大学一直认为它培养社会精英的，跟哈佛大学一样想啊。后来，我才知道有一本书，哈佛大学，他们的本科生叫学院，叫哈佛学院，哈佛的Colloge，那个前院长卸任之后，用一年的时间写了一本书，2006年发表，标题叫《失去灵魂的卓越》，副标题“哈佛大学是怎样背离教育宗旨的”。后来译成中文本了，我一看跟我的想法一样，你看。哈佛大学别自以为，在培养社会精英，那些人很卓越，但没灵魂你知道吧。你看，英雄所见略同。所以，我们复旦大学别以为自己在培养什么社会精英，我们先要培养的是，我们根本要培养的是民族的脊梁。</p>
<p>就你有意思要说，那个“<strong>诚</strong>”字啊，很重要，做任何事情都如此。所以，我就这样理解了惠能讲的什么，千百亿化生佛，关键在<strong>思量</strong>。那么，用儒家的话叫“<strong>意诚</strong>”，意要诚，因为意是最关键的地方。我们的心本来是心体自明吧，那么也无善、无恶，“无善无恶心之体，有善有恶意之动”。那么，用禅宗的话叫思量来了。所以，我觉得应该跟我们的年轻一代多讲讲这种道理。</p>
<p>所以，惠能的这些话表面上好像就一大堆，其实绝不是空话啊，很实在的。一是，当前我们的忧惧都来自<strong>意念</strong>，起念、起意啊，这个意不诚，我们的忧惧很多。所以，阳明会说那句话，<strong>事变只在人情里，心外无事</strong>。</p>
<p>我在这里讲过，我曾经。不知我忘了，我是否讲过，动物世界曾经拍一个片子，我看了。西方人真有意思，动物学家很有意思，那些摄影师也很了不起，屎壳郎推粪球啊。哎，他们那个拍摄的极佳，就是那个清晰得很，那个情景居然被他们拍下来。那个屎壳郎，在一个小的土坡上往上推那个蹦球，推到一半这个粪球被一个木桩卡住了。正好我在看这个节目，我心里就想，看你这个蠢物怎么解决这问题啊？这个屎壳郎正面推不动。绕到左边推，也没动，这个粪球就不动了。然后又看着它绕到右边推了。我说这还都想办法了，右边推还不动，然后就居然跑到这个粪球的上方，往下面推了，一推，动了。这个粪球居然就被它从木桩里推出来了，一路滚下去了。滚下去呢，我就看那个屎壳郎，不紧不慢地又到山坡底下继续往上推，终于推到了坡顶。整个场景被我看到，当它推不动的时候，我想假如我们人类会怎么样？跺脚、苦恼、折腾，是吧？我看它很平静，左面推推，不行，右面推推，再不行，上面一推，好了。那么，推成功了，我欢呼了，你知道吧？我作为观众，欢呼起来了。哦，这太妙了，伟大的成功。但它很平静。如果人类碰到这种事情，马上举行隆重的庆典，那是伟大的胜利啊，欢呼雀跃。它没有，它又退下去了。看完了这个短片之后，我第一个反应就是生活本无痛苦。如果我们像屎壳郎那样，生活真是不能痛苦，有什么痛苦的。后来，我又想，我们不可能跟屎壳郎一样，因为我们是人，人就有心，是吧？就有生命情感。学佛，不是学成一个屎壳郎，我又想到这一层。我们不可能成为屎壳郎，面对着挫折、苦恼、困境，我们无动于衷，这不可能；当我们克服了千难万险之后，取得了成功，我们不可能是无动于衷，我们会欢呼、雀跃、庆祝，这就是人。推粪球就是一件事。对人来说马上就成心事：对屎壳郎来说不是事，它本来就要推粪球的。所以，我立刻明白了阳明讲的那句话，事变只在人情里。所以，我们要<strong>养心</strong>。阳明心学讲<strong>养心</strong>，佛教讲<strong>修行</strong>，其实是一个意思。修行，修什么？修我们的<strong>心</strong>，那叫禅宗，直指人心，问题全出在生命情感上。于是我们去提升我们生命情感的境界，我们仍然喜怒哀乐，但是那是大喜大悲，不是小喜小悲，这叫心大了。养心养得和天一样大，这是谁讲的？陆象山，</p>
<p>“吾心便是宇宙，宇宙即是吾心”，心就是生命情感，我们的生命情感跟宇宙一样大。这就是我们学佛，在禅宗里的话，叫<strong>修行</strong>。在陆王心学里的话，叫<strong>养心</strong>，叫存养扩充我们的心。存养扩充，这是王阳明经常用的词语，叫<strong>存养扩充</strong>，讲的就是心。所以，中国哲学有意思，它不诉诸头脑。西方哲学诉诸头脑，它的主题是<strong>知识问题的解决</strong>。中国哲学诉诸人心，它的主题是<strong>人生问题的解决</strong>。人生问题，就是我们的情感怎么安顿。人最后的毛病，都出在自己身上。出在什么事情身上，出在生命情感上。所以孔子那句话说“唯仁者能爱人，能恶人。”什么意思？唯有真正的仁者，才能合适的爱，和合适的恨。我们都爱爱恨恨，但大多数情况会不合适，如果严重的不合适，那可了得。人这种东西呀，最可爱，也最可悲。人能够往上升得啊，这个境界往上升，上通神圣、成圣成贤；人也可以往下坠落，叫下坠恶道、禽兽不如。人这个东西就是这样的，你说他可爱很可爱呀，人多可爱，说他可恶也很可恶的。为什么呢？怎么会这样？爱、恨不合适，生命情感不合适；爱一个人，爱之欲其生；恨一个人，恨之欲其死。希特勒，不是屠杀犹太人了嘛，那是骇人听闻的暴行啊——奥斯维辛集中营；但是希特勒有非常崇高的一面，他认为日耳曼民族担当拯救人类的伟大使命。他希特勒说，把自己交给了这个民族，你看多伟大、多高尚，你读他那本书叫《我的奋斗》啊。你如果不了解他的恶行的话，你光看这本书，你就会觉得这个作者的境界多高。你看同一个人，造成如此滔天之大恶业，根源在哪里呢？不能合适的爱人、合适的恨人。所以，孔子说，唯仁者能爱人，能恶人，爱恨合适。中庸那句话怎么讲，“喜怒哀乐之未发，谓之中”，当中的中啊，就是我们的心。一定会发出来，因为人跟人打交道，人际关系其实首先是情感关系啊，一定是喜怒哀乐的。你不可能冷冰冰的跟人打交道的，这绝不可能。那么，“喜怒哀乐之未发，谓之中；发而皆中节”，就<strong>合适</strong>，“谓之和”，和平的和，“中也者，天下之大本也；和也者，天下之达道也。”天下达道，就是这个社会生活符合天道，怎么会符合天道？因为我们的喜怒哀乐，发出来都中节的，那叫<strong>和</strong>。“中也者，天下之大本也；和也者，天下之达道也。致中和”，就是达到中和。“天地位焉，万物育焉”，天在上地在下，其实是对的；“天地位焉，万物育焉”，万事万物都生机勃勃。《中庸》第一段，说得好。<strong>中和</strong>的<strong>中</strong>字，就是<strong>心</strong>，它没发出来的时候，叫<strong>心</strong>；发出来就是要合适，就是<strong>和</strong>了。所以，像王阳明的那个四句都有来历嘛。</p>
<p>“无善无恶心之体”，为什么？它还没发嘛；发了会出问题，于是叫“有善有恶意之动”，就发出来了，一发就会有区分。所以，惠能也是在这里紧紧抓住这一点，就是<strong>思量</strong>。这个思量，不是逻辑思考啊；<strong>思量</strong>，全是<strong>生命情感</strong>。思量恶事，或思量善事，或毒害，或慈悲，就是讲生命情感的事情。那么千百亿化身佛就是我们应世时候的生命情感，应当是在佛性中的。我们也千万别把佛性当成一个空洞的东西叫空寂。又错了。学佛就是守住这个空寂，那是错的，佛性不等于空寂。<strong>佛性是人类生活价值的总和</strong>。这个人类生活的价值是不朽的。过去的人、今天的人、未来的人，只要在人类生活中，那些基本价值是不朽的。佛性就是人类生活不朽的价值之总和。我们怀里都揣着个宝石，佛性，是吧。这佛性是**生命情感的本质。**不偏离，就这个意思。后来，阳明心学就把这一点继承和发挥，就是我们经常要检省的是我们的生命情感是不是掺杂了别的东西。比如说你孩子，这个学期期末考试倒数第一名，班级，你那份愤怒来了吧？来了；这愤怒真实吧？真实；正常吗？正常。但是，你一定要想一想，当你在面对你的孩子，在指责他的时候，你是怎么说话的？是哪一种情感推动了你？假如是：你看看别人家的孩子，我们那个同事啊，他的孩子跟你同一个年级呀，你看期末考试，班上第一名呐，年级第三名呐，你怎么这个样子？这种话就不对了啊，脸面，从自己脸面考虑的，所以要检省自己的生命情感。</p>
<p>小孩子也是生命情感，他完全能体会到父母那份生命情感，哪一份是真爱、哪一份出于私欲啊，叫“私欲之蔽”，遮蔽的蔽，他分得清楚。在一种愤怒当中，他体会到了父爱，这很正常。所以我小时候，我父亲对我蛮严厉的，我知道，我实际上不恨他的。他如果外面吃了亏，回来在我身上撒火，完了。这份情感就不对了吧，我就知道他并不爱我，我成了他出气桶了。我父亲从来没有这样对待过我，但他对我的这种严厉啊，一般的家庭很少的，但是我仍然爱着他。所以，这就是生命情感的合适嘛，这非常非常重要。我后来读书，为了什么，为什么努力你知道吧？讲到底，很简单，为了讨好他，就这个动力啊，所以很用功啊。结果呢，很难讨好的。有一次，我一篇作文，三个班级都读了，那个语文教师带三个班，看到我这篇作文不光在我班上念了一下，还有另外两个班都念了，我怎么知道呢？另外两个班的同学在这个楼梯口遇到我：今天我们老师读了你的文章，你文章写得好。我很得意，你知道吧，回到家里，把这件事情告诉我父亲，想要得到他一个表扬。我没想到他这么跟我讲的：你今年几岁？我说16岁，这时候在读中学嘛。我再问你啊，你知道王蒙吗？我说，知道。王蒙16岁的时候，发表了他的小说《组织部来了个年轻人》，你也16岁。我没话好讲。你有什么好骄傲的呢？就这个意思，你也16岁，人家王蒙也16岁的，人家发表了《组织部来了个年轻人》了；然后毛泽东看了这部小说，很欣赏啊，你知道吗？我没话讲。要讨好他，真难，这就是我父亲。但我知道他深深的爱着我，就这样。</p>
<p>所以，我们就讲那个，读禅宗啊，读《坛经》啊，还有将来会读《传习录》，是吧。其实，都是我们的生命情感，我们养心啊，就是这件事情。事变只在人情里，有时候做事，做败了，我们会怎么总结教训，这件事情怎么会失败的？从哪里找原因？经验不够、知识有缺陷，所以我犯了过错。我们如果是这样来总结我们以往的话，我们肯定错了。为什么？道理很简单，我们任何一个人都不可能在知识完备和经验丰富的情况下做事情的，这不可能。做事情做败了另有根源，察一察心吧，是这样解释。好，这样呢，我们把这一段看完啊，讲了三身佛之后，惠能来了“无相颂”了，我们把这无相颂看一看。</p>
<p>“吾有一无相颂，若能诵持，言下令汝积劫迷罪，一时消灭。”累世累劫啊，那个迷罪就可以消掉了。那么，无相颂来了。</p>
<p>“迷人修福不修道，只言修福便是道。”错了，修福得福报，但不能灭罪，修福不能灭罪，这第一层意思就来了。</p>
<p>“布施供养福无边”，承认的有福报；“心中三恶元来造”，三恶还在啊。哪三恶？也就三毒：贪、嗔、痴。</p>
<p>“拟将修福欲灭罪，后世得福罪还在。”后世得福是承认的。这辈子贫贱，但是，修福、布施啊、帮助别人做了好多好事嘛，下辈子恐怕就富贵了，这叫三世因果嘛。但是，得了福，罪还在。</p>
<p>“但向心中除罪缘，名自性中真忏悔。”讲到真忏悔了，我们已经讲过了，真忏悔是名与法空。</p>
<p>“忽悟大乘真忏悔，除邪行正即无罪。学道常于自性观，即与诸佛同一类。吾祖惟传此顿法，普愿见性同一体。若欲当来觅法身，离诸法相心中洗。”要离相。</p>
<p>“努力自见莫悠悠，后念忽绝一世休。”我们活在当下，是。活在当下，不要忘了终极关怀。时不我待。不要到了临终的时候，才知道后悔就这个意思。我们常人每每是如此，一辈子在奔走，前面有两样东西等着我们，一个叫<strong>名</strong>、一个叫<strong>利</strong>，就像司马迁当年所说的，是吧，“人群熙熙，皆为利来；人群攘攘，皆为利往。”一辈子奔求，追求着一个富贵、一个名声、地位，就在那里奔啊，奔了一辈子。到要快走的时候了，头脑如果还清醒，一定会回顾自己这一生，回顾的时候，会想什么呢？是不是想这件事？我曾经买过三架电视机，其中一架是被人偷掉的，会想这件事吗？绝不会想啊。会想什么？我这一生最大的欣慰是什么？最大的遗憾是什么？所以，中国人有句话这么讲的“人之将死，其言也善”，就是终极关怀来了。</p>
<p>那惠能的意思，我们不要等到那个时候才来，我们现在就应该在终极关怀里。所以，“努力自见莫悠悠”，岁月很快就过去了，韶光易逝嘛。然后，“后念忽绝”，“后念忽绝”就死嘛，一世休了。</p>
<p>“若悟大乘得见性，虔恭合掌至心求。”从我们心里去求吧。</p>
<p>“善知识，总须诵取，依此修行。言下见性，虽去吾千里”，就表示惠能要跟他们告别了，一路讲下来，讲到第六品了，也讲的讲完了，咱们要分手了。你们和我之间，恐怕相隔千里，“去吾千里，如常在吾边”，就好像和我在一起一样。</p>
<p>如果你们言下不见性，若言下不悟呢，哪怕我们始终在一起，面对面，其实有千里之隔呢，叫“对面千里，何勤远来”。所以，到时，你们不必再来找我了，只要你们言下见性、言下开悟，你们就和我在一起了。</p>
<p>“何勤远来，珍重好去”，大家各自散吧，各自珍重。“一众闻法，靡不开悟，欢喜奉行。”这个这么说的，都开悟了；然后大家都很高兴，心中满是<strong>法喜</strong>。</p>
<p>这样，我们就讲完了第六品。那么，我们下午就要进入第七品“机缘品”。机缘品里面，一共十二则机缘。每一则机缘，都是让人悟，惠能让一个人悟，或者印证了、印可了那个已经悟了的人。一共十二个，非常有意思。为什么说惠能是禅宗的奠基人？从十二个机缘里面就看得出来。后来惠能走了之后，圆寂之后，叫一花开五叶，禅宗后面有五个分支呢，<strong>临济宗、沩仰宗、法眼宗、云门宗、曹洞宗</strong>，一共有5个。这些宗派，教人开悟的方法，源头都在惠能这里，其中包括棒喝都有。所以，惠能是禅宗的真正的奠基人。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="机缘品"><a class="header" href="#机缘品">机缘品</a></h1>
<p>我们上午，已经读完了“忏悔品第六”，也就是说惠能回到广东韶关，在大梵寺讲禅宗南教主持东山法会，从第一品讲到第六品。完了，他要回宝林寺，分别之前，跟大家讲了，各位要言下见性、言下开悟。如果这样的话，我们虽然分开了，“如常在吾边”，就是“海内存知己，天涯若比邻”，叫各位珍重。</p>
<p>第七品开始，就是讲惠能让许多人悟的例子。第七品、第八品、第九品，如果说加起来，惠能一共为16个人开示，其中12个是在机缘品里。那么，我们就进入机缘品。</p>
<p><strong>机缘</strong>二字，先分开来说。每一个前来问佛法的人，都有他的特征，跟他说话，要对他的机，<strong>机</strong>就是<strong>特征</strong>。要对得准确，这个<strong>契机</strong>、<strong>对机</strong>，要准确而锋利。如果锋利的话，那就是机锋了。一个<strong>缘</strong>字，表示场合、表示事情，因某场合、某事情，让这个人开悟的机会成熟了，这叫<strong>缘</strong>。<strong>悟</strong>，要有<strong>悟缘</strong>，合起来“<strong>机缘</strong>”。所以，就有禅宗机缘这个说法。我们日常语言也说，要抓准了那机缘，后来成为一个普通的词语。</p>
<p>机缘品讲了十二个例子。我们先来看，在十二个例子之前插入一段，这一段呢跟史书的记载有不同。史书的记载呢，那二十四史里边，你可以去查，是惠能从广东赶往湖北的路途上，曾经寄宿在一个叫刘志略的家里。这个刘志略有一个姑妈是修行的人。惠能跟她相遇有一番对话。这件事情呢，在这坛经里边却放到后来来说。就是说惠能在黄梅得法之后，回广东韶关的路上，到韶州曹侯村遇到刘志略，这样就跟史书不一致了。按照史书的去解释，惠能尚未遇到弘忍法师之前，已经跟刘志略有一番这样的对话。</p>
<p>我们看这个插入的一段啊，这个书117页。</p>
<p>“师自黄梅得法”，黄梅县，黄梅就代指弘忍法师了。从弘忍法师那里得了心法，回到韶州曹候村 “人无知者”，没有人知道他。“有儒士刘志略，礼遇甚厚。志略有姑为尼”，家里有个姑妈，法号无尽藏，“常诵《大涅槃经》”，边上呢，惠能就在听，惠能不识字。无尽藏念他就听，听到那里即知道佛法妙义，遂为解说。</p>
<p>无尽藏有一个字不识拿着《涅槃经》请教惠能。惠能说，“字即不识，义即请问”，这是非常著名的一件事。那个无尽藏大吃一惊啊，“字尚不识，焉能会义”，你字都不识，怎么能明白经文的含义呢？</p>
<p>“诸佛妙理，非关文字”，这句话一下子点通了无尽藏。无尽藏实际上很激动，按照史书的记载，就跟惠能讲：你一句话点通了我。我知道我这几年在干什么？我这几年是从佛经的文字当中，从《涅槃经》的文字中讨真理。如此讨法真理是讨不到的。按照史书的记载，惠能此时尚未遇到弘忍法师，已经说得出这样的话。这样的话的含义其实是禅宗的第一条原理，“破文字执”，打破对文字、概念的执着。我们上午提到过，禅宗的16字纲领，大纲“教外别传，不立文字，直指人心，见性成佛。”真理不在文字概念里，这叫破文字执。这里讲，这个姑妈非常惊异呀，就跟乡里的人讲，这里有一个了不起的大德 “此是有道之士，宜请供养”，应当在这里就造一个庙来供养他。按照史书的记载，惠能心里想我都还没得佛法呢，还没找到弘忍法师，我怎么就能够在这瑞安享供养呢？所以继续上路，往这个蕲州，就是湖北黄梅县城。</p>
<p>那么，我们翻到118页啊，曹侯村就是讲曹操的后代在这里，“有魏武候玄孙曹叔良及居民”，周围的村落里的居民，“竞来瞻礼”。“时，宝林古寺”，宝林寺就今天的南华寺，惠能的真身还在里面。当时的宝林古寺，隋朝末年的时候遭了兵火，“已废”：于是在这故基上重建了梵宇，“延师居之”，把惠能请到那里，请到宝林寺。“俄成宝坊”，很快就成为名声传得很开的一个名刹了，叫宝坊。</p>
<p>“师住九月余日，又为恶党寻逐”，然后就躲到山上去。然后那些恶党来追逐他，知道他在山上，于是就焚烧草木，惠能就“隐身挨入石中得免”。可见，他一直是命若悬丝啊。这块石上他坐在那里，叫跌坐，留下了“膝痕及衣布之纹”，就有一名称了，叫避难石。惠能想起了五祖弘忍法师跟他讲的“逢怀则止，遇会则藏”。怀就是怀集县，广西（应该是广东）的一个县；会就是四会县，广东的一个县。当时弘忍法师跟他讲，他将来的归宿就在两广之间，住化一方。所以，他就想起了弘忍法师的这番话，叫“怀会止藏”一一逢怀则止、遇会则藏。“遂行隐于二邑焉”，就在这两个地方隐居起来。</p>
<p>这是插入的一段，现在已经很清楚了。惠能就在宝林寺，很快的名声就传出去，人们就要来。其中讲到一个人，最初来的人叫法海，不是白蛇传里的那位啊，韶州曲江人，“初参祖师”，来参拜惠能，提问题，这就是第一则机缘来了。法海问总听说禅宗讲“即心即佛”。密宗讲“即身成佛”，密宗修神通，这个禅宗是修心，所以“即心即佛”，究竞什么意思呢？“愿垂指谕”，向惠能请教。</p>
<p>惠能回答了，我们看回答的方法。把这个词语就拆开来了。什么叫<strong>即心</strong>？“前念不生即心”；什么叫<strong>即佛？</strong>“后念不灭即佛”。他拆了两组词语，“即心即佛”拆开来，“不生不灭”拆开来。我们都知道，涅槃境界指的是不生不灭。用前念、后念，把这两个词语都拆开来，这是惠能经常用的一种方法。比方说功德，一个<strong>功</strong>字先说，再说一个<strong>德</strong>字，合起来叫<strong>功德</strong>；<strong>无念</strong>，先说一个<strong>无</strong>字—“无者无二相”，再说一个<strong>念</strong>字——“念真如本性”，合起来叫<strong>无念</strong>。这里也是用这个方法，“不生不灭”拆开来，“即心即佛”拆开来，你如果再合起来——“不生不灭，即心即佛”，那么通过这个拆开来的方法来说一件大事情，就是禅宗如何看待了生死这件事。</p>
<p>后面又拆，“成一切相即心，离一切相即佛”。前面一句话等于讲<strong>相由心生</strong>。人有分别识，就会区分事物——高低贵贱；这也是我们的心，所做的区分，相由心生。当然，现在把“<strong>相由心生</strong>”这个四个字的含义呢，又理解为：我们的面相跟我们心态的关系，相由心生。最初的意思是，世界上事物的高低贵贱，并不是这个事物本身有高低贵贱。一块钻石放在桌子上，我们认为它宝贵的不得了。一块茅坑里的石头又臭又硬，这个石头和钻石之间的区分，难道是茅坑里的石头就低贱，供放在一个精巧的盒子里的钻石就高贵？它们本无贵贱，是人心所做的区分，所以叫“成一切相即心”。成了相，再离开它吧，“离一切相即佛”。文明总要成相，一切文明都要有所创造，有所创造就区分高低贵贱了。什么重要、什么不重要，然后万事万物都有了相。那么学佛呢，就要离相。所以，他就说了两组话，都是把“<strong>即心即佛</strong>”拆开来的，“前念不生即心，后念不灭即佛；成一切相即心，离一切相即佛”。</p>
<p>“吾若具说，穷劫不尽”，这样的话可以一直说下去，还是给你一个偈句吧，“听吾偈”：</p>
<p>“即心名慧，即佛乃定”，把慧和定放进去了，“定慧等持，意中清净”。“悟此法门，由汝习性”，这个习性，不仅是指这一辈子积累起来这种特征，也是累世累劫。所以，我们悟佛法呢，是因人而异的，不同的人有不同的习性，“悟此法门，由汝习性；用本无生，双修是正。”这个双修是指<strong>定慧双修</strong>。所以，前面讲“定慧等持”。这个本，就是用和体，它们本来是同一个东西，只是从不同的角度说。从<strong>体</strong>的角度来说是<strong>定</strong>，从<strong>用</strong>的角度来说是<strong>慧</strong>，其实是一个东西，叫“定慧一体”，这是定慧品里讲的道理。所以，“双修是正”，不是说先修定、然后由定而发出慧来，或者是先修慧、由慧才能定。这都错了——即定之时慧在定，即慧之时定在慧。这都是定慧品里讲的，我们对“定慧一体”已经说了许多话，定就是 “见境心不乱”：既然定，我们做事情自然就在智慧中了。由于“见境心不乱”的缘故，我们的实践就在智慧中。</p>
<p>这是先讲两句，两组话，再来一个偈句。好！我们现在来讲讲为什么说法海的这一则机缘惠能讲出的是“了生死”？我们人都贪生怕死，我们所贪之生是什么呢？我们所怕之死又是什么？我们不想离开这世界，眷恋这世界，原因是我们曾经生活过。在这个世间生活过。我们曾经有过欢乐、也曾有亲情的牵挂，所以我们就怕离开这个世界。所以我们实际上所贪之生是什么呢？我们以往经历的一切都是<strong>念</strong>，我们<strong>念</strong>尽了吧？！那个欢乐。其实那些都已经过去了，它不再存在，不要老记在心里。其实我们“贪生”贪的是以往的<strong>念</strong>而已，前念！有种种的前念、有种种的生命感受，我们不想不再有他们，我们所贪的生其实不是这个身体，是种种的<strong>念</strong>。我们为了种种的<strong>念</strong>，哪怕我们要舍弃身体的一部分，我们也愿意的。比方说截肢吧。截去一条腿，只要活着。假如我们整个身体都没了还能活着，也就不怕了。</p>
<p>所以我们所贪之生并非身体的事，是以往种种的念，<strong>心</strong>跟着<strong>念</strong>走了。这里一个错误是以<strong>念</strong>为<strong>心</strong>了。念其实是心里边生出来的，但我们把念当成心本身了，然后我们就活在过去了，就活在过去的种种<strong>念</strong>之中了。我们贪的生就是贪以往种种的<strong>念</strong>，细想一想是不是这个道理？我们希望曾经有过的将来还将继续，我们有种种的念头，念亲人、念朋友是吧？种种的念！希望它将来也将有、一直延续，但这一切都不可能延续。这些只是<strong>念</strong>，前念不生你才明白心了，否则你不知道自己这个<strong>心</strong>，“应无所住而生其心”，我们住什么？<strong>住念</strong>。所以本心不起来，过去的都过去了，心还在那里，“前念不生即心。后念不灭即佛”，我们所怕的死是无后念！这绝念就是死了，其实我们不死，我们也从未真正生过。<strong>生</strong>和<strong>死</strong>的对立是我们自己<strong>心</strong>所做的区分。</p>
<p>这话做起来令众人不相信的，所以有一个禅宗公案是这样的，一组对话：一个是和尚问，一个禅宗祖师，问三个问题：</p>
<p>如何是<strong>解脱</strong>？第一个问题来了，佛教不是讲解脱吗？</p>
<p>如何是<strong>净土</strong>？第二个问题来了，我们想要往生净土；</p>
<p>如何是<strong>涅槃</strong>？第三个问题。</p>
<p>面对第一个问题，这个禅宗祖师是这么回答的，如何是<strong>解脱</strong>？“谁缚汝？”他没正面回答，反过来问。谁缚汝？谁把你束缚住？</p>
<p>对第二个问题，如何是<strong>净土</strong>？同样反是问，“谁垢汝？”谁把你弄肮脏了？</p>
<p>如何是<strong>涅槃</strong>？涅槃就是不生不死了，面对这个问题同样是反问一句，“谁将生死与汝？”谁把生与死的区别给了你？每一个反问其实都隐藏了一个回答。</p>
<p>谁缚汝？没人束缚你，你自己的心束缚了你自己。</p>
<p>谁垢汝？你要净土嘛，那么谁把你弄脏了呢？也是你自己的心。谁把生死与汝，生和死的区别给了你——也是你自己的<strong>心</strong>！</p>
<p>对于第三个反问里面所隐藏的意思我们最难理解，生和死的区分不是很真实嘛！于是我们一定贪生怕死吧？<strong>其实生与死的区分是自己的心给出的</strong>，有人误解了佛教，把涅槃境界看成是永远的寂灭，就等于永远死了，就这个意思。这哪里是涅槃的意思？涅槃是不生不死的。我们总摆脱不了生死的轮回的话，在某些人看来恐怕就是件好事情，咱这辈子死了没关系，早死早投胎，反正这辈子活得不怎么样，早点死吧。投胎下辈子说不定比这辈子活得好一点。所以他就不怕了是吧？我们在生死轮回当中是件好事情，这是一种看法。那么佛陀认为这不是好事情，我们受业遭罪，来到这娑婆世界不就受苦来了吗？佛陀从四圈城门走了一遭，分别看到生、老、病、死，无一不是苦，所以叔本华就接受了佛陀的思想。</p>
<p>我在这里讲过吧？性羞耻心怎么来的？男女性爱为什么要躲起来呢？生物学无法解释这件事情，我张开嘴巴吃饭这件事情要躲起来吗？不用躲起来。Make love这件事情倒要躲起来的，其实它本来也很天然吧？两性，这不是很天然嘛，明明一个很天然的事情，其天然的程度跟我们饮食吃饭不是一样的吗？饮食吃饭我们堂而皇之，公开的就吃饭了，Make love为什么躲起来？你向生物学要求说明，它能说明吗？你向科学要求说明，它不能说明，叔本华得佛陀的启发给了一个说明，为什么要躲起来？不好意思让别人看见呢？因为Make love的行为是制造生命的行为，制造生命的行为就是制造痛苦的行为。你正在制造一个新的痛苦，你还好意思公开做吗？所以就躲起来了。这就是叔本化的解释，我们不免要笑是吧？笑归笑，除了叔本华这条解释别无解释。</p>
<p>康有为有时候很好玩的，说了一句话，假如人的生殖器官长在额头上，这有什么稀奇呢？什么叫性交？跟握手一样呀。康有为有意思。康有为是了不起的，胆子很大的思想家，什么都敢想呢。他说人类的男女两性的性器官就长在额头上，可以吗？也可以啊，他说。那么如果康有为遇到叔本华，他们将怎样交谈呢？</p>
<p>这也是有意思的事。反正叔本华说明了Sex shame性羞耻的来历，根据的就是佛陀的思想——佛以一大事因缘而出世。佛陀因为一件大事情来到人世间，什么大事因缘？<strong>了生死</strong>。这就是四个民族在轴心时代打开四种思想境界当中的一种是吧？佛学的境界，起点就是这件事情，人生就是苦。</p>
<p>这样让我们觉得不免悲观。其实叔本华没想到过，佛教把根本的悲观往上一翻转，转出至高的欢乐，就往上转一下，那叫往上翻转。至高的欢乐就是什么？对！<strong>扬弃了生与死的对立</strong>，那叫<strong>真乐</strong>，又叫<strong>常乐</strong>，最高的乐。我确实是在少年时候读《坛经》的，然后就想这个问题，后来终于知道，根器不利。小根之人啊，想不清楚，如何不生不死是真乐呢？此乐是种怎样的乐？谁来承受它？受者是谁？乐总要有接受者嘛，后来读到后面你才知道人家也问这个问题，机缘品里有的，可见来这样问的人跟我也差不多。小根之人，了悟不了，不能了悟生死。</p>
<p>我们把死跟死对立的生当回事，其实我们本无生，但我们却当做自己的生了，为什么生了？种种<strong>念</strong>嘛，以<strong>念</strong>为<strong>心</strong>，其实以念为生。</p>
<p>“用本无生”，用之本是什么？体啊。我们的心体有没生啊？无生的。所以修净土宗是要了悟这件事情的，修净土宗是念佛，每天念几千遍“南无阿弥陀佛”，几十年如一日。于是就仰仗佛力，在走的时候横超三界直达净土，你悟还没悟，那里条件比较好，在那里听佛法。花开见佛，了悟无生，就这件事。</p>
<p>那么禅宗惠能就在这里叫法海了悟无生，用本无生。我们哪里生过？既无生也就无死，难了，我呢也是没悟过，就只能讲到这里了。</p>
<p>所以第三个反问，前面两个反问都能理解。什么叫<strong>解脱</strong>？那么先问谁束缚了你？人都自己束缚自己，自己的那个心束缚了自己。谁把你弄肮脏了？也是你自己，最后一个最难参透，谁把生死与汝？还是你自己的<strong>心</strong>，把生与死的区别做出来了，就这个意思。</p>
<p>人世间最难堪的事情，就生离死别。没有比这更难堪的了，即更难忍受的了。从这一点来看，人生终究是个苦难，终免不了<strong>生离死别</strong>。佛陀的思想叫我们直面这件事情，别躲闪，所以佛以一大事因缘而出世—<strong>了生死</strong>。生死的问题都想开了，世界上还有什么事情想不开的呢？</p>
<p>经历过生死，然后还活下来的人，我想总该悟了吧？居然还少数有不悟者，我们系里就有：当时不得了了，差不多就是要走了。后来没事，我想当他行将离开的时候就是个存在主义者了，心中就是存在主义情结了。好好的你知道他又开始争取终身教授了！那就是根基实在太差了，当时只要活下来，活着就是王道。还有什么其他的事呢？好，现在活了，继续干。这样的人也居然有，我们当时都说此人已经进入存在主义了。</p>
<p>我们学过哲学都知道存在主义，海德格尔和萨特。海德格尔就告诉我们要向死而生。在第二次世界大战的战壕里面，后来德军失败了，许多德国士兵都死在战壕里，然后去收他们的遗体是吧？收他们的遗物，基本上差不多每一个德国士兵的行囊里必有一本书--海德格尔的《存在与时间》。西方哲学认真的面对死亡问题，第一个阶段最初出现在哪里呢？就古希腊晚期的哲学，斯多葛主义、伊壁鸠鲁主义。那么斯多葛学派的思想我们有所了解，后来我们的前总理温家宝还主张大家去读Aurelius古罗马皇帝奥勒留斯那本《沉思录》。古罗马的奥勒留斯皇帝是斯多葛学派的坚定的信仰者，他有一本书叫《沉思录》，温家宝蛮有意思，拿西方哲学来教导我们，那么我们现在来了习大大，没讲《沉思录》，讲另外一个录，《传习录》，蛮有意思。前后两代领导人，也就是说总觉得我们这个民族没有精神、没有信念，所以要想办法是吧？一个主张《沉思录》，一个主张《传习录》。</p>
<p>所以海德格尔讲的非常清楚，人领会存在，领会存在就是领会虚无，不是知道存在者。这个书桌是个存在者，人也是个存在者，人这种存在者跟书桌这种存在者的区别在哪里？书桌存在着，它就存在着，它并不知道自己的存在。人这种存在者存在着是知道自己的存在，以<strong>领会存在的方式存在着</strong>！其他万事万物都不是如此，就是人领会生死。所以存在主义哲学的一个主题，即如何面对虚无？所以西方哲学有两段抓住生死的问题，一个是古希腊晚期哲学，一个是20世纪存在主义。</p>
<p>那么现在我们看到了机缘品第一个，就法海问，如何是“即心即佛？”直截了当回答“前念不生即心，后年不灭其佛。”还给他一个偈句，</p>
<p>“悟此法门，由汝习性；用本无生，双修是正。”习性的因素很多，有的人了悟生死要比别的人容易一些，有的人最难参透的，别的事情都能领会，围绕这件事情解不了。我就是其中一个，总是参透不了生死。后来知道血型性格学，各位听说过，以日本最为发展，我曾经读到过，80年代读了一本书《血型与性格》，日本人写的叫这个人叫能见正比古，血型性格学专家，这本书里居然这么说：四种基本血型，A型、B型、O型、AB型。他说其中只有一种血型，AB型，最能了生死,其中有一种血型，最了不了生死，O型.我就是0型，习性也不一样的。后来我就问过那些AB型的人，能见正比古的话， AB型的基本回答说对的，我们AB型人就这样，知道怕死的，但很快就想通了。O型人不行就想不通，所以四种血型当中最关注健康的，人人都关注健康，这是毫无疑问的，最关注健康的是O型，你把他健康拿掉，他就一下子觉得整个生活的基础消失了，这也是习性。</p>
<p>所以我们生生灭灭的都是念，心体不生不灭，心之体。<strong>念</strong>都是它生出来的，都有此心生出来.生前念后念，它本身不灭，不生不灭。所以前念不生<strong>即心</strong>，那个念过去了就过去了，后念不灭<strong>即佛</strong>，你把它换过来也一样的，前念不生即佛，</p>
<p>后面不灭即心，也一样。总而言之即心即佛，即佛即心，这就是第一则机缘，很难参透的。我们只是把它说了一说，你能了生死还不得了吧。不是有三句话吗？儒家教我们拿得起，道家教我们放得下，佛家教我们想得开。想得开什么意思？第一件根本的事情，生死的问题想得开，那么其他自然都想开了，最难参的。所以它放在机缘品的十二则机缘当中为首，这是对的。但为首有两个原因，12个机缘，第一个先讲法海的机缘，有两个原因，第一他讲的事情是佛教的根本大事，就<strong>了生死</strong>。所以放在篇首，对的。其次，法海的重要性。没有法海我们都得到《坛经》吗？读不到。惠能圆寂之前跟法海讲的，你已经记录了我说佛法的所有言论，你要把它汇编成册，让它流布于世，于是我们有了《坛经》，那么法海功不可没。所以放在篇首。</p>
<p>所以一旦明白这个道理，当下即能了生死，世间万事万物都是相，来来去去、生生灭灭，唯有心是本体，不生不灭。法海言下大悟，他也来了个偈句</p>
<p>“即心原是佛，不悟而自屈：我知定慧因，双修离诸物。”</p>
<p>由于惠能的启发，他第一句就说什么？“即心原是佛”，我们的心本就是本体，所以他说佛就是不生不灭，即心原是佛，不悟而自屈，我们不悟的时候看清了自己的心，其实都是把心当成念了，或者把念当成心了。“我知定慧因，双修离诸物”，我现在明白了，定慧的关系。所以要定慧双修。离开无常的事物，心不跟着无常之物走，这叫“双修离诸物”，这是第一个机缘。讲完了。</p>
<p>我们看第二个，又有一个人来了，此人叫法达，洪州人。那么洪州就是江西南昌，这个人前来问佛法了，7岁就出家了。常读《法华经》前来礼拜惠能。你磕头就磕头喽，磕头的时候头不碰地板，头不至地。禅宗祖师惠能一旦接引一个人，一眼之中就看到他的特点了，你看这个动作就知道了，你拜嘛他不能不拜嘛，你是来请教惠能的吗？你当然拜了，你拜就拜了，但头不碰地，马上一眼被惠能看清楚，使人心中被有所负，好像有什么本事的。不肯彻底放下自己这个小我，所以拜的时候头就不碰地呀。那么惠能，禅宗祖师是绝对不客气的，哪有跟你什么客气一番、礼貌一番，何必。</p>
<p>第一句话就问他了，“礼不投地，何如不礼？”你既然礼拜了吧，那头不碰地你还礼拜干嘛呢？</p>
<p>“汝心中必有一物”，你心中有什么东西了？你不愿意把头碰到地板。</p>
<p>“蕴习何事耶？”就问你了，你平常的功课是什么？你平时积累了什么本事？你说出来看看嘛。</p>
<p>“念《法华经》己及三千部”，哎呦！倒蛮厉害的。法华经念了3000遍了，这功课也不薄了，所以他就头不碰地了，天下念经的人哪有像我，你看3000遍法华经。</p>
<p>“汝若念至万部，得其经意，不以为胜。”你哪怕念了1万遍，你领会法华经的经意的话，跟念3000遍差不多吧。没什么，“不以为胜。”也就跟我一样了。</p>
<p>“则与吾偕行，汝今负此事业，都不知过”，这是很不客气的。我们后面看几个机缘都会发现这一点。你跟禅宗祖师见面了，说话紧凑的很，一句来一句起，当做毫无虚伪故饰的。直截了当就说你都不知道自己的过错，“听吾偈”，我念个偈句给你听。</p>
<p>“礼本折慢幢，头奚不至地；有我罪即生，亡功福无比。”亡就是遗忘的意思，忘的意思。行这个礼本来就是为了提醒自己，把自高自大的心放下来。</p>
<p>那就是为了这件事情才礼的。我们每天拜佛可以呀！佛像，要么泥做的，要么其他金属材料做的、或者木雕的，不就是一个偶像嘛。你对它拜干嘛呢？有意义的。每天提醒自己微不足道，把这个小我放到地上去。你本来就这个目的，你却头不碰地，“头奚不至地”，这个“奚”就是个疑问词了，头为什么不碰地板呢？有我了吧？你有小我。罪就来了，有我罪即生。你做了许多事情，把它忘了吧，那叫“亡功福无比”。这也是人生的一个重要的准则。我们在人世间做事情，有时候真是建功立业了，那个功绩蛮大的，别放在心里，把它忘了，才会有福。你不把他忘了，不会有福的，弄不好还要招来祸呢。</p>
<p>王阳明就是一个例子，平定宁王朱宸濠，如此大功他马上把这个忘了。然后朝廷当时武宗皇帝，在平定宁王朱宸濠之后，在平定朱宸濠的叛乱的过程当中，阳明还写了封信给武宗皇帝的，上书。在写给皇帝的这封信里边就指责这个武宗皇帝，你现在要痛改前非，像你这样做皇帝以后这种事情不断的要来的。你看你正在为朝廷立大功啊，同时你又上书一份给皇帝得罪他，这就是王阳明。所以武宗皇帝很不高兴，当然知道他已经平定了朱宸濠滚了，把朱宸濠滚抓起来了。抓起来了之后武宗皇帝很奇怪，他要放，放到鄱阳湖上去，我来抓他就是这个意思。岂有此理！王阳明当然不会服从这个朝廷的命令，然后武宗皇帝一本正经出征了，后来还是阳明把朱宸濠绑了交给了朝廷。那么皇帝执法。也有点面子，就这个意思。武宗皇帝一走嘉靖皇帝上来，一开始嘉靖皇帝不错的，这个人，也实事求是的，马上要把王阳明封候，新建伯。王阳明上书谢绝，多少将士死在这场战争中，朝廷还没对他们抚恤和论功行赏，我怎么好得这个新建伯呢？屡次辞谢，所以这里讲对的，有我，有这个小我，罪就会来“有我罪即生，亡功福无比”。</p>
<p>“汝名什么？法达”。你叫什么名字？法达。</p>
<p>“汝名法达，何曾达法”，倒过来，法达法达嘛当然要达法了，要通达佛法，你达了没有呢？又来说一个偈句了。</p>
<p>“汝今名法达，勤诵未休歇；空诵但循声，明心号菩萨。”你这个念经叫有口无心。只是把声音念出来了，如果你明心的话，你就是菩萨了。</p>
<p>“汝今有缘故，吾今为汝说；但信佛无言，莲花从口发。”今天倒是有缘分，所以我就跟你说。</p>
<p>“但信佛无言，莲花从口发”。佛其实没说话，这话听起来很奇怪，佛经不都是佛所说吗？你要知道佛学的真谛并不在文字里，你如此读《法华经》就拘泥于它的文字，你先要懂佛无言，然后你再说佛法那叫口吐莲花。说到哪里都是对，不管你怎么个说法，假如你说佛法只能背诵经文的话，你根本不懂，这话也说得很有道理的。我们不要说佛法吧，我们就讲平时做教师的，你做教师怎么讲课？你照本宣科吗？何要你照本宣科。那个教材放在那里，学生自己可以去读嘛，何必要你再来讲呢？如果你要来讲课，你就不是拘泥于这个文字的，你把对这个学科、这门科学的真精神的领会随口说出来就对了。所以复旦大学呢，在复旦，我几十年做老师心深有体会的。这个大学如果说别的地方都不大行，就这件事情是行的。他是个无声的传统，一个在复旦留校做老师的很快就知道压力多么大了，那些学生根本不想听你照本宣科，那本教材不在那里吗？就不来听你的课，除非你点名。你复旦大学教师上课点名你很差劲，你知道吧？点什么名？你一定要叫人家坐在下面听，有意思吧？你也许正在浪费人家时间呢，此刻人家睡得好好的是吧？你叫他们赶过来听课，早晨八点到算什么？人家要听你的课，七点就起来抢座位。就这样一件事。你很快就感受到压力了，在复旦任教。</p>
<p>所以惠能跟他讲了，讲了这个偈句之后，我就有一个感慨，等会再说说看看。法达是一类人，这一类人叫知识分子，去参加学术讨论会，你知道吧？心中有所负，然后就去宣读论文去了是吧？所以做知识分子的人，机缘品第二则机缘好好读一读，这很重要！</p>
<p>“达闻偈，悔谢曰：‘而今而后，当谦恭一切。弟子诵《法华经》，未解经义，心常有疑。和尚智慧广大，愿略说经中义理。’”你能不能帮我讲讲《法华经》的意理？</p>
<p>惠能又来了：“法达！法即甚达，汝心不达。经本无疑，汝心自疑。汝念此经，以何为宗？”汝心不达，佛法本来就是那个境界在，你心没上去，心没到这个境界。“经本无疑，汝心自疑。汝念此经，以何为宗？”问他一个问题了，你念法华经宗旨是什么？问他这个问题。</p>
<p>“学人根性暗钝，从来但依文诵念，岂知宗趣！”我们这种人根器太差，法华经的宗趣我们怎么可能了解呢？他居然这么说。</p>
<p>好，我们翻过来，125页，惠能就跟他讲：“吾不识文字”，我不识字的。“汝试取经诵一遍，吾当为汝解说。”你就把法华经念一下吧，念了我帮你解说。法达马上高声朗诵了，“高声念经，至《譬喻品》。”念到《譬喻品》了。惠能说“止！”就停在这里吧。</p>
<p>“此经元来以因缘出世为宗。”他已经明白了，惠能已经明白了，法华经的宗旨是说——佛以一大事因缘而出世，《法华经》是说这个，法华经是释迦摩尼所说的最后一部完整的经，它的地位向来高，高在哪里？是总结！佛陀最后的总结。所以后来中国的天台宗就以《法华经》这个经为根据的。</p>
<p>那么佛来到这世界干嘛来的？一大事因缘，纵说多种譬喻，亦无越于此。说种种的譬喻其实都还是讲这个出世，宗旨。“何者因缘？经云：‘诸佛世尊，唯以一大事因缘，出现于世。’一大事者，佛之知见也。”我们平时对生活、对社会、对世界的认识叫什么？**众生之见。<strong>我们都在众生之见中，那么众生之间就是邪知邪见，要开</strong>佛知见。**佛陀教我们重新领会这个人生、这个世界，第一件要紧的事情就了生死，这叫大事因缘。所以惠能听了一段就明白了。</p>
<p>“世人外迷着相，内迷着空。若能于相离相，于空离空，即是内外不迷。若悟此法，一念心开，是为开佛知见。”什么叫“外迷着相”，我们都知道，心往外走，跟着事物走，那叫着物。什么叫“内迷着空？”不知道自己的本心，内里是空的，若能于相离相，“于空离空”，即是内外不迷。若悟此法，一念心开，是为开佛知见。底下继续解释，佛就是觉的意思，Buddha就是觉的意思。分为四门——开、示、悟、入。我们不是讲开示嘛，禅宗祖师给我们讲开示，我们就跟着悟入。“开觉知见，示觉知见，悟觉知见，入觉知见”。觉知见就是佛知见，Buddha就是觉嘛，然后我们就“悟觉知见，入觉知见”，合起来叫开、示、悟、入。</p>
<p>“若闻开示，便能悟入，即觉知见，本来真性而得出现。汝慎勿错解经意：见他道开示悟入，自是佛之知见，我辈无分。”你这么想，你读《法华经》3000遍，你心里就想佛知见咱开不了的，所以你问我经义是什么？我当然不懂。你这样想错了，你这样想简直是 “谤经毁佛，彼既是佛，已具知见，何用更开？”佛需要开吗？不用开，他就是佛了嘛，他本就在觉知见里。但佛要说那么多话是为了我们啊。然后我们听了他的话也不想去开佛知见，他白说了，佛是苦口婆心跟我们讲，我们说这种事情跟我无关，这怎么行？这叫“谤经毁佛”。</p>
<p>“汝今当信佛知见者，只汝自心，更无别佛。”佛之所以跟我们说那么多经，就是相信了我们，你们每个人都有佛性，所以你得相信你自己。所以你跟佛经的关系是什么？</p>
<p>底下就说，所以“汝今当信佛知见者，只汝自心，更无别佛。盖为一切众生，自蔽光明”自己遮蔽了。</p>
<p>“贪爱尘境，外缘内扰”外面碰到各种事情，然后就受各种事情的干扰，心里就乱。“外缘内扰，甘受驱驰”，于是“便劳他世尊，从三昧起，种种苦口，劝令寝息，莫向外求”把你那个向外驰求的心放下来。莫向外求，如果这样就“与佛无二”，就跟佛没什么区别了。</p>
<p>这叫<strong>开佛知见</strong>。“故云开佛知见。吾亦劝一切人，于自心中，常开佛之知见。世人心邪，愚迷造罪，口善心恶，”口上说的好听，都是善话，善语，心里边可恶着呢。</p>
<p>所以叫“贪嗔嫉妒，馅佞我慢，侵人害物，自开众生知见。若能正心，常生智慧，观照自心，止恶行善，是自开佛之知见。汝须念念开佛知见，勿开众生知见，开佛知见，即是出世。开众生知见，即是世间。”你就从未出过世，出世而后再入世。入的前提是出是吧？从未出过谈什么入世呢？你就在世间呀！ </p>
<p>我不知道我在这里讲过没有，就是说中国人为什么需要我们自己的哲学，其他民族为什么需要他们的宗教信仰，都是为了安顿我们这个心。因为人心有无限的一面，正因为人心有无限的一面，就是说它要超越现实，超越事实。我们在筹划未来，未来尚不存在，未来不是事实、不是现实，我们却要去筹划它。这表明心有无限的一面，即超越现实、超越事实。筹划了之后想要实现，实现了叫如意，不实现叫不如意，所以心有无限的一面，所以才会有烦恼。动物没有烦恼。那么这个无限心如何安顿呢？在这人世间所有的事物，构成这世界的所有事物，无一不是有限的事物，我们能把我们的无限心安顿在政治局常委这个高官厚禄上吗？安顿不了。你做了政治局常委总得下来。下来嘛两种下法，一种叫安全着落，还有一种叫送到秦城监狱。你拥有豪华的别墅，再豪华也是一个有限的事物，无限心如何能够安顿在它上面呢？但是心还得要安顿，没办法，结论就出来了——<strong>在现实世界中无法安顿我们的无限心</strong>，结论就是<strong>出世</strong>。西方人怎么出事？信仰上帝、信仰天国，这叫宗教上出世的路。中国人没有宗教。中国的精神、我们的民族的精神，不是宗教精神。中国人是通过哲学来出世的。儒家有儒家出世的路，道家有道家出世的路，佛家有佛家出世的路，儒道佛三家后来合流，就宋明新儒学学，把中国哲学推上最高峰。所以中国人走了一条哲学上出世的路，出世而后再入世。后来一句话说得好，<strong>以出世的精神做入世的事情</strong>。出世和入世的统一，构成了中国哲学几千年发展的主线。这是顺带说一下，所以惠能就跟他讲了，你要开佛知见，这叫<strong>出世</strong>。你如果只是开那众生之见，就是<strong>在世间</strong>而已，“汝若但劳劳执念，以为功课者，何异牦牛爱尾？”那叫自恋了。牦牛喜欢自己的尾巴呢，然后就转圈子。</p>
<p>我们翻到127页。法达有疑问了，如果按照你这个说法，“但得解义，不劳诵经耶？”诵经这个功课就不需要了吗？来问这个问题。我们只要解了经义，还要诵经干嘛？</p>
<p>惠能这样回答他？“经有何过？”佛经有什么过错？“岂障汝念！”怎么会障碍了你呢？不可能嘛。“只为迷悟在人，”是迷还是悟全在自己，“损益由己。“口诵心行，即是转经；口诵心不行，即是被经转，听吾偈，曰：心迷法华转，心悟转法华。诵经久不明，与义作仇家。”像你这种诵经，心里却一直不明，你简直是把佛经的经义当成你的仇敌了，“无念念即正，有念念成邪，有无俱不计，”更高一层境界，“长御白牛车”，先要从有念变成无念，无念不是没有念头，不是绝念，是无妄念。然后你老是想着我无妄念，又错了，有超越有和无、有念和无念之上。</p>
<p>禅宗很有意思，讲人这个错误，比如学佛法，第一次错、第一个错误是怎么犯的？叫骑驴觅驴。你本来骑在驴上，却到处去找驴，即本来你有佛性的，不要到外面去寻觅，每个人怀里都揣着一个宝，叫佛性，明明有这个宝到外面去求，这就好比骑驴觅驴。</p>
<p>那么这个错误终于克服了喽，还会来另外一个错误。骑驴不肯下，骑着驴不肯下来，又是一个病，老是想着：哦！我在正念之中了。我在佛性之中了。我在真谛之中了。那叫骑驴不肯下。真谛跟俗谛其实不二的。所以他后面，这个偈句的最后两句就这个意思了。假如你又超越了有念和无念了，那就是“长御白牛车”，车就是乘（大乘小乘），乘嘛就是车，古代的车由马来拉、或者有牛来拉、或者羊来拉，羊车、牛车，还有鹿来拉，叫鹿车，那么最了不起的叫白牛车，最高境界。讲到这一句，讲到这里，法达不觉悲泣，那叫悟了。悟了是生命情感的升华，所以他流下泪来，“言下大悟。”</p>
<p>然后就跟惠能说了，“法达从昔以来”，从过去到现在，“实未曾转法华，乃被法华转。”</p>
<p>“再启曰：‘经云：诸大声闻乃至菩萨，皆尽思共度量，不能测佛智。今令凡夫但悟自心，便名佛之知见，自非上根，未免疑谤”。他又怀疑，怀疑什么呢？你惠能给我这么大的信心，能够常御白牛车。但是许多人都还没达到，比方说<strong>声闻乘</strong>，<strong>声闻乘</strong>上面叫<strong>缘觉乘</strong>，<strong>缘觉</strong>乘上面才是<strong>菩萨乘</strong>。你看还有人只不过到菩萨乘，我怎么可能“开佛知见”呢？我非上根之人嘛。所以他有点不相信。“又经说三车，”哪三车呢？“羊鹿牛车与白牛之车，如何区别？”三车就是羊车、鹿车、牛车，经里边说这个区分，这是《法华经》里的，他熟知《法华经》嘛，“如何区别？愿和尚再垂开示。”</p>
<p>那么惠能就解释了，“经意分明，汝自迷背。”你是自己迷惑了。“诸三乘人，不能测佛智者，患在度量也。”那么我们先搞清楚什么叫三乘人，我们看注释第10条：羊车、鹿车、牛车都是譬喻。这些说法都在法华经的《譬喻品》里的。<strong>羊车</strong>譬喻<strong>声闻乘</strong>，<strong>鹿车</strong>譬喻<strong>缘觉乘</strong>，<strong>牛车</strong>譬喻什么？其实是譬喻<strong>菩萨乘</strong>。他这里说大乘，其实就是菩萨乘，当然大乘也可以，因为菩萨是大乘精神，要普度众生的。</p>
<p>其实先前有三种境界，声闻乘又叫凡夫乘。我们大概最多在凡夫乘里。我们对佛经有所耳闻、对佛理也有所耳闻，这叫<strong>声闻乘</strong>，只是听说而已，还不能实践，这叫<strong>凡夫</strong>。那么这个车就比较小，乘就是车呀，所以叫羊车。第二，境界比较高一点叫鹿车，<strong>缘觉乘</strong>就是<strong>阿罗汉</strong>，为什么叫缘觉乘？觉了<strong>缘</strong>！即自己的来历，知道自己怎么来，也知道自己怎么走。阿罗汉，所以叫<strong>缘觉乘</strong>。对自己的缘已经觉了，这叫阿罗汉境界。这两乘合起来叫什么？通常有一个名称，合称<strong>二乘</strong>，我们谈二乘就是指这两乘。<strong>声闻乘</strong>和<strong>缘觉乘</strong>，合称<strong>二乘</strong>。那么往上走了，牛车来了，那叫菩萨乘，到菩萨境界，那个车的动力比较大是吧？牛，牛拉的，还有更高的呢，<strong>一佛乘</strong>，到了佛的境界了，那叫白牛车。一佛乘。</p>
<p>好，我们把这段看完。说三乘人，即前面二乘加上菩萨乘，这些人的问题出在哪里呢？患在度量也。什么叫<strong>度量</strong>？<strong>逻辑思考</strong>。“所谓尽思共度量”，就在逻辑思维里边了，没走出，没达到超逻辑的境界。度量就是这个意思，当然汉语当中本没有逻辑这个词嘛，我们后来翻阅了西方的文献，知道他们有一门学问叫《逻辑学》。我们没有这个词，佛教当中的逻辑学叫<strong>因明</strong>。这个藏传佛教很讲究<strong>因明</strong>，他们不是辩经嘛，“辩经”即在因明学的范围里面讨论经义，到西藏去指导，他们要辩经，那是一种训练。</p>
<p>佛学主要的逻辑就<strong>因明</strong>。他都“不能测佛智”，不能达到佛知，因为毛病出在逻辑。</p>
<p>“饶伊尽思共推”，尽管让他们一直思啊推啊，</p>
<p>“转加悬”远越推越远，离开佛法的妙义越来越远，佛本为凡夫说，不为佛说。</p>
<p>“此理若不肯信者，从他退席。”你到现在还怀疑，就是你没有自信，佛自己不用说是吧？他已经是佛了嘛。但要说那么多话是相信我们，相信凡夫能成佛嘛，你还不相信你可以走嘛。</p>
<p>“殊不知坐却白牛车，更于门外觅三车。”你本就坐在白牛车上。</p>
<p>“更于门外觅三车，”羊车鹿车牛车你还去找。</p>
<p>“况经文明向汝道：唯一佛乘，无有余乘，”其实本来没有其他的。</p>
<p>“若二若三，乃至无数方便，种种因缘、譬喻言词，“仅仅是许多比喻，而已，你别把它当真。</p>
<p>“一乘是实，三车是假，”从佛法上讲，我们的境界要么没达到，一达到就是一乘了。</p>
<p>“是法皆为一佛乘故。汝何不省？”你怎么还没醒悟？</p>
<p>“三车是假，为昔时故；一乘是实，为今时故。只教汝去假归实，归实之后，实亦无名。”也不需要称自己为一佛乘，名相也不必有了。</p>
<p>“实亦无名。应知所有珍财，尽属于汝，”所有佛法的宝贵的财富都已经属于你了。</p>
<p>“由汝受用：更不作父想，亦不作子想，亦无用想”这是佛家的专门的话，什么叫父？父亲的<strong>父</strong>，就是<strong>大富长者</strong>，就被称为父亲的父了。什么叫<strong>子</strong>呢？<strong>众生</strong>，这是佛家的术语。用<strong>父</strong>来比喻<strong>深通佛理的人</strong>，这叫<strong>大富长者</strong>。用<strong>穷</strong>表示<strong>不通佛理的人</strong>，叫<strong>穷子众生</strong>。你现在如果达到一佛乘的境界。</p>
<p>“所有珍财，尽属于汝，由汝受用；更不作父想，亦不作子想，亦无用想，”这就叫 “持《法华经》。从劫至劫，手不释卷，从昼至夜，无不念时也。”从白天到夜晚，再从夜晚到白天，其实你一直在念诵着法华经呢，因为这个财富已经属于你了，“无不念时也！”</p>
<p>法达听到这里，“踊跃欢喜。以偈赞曰：经诵三千部，曹溪一句亡。未明出世旨，宁歇累生狂？羊鹿牛权设，初中后善扬。谁知火宅内，元是法中王。”</p>
<p>黄梅是指弘忍，“曹溪”是指惠能，按照地名嘛。如果并不明了，《法华经》的宗旨是讲我们要开佛知见，那叫出世。不明白这个宗旨，哪里能够把累世累劫的狂歇下来呢？“宁”就是一个疑问词。</p>
<p>“羊鹿牛权设”，这三车的分别是权宜的说法。</p>
<p>“初中后善扬，”佛经一般分三部分，初、中、后，其实都一致的。</p>
<p>“谁知火宅内，元是法中王。”这是佛家说人世间，就像火宅一样，在里边烦恼不断嘛。其实有法中王。</p>
<p>惠能听了他这个偈句之后就说了，“汝今后方可名念经僧也。”从此之后你才算得上念经僧，念经是好事情，我后来把它读成，从此之后汝今后方可名知识分子也。就这个意思。知识分子老容易文字执！自己懂一些概念，就不得了了。那么去参加全国讨论会，拿着论文在那里哇啦哇啦讲，人家都错了，唯他对，心中有所负。看到老先生来了很恭敬的，假的，头不至地的。就一个个法达，我也曾经是其中一个，实事求是讲，以前开这个学术讨论会，年轻气盛，带着自己的论文去了，心中有所负，然后在大会上发表了自己的、宣读了自己的论文、发表了自己自以为是的高见。大会上午三个人中心发言，我也发完了，其他两位也发完了。因为我们请了老先生来的嘛，大会的组织者要考虑到尊重学界老前辈，后来还留半小时，请两位老先生上来讲讲话。那么我们在下面就听着，心中并不以为然，你们都out了。一个老先生上来，他说：“不要给我15分钟，也许5分钟我也用不了”，讲了三五句话下去了，我认真一听——不得了，把前面三篇论文全废掉了。</p>
<p>“你们刚才讨论的话题我也不怎么懂，但是我也知道你们在研究一个重要的问题，这个问题的研究的路径，你们有新路，我也不怎么懂，我的路子是什么什么”讲了一下，我们一听，才对！就三五句话下去了。后来又来一个，我们请两个上来。还有一个哈，“他五分钟，我两分钟够了。”哪有哇啦哇啦讲的意思，“这个问题的要点是什么？我的体会说出来，请年轻的同志们批评。”讲完下去了，好了，没话好讲了吧？下午开小组会，我是率先发言的，马上来一个自我批判。刚才上午两位老先生说的对，要实事求是。后来读《坛经》再想想，哎呦，就是法达。被经转了，被那个理论转了。就好像毛泽东当时批评王明 “从苏联带着一麻袋的教条来的。”就这个意思，还振振有词的。一个法达。所以第二则机缘很有意思的，非常非常有意思，它有普遍的意义。不要被经转了，我们本应当转经。毛泽东说的很简单。马克思主义理论是来拿来派用处的，这对的！</p>
<p>我们前面讲了两则机缘，现在进入第三则机缘，第131页，有一个和尚叫智通，前来问了，寿州安丰人，也就是安徽寿县。“初看《楞伽经》，约千余遍，而不会三身四智。礼师求解其义。”智通来问三身四智。三身我们已经知道，前面在《忏悔品》里边讲，佛教的功课，最后一个环节成佛，成佛的境界叫一体三身。佛——法生佛、报生佛、化生佛。<strong>法身、报身、化身</strong>叫<strong>三身</strong>。<strong>四智</strong>是什么意思呢？就转识成智。这个识按照唯识宗明确的讨论，有八识，<strong>眼、耳、鼻、舌、身、意</strong>，眼耳鼻舌身是前五识，第六识是意识。第七识——<strong>末那识</strong>，第八识——<strong>阿赖耶识</strong>，一共八识。三身四智，要把这八识都转成智。八识转成四智，智通就来问这个问题的。</p>
<p>惠能就回答：“三身者，清净法身，汝之性也”就是你身上本有的<strong>佛性</strong>；“圆满报身，汝之智也；”就是你的<strong>智慧</strong>；“千百亿化身，汝之行也。”就是你的<strong>实践</strong>。</p>
<p>我们上午讲了，我们顿悟了，于是我们就有由色身转化为 “清净法身”。悟了之后就能够消累世累劫的恶业，这就是我们的色身转化为报身—在智慧之中。然后我们活在人世间，要应接万事万物，有不同的社会角色，这叫“千百亿化身”。“汝之行也”，就是你的生活实践，所以讲得非常简要、明了。</p>
<p>前面在《忏悔品》里边，最后讲成佛的境界，三个方面，讲的比较的详尽。这里就几句话，“清净法身，汝之性也；圆满报身，汝之智也；千百亿化身，汝之行也。若离本性，别说三身，”说离开我们的佛性来说这三身那就是错了。这叫 “有身无智”。</p>
<p>“若悟三身无有自性”什么意思呢？三身不是分开来的，不同的身、各自有他的自性，不是的。他本是一体三身！成佛的境界的三个方面而已，并不是各自有三个不同的身，不是这个意思。所以如果你悟了，“三身无有自性” ，你就明白“四智菩提”了，一体三身佛，其实是我们转识成智的成功。</p>
<p>所以他说：“自性具三身，发明成四智。不离见闻缘，超然登佛地。”</p>
<p>他来了偈句了。“不离见闻缘”是什么意思？我们在人世间生活，这就见闻缘。但是我们的境界，心灵的境界，已经超然、成佛了，这叫转识成智成功了。“吾今为汝说，谛信永无迷。”你要笃信、认真的相信，才不会有迷雾。“莫学驰求者，终日说菩提。”有许多学佛的人天天说要成正等正觉呢，菩提就是正觉，觉悟的觉。</p>
<p>那么智通就再问了，“四智之义，可得闻乎？”你能不能告诉我四智的含义呢？惠能就是说了：“既会三身，便明四智，何更问耶？”何必还要问呢？你应该已经明了了。“若离三身，别谈四智。”离开三身就不要谈四智了。“此名有智无身，即此有智，还成无智。”底下还是具体说了，“复说偈曰：大圆镜智性清净，平等性智心无病，妙观察智见非功，成所作智同圆镜。五八六七果因转，但用名言无实性，若于转处不留情，繁兴永处那伽定。”这个“大圆镜智”是从哪里转来？从阿赖耶识转过来。第八识转成了大圆镜智。“平等性智心无病”，平等性智从哪一识转过来？<strong>末那识</strong>。第七识转成了平等性智，这完全有道理。<strong>末那识</strong>就是小我，我们有一个我，所以我们就把自己看得十分的重要，跟别人做了区分，这叫人我别。假如我们打破了我执，也就是把末那识这个小我转为平等性智，放下小我了，那就是众生平等了。即第七识转成了平等性智，这“妙观察智”从哪里转来？从第六识，<strong>意识</strong>转来。第六识<strong>意识</strong>转成什么？也是转识成智喽，转成了妙观察智。</p>
<p>前面讲的话都很重要，大圆镜智我们阿赖耶识转成的。我们曾经说阿赖耶识叫种子识。我们的累世累劫的流转其实就是阿赖耶识在转。三世因果都是阿赖耶识连缀而成。此世，这今生今世所做的事，事情结束了，却成了种子进入阿赖耶识。到下一世出现、就要起作用。那么现在把阿赖耶识转成了<strong>大圆镜智</strong>，业力就消掉了，种子的业力就消掉了。变成大圆镜智，那叫<strong>性清静</strong>。平等性智是从<strong>末那识</strong>转来的，这小我之心放下来了，这叫<strong>心无病</strong>。第六识叫<strong>意识</strong>，我们平时学习要靠第六识，分别识，学知识掌握经验，要努力的啊，但是你没转成的话，当然要努力，认识起来也费劲。学科学、学经验、学知识都蛮费劲的。但是一转转成了<strong>妙观察智</strong>。其实就是神通。第六识意识转成妙观察智就是神通来了，神通要花力气吗？不要花力气，这叫<strong>见</strong>，见就对事物的认识，不要花力气，叫<strong>非功</strong>。我们都没神通的，所以我们认识事物蛮吃力的，要功。妙观察智见非功，这是第六识转成的。</p>
<p>那么前五识呢？叫<strong>成所作智</strong>，眼耳鼻舌身前五识都转成了<strong>成所作智</strong>。妙观察智叫神通。眼耳鼻舌身前五识转成了成<strong>所作智</strong>，做事情时就非常的流通方便。我们的耳朵是能欣赏音乐的耳朵，我们的眼睛是能发现美的、并且能创作美。我们的绘画、我们的艺术的制作，这些都叫<strong>成所作智</strong>，眼耳鼻舌身5种感觉叫前五识。要理解的话很简单，就是艺术。用马克思的话来叫感觉的人性。属人的感觉。</p>
<p>佛教非常有意思，人世间所有的事物，万事万物大概都没有遗漏的被他们说过一遍了。比方说唯识宗，轻易别去研究。一辈子的功夫，只能研究它一个角落呢。有许多学者一辈子研究唯识宗呢，那叫望洋兴叹。什么后来的学问比方说弗洛伊德的精神分析学，有许多最基本的思想，唯识宗里都有。所以不仅赞叹佛陀怎么了得！现在有许多科学家也会想到，哎呀，我们在说的事情佛经里也说过，所以浩如烟海。讲这个世界有八识组成的，那就唯识宗的基本思想，玄奘，大翻译家是吧？那么就他的佛教信念在哪里呢？就在唯识宗里的，所以研究唯识宗呢就很可以很可能成为一个博学的学者。我举个例子，熊十力。熊十力就一辈子精研唯识宗思想的，后来他要提出新唯识论，新唯识论就把唯识宗的思想跟儒家的思想要结合，叫新唯识论。你读新唯识论的著作，真难！</p>
<p>毛泽东也是有慧眼的。建国以后就讲过了，像熊十力先生的著作，写出一本就出版一本，他都是唯心主义。我们就要让这些唯心主义的著作也能够发表嘛，他在研究他的东西，有价值的。这是毛泽东特许的哦，其他的学者发表唯心主义著作批要判的，唯独熊十力，毛泽东给他开了扇门，你写一本发表一本，熊十力在上海。所以熊十力的著作当时我们都可以看得到，很厉害。那么他的佛教思想走的就是唯识宗，唯识宗又叫法相宗。在佛教中国化当中它不重要，唯识宗基本上没被中国化，中国化程度比较高的天台宗，华严宗、净土宗、禅宗。但是唯识宗是代表佛陀思想非常学术的一面。所以你穷其一生都很难搞透的，基本上搞不透。所以这也是人类思想的一个奇迹啊！就佛陀的思想，所以禅宗就要化繁为简了。弘忍法师说只要读一部就够了，佛经浩如烟海，读不胜读，一部就够了——《金刚经》终身受用就可以了。禅宗的主张，这大致说明一个情况。所以惠能虽然不识字，听得多了，人家诵这个经他也听，那个经他也听，所以<strong>三身四智</strong>他都明白，讲的清清楚楚。转识成智。</p>
<p>第八识阿赖耶识转为大圆镜智，这是最高的神通，叫<strong>神镜通</strong>。佛教讲有六种神通，<strong>天眼通、天耳通、他心通、漏尽通</strong>就是烦恼都没了那种通。还有一种通叫<strong>神境通</strong>，神仙的神境界的境，神境通就是大圆镜智，第八识转成的。所以这就是惠能讲转识成智。</p>
<p>底下还有：“五八六七果因转，”用力是怎么用的？前五识转成“成所作智”，第八识转成大圆境智，这是你无法努力的。你成佛了，它是一个自然的结果，叫果上转的。你要努力的是第六识和第七识的转，六七是因上转，或者说“因位转”，一个叫果位传，第六识、第七识转成了，第五识、第八识自然也就转成了。我们当然要转，比如说第七识要转，从小我、我执转为平等性质。那么第六识也得转，第六识是分别识，我们科学都在分别，你学物理学要分别吧，有种种的概念范畴，都是分别识在起作用。学社会科学也是如此了，经济学、金融学、社会学、法学、政治学都要分别，分别识。我们<strong>有分别识但不着分别相</strong>，这样一转，就妙观察才来。这两个转，就六七因上转。然后还要补充说一句，这些都只是名相，名言无实性，关键后面一句来了，转的时候要不留情，若“于转处不留情，繁兴永处那伽定，”那伽定就是龙，那是比喻。要转的彻底。讲了这个偈句之后，“智通顿悟性智”了。</p>
<p>“遂呈偈曰：”来了自己的偈句：“三身元我体，四智本心明；身智融无碍，应物任随形。起修皆妄动，守住匪真精：妙皆因师晓，终亡染污名。”</p>
<p>“三身元我体”，本是一体的，就是我本有的佛性，体现为三个方面的成佛境界。“四智本心明”，大圆镜智，平等性智，妙观察智，成所作智叫四智，本心明。“身之融无碍”，元融没有妨碍。“应物任随形”，遇到任何事物都可以用。“起修皆妄动，守住匪真精”。一开始我们要修，把这个修看成是一个确定的目标要去执着，每每妄动，要守住些什么，又叫<strong>执着</strong>，“匪”，就是一个是非的“非”的意思，不是佛教的真精神，守住“非”真精。你要应物而变化，不要执着。“妙皆因师晓，终亡染污名”，智通最后的感受是什么？因为你启发了我，你惠能启发了我，所以关于佛教的佛理啊，不要执着于明相，三身的说法，四智的说法，惠能最后说：“但用名言无实性”，归根到底，明白自己的心之本体，就可以了。所以禅宗还是主张化繁为简的。在本心上用功夫就可以了。那么唯识宗是讲得繁琐，学不胜学，这也是禅宗这里透露出惠能对唯识宗的看法，你那些话都也没错，转识成智，八识要转成四智，都对的啊，但归根到底还是要明白自己的心体。“三身元我体，四智本心明”，这就是智通的领悟了。所以说，四智就是转识成智，从凡夫的意识，转变为应世的智慧，这就是第三则机缘，那么我们就进入第四则机缘。</p>
<p>我们翻到第134页，又来一个和尚，一个僧人叫智常，信州贵溪人，江西人。“髫年出家”，年幼的时候就出家了。“志求见性”，这个志向很明确，要见性成佛，自见本心。“一日参礼”，有一天来了，参礼惠能了，那么惠能照例要问了。“汝从何来，欲求何事？”你从哪里来，你来求什么？他就说了啊，“学人近往洪州白峰山礼大通和尚”，去参礼一个叫大通和尚的人，这个大通和尚究竟是怎样历史记载并不清楚，反正是跟惠能同时代的，也在那个地方主持法会呢，他去参礼那个大通和尚。“蒙示见性成佛之义”，大通和尚应该是跟他讲了，如何见性成佛，但是听了大通和尚的讲法呢，心里没有摆脱怀疑。“未决狐疑”，所以远来投礼。“伏望和尚慈悲指示”，惠能就说了，他怎么跟你讲的呢？你讲给我听听啊，“彼有何言句，汝试举看？”智常就说了，我到他那里的时候，经过三个月的时间大通和尚都没跟我讲开示的话，所以终于忍不住了，为了求佛法心切得很，一天晚上就闯入了方丈室，向大通和尚问，“如何是某甲本心本性？”古人称自己叫“某甲”，如何是我本心本性呢？什么是我的本心本性，因为智常想要见性嘛，大通就说了：“汝见虚空否？”我回答他“见”。然后他又说，大通和尚又说，“汝见虚空有相貌否？”有形象吗？“虚空无形，有何相貌？”好，大通和尚就讲了，“汝之本性，犹如虚空，了无一物可见，是名正见”，如果你知道这一点就是正见，“无一物可知，是名真知。无有清黄长短，但见本源清净，觉体圆明，即名见性成佛，亦名如来知见。”“学人虽闻此说，犹未决了，乞和尚开示。”我们看一看大通和尚对智常的回答，回答得如何？智常想知道自己的本性啊。就像弘忍大师对那个神秀讲啊，“汝作此偈未见本心”，后来不是惠能开了个偈句嘛，本来无一物啊，“本来无一物，何处惹尘埃”，然后弘忍大师还说 “亦未见本心”，现在看来大通和尚的回答相当于惠能当初做偈句的境界，就是知道空了，但停留在空里边。我们的自性就是空吗？所以当智常告诉大通和尚跟他讲的这些话之后惠能自然知道了，这个大通和尚还没悟呢。“彼师所说”，那位大通和尚所说的话，“犹存见知”，还是有普通的众生之见在里边。“故令汝未了”，所以你不能了悟啊。“吾今示汝一偈”，我现在说个偈句给你，“不见一法”，法就是事物，“不见一法存无见”，他就停留在“无”里边了，“大似浮云遮日面”，本心还是没看见，我们自己的本心如太阳一般，还是被浮云遮住了。“不知一法守空知”，那叫执着于空，执空仍然是一烦恼嘛，第一步会说空，第二步就要把这个空再空掉，那叫“空空”。所以当大通和尚说你的本心就如虚空一般，了无一物，无一物可见，无一物可知，那个叫守住空知，就好像 “太虚生闪电”，这个道理一晃就过去，没了，“此之知见瞥然兴”，在一瞬间起来，然后也就没了，“错认何曾解方便”，假如你把这当成是佛理，当成是佛对我们本心的说法，那就是错了。“汝当一念自知非，自己灵光常显现”。这里牵扯到一个很大的哲学问题，比如说见性我们就不免要问：“见者是谁？” “被见者又是谁？”假如说佛性是空，本性是空，那么见空，见者是谁呢？这个见者在佛性之外喽，然后说这是空，那么空你怎么见得到呢？那个僧肇有一个《宝藏论》哦，我们就来想想这件事，说有一个人来到一个仓库里，里面堆满了各种金器，这个仓库就叫“金器仓库”，比方说有金项链啊、金戒指啊、金筷子啊、金碗啊、金条金砖啊等等，说这个人来到这个金器库里边，说他是不睹众相，常观金体不睹众相。虽睹众相，并不是他看不到金戒指、金项链的区分哦，他也看到了，“虽睹众相，亦是一金”，这是僧肇《宝藏论》里边的话。说这个人是“真人”，这个真人来到金器仓库了，看到了种种的金器，不同的金器之间的区分就是相的区分，戒指、项链、碗、筷子等等，说这个人呢看到的是金子本身，不睹众相，虽然也看到了戒指和项链碗和筷子的区分，仍然知道他们都是金子，亦是一金。僧肇拿这个比喻来比喻 “佛性”，拿金体来比喻佛性。似万事万物，就是不同的器啊，佛性都在其中。所以有一条禅宗公案就是讲一个禅宗祖师当着众人的面向着佛像吐了一口吐沫呢，引起众怒啊，这叫亵渎啊。然后那个禅宗祖师就问大家了：“你要让我这个唾沫往哪里吐呢？我吐到那里都吐到佛的头上呢。”边上有一个人当下就悟了。佛性就在世间万物上，万事万物的千差万别，他们都是佛性的体现。所以这个学佛啊，你说“平等心”哪里来？你说戒指一定比项链好，或者项链一定比戒指好，那叫着了相。他们都是金子，这叫不着相。那么我们再问一个问题，离开种种的金器，我们拿到那金子本身，可能吗？不可能。金子本身不可能离开金器单独存在，金子总是始终要在金器中才能存在，你无法把金子本身拿出来脱离出金器的。金子本身要么表现为戒指，要么表现为项链，要么表现为那个碗，要么那根筷子。没有脱离金器而单独存在的金子本身，但是项链碗啊筷子啊都是金器，所以惠能会说学佛在哪里学？在人世间学。“佛法在世间，不离世间觉，离世觅菩提，恰如求兔角。”不要把佛性搬出来脱离世间万物，另有一个佛性。没这件事。所以我们做任何事情，哪怕这件事情通常的标准来看微不足道，你也得认真做，为什么？其中有佛性的，佛性也在其中呢。所以那个真人就看到种种金器喽，都知道它们是金子，就像我们看人间万物，都知道它们是佛性的体现，这是第一步很重要，那么下面我们来讨论。</p>
<p>能常观金体，就是看到金子本身那个见者是谁？来问此问题啊，我们的五官感觉的能力，让我们能区分什么，戒指是戒指不是项链，碗是碗不是筷子。我们的五官感觉就能区分了。再加上第六识意识，就是分别识。所以要睹众相，睹者是谁？当然是通常的前六识嘛。眼耳鼻色声意，当然区分了不同的金器嘛，要观到金子本身的那个观者那个见者是谁？我们能回答吗？是五官？加上第六识意识吗？是什么？</p>
<p>【学生：提末那识】</p>
<p>末那识也是不行的，它还不是智呢。看到金子本身的一定不是通常的前六识，末那识是在前六识的基础上做事情，那就是行动者，<strong>小我</strong>。在万事万物当中都见到佛性的那个见者就是我们的<strong>心</strong>，要点在此。所以“即心即佛”。佛性是被你的心所领会到的，于是你的心就是佛性。所以再见本性这件事情上，没有在本心之外另有见者。倘若我们问见性者谁？就是这个<strong>佛性</strong>本身，因为它同时就是<strong>心</strong>。</p>
<p>这是个极高明境界，西方人要通过谁你知道吧？通过黑格尔，才达到这种认识。黑格尔说精神是怎么存在的？精神的存在就是它的自我认识，它不认识自己它就不存在了。这一点恰好说出了僧肇宝藏论里的事情，常观金体这个<strong>观者就是心</strong>，没有此心即无金子本身。你只能看到器。心一起来，金子本身自然看到了。那么金子本身其实就是心，统一的。把心拿掉没佛性，把精神的自我认识拿掉哪有精神？<strong>精神就是它的自我认识</strong>。比方说自由，自由是个精神的词语，它不是个物质的事物，我无法颁布给你。我无法把自由作为某种属性给你。你跟那个奴隶制最兴盛的时候的奴隶讲，你这样的生活处境是不对的，你不应当成为一个会说话的工具，你应该追求自己的解放和自由。这时候的奴隶是听不懂的，他觉得奴隶主就是他的恩主啊，奴隶主的家就是他的家。封建时代鼎盛的时候也是这样的，这个在贵族的庄园上生活和劳动的那些仆人半农奴，并不跟他的贵族主人对抗的。贵族的庄园就是他的家，你这时候无法把自由颁布给半农奴啊。就像红楼梦里讲的一样，你看那个金钥儿说的那句话吧，王夫人其实没睡着，宝玉不是在中午的时候到他母亲的房里见到那个金钥儿嘛，金钥儿不就是王夫人的贴身丫操嘛，然后宝玉看到金铺儿聪明伶俐可爱就跟他讲，我什么时候去跟太太说一声，把你要到我们那里去，到怡红院里去，我们在一起很开心。金钥儿就说了，“你急什么，是你的总归是你的。”一句话一说出来，王夫人没睡着，起身打她一个巴掌，“我好端端一个儿子，就是被你们这些狐狸精勾引坏的。”然后要把金钥儿赶走，那么今天我们的人就会想，她不就自由了吗？金钥儿投井了。她没家了你知道吧？你这时候跟那个金钥儿讲人权有意思吗？自由这种属性是精神的东西无法颁布给谁，他只有自己悟了他才有，他没悟就没有这个东西。精神不认识到他自己他就不存在。黑格尔说明了，中国禅宗老早说了，“<strong>本心自悟</strong>”，本心不悟即无佛性。见性者谁？就是这个心，它也就是佛，这叫<strong>即心即佛</strong>。你能说他是空虚吗？虚空吗？不是的。这就是大通和尚未了，所以让智常也未了，来问惠能了。我们别把佛性看成是个对象，它是死的然后我们去看，不是的！<strong>即心即佛</strong>。什么叫<strong>虚空</strong>？不是虚空，自性能含万法。就是刚才那个比喻啊，金子本身不可能脱离金器单独存在，看到金子本身的一定是我们的心，心一起来佛性起来，本心一起佛性即起来了，<strong>即心即佛</strong>。哪里可以用一个虚空可以说它呢？自己灵光常闪现啊，自己灵光不显现佛性也没有了。所以这个偈句最重要的是什么啊？自己灵光常显现，就是你的心起来即就是佛性见到了呀，他是同一件事情。</p>
<p>你既然觉悟你就是自由，你没办法把自由颁布给金钳儿，它是精神的东西，这一番道理在哲学上是一个大的讨论，学西方哲学啊，你一步步学下去，从康德再走到黑格尔，你就明白了，实际上中国思想很精彩，在时间上早于，这个禅宗惠能啊早于黑格尔多了，他早以尼采了。尼采说“上帝死了，我就是太阳”，说得那些欧洲同胞们一愣一愣的，觉得是个疯子在说话，因为欧洲人长期地在精神上不能割断跟上帝之间的脐带，他无法自己站立起来，他一直没有走出精神上的断乳期啊。一个信仰上帝的民族，终于有一个尼采宣布上帝死了，他们怎么听得懂？中国人向来没上帝，从孟子开始一路走到禅宗，把佛学中国化就树立一个 “我就是太阳”。这样一个思想，很了不得。惠能讲的，如日悬空啊。太阳没东西撑住它的，就是人世间没什么好依靠的。这根本上的自性就是这个东西，我就是太阳。“自性本无一法可得”，它如日悬空，放出光芒，万物毕现。这也就是要比尼采要早了。</p>
<p>听了惠能这个偈句之后，智常心意豁然，一个豁然也是顿悟的意思。乃述偈曰：“无端起知见，着相求著提，情存一念悟，宁越昔时迷。”就当初他自己，求佛法心切吧，想要一念能悟啊，但是问题出在什么？着相求菩提。究竟虚空怎么样？大通和尚跟他讲一番话，啊，就是虚空，了无一物。</p>
<p>“自性觉源体”，我们的佛性，我们的自性就是佛性，它是我们觉悟的本源，我们觉悟我们就是在佛性中啊。</p>
<p>“随照枉迁流”，你到外面去寻找，到处看，那一面镜子去照，枉迁流。</p>
<p>“不入祖师室”，假如我没找到你惠能的话，</p>
<p>“茫然趣两头”，在两边走来走去，要么相信有佛性，要么不知道它究竟是什么存在，两头走啊，都脱离了<strong>自性</strong>。<strong>自性</strong>乃是我们觉悟的本源，觉悟就是佛，即心即佛，佛性不是死寂的东西，它是能动的，即是我们的心，所以禅宗又叫“佛心宗”嘛。</p>
<p>那么智常就跟随着惠能了。有一天又向惠能提问题了，“佛说三乘法，又言最上乘”，其实刚才我们已经讲过了是吧？声闻乘，缘觉乘，菩萨乘，这叫三乘吧。我们凡夫乘就是声闻乘，听说过佛法，缘觉乘呢就是阿罗汉境界，知道自己的来历以及自己什么时候走、怎么走都知道了，阿罗汉，叫缘觉，觉了那个缘，觉悟了那个缘。那么还有菩萨乘，菩萨乘么牛车喽，这叫三乘，还有最上乘呢，叫白牛车，叫一佛乘。</p>
<p>那么智常也同样问这件事了，“弟子未解，愿为教授。”“汝观自本心，莫着外法相。法无四乘，人心自有等差。”人与人之间根器不一样，所以当初《法华经》的譬喻品啊，只是拿来比喻的。</p>
<p>“见闻转诵是小乘”，这叫凡夫吧，听了佛法也跟别人说说吧，我们就是在凡夫乘里的，叫小乘。</p>
<p>“悟法解义是中乘”，境界上去了，还不够啊，还应该实践，叫“依法修行是大乘”。“万法尽通，万法俱备，一切不染，离诸法相，一无所得，这叫最上乘。”“乘是行义，不在口争”，这对，乘不就是车吗？车又叫乘是吧？这个中国古代说有些诸侯国他的军队编制可以叫“千乘”。千乘之国，这个国家规模比较大，他的军队拥有的数量叫“千乘”。乘就是车，这就是要行的吧，车不行怎么叫车呢？所以车是行，车要往前开嘛，所以乘就是实践的意思。乘讲的是实践的境界，不是口上的讨论。</p>
<p>“汝须自修，莫问吾也。”从此之后你去实践吧，不用再问了，实践到什么境界就是什么境界，是羊车就是羊车跑得慢一点，是牛车嘛跑得快一点力量大一点，这自己会体会到，莫来问我。“一切时中，自性自如。”说到这里，智常礼谢执侍，终师之世，直到惠能圆寂，都没离开过惠能，这就是第四个机缘。那么后面还有几个我们下次来。</p>
<p>我们现在进入这个第五个机缘。也就是志道来问。我们这本书是138页。说这个和尚志道是广州南海人。来到惠能这里请义。他说自己出家以来，一直读一本经，就是《涅槃经》。“十载有余”，10年多了。“未明大意，愿和尚垂诲。”惠能呢，直截了当问：你哪里不明白？然后志道就引用了《涅槃经》当中，非常著名的一段话。“诸行无常，是生灭法。”天下万事万物都无常，生生灭灭，叫生灭法。什么是涅槃境界呢？就是后面八个字“生灭灭已，寂灭为乐。”我们看生灭灭已，这第二个<strong>灭</strong>字，灭什么呢？不是光灭那个生，还灭那个灭。就是生灭之差别给灭掉了。生与灭的区别，给它灭了，叫生灭灭已，达到的是什么境界呢？叫“寂灭为乐”。用一个快乐的乐。所以他就有疑惑了，这里怎么会有快乐呢？</p>
<p>“汝作么生疑？”你怎么会有疑惑呢？志道就说了，这话说得蛮恳切的啊，我们都会有疑问。“一切众生皆有二身。”按照佛学的说法区分了色身、法身。“色身无常”，色身就是我们的肉体，body。无常当然无常。从出生到长成，成长到衰老一直在变嘛，而在最后灭了。“色身无常有生有灭，法身有常无知无觉。”就是说志道把色身和法身做一个区分，色身是肉体，当然有知有觉了，那么法身不是肉体，它无知无觉。这个《涅槃经》中说“生灭灭已，寂灭为乐者，不审何身寂灭？何身受乐？”把什么身灭呢？是把色身灭了还是把法身灭了？都灭了之后，什么身来享受这种快乐呢？如果是色身灭了，“若色身灭时，四大分散”，风水火土这是佛教讲的基本元素，四大元素组合成我们的肉体，然后死的那一刻就叫四大分散。这是当然是很苦的事了。一个人走的时候，那叫四大分散，极大的痛苦啊。“苦不可言乐”，这里怎么有快乐的？</p>
<p>如果讲的是法身寂灭的话呢，那么，就和草木瓦石一样了。又无情之物，无知无觉。如何受这个乐，谁当受这个乐？然后他又把他的理解说出来了。“法性是生灭之体，五蕴是生灭之用。”体和用。五蕴我们刚才说过了，色、受、想、行、识。那么这个，志道就理解为它是法性之用，色、受、想、行、识是法性之用，“又法性是生灭之体，五蕴是生灭之用；一体五用，生灭是常。”总是生生灭灭，“生则从体起用，灭则摄用归体。”我们活着叫生，那是从体起用，我们死了，这叫色用归体，“若听更生”，如果让他再次来到这世界上，就是“有情之类，不断不灭。若不听更生”，如果他不再生，不再来到这个世间，“则永归寂灭同于无情之物”。他就这样讲涅槃了。涅槃等于不再来到人世间。永归寂灭。那么跟无情之物一样了。“如是”，假如是这样的话，“则一切诸法被涅槃之所禁伏。尚不得生，何乐之有？”这就是志道的疑问，并且他的理解都说出来了，就讨论的涅槃境界的问题，《涅槃经》就是讲涅槃境界嘛。是不是应当把涅梁理解为永远的寂灭？如果是永远的寂灭又如何有快乐可言呢？而《涅槃经》里面明明说“涅槃为乐”，此乐何解？惠能回答说，“汝是释子”，你修佛的人，就是释迦牟尼的弟子，所以佛教徒都叫释子。“何习外道断常邪见。”你是怎么从这佛教之外，听那种断啊常啊的邪见，“而议最上乘法？”所以，惠能是不客气，直接了当说你这个叫外道</p>
<p>“据汝所说”，按照你的说法，“即色身外别有法身”。两样不同的东西。肉身是一样的东西，法身是另一样东西。这法身呢，就离开生灭了？那么按照你的理解这个法身等于无情之物啦。即色身外别有法身，“离生灭求于寂灭”，脱离色身的生生灭灭，我们肉体生生灭灭，然后达到寂灭，叫法身，这是你的说法。“又推涅槃常乐”，你要去想你涅槃常乐什么意思呢？因为有一个乐字你就说要也有身受用，必须有受用者吗？快乐是谁在受用呢？你这样的想法在叫什么呢？他回答了，惠能就是说了，这叫“执吝生死，耽着世乐”。就是你把生与死的区分一直抓住不放了，这叫<strong>执吝生死</strong>。其实呢，是眷恋着人世间的快乐。你所理解的快乐，始终还是世乐。因为是世乐的缘故，总要有一个身去受用。所以说得很透，你的问题就错在这里。“汝今当知佛为一切迷人”佛陀知道天下一切迷人都有一个什么问题呢？“认五蕴和合为自体相，分别一切法为外尘相。”把五蕴和合当作是体了。我们刚才讲五蕴和合，那是个假的心，其实是<strong>业识</strong>，但是把它当真了变成<strong>体</strong>，叫<strong>自体相</strong>。外部世界为<strong>外尘相</strong>，一个主体一个客体，一个主观世界，一个客观世界。“分别一切法”，法就是事物。一切事物都做了区分，当然我们认识外部事物都有差别，然后构成的客观世界，叫“外尘相”。一方面是我们这个假的心当成本体来看，一方面外部世界的又当它真实存的，能够区分了。“好生恶死，念念迁流，不知梦幻虚假，枉受轮回。”按照佛教我们生生死死的。上次来过，这一次又来，下一次还来这个世界，那叫<strong>轮回</strong>。白白地受了这种轮回。其实都是梦幻虚假。“以常乐涅槃，翻为苦相，终日驰求。”这就是释迦摩尼认识到天下的一切迷人都有这样一个认识。执着于自己这个五蕴把它当自体，把外部世界看成是客观存在的一切分别的事物。然后呢，就要留恋这个世界，叫<strong>好生</strong>，怕离开这个世界，<strong>恶死</strong>，<strong>好生恶死</strong>，念念迁流，不知道这些都是梦幻虚假。然后倒是把常乐涅槃，看成是最苦的状况，这个翻为苦相。“佛愍此故”，佛陀对天下人的这种迷都有一个怜悯。因为怜悯这种情况的缘故，所以给我们提示了，就是显示给我们涅槃真乐。什么是涅槃真乐呢？就是“刹那无有生相，刹那无有灭相”。“更无生灭可灭，是则寂灭现前。”所以我们不能望文生义的，这个寂叫永远的寂寞，灭叫永远的没生命，这种望文生义。<strong>寂</strong>就是<strong>安静</strong>，本是安静的意思。这个<strong>灭</strong>不是死，是什么灭了呢？<strong>把生死的对立给他们灭了</strong>。合起来叫<strong>寂灭</strong>。因为把生死的对立灭掉了，其实就没有什么东西可灭了。那叫<strong>宁静</strong>。这叫<strong>涅槃真乐</strong>。这叫寂灭现前。当下就是。当现前时这个境界呈现了，亦无现前之量，这个量看上去是个数量的量，其实是指推理的意思。无量就是不去对它进行任何推理，任何逻辑的推理。无现前之量。佛教讲度量，其实不是测量，是用逻辑去思考问题，用逻辑去推理。用逻辑去推理都叫度量。那么“无现前之量，乃谓常乐”，这个乐不会有苦来取代，然后再乐再苦啊，不是这样了，那叫常乐。那么这个乐如何理解？谁受用呢？听上去我们一份快乐总得受用吧？有受用者。“此乐无有受者，亦无不受者。”这话奇怪了。哪里有？“岂有一体五用之名呢？”更何况啊，何况更何况更言，你还更进一步说，涅槃这种境界叫 “禁伏诸法”，把万事万物都什么束缚住了，“令永不生”，这叫 “谤佛毁法”。下了这个断语。我们读到这里，确实觉得很难理解啊，这个涅槃常乐。因为我们从我们生活与此世界当中，亲身感受了苦与乐的区分。那么这个乐，是我们的色身在受，苦也是我们这个色身在受，那么这个色身灭了以后呢？那就是法身，法身就是寂灭了。哪有乐可言呢？偏偏还要讲寂灭为乐。惠能又说这个乐叫常乐，这个常乐无有受者也无有不受者。这一番话是最难懂的。简单的说，假如我们说有一份快乐，总是有受用他的受者，那么这个受者跟快乐之间就有分离吧？就有区分，此刻，我这个受者获得一份快乐的状况。这份快乐与受者之间有区分吗？有，所以他又会被乐的反面——苦这个状况所取代。他时而受乐，时而受苦。那么这个受者本身是什么东西呢？乐只是它的状态，苦又是另一种状态。那么受者自身呢？所以这里一旦谈那个快乐的接受者。已经把接受者跟快乐，做了区分了。然后这个接受者恰好此刻在快乐的状态里边，后来又被苦的状态所取代。这就我们通常讲的这个受乐或者受苦。我们就追求受乐，避免受苦。就是这样一种领会。其实真正的快乐，真乐或者常乐，涅槃常乐是**这份快乐跟我接受他的没有区分。我就是这份快乐本身。**是这样一个领会。难就难在这里。</p>
<p>我们有一个假定，这个受者本身始终是这样的东西，然后它具有快乐的属性，或者不具备快乐的属性，具备快乐的状况或不具备快乐的状况。然后，我们这个受者就会执着。抓住乐不放，好像它会丢掉。后来它终于丢掉了，那么苦来了。那么我们要避开这个苦，然后再去获那个乐。就我们跟这个乐之间有区分。然后再去抓住这个跟我们有区分的乐不放。通常就是这么一个生命感受。这个生命感受有问题的！我们设定了一个享受乐的受者。这只是我们的设定。其实他本不存在。你比方说一个自我在哪里？自我在身体内部的某个地方被包围着。王德峰是谁？我这里一指，这个自我的，肯定不是，王德峰不是命名这个身体的是吧，命名一个与你不同的另一个我吗？那么这个我在哪里呢？在肌肤的包围之中的某一个位置上。我们就这么想的。其实这只是人的一种设定。自我在哪里呢？自我不在身体内部的某一个位置上的，<strong>自我在他所生存的一个场里边的</strong>。我们借用物理学的概念，叫field，<strong>场</strong>，王德峰在哪里？<strong>在与他的生命攸关的事物上</strong>。他不是个实体，这个有意思啊，西方人的思想呢，到了20世纪有存在主义思想的时候才明白这个道理的。你们可以去看一本书叫《非理性的人》。上海译文出版社出了它的中文版。这个作者是个美国的哲学家，其实是德国人后来第二次世界大战当做流亡到美国，叫威廉.巴雷特。写了一本《非理性的人》，这本书是向美国的公众介绍欧洲的存在主义哲学。这本书出版之后，威廉.巴雷特名声大噪，因为美国人基本上哲学修养很差，他们不懂欧洲哲学的。那么他们听到存在主义这种思潮起来以后，美国人不懂嘛，所以威廉.巴雷特就写一本书，向美国人普及存在主义思想，其中就举一个例子啊。他说一对双亲啊，父母啊，他的孩子慢慢长大，终于对这个孩子对他自己的名字，有反应了，比如说这孩子叫彼得。那么双亲很高兴啊，自己的孩子知道自己叫彼得了。那么客人来了，他要表演给客人看。当做客人的面呼唤自己的孩子--彼得，这孩子果然回头了。他向客人证明自己的孩子知道自己叫彼得了，那么客人还不放心追问了一下，问这个孩子彼得是谁？双亲正在期待什么呢？这小孩这么指，彼得就是我。他结果没指向自己的身体，指向他母亲的臂弯母亲的怀抱。这样呢这对双亲就大失所望。你到现在还不知道彼得在哪里？后来威廉.巴雷特说这孩子完全是对的，我们成年人才错了。此刻这孩子最需要母亲的拥抱。所以，客人问彼得是谁？他就指向母亲的怀抱了，这孩子是对的。你们双亲想要知道，想要这个小孩知道他这个自我在这里，彼得这个自我在哪里啊？在于他的生命攸关的事物上，此刻最要紧的是母亲的拥抱，自我就在那里，不在身体内部的。我们总把自己这个自我想象为一个现成的实体，然后他正好获得快乐一种状态，或者不快乐一种苦状态。这个自我实体的存在是人类的虚构。我在哪里？我们每一个我在哪里？<strong>在他生存场中。跟他的生存攸关的所有事物，自我就在那里存在的，他弥漫于整个生存场</strong>。我们成年人那个思维啊，就形而上学的思维，把这个事物跟人的精神存在类比了一下，比如说杯子在哪里？这个东西，是好像是个实体，自我在哪里？指向这里。这是个错误的类比！自我不是这样存在的。成年人有时候又回到真理去了，什么时候？比方说，我王德峰78年考入复旦，87年又回到复旦读研究生，90年毕业留校直到今天。复旦大学肯定是我的生存场的不可或缺的一部分吧。假如我在一个公共场所譬如说，坐地铁，在车厢里听到两个陌生人在说复旦大学怎么样怎么样。。。我听到他们在议论复旦大学的时候，我仿佛觉得自己的名字被呼唤了。当我这个感受起来的时候，我就回归了<strong>真相，自我的真相</strong>。我王德峰这个自我的一部分就是复旦大学，哪那里在我身体内部。假如我听到两个陌生人提到我儿子的名字的时候，我把我自己被呼唤到。我听到复旦大学哲学系，有人在议论我也仿佛我的名字被呼唤了。自我就是这么存在的。它不是个现成的实体。假如这个生存场是欢乐呢？我就是这种欢乐。我不是一个接受欢乐的受者，我就是这份欢乐本身。我此刻悲哀了，我就是这个悲哀的本身。我并不是另外一个不悲哀也不欢乐的东西，此刻承受了这份悲哀。没有！所以，叫“无有受者亦无有不受者**”**。</p>
<p>这是一层很重要的意思，别把自我收到了一个什么地方，然后从中心出发，跟外部事物打交道，自我向来在外面，在你生活的整个场里边，这是一份领会。然后再说为什么这个乐是常的，叫常乐？别把色身跟法身分离。我们现在始终在色身里边，法身跟我们没关，终于色身结束了，法身来了叫寂灭。错了！<strong>法身就在色身中。常在无常中</strong>。如果法身是常色身无常，那么这个法身并不脱离色身。我们当下色身是生生灭灭，但是不生不灭也在这色身里。涅槃就在当下，就看我们达到还是没达到。我们活着的每一个当下同时跟不朽连在一起，这是<strong>当下涅槃</strong>。别以为涅槃也是我们生命的终结之后达到的一个状态。你把涅槃领到当下，就先行进入不朽，而后活在当下。这是人生最应该有的根本态度，我们才摆脱了生与死的对立。</p>
<p>我不是在这里讲过吧？我最初感受到领会到这一点，是因为我母亲去世了，我母亲生前是克勤克俭的人，什么东西都不能扔掉的。后来我长大了自己成了家，经常回到我母亲的家父母的家，看我小时候用过的东西，它居然都还在。篮子买菜的，都已经破烂，如此她还用绳子把它扎紧扎起来，还可以盛放东西，家里就是一大堆垃圾，然后我不断的跟她讲，把它们扔了，你家里都变成垃圾桶了，她不允许的。</p>
<p>然后我母亲走了，我跟我姐姐一起整理她的遗物的时候开始扔了，扔的时候我有内疚感的，我想我们是趁着母亲不在了才扔，如果她在她一定愤怒了，我带着内疚感开始扔她东西。后来我又想，此刻她看着我扔了，她的在天之灵她会怎么样？看着我扔她的那些生前不舍得扔的东西的时候，她会怎么样？</p>
<p>我的第一感受就是什么？她微笑了。她微笑看着我扔这些东西，一定是这样，她已经跟不朽在一起了。她还会眷恋这些无常之物吗？一样的东西都不能扔，她不会这么想的，她微笑。在这个念头起来，想法起来之后，我一下子明白了。如果我王德峰，现在不是还活着吗？假如我像我母亲一样，同时是个在天之灵，然后看我的人生，这就是我们**在生生灭灭的当下，同时跟不生不灭在一起，这就是当下涅槃。**我们活在当下，同时跟虚无站在一起。后来西方人也懂这个道理，特别是通过海德格尔，他说要先行入死而后生，就这个意思了。</p>
<p>我们还存在着但是我们先要什么？<strong>在精神上进入虚无，然后活在当下，那就是涅槃了</strong>。别以为我们这个色身无可奈何，它就生生灭灭。色身中有法身的，就看你的境界。所以不要说色身外别有法身。也别把法身看成是永远的空寂，那叫苦不堪言是吧？无乐可享了。不是的，那叫<strong>常乐</strong>。<strong>无有寿者也无有不寿者</strong>，我就是这种永恒的欢乐。</p>
<p>这种欢乐超出了色身的感受，它是宁静的，叫<strong>寂静欢喜</strong>。仓央嘉措的一首诗，<strong>漠然相爱，寂静欢喜</strong>。写得好，用诗歌的形式写出了涅槃的境界。你见或者不见我，我就在那里不悲不喜。我们都背得出来的是吧？你念或者不念我，情就在那里，不来不去。不是无情，无形之物如同瓦石草木了，修行不要修到无情，那就错了。</p>
<p>所以我认为仓央嘉措写爱情这首诗，那就把爱情收归了佛门。爱情是佛性的一个方面，他不由具体的爱情的得失所转移，具体的爱情总得得失失，它不会永恒的，没有什么没完没了爱下去这种事情，爱情是永恒的，不是说它没完没了的意思，而是它是不朽的，就这个意思。</p>
<p>爱情是不朽的，具体的爱情跟苹果一样生生灭灭，这样我们就理解了什么叫<strong>涅槃常乐</strong>。我们先懂这个道理，要真领会那叫悟了。不是说解释了一下就会悟，就是另一种眼光来看自己的生活。这种眼光是既在当下又脱离当下的。就是我的那个比喻啊，母亲在天之灵看着我扔她东西，那么我也跟母亲在一起看自己的行为可以吧？一样。我们同时有个在天之灵，我们自己看自己当下的生活。不可尽言，只能到此。因为涅槃是说不清楚的，大概如此吧。既在此岸又在彼岸，既在当下又在永恒，这样讲比较妥当，也没那么复杂，我们不要扔掉不朽的东西，我们不知道有不朽的东西，我们只是在生生死死，沉沉浮浮当中过生活。</p>
<p>我们另取一个眼光，彼岸跟此岸也不是间隔的，彼岸就在此岸中，就像海水跟海面的浪花并不分一样，浪花生生灭灭的，海水是常通流不朽，统一的。所以惠能很厉害，所以直截了当说他这个叫邪道，外道邪见，你还区分色身与法身，区分当下的快乐，然后说法身涅槃叫苦相。永远的寂寞，永远的空寂你就错了。</p>
<p>所以这就是惠能的回答，然后来一个长长的偈，我们念一下：“无上大涅槃，圆明常寂照”。这个偈一定不能忘文生义<strong>寂</strong>就是<strong>安静</strong>，“凡愚谓之死”，凡人，愚人才把涅槃当成死来看。确实以前是这样说，风凰涅槃。涅槃就是死，然后再生就这个意思。其实涅槃是不生不死，不生不死不等于死，我们肉体就死掉了，就<strong>活在当下同时跟不朽在一起，那才叫不生不死</strong>。“凡愚谓之死，外道执为断”本来活着后来就断掉了，不是的。“诸求二乘人，目以为无作”求二乘人是什么？二乘是专门指两类人，一类叫声闻乘。我们凡夫听到了一点佛理的话，知道一点佛法叫声闻，我们最多是声闻乘现在叫凡夫。不是一点不知道佛理的，我们都多少知道过，那叫凡夫乘，又叫声闻乘，听说过。还有一个叫缘觉乘。我们都讲过的缘觉乘，那是阿罗汉境界。这两层合起来叫两层，二乘人，二乘人一定搞错了，以为在涅槃境界当中就无所作为了，什么都没了。</p>
<p>“尽属情所计”其实都是俗情所困扰。“六十二见本”这不去多讲了，我们看书自己回去看，回头看好了，因为他还立了六十二种邪见。什么唯物主义、唯心主义都属于六十二见。“妄立虚假名，何为真实义？唯有过量人，通达无取舍。”什么叫过量？超越逻辑推理叫过量，否则叫度量。一直在度量推理当中，过就超越，唯有超越逻辑推理的人才通达<strong>无取舍</strong>，不取不舍。“以知五蕴法，及以蕴中我。”我们这个我都是五蕴堆出来的，色受想行识。“外现众色像，一一音声相，平等如梦幻，不起凡圣见。”就是说其实我跟外部世界并不二的，外层也因五蕴而起，也因色受想行识才发现有外部事物的，所以这一点佛教永远是唯心主义的，没有一个自在的客观的物质世界，五蕴起来才有外层，所以不能把它们分离的，所以佛教确实唯心主义的这一点没错的。唯心主义不是贬义词，<strong>唯物主义才是比较低级的看法</strong>。</p>
<p>所以王阳明也同意了心外无物，心之外没什么东西的。然后有人反驳，那山间的花自开自落与你的心有什么关系？王阳明回答说“汝未去见那花时，汝心与花一时俱灭。”都没有啊，主体客体都没有的。“汝一去见那花时，汝心与花，一时都明了起来”，主客体都来了，所以平等什么意思？统一的。“平等如梦么幻”什么意思？我相外尘相全是梦幻，“不起凡圣见”，区别了凡俗与贤圣这种区分都不对的。“不作涅槃解，二边三际断。”<strong>两边</strong>是<strong>有</strong>和<strong>无</strong>，叫两边二边，<strong>三际</strong>就是<strong>过去，现在，未来</strong>。既不区分有与无，也不区分过去，现在，未来，三际就是时间：过去，现在，未来。“常应诸根用，而不起用想。”我们的慧根它在我们生活中起了根本的作用，但是我们在做事情，不要把它当做用想。不起用想，这个都是《金刚经》的基本的境界。</p>
<p>比方说《金刚经》主张无相布施。“我正在布施”，好了有相了，不要做用想。现在有些人做慈善事业，最好得一个证书。曾经捐过多少钱，曾经办过多少希望小学，有一个证书放在家里是吧？这就是有相的。人与人之间本应当互相帮助，这很自然。同时想着我正在做善事，好了，着相了。所以无相布施，无相是《金刚经》的中心思想，所以这里说我们应诸根用，有此根必有此用，但是不起用想。“分别一切法，不起分别想”，我们活在这个世界上是要区分事物的，所以你得科学的，也要积累经验，这里分别识一定要起来，但不要着分别相，我一直开玩笑说，你那个包LV包，比我这个包昂贵的多，质量也好得多，这真实的，叫分别识起作用。人怎么好不起分别识呢？但是不着分别相。什么叫不着分别相呢？你那个LV包再好，绝不妨碍我这包还是包。这就不着分别相。他说“分别一切法，不起分别想”就这个道理。你说习大大跟我见面了，我说我们一样，怎么一样？人家国家领袖。你就是一个子民这当然分别了，他担当国家，你王德峰担当了没有？分别吧？分别归分别，不着分别相。什么叫着了分别相，我一见到习大大我诚惶诚恐，说话都开始语无伦次，还了得，这就做着分别相。坦然的跟他交流，生活就应该这样。你说没有分别怎么可以呢？他要处理的事情你王德峰处理得了吗？处理不了的。我讲哲学他能讲的跟我一样好吗？那也到未必。无所谓的。这肯定有分别嘛。但是不着分别相，他很坦然的跟哲学王子握握手，我也坦然的跟总书记握握手就好了。不着分别相。“分别一切法，不起分别想”。</p>
<p>天翻地覆，人世间沧海桑田，不足以影响我们，他说“劫火烧海底，风鼓山相击”那叫地震了。地震不是山都相击了嘛。对没关系的。“真常寂灭乐，涅槃相如是，吾今强言说，令汝舍邪见。汝勿随言解，许汝知少分”，你不要跟着佛经的文字去找，也是讲破文字执嘛。如果你做到这一点，我可以担保对佛教的教义，就佛法会有所领会。“许汝知少分，志道闻偈大悟，踊跃作礼而退。”这就是就机缘五。那么底下有两个机缘特别有意思的，一个叫行思，后来还来了一个怀让，这两个人物在禅宗的历史上非常重要，他们来到慧能那里不是求惠能开悟的，他们已经悟了，来到惠能那里是来求一个印证。</p>
<p>后来行思在惠能那里得到印可了，后来又来一个怀让，也被惠能印可了。所以从行思那里开出三支，从怀让那里又开出了两支，叫一花开五叶。从行思那里开出云门宗，曹洞宗，法眼宗。从怀让那里开出了两支，就是沩仰宗和临济宗。怀让底下出现一个谁啊？马祖道一。所以一花开五叶，从惠能那里分五个分支，这件事情谁知道？达摩都已经知道了，达摩原先就讲过。所以这两个人来，我们用今天能理解的话，来到惠能那里得到一个教师资格证书。所以禅宗它的传承都是普系很清晰的，其他宗派都没达到这一点。谁在谁那里得到印可都记录在历史上的。前面几个人都没悟，到惠能那里求一个悟。行思悟了，怀让也悟了，到惠能那里得到印可。印可以后他们都各自去驻化一方，然后开出五叶。注释里面讲的清楚，我们看144页，第一个就讲行思，他来自青原山，所以就叫青原行思。后来门徒云集，禅宗大振。注释一，从里边衍生出什么云门，曹洞，法眼。然后看第三个注释怀让，惠能园寂之后，得师其法。他是从惠能那里继承下来，在南岳，所以他又叫南岳怀让。到他的弟子马祖道一，怀让一系就兴盛起来，被称为南岳系，其后衍生出沩仰宗和临济宗。所以这两个人很重要的一个行思，一个怀让，一花开五叶也终于在他们那里开出来。</p>
<p>我们上午在机缘品当中讲到了第五个机缘，就是志道来问惠能《涅槃经》当中的那一段话。其实问的就是什么是涅槃的境界？然后我们就要进入第六个机缘。从第六个机缘到第七个机缘，这两个机缘其实都是两位已经悟了的禅师，他们要到惠能那里得到印可才行。所以《坛经》里面称呼他们时候，已经直接称他们为禅师了。前面来的几位都叫僧、和尚。我们翻到143页，行思就被称为禅师，禅师就是禅宗祖师的简称了。</p>
<p>他是江西吉安人，听说曹溪这一带法席盛化。因为惠能的名声已经传出去了，他来到惠能这里，有一番简短的对话。到惠能这里先问了一个问题。“当何所务，即不落阶级？”这个阶级不是我们今天所理解阶级斗争，而是指这个佛教修行向来被认为是有次第的，就一步一步的前进。从低到高，这样就有次第的区分，你在哪一个位置上，比如说你修到哪一步了。但是，禅宗的境界不讨论次第，尤其是禅宗南派叫顿悟，主张顿教。所以就不说有个循序渐进的过程，这一点行思知道。所以行思就问惠能在什么情况下我们修行不在某一个阶级上？我们应当怎么做才能跳出阶级的区分呢？惠能反问他：“汝曾做什么来？”就是你曾经是怎么修行的。行思回答说：“圣谛亦不为。”我们都知道圣谛就是<strong>四圣谛</strong>，佛陀在菩提树下悟道的时候开始说佛法，最初说佛法，叫初转法轮。初转法轮讲的佛理是四谛说。<strong>苦、集、灭、道。苦谛、集谛、灭谛、道谛</strong>，这<strong>四谛</strong>。学佛第一步就是要了解佛陀的基本思想，他的人生观他的世界观就由四谛来说的。</p>
<p>第一个就是讲人生，到处都是<strong>苦</strong>。佛陀说城门，四扇城门。东西南北，分别看到<strong>生、老、病、死</strong>。整个人生就是生老病死，无一不是苦。生是苦，老是苦，病是苦，死也是苦，人生就是苦海。先把这个说清楚，否则佛陀来讲他的佛学思想干嘛呢？佛家就是这么看人生的。先说明人生这个苦是真相，谁都摆脱不了。欢乐是暂时的。后来德国哲学家叔本华读到了佛经，非常赞同佛陀的思想。叔本华说，人生总体上就是悲剧，只有在个别细节上有一点喜剧的成份。这是叔本华的原话，所以叔本华就接受佛陀的思想来看人生。什么叫幸福呢？痛苦的暂时的解除。没有什么真正的幸福，幸福其实是痛苦的暂时解除而已。只是暂时的解除。那么痛苦的根源叔本华讲就是<strong>欲望</strong>。人首先必须被理解为一个生命体。生物就有欲望，欲望要去实现它，实现了叫如意，不实现叫烦恼，叫不如意。所有的欲望都实现了呢叔本华来讲最后留下来叫空虚，这就是叔本华接受了佛陀的思想，然后把宇宙看成是生存意志的宇宙。生存意志的体现就是欲望，这种欲求要实现。所以他是从佛陀那里得启发来看人生。</p>
<p>所以，第一个<strong>苦谛</strong>。苦哪里来？苦的原因是什么？用<strong>集谛</strong>来说。<strong>集</strong>就是说<strong>苦</strong>的原因，<strong>无明</strong>就是<strong>烦恼</strong>的另一个称呼，另一个说法。后来中国人的汉语中说发无明火，<strong>无明</strong>就是<strong>烦恼</strong>。因为我们无明，佛陀讲了一大串我们苦的原因。特别是讲的十二因缘，三世因果如何轮回，都是在集谛里边讲。那么既然人生是苦，苦的根源搞清楚就要把这个苦的根源灭掉！就要灭苦，就是<strong>灭谛</strong>来了。那么，如何灭？要有根源上着手，要<strong>转识成智</strong>，讲这个智慧就是<strong>道谛</strong>。前者是结果，后者是原因，苦是个结果，集是讲苦的原因。灭苦是个结果，如何灭？灭苦的原因叫道，所以苦、集、灭、道。最初学佛法就要进入四谛说，那么这是学佛的道路上最初的阶梯了。然后行思说自己是“圣谛亦不为”。我连四圣谛都没思考过，后面都谈不上了。修行的第一步你都没做，后面还谈的上什么阶级呢？</p>
<p>惠能是有意考他的啊，人家已经说了“圣谛亦不为”，惠能居然问他落何阶级？那么你在哪个阶级上？别以为惠能很蠢，问了一个很傻的问题，禅宗祖师每每就是用一个傻问题来探探你的底。所以有意问了一个傻问题，人家已经说了圣谛亦不为，你还说落何阶级。他马上来了一句“圣谛尚不为，何阶级之有！我第一步都没踏过，后面还有什么一步步高的东西，没这句话一说出来惠能认可了，所以底下很简单，说很器重他。“师深器之，令思首众。”惠能竟然就让行思做了首座弟子。首座弟子又叫教授师，教授师实际上就是我们今天讲的所谓助教。当初弘忍法师让谁做了教授师？神秀。现在惠能让行思做了教授师叫首座弟子。凡是是我没时间，没工夫讲的话，就让首座去跟大家讲，这是行思的角色。有一天惠能就跟他讲了，“汝当分化一方，无令断绝”，你有你的使命。我惠能在这里广东曹溪驻化一方，你到另外的地方驻化一方。就像我们上午戏称的，就给了他教师资格证书，你可以走了。</p>
<p>“思既得法，遂回吉州”那座山叫青原山。中国古人常以地名来命名那个人，就像我们说黄梅的话是指谁啊？弘忍。曹溪的话就是指谁啊？惠能。青原就是指谁呢？行思。所以后来就叫青原行思。在青原山弘法绍化。他圆寂的时候被视为什么啊？弘济禅师。我们上午说到此人很重要，从行思底下有三支出来了。云门宗，曹洞宗，法眼宗。一花五叶，三叶是从行思那里开出来的。这就是很简单的第六个机缘。简单归简单，里边有意思。其他的宗派讲修行很讲究，有些宗派的修行程序繁琐。规则很多，一步步来。禅宗彻底打破这一切，直指人心。</p>
<p>《金刚经》当中有句话这么说的，一切贤圣皆以无为法而有差别。修行学佛法。如果<strong>有定法的话，那叫有为法</strong>。严格的遵守某些经典所说的佛法的修行。在《金刚经》这部经看来这都叫<strong>有为法</strong>。就执着了有所得，学佛也会贪求。当然，我们终于不去贪求钱财了，也不去贪求权利了，也不去贪求名誉了，那么学佛的人也贪啊。就是好像我一步步的比你更多，大家都还比较谁修得更好。你说出一套，我说的比你更高的一套是吧，这一切在禅宗看来是错的。</p>
<p>因为归根到底那个我执还是没放掉，所以《金刚经》就讲<strong>无为法</strong>。《金刚经》最后几句怎么讲？“一切有为法，如梦幻泡影，如露亦如电，应作如是观。”所以《金刚经》当中又有这句话，“一切贤圣兼以无为法而有差别”。古往今来修佛达到贤圣境界的都有很大的差别。假如大家按定法来修还会有差别吗？没差别了。一个套路里出来的，一个师傅带出一百个的徒弟都一样，那就<strong>有为法</strong>造成的。各有各地成佛的道路，那么这个路自己来，自己走出来的，这叫<strong>无为法</strong>。因为<strong>无为法</strong>的缘故天下的贤圣，成佛的人，差别大了。</p>
<p>那么这也是给我们的信心。有的人来按照某一种方法来修，然后到后来修不成了，他就失去信心了，你看人家修成了我不行。其实你在<strong>有为法</strong>里。人的根器它有不同，出生环境，时代的境遇都不一样，所以《金刚经》主张<strong>无为法</strong>。就像西方的谚语：条条道路通罗马，你说只有一条路通罗马，那就<strong>有为法</strong>。其实都应了贤圣之间有差别，差别再大都还是贤圣，你去追问那些禅宗祖师大德高僧第一生的生平事件差别这么大。有的人没做什么事，懒懒散散一辈子过去了，但是他开释了许多人。有的人一生的勤奋，不得了，他也开释了许多人，差别都很大。都不妨碍他们都是贤圣。所以，这个机缘里边颇有中国道家学说的境界。我们都知道，道家有一个最基本的命题，就是老子说的，<strong>无为而无不为</strong>。不要人为。修佛也是这样，人为两个汉字合起来又是一个汉字“<strong>伪</strong>”。所以有的人修佛走偏了，就是个<strong>伪</strong>字，他是不知不觉的伪了，他还当真。有一种修佛人是得通过佛经的文字含义的领会来修的，这种人就是一头扎到佛教大量的名相之中，我们今天的话就是<strong>概念</strong>。</p>
<p>佛学当中名相之多，多到什么程度？中国到现代以来那个叫丁福保吧，编了本佛学辞典。后来我拿到手一看吓死了，这辈子佛学学不完。这么厚一本词典，里边每一个条目都是一个名相。比方说，我执就分了两类，我执吧，这个叫分别我执。我执里心，一个名相，还有俱生。那么就去搞清楚吧，分别我执，俱生我执的区别是又什么？查佛学词典，查出来了，搞清楚了。俱生我执是与生俱来的我执。这很简单，实际上就是每一种生物自保的本能。</p>
<p>动物也有我执，每一个动物都要吃饱吧？一个刺猬，突然外部威胁来了，它马上说缩成刺球，就保自己的生命了，与生俱来的我执。那么人类的<strong>我执</strong>带多一层，<strong>分别我执</strong>。也有道理，我们光是俱生我执倒也罢了，别的地方都不我执。但人类有一种后天来的我执，人与人比较，一比较你地位比我高，或者地位比我低，或比我聪明，或比我愚笨，比我钱多钱少，这叫<strong>分别我执</strong>。我举例子，就是佛学的名相实在多，你把所有的名相全搞清楚的。</p>
<p>你学成了佛了吗？不是名相没用，但是它只是相，只是手段工具，要跳出去，于相离相。说佛法不离自性，禅宗的原则。所以惠能的本事大到什么程度呢？你问他许多名相他也没研究过，然后他就知道你在问什么？问什么我就从自性来跟你解释，又把你们的相破了。禅宗——惠能为奠基人。所以禅宗是佛学的中国化，我们有自己的智慧做根据的，其中就是道家。道家也破名相的，道家破名相最厉害的是庄子，是和非都要破掉。“此亦一是非，彼亦一是非”没完没了的，你不要执着在是非的对立中，这些都是<strong>破名相</strong>。</p>
<p>就像我上午讲的，你们如果去读庄子《齐物论》。你就深有体会，因为我们经历过时代的转变，整个毛泽东时代的那一套名相都被破了吧？立了邓小平时代的名相。所以，那时候的“<strong>是</strong>”后来就成了“<strong>非</strong>”。那时候的“<strong>非</strong>”后来就变成“<strong>是</strong>”了。你怎么好<strong>执着</strong>呢？庄子老早告诉我们。所以有了中国智慧做底子，佛学中华化禅宗，也<strong>破名相</strong>。修行的道路一个阶梯一个阶梯的前进，这也在名相之中。然后还起另外一种贪性。归根到底，还是<strong>我执</strong>。所以这就是这一则机缘给我们的启发，虽然它很短。</p>
<p>正因为行思说了“圣谛尚不为，何阶级之有”惠能就认可他了。《心经》后来也是这么讲的“无苦集灭道，无智亦无得，以无所得故……”。</p>
<p>修行的人也会贪，贪那个佛法之得，追根到底是无所得。以无所得故，无有挂碍，无挂碍故，无有恐怖，心无挂碍，无挂碍无有恐怖，运离颠倒梦想，究竟涅槃。学佛后来也会颠倒梦想的，所以这些《心经》里也都讲了，这就是第6个机缘。</p>
<p>第七个机缘来了。怀让，也被称为<strong>禅师</strong>。凡称为禅师的其实都已经悟了的。说他是金州杜氏子也，初谒嵩山安国师。这个安国是弘忍法师的弟子，这样呢，他其实跟那个惠能是师兄弟关系。在嵩山那个地方。那么，安国他也很有自知之明，跟怀让说：你在我这里是不行的，你要到惠能那里去。“安发之曹溪参叩”。安国禅师就要让怀让到曹溪去，参扣参见扣问惠能。于是怀让就到了惠能这里。</p>
<p>第一件事，礼拜，要磕头的。磕头完了，惠能第一句话就问：甚处来？</p>
<p>这通常会这么问。从哪里来？嵩山。什么物，恁么来？你什么东西怎么来？我曾经开玩笑，我说，我王德峰如果现在要去参见惠能，假如，惠能尚未圆寂，那么我就到南华寺去，我去参见惠能的目的很清楚，想要在惠能面前印证一下，我王德峰悟过没有？带着这个目的去的，那么惠能一定会接见我。</p>
<p>接见我，一定提我问题，通常会这么问。什么物，恁么来？你什么东西？怎么来？我王德峰应声回答，复旦教授，坐飞机来。完了，完了。惠能一定知道此人没悟过，底下就没有什么交流的必要了。复旦教授不是我的本来面目，他问你什么物？就问你本来面目啊。复旦教授怎么会是我本来面目呢。</p>
<p>1966年文化大革命爆发，我知道我叫狗崽子。那么狗崽子也不是我本来面目。多少年之后，复旦教授难道就是我本米面目吗？也不是嘛。</p>
<p>怎么回答？没办法回答的。你说什么都错。中华人民共和国公民也不是我本来面目。说什么都错，该怎么回答？向怀让学习。说似一物即不中。我怎么说都错的是吧？所以回答干脆一点，<strong>不是东西</strong>。这就对了。</p>
<p>恁么来？怎么来？<strong>没来</strong>。来到只是我的肉体，佛性不来不去。当然这后面这句没这么说啊，我发挥一下。说似一物即不中，这句话已经对了。本来面目是无法说的，自己领会到的。修行成功的人就见性成佛，见性成佛肯定有一件事情，知道自己来历，这个来历不是这辈子我是什么人，这不是我的来历。</p>
<p>这辈子我恰好是复旦教授，或者恰好是外科手术的医生，这都不是我的来历，或者总书记，这怎么是我的来历呢？那么我说我上辈子什么人？上辈子那个人也不是本来面目，是上辈子那个<strong>末那识</strong>，那个<strong>小我</strong>。本来面目是无法说的，但你领会到了，悟了就领会就受用了，无法用语言表达，那是<strong>阿赖耶识</strong>了。种子识，轮回就是种子识是在轮回。什么叫种子？就是先前所做的事情变成业了吧，这个业就在种子里边，带到这辈子来的，然后这辈子成家后又是个小我？另一个小我。上辈子打仗的，这辈子文人，上辈子打仗的这个战士或者将军也不是你本来面目。那么我们还说轮回，啥东西是在轮回？不是这个小我在轮回，是阿赖耶识在轮回。所以我们来到这个世界上，从娘胎里出来，首先到来的是八识当中的<strong>阿赖耶识</strong>。死的时候最后离开的还是<strong>阿赖耶识</strong>。这最后离开的<strong>阿赖耶识</strong>就携带着这辈子的种子，准备下一次轮回了，就这样的。我们信不信是另外一回事情，佛教就这么说。</p>
<p>所以这个本来面目是无法用语言支撑的，无法支撑。说似一物即不中。你别把自己宣布为一个什么东西。我们都有名片吧？什么物？拿给你，就是这个物。</p>
<p>错了。那是名片。我们现在很要名片的，把自己放到一个名相里，叫professor，教授。或者manager，经理。其实这全不是东西是吧？讲到底都不是东西。所以，说似一物即不中。明白了，此人已经悟了。</p>
<p>所以底下问一句，还可修证否？你还能修吗？这里牵涉到佛教当中一个很大的问题，尤其是禅宗一个很大的问题，就是悟了之后还要不要修？就这样一个问题。你不是见性成佛了吗？成佛了你还修什么修呢？两种看法。一种看法，悟了以后什么事都没了。还一种看法，还得修。那么惠能持哪种看法呢？</p>
<p>我们看下去就知道了，怀让回答说，修证即不无，污染即不得。已经知道自己本来面目了，如果你不修证，就又没了，你又会回到<strong>末那识</strong>里去。又会回到小我那里去，那叫<strong>退转</strong>，不能退转，还要修。但这个修叫<strong>修证</strong>，一个证字很重要。就<strong>用你的生命实践来印证佛理</strong>，底下的事情全是生命实践本身。不要再跟人家讨论佛法了，佛经可以扔掉了，人家禅宗祖师讲开示也不用去听，因为你悟了嘛，你就用你的生命实践来印证佛理吧。你进入了证悟阶段，这叫<strong>修证</strong>。</p>
<p>这个禅宗，由于禅宗中国就有一个成语，百尺竿头更进一步。你不要翻译成欧洲语言跟老外讲，他们听不懂的。你都爬到了这百尺竿头上面，你如何还进一步呢？你往哪里进呀？禅宗偏偏说这句话。百尺竿头，到了竿头上你悟了吧，悟了后面没事情了？有事情的，叫更进一步。叫回到什么？日常生活中。用自己的生命实践印证佛理，这就叫更进一步。这个成语当然也可以用到普通的事情上来，比如说你学习，学得很好的，毕业了。你得更进一步，干嘛？去实践吧，就这个意思。修佛也是。修佛第一阶段叫做解悟。解悟到什么时候终止呢？<strong>顿悟</strong>。顿悟开始了第二阶段叫<strong>证悟</strong>。一个解就是理解的解，觉解。先要觉解，这叫<strong>解悟</strong>。这个阶段少不了，连惠能都有这个阶段，虽然慧根很深了，听人家念《金刚经》听到8个字，心即开悟。因无所住而生其心。但他还没悟呢，要谁帮忙？弘忍法师。弘忍法师在关键的一步帮了他一把。这样呢，才悟了。所以惠能也有解悟的阶段。</p>
<p>虽然禅宗主张不立文字，但禅宗绝不否定佛经的重要性。佛经不就是经文嘛，经文不就是文字嘛。很重要。但真理不在文字概念里，两句话都得说。经文是帮助我们的，因为我们有病，有病就要治疗，治疗就要有药，佛经就是药。我们读佛经不要以为在从其中得到真理啊，不是真理。别在佛经中寻求真理。你这样读佛经你读错了，是拿佛经来治自己的病的。</p>
<p>什么叫治病啊？就是<strong>去妄</strong>。无需求真，但需去妄。去妄就是治病，不要到佛经当中讨真理，而是得它这个药来，去治病。你读遍了《金刚经》，一遍又一遍，里边有什么真理呢？没有啊。不就是在帮助我们什么？<strong>去妄</strong>啊。</p>
<p>然后我再补充两句，这是老修行的话，那么我这个刚刚开始想要修行的人还可以补充两句，一旦去妄，真在行中。这是我小小的贡献。</p>
<p>老修行只有这两句（无需求真，但需去妄），我这个小修行再加两句（一旦去妄，真在行中），<strong>一旦你病除掉了真理就在你的实践中</strong>。真理不在文字里，不在概念里，在你的生命实践中。所以学佛难吗？又不难。无非是<strong>去妄</strong>，不是去寻求真理。因为真理本来就在佛性里，哪里要去求啊？只是被遮蔽了。去妄就是去蔽。去蔽成功了吗？你的生命实践你不要去想，都在真理中呢。没有什么真理的条目让你背诵的，然后按照它去做，那叫座右铭是吧？真理不是座右铭，这个道理蛮基本的。</p>
<p>我们现在有一个想法就是寻求真理，那就是西方思想。真理在某一个地方待着，等我们去找到它，我们历尽千辛万苦，千里跋涉，终于找到它，找到它能怎么办？看着它发呆，还能干什么？真理就在这里。你只能看着它发呆了，这怎么会是真理呢？就中国思想高明，因为我们本心具备。所以孟子讲的好，万物皆备于我，反身而诚。乐莫大焉。</p>
<p>真理不要到心外去求，这一条信心，我们很难树立。要树立这个信心，否则你就一辈子<strong>谋虚逐妄</strong>。你要去求的那个真理终于还是妄，你不就谋虚逐妄了。我们只要做的是一件事，去妄。病除了你还捧着这药罐子干嘛？药到病除是吧？药罐头就扔掉了。不要等待一个人生的导师，教导你一辈子该怎么做，没这种事。我小时候有这种天真的期待，一开始把父亲当导师的，父亲说的话嘛，就真理啊。后来慢慢长大了发现他比我还傻，然后看不起是吧？然后要寻求比父亲来说，更真正的导师。你找得到吗？</p>
<p>当然我们怀着这个虔诚的心。比如说当时我很虔诚，就觉得许多的具体科学咱就不学了，这种东西动动脑筋都会的。要学哲学。学哲学干嘛？得到那个绝对的真理。然后以不变应万变，不就求这个东西嘛，我真的求过的。看来我有来历的，就学这空之又空的哲学。干嘛呢？要统御万物，你得到最高的科学嘛。哲学被看成是科学的科学，是不是最高。我说好！我要哲学。就像当时项羽小时候，他的伯伯叫什么名？（项梁）你好好的，学武吧，要打仗的。那项羽说：我学这干嘛？我会打仗，一人敌来了，我可以一个人干了，我要学万人敌。哦！有志向。</p>
<p>那么我当时也是这个想法了，什么经济学、社会学比较容易，咱就不学了。学哲学。怀着一个追求到绝对真理的愿望，终于发现没有！中国人把这看得很透，西方人一直在寻求绝对真理呢。后来当然绝对真理是找不到的，每找到一个绝对的，你会发现它都是相对的。终于把绝对的真理叫做上帝。</p>
<p>你看那些科学家啊，到后来都会信上帝的。牛顿也是，整个太阳系的运行，九大行星围绕着太阳做椭圆形轨道的公转。他就想第一推动力是谁给它的？上帝给它。好，终于归于神学。西方哲学是这样，所以罗素就讲，哲学的位置在哪里？哲学的每一个成果都化为什么？具体的科学。哲学不能解决的问题教给了宗教。</p>
<p>所以哲学就是在科学与宗教之间的一个中间地带。这到蛮有意思的。所以他终于承认哲学不能回答的问题交给了信仰。终于明白绝对真理是找不到的。如果还要，那就信仰吧。那么中国人不讲宗教信仰的。中国人说绝对真理向来就是找不到的，你不用找。</p>
<p>他本性中有，天命之谓性，率性之谓道，修道之谓教。《中庸》第一句话。天道下贯是为我们的人性，你本就是人，你在人性之外找真理干嘛？儒家有这个思想。佛学来了，那么中国人把它中国化了。阐述很清楚，就是<strong>去妄</strong>。所以说这个道理说清楚了。就像我们上午讲的，也是先前讲到定慧品的时候也是这样，<strong>慧</strong>跟<strong>知识</strong>不一样的，知识可以一条条讲出来的。</p>
<p>然后你就去学，比如说你学管理科学。进入MBA课程，那是一条又一条具体的管理知识。你说我要学智慧，你也需要一个老师给你一条又一条智慧，没有的。</p>
<p>智慧是什么？定之用呀。定是慧之体啊。关键是你<strong>定</strong>啊。你定，这个体一成立，<strong>慧</strong>之用马上就来了。哪有教条呀？所以我们会犯教条主义的错误，就是把智慧当教条，没有的，智慧永远不是教条。我们说涨智慧，这话说的好。怎么涨法？Accumulation叫积累。知识是积累的，由少到多，由简单到复杂。物理学第一章你搞不清楚，第三章你别看了吧？第二章就不能看了吧？要循序渐进，那叫积累知识。智慧是积累的吗？你要么有，要么没有。怎么叫有？<strong>定</strong>呀。你自然<strong>慧</strong>了。<strong>定体慧用</strong>，四个字，这功夫用在心上，不是向外求知识，根本道理，修行就这个意思。</p>
<p>修行就是修心，修心就是心定，叫心之体，体安然。那有一人走过来，你觉得和你一样，普通一个人。很快你就会感觉到大家遇到同样的处境，同样的事，突然突发事件，他不一样了。现在我们说这种叫什么气场。其实他就是定呀。不是说他知识比你多，然后他定，不是。知识说不定比你少，你知识比他多，还比他更聪明，你乱的不得了。</p>
<p>我们现在来看第9个机缘。就是那个智隍，149页上。这是一个一直在修禅宗的，所以叫他禅者。“禅者智隍，初参五祖”，他曾经去参拜弘忍法师。自信认为已经得了正受，得了这个正法。然后他就是，“庵居长坐”，就在这个庙里一直打坐。“积二十年”，这个功夫深了。又讲到这个惠能的一个弟子叫玄策，他老在外面游方啊，到了河朔这个地方，闻，人家都说那个智隍禅者了不得，听到他的名声了。造庵，去造访他，问他，问智隍：“汝在此作什么？”</p>
<p>智隍回答说：叫入定，打坐坐禅就是想入定嘛。这一话一出来就有问题了。玄策就说，汝云入定，是为有心入耶，无心入耶？一个问题就来。如果是<strong>无心</strong>入，那么一切无情草木瓦石，应合得定。它们都定了。他们无心嘛，草木瓦石都是无情之物，谈不上有心。假如你是无心入定，你就如草木瓦石一样。若<strong>有心</strong>入者，一切含情有识之流，亦应得定。不光是人啊，那动物都是有心物啊，叫<strong>有情含识</strong>。动物是不是也有六识啊，眼耳鼻舌身意。动物都能区分事物吧，猫也知道它的食物在哪里，狗也知道它的主人在哪里，都有分别识，都是<strong>有情含识</strong>。</p>
<p>那么它们也能定吗？就问这个问题，你无非<strong>有心入</strong>或<strong>无心入</strong>咯。智隍回答说，我正入定时，不见有有无之心。并没有有无之心的区分，也不是有心也不是无心，他这么回答。不见有有无之心，即是<strong>常定</strong>，你本来就定了。既没有有心入定，也没有无心入定，那么你就恒定了，何尝需要入呢？</p>
<p>“即是长定，何有出入？若有出入，即非大定。”</p>
<p>你看玄策从惠能那里学到了，问的妙，你一开口就说错话。入定，那么你就是怎么入，有心入还是无心？一个问题来了。你说既不有心也不无心，叫有无有有无心，无有不见有有无心。</p>
<p>那么你就本来就定，何须入？如果还是有出入的之分，那就非大定。这话也说的真实，我们想要入定就是说我们经常是不定的，也谈不上常定。你20年干嘛？你20年功夫，名气响的不得了，积20年坐禅的功夫，那你就常定了。那你还需出入吗？可见你20年没定过，那就这个意思。</p>
<p>玄策厉害的很，“隍无对”，智隍没办法回答了。“良久”，沉默了好长一段时间，就问了，“师嗣谁耶？”你是跟谁学的？老师是谁呀？“我师曹溪六祖”。那么智隍就问了“六祖以何为禅定”？玄策这时把他的师父的话照搬给他听，“我师所说，妙湛圆寂，体用如如，五阴”，就是五蕴，五蕴有几个名称。五蕴或五阴或五堆，土堆的堆。都是指色受想行识。“五阴本空，六尘非有”，为什么有六尘呢？眼耳鼻舌身意，对外部事物六个方面，色声香味触法，所以叫<strong>六尘</strong>。</p>
<p>五阴是我们主观的小我，本来是空的，于是外部事物的所谓真实性也是不存在的，叫“六尘非有”。这里批判了唯物主义了。我们没有主观与客观的对立，既然没有主观与客观对立，哪有出和入呢？我心起来，即有事物呈现。我不起来，它就没事。所以它起来也不影响我，我知道它是我的心造出来的。物由心造嘛，哪有不定的意思。你把外部事物当真了，然后你跟着外部事物去走，心往外面持求，那就不定了。</p>
<p>我就在诸事物中啊，诸事物离不开我的。<strong>幻由心生，相都由心生，境也由心生</strong>。这样一个意思已经明了，你如果明了这个意思，何必出入呢？“妙湛”，<strong>湛</strong>是什么？就是指的水又清又深，<strong>既清且深</strong>叫<strong>湛</strong>。禅定的境界叫“妙湛圆寂”，<strong>圆</strong>就是<strong>圆满</strong>，毫无欠缺。<strong>寂</strong>是<strong>平静</strong>，如深深的海水。一眼就能见到底，其实它很深。一眼见到底</p>
<h2 id="它是清既清且深那叫一个湛字妙湛圆寂"><a class="header" href="#它是清既清且深那叫一个湛字妙湛圆寂"><em><strong>*它是清，既清且深，那叫一个湛字。“*</strong></em><em><strong>*妙湛圆寂。”*</strong></em></a></h2>
<p>这是指描写摹状一种禅定的境界。“体用如如”，体用如如，就是如其本来。我们一直要区分的，<strong>如如</strong>相对的是<strong>如意</strong>。<strong>如意</strong>是从小我出发的愿望，想要实现叫<strong>如意</strong>。如其意，不能如意叫烦恼。不求如意，但求<strong>如如</strong>。让万事万物如其本来的呈现，不要从自己小我的意愿出发区分事物。我们心体，本是定的。它的用就是智慧。体用不分，体用如如，五蕴本空，“五阴本空，六尘非有，不出不入，不定不乱”。</p>
<p>你一定要讲个定字是因为有乱在那里。到后来定和乱都不用讲了，那叫真定。“禅性无住”，别把禅性看成是去执住（住相——离相）。住就是停留，离住禅寂，不要去执着什么。禅是一种实际的状况去执住它。离是个动词，住禅寂是一种追求，坐禅就是住禅寂就是执住于禅寂，把这个离了。“禅性无生”，要“离得生禅想”。我们知道这个需求。<strong>离住禅寂</strong>。<strong>离生禅想</strong>。许多打坐的人坐禅的人就是住禅寂生禅想。要把住禅寂和生禅想都离了，因为禅性无住，禅性无生，就这个意思。</p>
<p>“心如虚空”，第一个要讲空。第二，“亦无虚空之量”。也别去思考那个虚空。这个量不是数量的意思，也别去推论那个虚空。亦无虚空之量，什么意思？就是别执住于虚空。虚空是第一个前提，心如果不空，它就大不了。摩诃，就是大的意思。大的前提是空，第一步空，然后不要执空，不执空什么意思？它能含万物，能包含万物。不空如何大？但大是指<strong>能含万物为大</strong>，不是把什么东西都弄空了。这是前面般若品里面就讲的道理是吧？惠能曾经先后解释了三个词语，第一个叫摩诃，第二个叫般若，第三个叫波罗蜜。在解释摩诃的时候先说第一层意思，叫空。再说第二层意思叫大，大就是能含万物。但能含万物的前提先空，我们的心不空就含不了万物，这是人的通病。</p>
<p>人在这个文明的世界里面慢慢长大都会有所积累啊，有经验、有知识、有地位、有金钱，有权力，心里不空啦，这是通病。还不如小孩子空，小孩什么都没有你知道吧？然后我们长大本事多了，本事越大越以为是，心就空不了，然后就不能包容了，你就不能包容了。先把你有的东西空掉，别以为这个要紧那个要紧不得了的事情啊，其实没什么。《道德经》先告诉我们的就是这个道理，老子啊。《道德经》从来没正面告诉我们道是什么。因为道不可言说，道可道非常道，你无法正面的说道是什么。</p>
<p>所以通篇《道德经》都没告诉我们道什么，而是告诉我们道不是什么，告诉我们<strong>道不是什么</strong>，就是让我们空，就是要做减法。</p>
<p>我们在以往的生活或者工作中某一条经验非常宝贵，为什么非常宝贵？因为它可能曾经给我们带来巨大的成功，所以我们就非常珍惜这条经验，把它看成是宝贵的经验，终身奉行。他错了。你把一条只是经验的东西上升为<strong>道</strong>了。它曾经给你带来成功，它以后会给你带来失败。但老子教我们呀。所以你曾经有的知识和经验，有，但是要把它无了，这就空了。教我们道不是什么，就是叫我们做减法，别把那些只是经验和知识的东西上升到<strong>道</strong>的地位上去，不能这么做，就是这个意思。</p>
<p>所以有了道家的智慧，然后禅宗就把佛学中国化，所以将这个摩诃就解释为第一叫空，第二叫能含万物。</p>
<p>“心如虚空”讲空。“亦无虚空之量”，能包含万物。“隍闻是说”，智隍听到这样的说法他开心了，干脆去找惠能吧。“径来谒师”，惠能就问：“仁者何来？”还是这句话，从哪里来？那么智隍就把自己先前所做的事情都说了一遍。如何打坐入定20年功夫，然后玄策又怎么跟我讲的，都告诉惠能。所以玄策跟我讲的这些话，我所以来找你，这叫“具述前缘”。惠能就说了，“诚如所言”。玄策说的没错。“汝但心如虚空，不着空见”，两句话都来，一要空，二不要执着于空。叫不着空见。“应用无碍，动静无心”，动了静了你还要做一个区分，不必区分，该动就动，该静就静，其实一直是不动，一直是定，就是这个意思。</p>
<p>“动静无心，凡圣情忘”，四圣谛讲的苦集灭道，一开始要学佛法就这样。然后把它当真谛看。把它当真谛看，那就区分了俗谛。真谛俗谛第一步是区分，第二步不能区分，俗谛即真谛。担水砍柴无非妙道，达到真俗不分，这境界才到。你还在日常生活中。</p>
<p>这叫“凡圣情忘，能所俱派”。我上午讲的能和所，主观与客观的区分泯灭了。不要有主观和客观的区分。妄念的来历就是主观与客观的区分。我这个主体在哪里？在我的生活所及的所有事物上。我上午讲的自我在哪里？在你的<strong>生存场</strong>上。“能所俱泯，性相如如”，<strong>性</strong>就是<strong>本体</strong>，<strong>相</strong>就是<strong>区分</strong>，其实都是<strong>如如</strong>。“无不定时也”。汝达到这个境界，你始终在定中啦。“隍于是大悟”。有玄策前一番话跟他讲，又有后来惠能这一番话跟他讲，他终于明白了。“二十年所得心，都无影响”。20年他打坐要入定好像很有心得，全没了。</p>
<p>这听上去神话，空中居然有声音说智隍禅师今日得道。现在被称为禅师了，先前叫禅者，现在叫禅师。“隍后礼辞，复归河北，开化四众”。又回到河北，住化一方。这四众实际上就是：出家的男性叫比丘，出家的女性叫比丘尼。在家的居士，男的叫优婆塞，女的叫有优婆夷，这叫四众，这是佛教通常的说法。</p>
<p>好，这就是第9个机缘，主题就是不住禅定。住禅定就是把坐禅着了相，着了这禅定的相。不住。</p>
<p>我们在日常生活当中，无论是动还是静，无不定时，都在定中，那叫真正的禅定。所以有人后来也就诟病惠能了，你把这些坐禅的功夫都一并抹杀了。其实不是，一并抹杀，你可以去打坐，有时候也必要，但是别把打坐的形式执着了，它还是要起到一个什么？我们心定下来的这样一个作用才好。不是身体不动，是心的定，就是“见境心不乱”就可以了。见境心不乱是最最难的事情，说起来就一句话，“见境心不乱”，实在来是功夫。这就是第9个机缘，惠能让智隍开悟。</p>
<p>后面几个，第十、十一、十二都是小小的一段一段。我们来看第152页。具体的名字也没讲。某和尚，一个和尚问惠能：“黄梅意旨，甚么人得？”黄梅就是指弘忍。大家都说你是得了弘忍的衣体嘛，那么弘忍把衣服给你，肯定教了你怎么坐禅，有密法交给你吧？“甚么人得？”惠能说，“会佛法人得。和尚还得否？”僧人继续问他，你和尚得了吗？惠能居然回答说：“我不会佛法”。这个机缘就这么短，意思又让我们觉得奇怪。你惠能在曹溪住化一方，还说自己不会佛法？这怎么理解？这理解不难。</p>
<p>从两个方面看都是对的，一个方面，如果惠能会佛法，什么意思？他现在需要它。惠能还需要佛法吗？佛法都忘了。他已经在第二阶段了。护念证悟，你问我我什么都说不出来了，佛讲的真理就在我的实践中了，佛经的文字也扔掉了，修佛的所谓各种方法都不重要了，都已经去掉了，这是一层理解。会佛法就是你还得吃这个药，因为病还在。还有一层意思禅宗特别强调，修佛没有什么固定的方法。禅宗主张的自性自度，自性自度不离自心。所以这就是说明不要执着于佛法，佛法就是方便。最初我们需要它，还是《金刚经》那个的意思，<strong>无为</strong>。一切有为法，都如梦幻泡影。第10个机缘很简单，我们如果没病了，也就不需要佛法，如果惠能现在还说我会佛法，那就是惠能还需要它，这是一个。下面还来一个，叫方辩。说惠能有一天正在洗他的衣，就弘忍法师传给他的衣，但是当地这个地方没有很好的泉水，“而无美泉”。于是到寺庙的后面大概有五里路的地方，那个地方的环境非常好，“山林郁茂，瑞气盘旋，师振锡卓地，泉应手而出。”这又是神迹了。锡杖往地上一戳，泉水就涌出来了，“积以为池”。你现在到南华寺人家还会带你去参观，当初惠能就是在这里，打出这个泉水来的，然后在那里洗他的衣的。</p>
<p>因为《坛经》当中这么记载了，然后说他“跪膝淀衣石上”，这些东西都留下来了。“忽有一僧来礼拜”，自己说自己是西蜀人，在四川那里过来的。“昨于南天竺国，见达摩大师，”那就更神奇了。</p>
<p>还见到达摩了，达摩还跟他讲。他的心法已经传了，已经传到第六代了。叫我赶快到唐土，就到中国中原这一带，到中国。这个西属还跟唐土还有区分似的，然后到唐土也就是到中国。</p>
<p>“吾传大迦叶正法眼藏”，什么叫正法眼藏？我们都知道灵山法会的，禅宗的源头就是这件事情嘛。释迦摩尼在灵山说法。他不说，拈花一笑。底下许多人很惊讶，干嘛？唯有一个人，迦叶尊者会心一笑。这就是佛陀传心法给了，谁得了这个心法呢？迦叶尊者。于是这个成语就来了，叫<strong>心心相印</strong>。心心相印这个成语就来自灵山法会这样一件事情。第一次传心法，心法是无法用语言来说，所以叫心法。禅宗就是传心法的。传心法当然也可以用说话的方式，也可以不说话的方式，一个动作，都可以传给你。但是前提就是一个，得心法的人要准备好条件的。那么迦叶尊者就准备好了。</p>
<p>这样呢，迦叶尊者就很重要了。</p>
<p>这个叫 “传正法眼藏”。正法就是佛法，<strong>藏</strong>就是仓库，正法藏是什么意思？<strong>佛法的全部</strong>。但当中加一个字叫眼，眼就是<strong>直观到</strong>。不是用语言文字来表达的，叫<strong>朗照</strong>，朗照宇宙。我们向来以为佛法离不开文字的表达，传心法了。正法的全体叫<strong>正法藏</strong>。正法眼藏，你直观到。不能用文字表达。这就是释迦摩尼第一次传正法眼藏，给了迦叶。这很说明问题，禅宗了不得就了不得在这里了。不用文字的，我们要领会佛法是不假文字。它可以用文字，但它不依赖文字的。你一眼看明白了这宇宙，朗照宇宙。禅宗的这个意思后来也被宋明新儒学继承过去。程颐、程颢听说了，程颐是程颢的弟弟，他就讲这个天理是怎样的，冲漠无朕，万象森然。</p>
<p>他用了这样8个字来描述。程颐实际上是程朱理学的程。就是理学的，开理学先河的人是程颐。开心学先河的人是他的哥哥程颢。所以二程兄弟其实有区分的。</p>
<p>所以冯友兰先生后来很感慨的说，你看中国思想史上这么绝妙的一件事情。理学心学对立吧？</p>
<p>这两派的对立的源头居然是两个兄弟啊。一个程颢，一个程颐，太妙了他说。所以王阳明继承的是什么？就是继承陆象山，陆象山继承的程颢。所以程颐有许多话王阳明都要批评的，唯独这句话王阳明很赞赏，叫<strong>冲漠无朕</strong>，万象森然。天理的世界啊。这个<strong>冲漠</strong>，<strong>冲</strong>就是<strong>空</strong>啊，空而广漠。<strong>朕</strong>就是<strong>缝隙</strong>，没有缝隙。然后又是万象森然。这种东西、这种情景叫天理的世界，是不讲文字的，就这个意思。这倒是从禅宗那里过来，正法眼藏。佛法，你可以直观到的。所以用个眼字。我们信不信？这个道理我们现在中国人很难理解的，为什么？因为接受西方学问时间长了，西方的哲学西方的自然科学都来了，总是离不开概念文字的。中国思想本来认为什么？文字是在后的事情。你看中国古人写的哲学，这书其实也都是写事情的，那么道理都在里边。</p>
<p>那么中国古人就认为，他们写的东西并不给你做推论的。你读西方哲学著作你会追问这个范畴的演绎，你读黑格尔的哲学著作，一步一步严密的很啊。一个范畴推出另外一个范畴当中不能跳跃的，一个个范畴演绎下去的。那么这就是西方哲学著作，就是这么样一个写。</p>
<p>那么我们就信赖逻辑的东西。那么我们讲一个道理总是一个推论，推论按照亚里士多德叫三段论法：<strong>大前提、小前提、结论</strong>。好，那么推论的大前提来自哪里呢？可能来自另外一个推论，是另外一个推论的结论，做了这个推论的前提。</p>
<p>好，那么另外一个推论它有大前提小前提结论啊。那么那个推论的大前提又来自哪里呢？你再往前追溯，可能是再前面一个推论的结论。你总会终于追到这样一个推论，它的大前提、它的前提不再是任何推论的结果，它来自哪里？<strong>直观</strong>。我们现在相信的道理都是要有通过逻辑推论的。</p>
<p>但是我们不免要问总有这样一个推论，它的出发点不是任何推论的结果，它只能来自伟大的<strong>直觉</strong>。伟大的<strong>感悟</strong>。中国哲学著作美妙就美妙在这里。你千万别叫老子推论什么东西。老子会回答说，我所说的就是我看到的，信不信由你。你不要向我要求逻辑推论，你们以后的事情就是按照我告诉你们我看到的东西，你们再去推吧。中国哲学著作是一座伟大的宝库啊。里面直接宣布给我们的他所看到的，那叫开天眼了，我们是开不了天眼的。</p>
<p>所以我们只是跟着古人的直观到的东西自己做推论。我们的才智，我们的智慧就因此受启发，我们的知识都有来历，知识的来历最后就是哲人所看到的。西方也一样的，今天的自然科学是不是？从西方学，西方的自然科学是不是有共同的前提？是把自然状态放到数学公式里去。假如这一个自然状态不能成功的放到数学公式里面，那么我们就认为这个自然状态是不存在的。实验物理学家搞错了，成功的放到了数学公式里边，这个自然状态的奥秘就算被揭示了。自然科学的定律是不是同时都是数学公式？所以一个科学一门科学它的成熟的标志能够用数学理性。那么社会科学里面也开始模仿，也开始追求科学的典范，就像自然科学那样，我也能够量化，并且变成数学公式。那么最骄傲的一门社会科学就是经济学，经济学是社会科学当中最符合科学的，为什么？它能用数学。所以你在复旦大学考经济学院，研究生你必须考数学。它要求蛮高。要考数分，就是数学分析。否则你做什么经济学研究呢，你要建立数学模型，你看骄傲起来了，经济学因此就很骄傲，我最科学了！</p>
<p>科学的标志是西方人建立的，你不能量化的描述这个事物，不能把它放到数学的理性里边，变成个数学公式，你这事物你没认识清楚，请问这个想法哪里来？科学为什么拿这个做标准了呢？来自古希腊的毕达哥拉斯的宇宙观，毕达哥拉斯跟他同时代的其他哲学学派一样，都要追问宇宙的本源。</p>
<p>有些学派说字宙的本源是水。有些学派说宇宙的本源是气。还有说有四个根。都有种种的宇宙本源学说。唯有毕达哥拉斯说宇宙的本源是number，数。数与数之间的和谐比例的关系，不仅是人类的数学，而且是宇宙的构造。宇宙的构造本来就是符合数学的。数学不是人类认识事物的方法，不仅仅是人类认识事物的方法，而且就是宇宙的构造本身。毕达哥拉斯这么向我们宣布了，这叫数的宇宙观。没有毕达哥拉斯<strong>数</strong>的宇宙观，哪有今天我们学的西方自然科学，它都要求量化的。</p>
<p>比如说你学物理学第一步是测量。知道度量衡的规定，怎么测量长度都有规定。物理学是不是门经验科学？对。它建立在观察和实验的基础上，对不对？对。什么叫观察？观察就是测量。如果你没有测量什么，你等于什么也没，观察西方思想来了。这个思想的渊源是毕达哥拉斯数的宇宙观。然后我们向毕达哥拉斯要求证明，你如何向我们证明数是宇宙的本源，你能证明吗？毕达哥拉斯跟我们讲，我看到的就是这个。这是我看到的，我告诉你们，就这样。有了这个大前提，西方人有了毕达哥拉斯数的宇宙观的大前提，才会有今天的自然科学。量化的描述自然状态。把数学的理性不仅看作是人类的理性，而且是宇宙的构造，这件事情就是毕达哥拉斯看到的。是他的正法眼藏。你能向他要推论吗？不能。</p>
<p>所以我们就理解了什么叫正法眼藏，很厉害的。佛法，全部佛法叫正法藏。加一个字“<strong>眼”</strong>，看到的、直观到的。我们今天的人心很狭小，我们就注视着一事一物，具体的知识，具体的经验，然后我们去读古人的哲学著作那我们就累了。其实他要求我们去应和他那个直观，而不是去追问和讨论推理他那个直观。<strong>直观不是你推理的对象</strong>，是你任何推理的<strong>前提</strong>。这样我就把正法眼藏解释了一下。如果我们还不信，不信很简单，你去读呀。</p>
<p>你去读中国古代哲学典籍就看到了。你如果对西方的学问感兴趣，你比方说你去读那个谁，欧几里德的《几何原本》，《几何原本》跟我们今天写的几何学教科书根本不是一回事。欧几里德把他在几何的领域里边直观到的东西都告诉我们了。你从中体会几何学的精神。这是你获得他给我们的东西是他看到的。所以今天有点难，所以我们读《道德经》读了老半天，其实很短，就5000言，分章的就81章，每一章都短短的几段话，这几段话不得了老子告诉我们他看到的，比如说他说<strong>反者道之动</strong>，你就问为什么？你告诉我为什么反者道之动？他说没有，我告诉你我就知道这件事，我告诉你我看到的，信不信由你。你后来发现都对。什么叫<strong>反者道之动</strong>？所有的事物都变化，什么叫变化？走向自己的反面，变化就是走向自己的反面，就这个意思。你还不相信，不相信是你的事。你向我要求推理，我没有的。你就获得吧。</p>
<p>有人说这样很不讲道理。什么叫不讲道理？你要讲的道理都是以不讲道理的前提给你的，那叫伟大的<strong>直觉</strong>，intuition。这不得了。我们有了正法眼藏再去作知识，我们就会有创造性。我们没正法眼藏作知识，我们只是继承和传授知识。这个差别就在这里。所以我在复旦组织了通识教育，通识教育的核心就是阅读伟大的哲学经典。哲学经典就告诉我们，他们结论告诉我们的就是他所看到的东西，你去读吧。我们的孩子都不信这个的，他成长的过程就是符号逻辑这些东西。</p>
<p>然后我说复旦大学是什么地方？不仅是传授知识的地方，而且是创造知识的地方。</p>
<p>那么创造知识的前提是伟大的<strong>直觉</strong>、<strong>想象</strong>和<strong>感悟</strong>。用佛家的话叫<strong>正法眼藏</strong>。这要进去的，不进去不行的。你像爱因斯坦发动物理学革命。提出了相对论。那是场革命，就是把牛顿物理学的范式转换，革命就是范式转换。这种范式转换不是靠理性推论的，靠的是爱因斯坦伟大的<strong>直觉</strong>、<strong>想象</strong>和<strong>感悟</strong>。所以当他提出相对论的时候全世界只有三个半人懂。因为跟不上，什么不同时期的原理，你怎么会明白？你接受的是牛顿的东西。一场物理学革命是范式转换范式转换的前提就是直觉、想象和感悟。这些例子都很说明问题。</p>
<p>所以爱因斯坦不仅是物理学家，他有非常好的哲学思考能力，哲学思想。还有他的音乐的爱好，就是艺术，艺术保存我们的性灵，中国人有这个概念叫<strong>性灵</strong>。性格的性灵魂的灵，在文学中用，在哲学中也用。诗歌创作有性灵，公安派就是性灵，主张性灵的。超逻辑超概念，那是直觉、想象和感悟。</p>
<p>所以读中国哲学著作很开心是什么道理？它不是说纯粹的哲学理论，它同时是伟大的文学，同时还有历史在里边，叫文史哲打通。你读《庄子》，中文系老师也讲《庄子》的，那是伟大的散文。鲁迅先生说庄子的文字在战国春秋以来战国诸子没有一个人可以比得上庄子的文字。叫<strong>汪洋辟阖</strong>，<strong>仪态万方</strong>。很了得。鲁迅是有发言的吧。文学。他写《汉文学史纲要》就这么称赞庄子。那文学成就高了，巨大的想象力。<strong>汪洋辟阖，仪态万方</strong>。读《庄子》读到后来入迷了，我们要去感受一下。但它是哲学吧，就是哲学。所以中国哲学典籍很妙，它就是直观的东西，不脱离形象，但是又不是局限在有限性上，这就是了不得的。</p>
<p>这就是正法眼藏，朗照宇宙，冲漠无朕，万象森然。不讲文字，不讲概念。这个传就是第一次传，传给谁？迦叶尊者。这不得了。所以他就讲了，达摩就跟那和尚讲，“吾传大迦叶正法眼藏，及僧伽梨”。实际上就是衣啊。“见传六代”，已经到第6代了，就是六祖惠能了。“于韶州曹溪，汝去瞻礼”。你应该到那里去。方辩远来，“愿见我师传来衣钵”。我想亲眼看一看。那么惠能当然给他看。“师乃出示”。然后给他看的时候惠能问他，尊称他为上人。“上人攻何事业”？你的专长是什么？就这个意思。</p>
<p>“善塑”。我是雕塑家，我的能干就是能做雕塑。惠能非常认真跟他讲，叫“正色曰：汝试塑看”。你弄个雕塑给我看看。好。这下子因为他如此认真严肃，方辩就不知道怎么回事叫“罔措”，不知该怎么回答他，当然也就去做了这件事。</p>
<p>几天之后把雕塑做好了，做的谁的雕塑？惠能的。“塑就真相，可高七寸，曲尽其妙”。就是栩栩如生，非常逼真。把惠能的塑像做出来了。给惠能看了惠能就笑了，“汝只解塑性，不解佛性。”佛有相吗？佛其实无相。当然你有本事也承认。你知道怎么雕塑，你还不明白什么叫佛性。</p>
<p>没关系，对佛教事业做贡献的人有种种。有的人有这个专长，有的人有那个专长，方辩也算一个。所以为他摩顶。“舒手摩方辩顶”，跟他讲了句话，“永为人天福田”。这个暗示他什么？</p>
<p>你将来就为佛教多做庙宇的建设，佛像的塑造，这也算是福田。这里就到这里结束了，后来历史上表明方辩是这样做的。这个人也有来历的，所以知道这里的寺庙以后会被战争破坏，破坏了以后方辩来重建庙宇，又把佛像做好。这就是方辩在佛教事业中的贡献。需要。所以方辩又成了一个代称。所有为佛教做寺庙的建设和塑像的塑造的人都是方辩。方辩通过惠能那里，知道了自己的使命。</p>
<p>然后最后一个，有一个和尚来找惠能跟他讲，有一个叫卧轮禅师的。此人有一个偈句作得好，念给了惠能听。卧轮禅师自己这么说自己的，“卧轮有伎俩，能断百思想。对境心不起，菩提日日长”。认为自己境界可以了吧？</p>
<p>作为禅师的人能达到，坐禅能达到如此的境界不得了。“能断百思想”的，外境怎么变化我心都不动的。对境心不起，我的觉悟是每天都在提高。叫菩提就是觉悟了，日日长。好，这首偈句念给了惠能听，惠能听了。说了“此偈未明心地，若依此而行之，是加系缚”。束缚了。然后他给出他自己的偈句，“惠能没伎俩，不断百思想。对境心数起，菩提作么长？”这有点像当初针对神秀，完全是跟他唱反调的。</p>
<p>你有伎俩好，我没使俩。你断百思想，我不断。你对境心不起，我对境就心起来了。菩提，怎么长？这句话也很妙。你要么觉悟了，要么没觉悟。觉悟不是知识的增多，由少到多积累起来，哪有这种事情。要么觉悟，要么没觉悟，所以它有什么长呢？我从少一点到多一点，没这种事情。不要怕心动，不要怕心起念，心当然要起念。你念都不能起心就死掉了，叫绝念，绝念嘛就是死。</p>
<p>“前念不生即心，后念不灭即佛”。心怎么好不动？这个道理已经是知道的事情了。对境心数起，对。境来了心会动，但心不要跟着外境走。跟着外境走叫乱了，心数起不等于心乱。日本鬼子冲进来打了，你说我心不动，你来吧。不，抗战！这有什么话好讲，心当然起来了。</p>
<p>所以这是惠能的偈句，告诉我们不要怕念头起来，也不要怕烦恼来了，烦恼来了正是觉悟的好机会，叫<strong>烦恼即菩提</strong>。你说你修到烦恼都没了，怎么可能？你要能够<strong>住烦恼而不乱</strong>。你就在烦恼里，但是心没乱。你冬天冷的要死没衣服穿的是吧？再这样下去要冻死了。烦恼来了吧？来了你就谋衣吧，但不要乱。一乱你就是偷人家衣服去了，你谋衣于正道就对了。所以我们别害怕烦恼，也别拒绝烦恼。后面又讲这个道理了，就是那个谁来？皇帝派来的一个太监叫薛简。我们看看就知道了。第182页。薛简是个太监，来叫惠能到北面去，惠能谢绝了，说身体不好，那么这个薛简说我也不能白来一趟，你能不能讲一些话，我传给皇帝。那么就问问题了，182页倒数第7行。薛简就问了，“明喻智慧，暗喻烦恼”，光明就是智慧，黑暗就是烦恼。“修道之人，倘不以智慧照破烦恼，无始生死，凭何出离？”</p>
<p>怎么出离生死苦海呢？惠能回答说，“烦恼即是菩提”，<strong>无二无别</strong>。别把烦恼跟菩提区分开来。“若以智慧照破烦恼”，这种见解叫二乘见解。“羊鹿等机”。声闻乘的人就是羊拉的车子，缘觉乘的人叫鹿拉的车子，这境界比较低，“”上智大根，悉不如是”。那么如何是大乘的见解呢？“明与无明，凡夫见二。智者了达，其性无二。无二之性，即是实性。实性者，处凡愚而不减，在贤圣而不增。”我们都有的佛性就是实性，凡人愚人那里并没有少了佛性，圣人贤人那里也没增加佛性。“住烦恼而不乱，居禅定而不寂。”这两句话很好。</p>
<p>不要去拒绝烦恼，我们的本质是在烦恼中没乱，叫住烦恼而不乱，这话就很到位了。人生总是烦恼不断，但是心没乱过。肚子饿得要死，你要做盗粮谋真没办法了。你说我没饭吃也可以好，怎么可能？天道让我们有个胃，肚子饿了就得吃嘛，不吃嘛就饿死了，那就去谋吧。烦恼当然在，但是心不乱。一乱就不对了，鸡鸣狗盗之辈就来了，无非是这样。所以这就是惠能机缘品第12个机缘一个道理。它针对的什么？卧轮禅师的偈句，来了他自己的。好，我们明天将进入后面三品。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="顿悟品"><a class="header" href="#顿悟品">顿悟品</a></h1>
<p>我们昨天把《坛经》的第七品机缘品讲完了，在机缘品里面一共讲了十二个机缘。我们特别关注的是两位禅师，一位是行思，一位是怀让。这两位禅师的重要性就是从他们两位禅师后面衍生出顿教就是禅宗南宗的五个支脉。行思和怀让都是悟了的人，他们是到惠能这里来印证，后来得到了印可。</p>
<p>在行思、怀让之后的第八个机缘讲永嘉玄觉，这是非常精彩的一段对话。非常典型的表现了禅宗祖师的参禅和机锋，这个思想内容也特别重要。特别是玄觉最后讲的分别亦非意。我们在这世界上总是要分别事物，分别事物就是关于世界上事物的知识，知识是不可少的。但是不应、不能因为知识的缘故而着了分别相。我们呈现在知识本身之中的话，我们就离开智能很远。不是不要知识，而是不要让知识遮蔽了智慧。</p>
<p>所以第八个机缘蛮重要的。永嘉的重要性就在于他对坐禅作了他明确的说法。行亦禅坐亦禅，语默动静体安然。他后来有一首《证道歌》，也非常的流行，影响了许多参禅的人。后面几个机缘，每一个机缘讲一层意思。第十个机缘就是讲佛法是药，用来治病，药到病除。不需要抓住佛法不放，所以惠能回答那个和尚的提问，他是这么说的，我不会佛法。第十一个机缘就是讲对佛教做贡献的另一类人。他们可以去建造庙宇，可以去说雕塑佛像。这些事情也是重要的，惠能也充分的承认。这个人叫方辩，所以惠能为他摩顶，说他永为人天福田。</p>
<p>最后一个机缘就是讲烦恼就菩提的意思。我们不需要这样的来追求禅定，这种禅定达到一种境界，断了百思想，什么念头都没有，这种追求是虚幻的。我们只要活在人世间，我们总是面对各种各样的烦恼，个人的烦恼可以舍弃，民族和国家的烦恼你也无法避免。</p>
<p>比方说抗日战争，整个中华民族陷入烦恼之中，你不能不承认。那么在惠能看来，烦恼跟菩提，烦恼跟觉悟，不是两件不同的东西，是<strong>一体</strong>的。这是很高的很高明的认识。**人世间若无烦恼，要智慧干嘛？**不要害怕烦恼，不要拒绝的烦恼。我们正是在烦恼中有了觉悟，所以他说他自己是对境心数起，这是他针对卧轮禅师的偈句写而念出来的自己的偈句，这样就结束了机缘品。</p>
<p>我们今天就进入顿渐品。《坛经》第八品顿渐品。</p>
<p>从这个标题我们就看得出来，其实就是讨论禅宗当中北宗和南宗之间的关系。北宗领袖神秀，主张渐悟。南宗领袖惠能，主张顿悟。一个渐一个顿。我们常人容易接受神秀的说法，我们不断的积累，慢慢的悟起来，也许终于有一天大彻大悟。它是一个积累的过程。而惠能偏要说，要么没悟，要么悟了。悟只在一刹那之间，这叫顿悟。渐悟和顿悟的这种区分。</p>
<p>所以北派的禅宗就是北宗，其实被称为渐教，惠能的禅宗被称为顿教。这个教门有区分，第八品就讲这个主题。通过三个人，一个是神秀底下的弟子，叫志诚这个人。神秀把他派到南面，让他去听惠能说法，听完了以后记下来，回来告诉自己。又提到一个人，是北面的神秀的弟子，想要害了惠能，派了一个刺客叫张行昌到南面来刺杀惠能。第三个人就是曾经在神秀手下修了没有结果，年纪非常轻的僧人叫神会。他也从北面到南面来了。顿渐品就讲这三个人如何跟惠能交流，我们把这本书翻到156页，顿渐品第八。顿渐品第一段先交代了当时的局面。神秀当时在湖北一个叫玉泉寺，住化一方。惠能在曹溪宝林寺。所以《坛经》里面说，“于时，当时两宗盛化”。北宗和南宗影响力都很大。“人皆称为南能北秀”，南面的惠能北面的神秀，“南能北秀，故有南北二宗顿渐之分”。</p>
<p>在那儿学佛的人，学禅宗的人摸不着头脑了。不知道应该跟随哪一宗，是跟随北宗好还是跟随南宗好，这叫“莫知宗趣”，趣就是去向方向。惠能当时对这个情况就做了一个解释。</p>
<p>他跟周围的人讲，“法本一宗，人有南北。”佛法没什么南北的。“法即一种，见有迟疾”。对佛法的领会因人而异，有的快有的慢。</p>
<p>“何名顿渐？法无顿渐”，佛法没有什么顿或渐。“人有利钝，故名顿渐。”有的人根器好，有的人根器不好。这叫根器不好叫钝，根器好叫利。就像弘忍法师当初听到惠能这么回答，人“有南北之分，佛性本无南北。”他就明白惠能这个人根器大利。根器就是慧根，我们智慧的根。佛教相信在这一点上人有区别。大多数人恐怕属于小根之人，少数人是上根之人，比方说惠能就是上根之人。智慧的根是在前世乃至再前世种下来的，所以佛教就说我们智慧来自前世，过去世。所以这个智慧叫<strong>宿慧</strong>。用现代科学的观点不能接受。我们真的有前世吗？但是生活中许多的事实说明，说明了宿慧这个概念是能够成立的。有的人并没有经历很多的事情，生活还比较简单，但是年纪并不大，或者非常年少，每每对生活有一种洞察，有一种超出常人的感悟。但千万别把它理解为智商。智商也有区别，生物学可以证明是遗传所得。但是慧根不是智商，因为慧根之用不是用作知识，不是聪明伶俐。而是<strong>从现实事物当中发现超越现实的东西</strong>，它跟知识没关系。</p>
<p>当然关于这个话题可说的话很多。第一什么叫智慧？第二宿慧是否真实？《红楼梦》就是非常清楚，塑造一个人物叫惜春。她就是慧根深啊。惜春也没经历什么大不了的事，生长于富贵之家，没有什么坎坷磨难。《红楼梦》当中总说她还小呢，年幼。就向往佛教，跟妙玉很谈得来，不喜欢诗词歌赋，对人间的爱爱恨恨不感兴趣，也从来没有恋爱过。所以王国维先生后来评价惜春，这个人叫天然神明！其实就讲的宿慧好，慧根深。</p>
<p>终于后来还是出家了。我们出家与否，其实这事情也不是由个人所决定的。有的人年幼就想出家，父母也不知道怎么回事，你干嘛要出家？不是家里养不活你，这种现象都有。那么佛教就说宿慧。这个观念。所以人有差别。佛教不讨论智商的高低，讨论的是慧根的深浅。像我们小根之人总需要大善知识，来开导我们。而惠能居然只听到人家在念经，听到8个字，“因无所住而生其心”。心即开悟。所以这就是惠能讲这个人有利钝。</p>
<p>好，我们再看。神秀本人倒是非常非常佩服和尊重惠能的。但它底下的弟子们不是这样。“然秀之徒众，往往讥南宗祖师”。讥讽。说这个人，“不识一字，有何所长？”有什么本事呢？字都不识。神秀就跟他们讲，“他得无师之智，”说他是无师自通“深悟上乘，吾不如也。”</p>
<p>其实说话也说的不对。惠能不是无师自通的，他有师是弘忍。他虽然是上根之人，也需要弘忍法师为他开悟。他虽然自己作出来了偈句，弘忍法师见到了，仍然说了一句话，“亦未见本性”。惠能说，“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。”周围的人看境界很高，弘忍法师仍然说他“亦未见本性”，就差最后一个环节。</p>
<p>所以后来弘忍法师就给他讲《金刚经》了。讲到了“因无所住而生其心”，惠能悟了。所以这一步也少不了。惠能后来说的话都是很有道理。他说我的智慧不是我自己生长出来的，是先圣所传。以往的圣人传过来的。这话又说对了。我们今天的人的智慧都不是自己生出来，都是对古代智慧的传承。</p>
<p>所以“他得无师之智”，这话说得不恰当。“深悟上乘”，固然如此。然后说他自己不如惠能。“且吾师五祖”，我的师父弘忍。“亲传衣法”。把衣法是给了惠能的。“岂徒然哉？”我们的师父不会莫名其妙做这样的事吧？“吾恨不能远去亲近”。神秀的意思，我很想亲近惠能就在他左右听他说法吧，但是没办法走不了。</p>
<p>“虚受国恩”。朝廷供养着神秀。“汝等诸人毋滞于此。”你们不要停留在我这里。“可往曹溪参决。”</p>
<p>有一天他就找了他的一个弟子叫志诚的人。跟他讲，“汝聪明多智，可为吾到曹溪听法。”你可以代我去听。“若有所闻，尽心记取，还为吾说。”有所悟你就记在心里，回头告诉我。志诚就带着这样一个使命这样一个任务去了，来到了曹溪。混在众人当中，“随众参请”。也不把自己的来历说出来，但是惠能已经知道有人来了。</p>
<p>当时。“时祖师告众曰，今有盗法之人，潜在此会。”惠能这种话就要把他激出来是吧？有人在这里盗法呢，潜伏在这里。这样一说志诚必须出来。“即出礼拜，具陈其事。”把自己的怎么会到曹溪来的事情讲了一遍。“汝从玉泉来，应是细作。”你不就是间谍吗？这又是激他的话。志诚说“不是。何得不是？未说即是，说了不是。”这话说得好。表明志诚这个人真是如他师父讲的聪明多智。这句话一语双关，表面上是说这件事，我不把自己的身份说出来，那么我就是细作，就是来盗法的了。我说了就不是嘛。</p>
<p>表面上是这层意思，其实这句话又是向来禅宗讲的一层意思，什么意思呢？一旦我们领会了领悟了佛法，我们达到了悟这个境界，是没办法说的。你领悟了道，你怎么说呢？一说就不是。“未说即是，说了不是。”不可言说。一个人悟的时候是没办法说的，悟之前会说很多话，禅宗不是说不说话，禅宗说很多话，但说话是为了达到不可说。</p>
<p>就比方说我们要攀登城楼，要用梯子爬上去。我们把这个语言比喻为攀登城楼的梯子，我们终于爬到城楼顶上了，还要这个梯子干嘛？这个梯子就撤了，也就是说不说话了，不需要语言了。这叫至言去言。最高的言说就是不说话。</p>
<p>禅宗祖师跟人说话的全部目的就是要把你逼到不可说那一边。就在这一刻心法才传过去的，心法是不可言说的。所以释迦摩尼是拈花一笑。悟的时候什么都说不上来，“未说即是”。一说就不对了，“说了不是。”它表明了禅宗这种智慧。禅宗认为智慧的最高境界，超出语言叫<strong>言语道断</strong>。到了对道的领会就把言语给断了，叫<strong>言语道断</strong>。</p>
<p>禅宗的这个思想后来广为的流传在中国。所以“未说即是说了不是”差不多变成口头禅了。你去跟懂禅宗的人，你问他这个道理，他怎么推脱？“未说即是说了不是，”所以我不说。这叫口头禅。但本来禅宗是这层意思。不过有人拿来推脱做托词吧？也有。那就叫口头禅。关于这个问题，中西方都有讨论。就是语言究竞是帮助了我们，还是妨碍了我们？我们人类跟语言的关系。西方人后来知道中国的禅宗就觉得非常惊叹，把人类语言的本性说出来了。语言只是一种手段，一种道路，通向最高的领悟的必经的路，那么走到了这个路的终端，语言就结束了。</p>
<p>所以有西方人就认为禅宗不仅是中国人的智慧，而且是人类所能有的最高的智慧。而且他居然是通过语言来达到的。通过语言之路终于达到不可说。那么西方人达到不可说那一刻，他们还在努力，还要继续说。主要的办法就创造新词，创造新的词语，继续坚持在语言的道路上。比方说20世纪德国哲学家海德格尔，他也知道东方这个思想禅宗的思想，但是他认为不能不说，继续说。</p>
<p>那么如果海德格尔遇到中国真正的禅宗祖师，中国禅宗祖师就是跟他笑一笑。你又傻掉了是吧？这就是一个蛮有意思的哲学问题。不是说语言终于不能表达我们内心深处最基础层面那个如弗洛伊德讲的无意识里，不是这个意思。无意识当然也不可言说，不是这个意思。</p>
<p>我们那些微妙的心理状态无法用语言表达，不是这个意思。而是一种就像我们昨天讲的正法眼藏，那种对宇宙的真相的领悟，确实不在文字里的，叫眼睛的眼就是直观到。</p>
<p>禅宗认为这个境界是真实存在的，你这里还用语言，再度把它遮蔽啊？所以海德格尔也知道这个道理，海德格尔说语言是对存在的，是存在的“既澄明名又遮蔽着的到来”。对存在的领会总是要有语言来说，但是语言说的时候在澄明存在的同时又遮蔽它另一面，既澄明又遮蔽，这是蛮高明的。所以虽然中西哲学有差别，但是伟大的思想家在一个更高的层面上他们相通了。</p>
<p>维特根斯坦我们听说过，英国的哲学家。本来就在语言上做功夫的，他要发明一种人工语言来解决哲学上争论不休的问题。他发现大多数哲学上争论不休的问题都是因为彼此说的概念不一样的其实，用词是一个，所指是不一样的，所以我们就发生莫名其妙的争论。</p>
<p>我们能否先做一件事情？我们先确认我们用这些词语所指的东西是共同认同的那个东西，然后再开始说话，那叫人工语言。他的努力后来失败了，他终于明白语言不是这个东西。他说语言是<strong>生活方式</strong>，那么不同民族的生活方式是不一样的，所以不同民族在思想的层面上交流会发生严重障碍，他认为这很正常。至于我们要说到思想最高的层面的时候，维德根斯坦还是说了这句话，对于不可言说的东西，我们只能沉默。那么这一点他就达到了禅宗的意思了。禅宗被西方人认为是静默的哲学。</p>
<p>静默的哲学，所以禅宗影响很大，对西方也有很大的影响，只是他们很难进入。做一个说明，所以志诚那句话说得很妙，这句话一说出来，惠能就知道此人也是根器大利的人。</p>
<p>“未说即是，说了不是。”一语双关。所以惠能底下就直截了当问他了，你的师傅如何跟大众们说佛法呢，“汝师若为示众？”那是怎样的教。</p>
<p>周围的回答说，“常指海大众，住心观静，长坐不卧。”首先要教大家什么啊？打坐、坐禅，住心就心定下来，“长坐不卧”。惠能的回答很有意思了，“住心观静，是病非禅。”这是病，怎么是禅呢？毫不客气。“长坐拘身，于理何益？”你老是坐着不动，拘束着自己的身体，与这个佛理的领会有什么好处呢？“听吾偈”，我说一个偈句你听。“生来坐不卧，死去卧不坐；一具臭骨头，何为立功课？”这是非常尖刻的话了。你打坐就常坐不卧了了，你不就是在自己这个臭骨头上的立功课吗？学佛是这功课在身体上吗？所以惠能说话不客气，要破这种弊端就得彻底的破。</p>
<p>好，我们翻过来看啊，实际上这句话已经对自己的影响很大了，只是没想到会这样的评价神秀的坐禅。</p>
<p>“弟子在秀大师处，学道九年，不得契悟。”还真没悟过。“经闻和尚一说，便契本心。”你这话说到我心里了。“弟子生死事大，和尚大慈，更为教实。”那就很恳切了。是人生死是大，我也是啊。学佛就是为了解决这件生死的事情，佛以一大事因缘而出世。。释迦摩尼来到人世间就为这件大事情来的，什么事情呢**？了生死**。</p>
<p>所以禅宗总讲这句话叫大事因缘。什么叫大事因缘？就<strong>了生死</strong>这件事。每个人都在此大事因缘中，有生就有死，很快你就明白到会有死的。几岁上发现这一点不知道，突然发现自己必有一死。问题就来了，谁都躲不了的问题，这叫大事因缘。所以志诚这里就非常恳切了，“弟子生死事大，和尚慈悲”，能不能为我说开示呢？</p>
<p>惠能说：“吾闻汝师教示学人戒定慧法”，我听说了，你们的师傅呀跟人家讲，如何戒定慧。佛法那么多最高的概括——戒定慧，或再高一点叫止观，叫戒定慧法。</p>
<p>不知道为什么？“汝师说戒定慧行相如何？”究竟怎么具体指点戒定慧的呢？这个行相是具体的，做法是什么？</p>
<p>“与吾说看。”你说来我听听。</p>
<p>“秀大师说：诸恶莫作名为戒，诸善奉行名为慧，自净其意名为定。”分别解说了戒慧定。</p>
<p>这话说的好不好呢？我们一看说得很好，有什么问题呢？他不是把戒，简单的规定为我们不能做什么，不能做这个不能那个，不能喝酒，不能杀生，不能偷盗或者其他一大堆了。这个真正的比丘要具得戒叫具足戒，那就100多种了。神秀可不是具体的说，具体的戒律是什么，而是说诸恶莫作。</p>
<p><strong>慧</strong>是什么呢？慧就是行善啊，诸善奉行的，这话也讲得对。我们切勿把智慧看成是技巧，过人的技巧叫智慧不是的，智慧跟大悲悯的心是统一的。一个人能行善是因为它悲悯嘛，大悲悯等于大智慧了。所以神秀这句话又说对了，“诸善奉行名为慧”。</p>
<p>什么叫<strong>定</strong>呢？<strong>自净其意</strong>，又是从意上入手的，也对啊。</p>
<p>志诚就问他了，神秀是这么说的，你和尚呢，是用什么方法来教我们戒定慧呢？“以何法诲人？”</p>
<p>惠能说：“吾若言有法与人”，如果我跟你讲我有佛法交给别人的话，那就是在骗你。“即为汝。但且随方解缚，假名三昧。”我其实是什么？因时因地因人而异的去交流一下，帮助别人解脱束缚。借用了名相，比如说三昧，这些都是名相，“汝师所说戒定慧，实不可思议”，这话厉害了。</p>
<p>刚才我们已经说这个神秀的这三句话，说得很好，我们确实觉得蛮好的。你看我们现在寺庙，你到外面去参观，中国的寺庙每每墙上有这样八个字吧，“诸恶莫作，众善奉行”。你看原来就是神秀的意思，都写在墙上的，多好的意思啊。惠能居然说他不可思议。想想看为什么？你要戒什么？不能做恶，什么叫是你的智<strong>慧</strong>？<strong>行善</strong>。什么叫你的<strong>定</strong>？<strong>心里干净</strong>。很好啊，惠能偏偏说说他不可思议，为什么？志诚也觉得奇怪了，惠能说“吾所见戒定慧又别。”跟他不一样。“只能说戒定慧只合一种，如何更别？”怎么还会有什么区别呢？</p>
<p>志成的疑惑就是我们的疑惑，但是我们不妨再想一想，你看这个寺院的外墙上书写八个字，人人都看到，“诸恶莫作，众善奉行”吧，有用吗？我们都知道这八个字，不是照样的作恶吗？照样的不行善吗？为什么？</p>
<p>这个我记得我昨天讲，你看神秀的原来偈句和惠能针对他的偈句，我们看到了后来的两个人，一个叫朱熹，一个叫阳明。我们完全可以说阳明就是儒家中的惠能呀。那么因此我们也可以，当然未必很恰当，朱熹是禅宗中神秀。朱熹讲我们要明白天理啊，要把天理说出来，让广大百姓都认识到，然后我们就解决问题了，心中之贼就破了。那么八个字老是书写在庙宇的墙上，为什么没用？根源在哪里？</p>
<p>神秀说的话没错，但是不及根源。善与恶的标准在哪里？你只是说应该行善，你只是说不能作恶，那么我还是不知道恶的与善的区分，你没说出来。还有行善的根源，作恶的根源又在哪里？也没说出来，说了等于没说。</p>
<p>我们中国人都知道孝，儒家讲孝，对父母的孝，天下的中国人都知道，照样把父母告到法庭上去。儿女父母对簿于公堂，他们难道不知道孝之理吗？是不是这个问题？你说应当孝你什么意思？朱熹和阳明的区分，就真正程朱理学和陆王心学的区分就是两个命题的对立一—一个叫<strong>性即理</strong>，一个叫<strong>心即理</strong>，我们以后读传习录要讨论这个问题的。</p>
<p>究竞程朱理学和陆王心学的对立在哪里？就是两个命题的对立。“天命之谓性，率性之谓道，修道之谓教”，中庸这句话程朱和陆王都有讨论——《中庸》的第一句话。那么这性——<strong>人性</strong>，当然事物有物性，人性也罢，物性也罢，都是天命规定的。天命规定了这种物种叫狗，那么狗性不变，那种物种叫猫，那么猫性不变，那种物种叫人，那么人性不变，那么天理都在性里面，所以你去认识他，性格特点，那心的位置在哪里？</p>
<p>那么朱熹当然知道心喽。心的位置就是认识性当中包含着理——就认识。然后陆王反对性即理，反对性即这个命题，提出心即理，为什么？当中有一个环节，性即心，于是心即理，是这样一个环节，很关键。程朱并没有认为性即心，按照陆王就陆象山、王阳明你把心拿掉进入人性，所以禅宗其实是启发陆王心学。心即佛是吧？叫即心即佛，离开心不要谈佛性。就好像对儒家的语言来说呢，离开心不要讲人性，心即性，性即心。这个区分就这么来了。我们了解了这一点，所以就知道为什么惠能讲神秀这三句话不可思议。</p>
<p>**善恶的标准在我心里呀，不是你把善与恶的对立写出来就解决问题的。**我们都搞不清楚标准了嘛。这个时代在变化，社会环境在发生巨大的变化，曾经认为是善的变成了恶的了，曾经认为是恶的变成善的了，还一直变下去呢。这庄子就启发我们了，“彼亦一是非，此亦一是非”，怎么办？所以神秀的三句话没解决任何问题，所以就要看惠能怎么说。惠能先跟他说。你们的师傅的戒定慧的说法是接大乘人的。大乘人已经蛮好了——境界啊。就知道把自己的生命实践要符合善。</p>
<p>我这个戒定慧，他说：“吾戒定慧接最上乘人，悟解不同，见有迟疾。汝听吾说，与彼同否？”现在你就听我说，看看跟他有什么不一样。</p>
<p>“吾所说法，不离自性”，自性就是自本性。</p>
<p>“离体说法，名为相说”，离开我们的心之本体来说佛法那叫——相说，概念多得不得了。昨天我讲名相多！</p>
<p>你看丁福宝的《佛学大词典》这么厚的，只是密密麻麻的条码多的不得了一—这叫相说。</p>
<p>“自性常迷”，自性还是你的。</p>
<p>“须知一切万法，皆从自性起用”，自性就是佛性，就是自本性或自本心，都从这里说，这叫“真戒定慧法，听吾偈”。我来一个偈句，“心地无非自性戒，心地无痴自性慧，心地无乱自性定，不增不减自金刚，身去身来本三昧。”</p>
<p>这三昧我们曾经说明过是吧？实际上有两个汉字来音译，梵文的单词是‘samadhi'，‘samadhi’是一种精神状况。高度凝聚的、专心致志的、心无旁骛的，就这种描述吧，说这种状态叫<strong>三昧</strong>，其实怎么描述都还没到位，所以当时我们中国人也就用声音来翻译了。这个三不是数量词的‘samadhi’的<strong>三昧</strong>。后来我们曾经做过说明，各位还记得吗？什么叫<strong>三昧</strong>？怎样一种状况。你做这件事的时候，你并没有这件事情之间的区分，你是做事的主体，那个事情是客体，正是你正在做的东西——这种主客二分就不是<strong>三昧</strong>。你做此事，你就是这件事情本身，这叫<strong>三昧</strong>状态。<strong>你没有你自己跟所做的事件的区分</strong>，这是最好的状态。</p>
<p>我曾经举过例子，一个艺术家创作艺术作品的时候，一开始没有进入三昧。没进入三昧之前，艺术家在创作的时候他蛮痛苦的。他始终有自己作为一个创作者和那个被创作的作品之间的分离嘛，于是在那里探索的，艰苦的很啊，艰难的很啊。但是这些都是准备阶段，终于进入三昧，创作者与作品之间融为一体，西方的用那个词来表达这个状况叫什么？Inspiration，灵感。翻译成灵感也是不很恰当，实际上应该翻译成<strong>三昧</strong>。这才对了。当时一开始也没办法翻，就用声音来翻的叫“烟士披里纯“一一音译。近代中国翻译西方著作遇到inspiration，找不到合适的汉语的词——“烟士披里纯”，人家真不知道在说什么，中国近代文人这时候翻译就这么做，后来终于找到两个汉字叫灵感，其实也不是很恰当。如果用三昧到是对的，但三昧又是外来语，又是音译梵文，你还是不行。所以尴尬了，那么把它解释一下就明白了。一个人做一件事情要做到很好的境界的话，这个作品是很了不起的作品，一定要经过——<strong>三昧</strong>，你做事者跟所做事融为一体。这个东西一旦出来就仿佛天成，浑然天成，第二自然没有任何造作人工的痕迹呀，没有的了，艺术作品要经过这个阶段才行。那么禅宗说人生就应该这样——<strong>三昧</strong>。其实不光是创作艺术了，做什么事情都这样，要做出境界来就要三昧。</p>
<p>我写学术论文也是这样的。你一开始很累的，到后来觉得自己文思泉涌，不可遏制，就写下去了，不能干扰的，谁在干扰我的时候这时你在做坏事，我进入三昧了，那个作品就要出来了。写理论文章都会这样的，你除非这篇理论文章通篇拾人牙慧的，没有任何创建的，但凡有创造性的，这个工作一定要进入创造性工作，一定要有一个三昧状态的，先前的努力都是为三昧的到来做准备的。这样我们就解释了<strong>三昧</strong>。</p>
<p>好我们看他怎么讲戒，惠能怎么说戒？我们究竟该戒什么？你举举例，你好多呢，没什么意思。从自性中入手讲，叫“心地无非”，这就是结论。这个“心地无非”是什么呢？当然要结合前面的讨论，心地什么叫非？什么叫无非？<strong>心地之非</strong>就是<strong>我执</strong>。但凡修禅宗总知道要<strong>去我执</strong>的。你我执去不了，心地一定非。这是根源上说话，什么事情不该做？什么事情一定不能做这个事？叫戒律。具体的事情不能做，哪些具体的事情不能做，你可以举出好多呢，关键是你为什么会去做？为什么会去做不该做的事呢？因为心地有非呀，什么叫心地有非呢——<strong>我执</strong>，就很清楚。什么叫<strong>戒</strong>？<strong>心地无非</strong>！</p>
<p>什么叫<strong>慧</strong>？—<strong>心地无痴</strong>，痴是什么呢？贪嗔痴的痴，我们概括为物执或者说法执吧，法是指广义的啊，万事万物，事物就叫法，万事万物叫万法。你执着了那就痴了。并不是一定是某一个物体，当然也可以包含物体。你就是喜欢那个东西，这个收藏石头。石头收藏好了就不能被人拿走是吧？这也是法执的一种。或者执着某种情境、某种事情都是法执，痴就是这个意思。说心地无痴自然就慧。你看到了事物的虚妄不实，停止对事物的贪恋——叫<strong>心地无痴</strong>，那就<strong>慧</strong>了。你<strong>心地无痴</strong>，停止对事物的贪恋，你哪里会做坏事呢？不会做坏事，你自然是行善的。所以从根源上说，从心地上说。</p>
<p>然后再讲一个定，神秀说要干净，什么叫干净和肮脏？你又搞不清楚了，我这个念头是不干净的念头，那个念头是干净的念头，谁给你立一个标准？自净其意都不知道怎么净他的？还是惠能说的根本，“心地无乱”，那就定了呀。非常典型的反映了惠能说佛法的原则，不离自性，不离自性，不要离开自性来说戒定慧。如果离开自性说戒定慧说了等于没说。禅宗就是心学，不是理学，你光说那个理嘛就理学，要把你说到心上去，心学，这样就明了了。</p>
<p>志诚听到这样的几句，“悔谢”，他非常激动了，感慨了。自己成了一个偈句了，叫“五蕴幻身”，五蕴就是我们假的心是吧，色受想行识，我们的色身体是幻的，五蕴幻身。“幻何究竟”，换到什么时候才结束呢。</p>
<p>“<strong>回趣</strong>”，趣就是趣向，兴趣的趣的这个意思，趣向的趣就是趣向的意思，回过来吧。</p>
<p>“回趣真如”，真就是不假，如就是不倒，那叫真如。天地万物都能倒，风吹山相近，那叫地震，都会倒心不倒的。心体不倒，那叫真如。我们上海有个庙叫真如寺。“法还不净，回趣真如”，你说许多佛法这道理还不干净，回头看看，太有意思了。这表明志诚真是领会了。</p>
<p>他说的这个偈句惠能表示同意的，“师然之。复语诚曰：‘汝师戒定慧，劝小根智人，吾戒定慧，劝大根智人’。”小根智人讲讲神秀的话也就差不多。先引上一条行善的路吧，究竟怎么后面还得修行，那么小根智人就这么慢嘛。我的话是给大根智人说，一说即通了。“若悟自性，亦不立菩提涅槃，亦不立解脱知见”，什么名相都不要列了。</p>
<p>我大概在这里讲过一个公案，有一个和尚问禅宗祖师本善的问题是吧？因为学佛都要有这样三个事情了——第一：<strong>解脱</strong>，第二：<strong>追求西方净土</strong>，第三：要<strong>达到涅槃</strong>。</p>
<p>好，一个问题来了，如何是解脱？禅宗祖师不正面回答反问的。“谁缚？”谁把你束缚住了？“如何是净土？”他也不正面回答，反问。“谁垢？”谁把你弄肮脏了。再问“如何是涅槃？”他也反问他，“谁将生死于汝？”谁把生和死的区别给了你。三问三反问一—一个禅宗公案。</p>
<p>“如何是解脱？”“谁缚汝？”反问了。“如何是净土？”“谁垢汝？”“如何是涅槃？”“谁将生死与汝？”</p>
<p>好了，那个人言下大悟。这个公案是很典型的不离自性的。我们要解脱，那么我们倒反过来问谁束缚了你呢？不就自己的心束缚了嘛。你要追求净土，那么谁把你弄脏了呢？这个世界把你弄脏了吗？世界本来就脏吗？没有，是你自己的心。你要涅繁达到不生不死，那么就解脱生死的区分了，消解生死的区分。那么消解的就是你自己的心对生与死的区分，你贪生怕死还不是你的那个心么？你什么时候不贪生怕死不就涅槃了嘛。你要知道你所贪之生也是梦幻而已，你怕的死并不是死寂。你不贪亦不怕是吧？那不就自己涅槃了嘛。所以这个很有意思的，禅宗公案。跟这里惠能说佛法是一样的。</p>
<p>所以上根智人一听嘛就通了，所以也就不列名相了，什么菩提涅槃，什么解脱之见，“无一法可得，方能建立万法。若解此意，亦名佛身，亦名菩提涅槃，亦名解脱知见。”如果你领会了这一层境界，你可以给他名身，什么佛身也罢，什么菩提涅槃也罢，什么解脱知见都可以用啊，<strong>名相</strong>才能上去嘛。</p>
<p>“见性之人，立亦得，不立亦得。”即可以立名相亦可以不立名相，这有意思啊。见性之人不会说话，什么名相都没不清楚，你跟他说佛家的概念，他一个都听不懂，你别小看他，他见性之人，有的人是佛教的概念说得滚瓜烂熟的。他没见性。有什么用？<strong>佛法不在口上争</strong>啊。</p>
<p>“去来自由，无滞无碍。”“应语随答，普见化身，不离自性。”“自在神通，游戏三昧，是名见性。”<strong>游戏</strong>不能做贬义词看，在三昧当中自由自在，这叫见性。所以《坛经》是了不起的。</p>
<p>因为惠能不识字是个必要的前提。不识字的人就不会执着明相。实际是个很重要的前提。那么后来我们的体会就是惠能必须不识字，使命规定的。他识字还了得？识字的话佛学就不能中国化。因为佛学中国化的前提，就让佛学的思想深入上每一个中国人的心，那就叫中国化。不是在少数文人那里理解，这叫什么中国化？马克思主义中国化也是这样的。我们像我王德峰研究马哲的，是吧？我们少数几个知识分子能完成的马克思主义中国化吗？完成不了的。要让马克思学说的思想，深入每一个中国老百姓的内心，那叫马克思主义中国化，我在复旦就一直讲这个道理，不是少数文人圈子里的事情，习大大拍个论文，那么我们获得了研究经费，然后去做中国化，这很荒谬。他们说需要怎么做，向惠能学习。惠能怎么佛学中国化的就知道了。所以毛主席评价《坛经》是一部人民群众的佛经，对了。所以他说什么“应语随答”。他不需要名相你问到哪里答到哪里吧。不束缚于这个佛教的概念。那么，文人在旁边听到惠能说，比如说惠能随时随地回答，文人一看，哎呦，说错了，又说错，什么错了？不符合概念。这时文人傻了。惠能没傻，文人着了概念的名相。所谓随答就是这个意思。你就让那些研究几十年的佛学的学者，你问他一些佛法的问题，他能做到应语随答吗？据我的了解基本都做不到的。他马上把那个问题转化为一个什么佛学上的概念然后拿给你解释。你就这个概念到明白了，你的问题还没有解决。你的问题是真实的他用概念来处理那个问题。那就奇怪了，不过每每就这个毛病。所以要破文字执。知识分子最方便的事情是拿概念来回答你很真切的问题是吧？然后你被他概念吓坏了。</p>
<p>你就搬着他给你的概念走了。我是在知识分子群体中的，但是，我最痛恨的这种知识分子。当然了，他们也不能怪他们是法达嘛。先前的法达没有达法嘛。所以惠能说佛法生动活泼。“随与应答。不立名相”，然后你给他名相，他也不怕是吧？一听明白了，然后就把那些名相的本义说一说。“立亦得，不立亦得。”</p>
<p>志诚再问惠能，“如何是不立义？”又为什么不要把那个佛理佛法的这个义，用概念有明显立起来啊，为什么不立的？回答了“自性无非、无痴、无乱，念念般若观照，”注意观照，后来美学上用这个概念。西方美学也用这个，中国人用汉字翻译的观照。观照什么？超概念的，你这概念说是不能观照什么东西的。概念就是概括的事情，用思维用逻辑概括，那就离开观照很远了。正法眼藏这个眼就是观照。我们说审美观照是吧？我们审美的时候，有概念起作用吗？没概念起作用的。有概念起作用就没办法审美的。一幅画画，挂在里面去，名画——《梵高的向日葵》，然后你觉得不美。因为我奇怪，这画怎么是世界名画呢？边上有个专家跟你讲，这画是怎么画的。他的在绘画的印象派的历史上，他的技法是什么什么，你听完了懂啦。概念多吧？一连串的绘画的概念给你了，然后你再看这个向日葵，你觉得还美了吗？还是没觉得它美，但你口中不敢说。哦对对对，了不起，了不起，仍然没觉得它美。一幅艺术作品的艺术价值是无法用概念来说明的。我说给你一整套概念，你仍没觉得它是美的，<strong>美是观照</strong>。之所以你无法观照因为你的<strong>性灵</strong>被压抑的。用佛家里面叫<strong>妙性</strong>，这个妙性被压抑，你怎么观照？性名是什么？<strong>直觉，向善，感悟</strong>。都是<strong>超概念，超逻辑</strong>。所以这个禅宗就讲<strong>观照</strong>啊。</p>
<p>“念念般若观照，常离法相，自由自在，纵横尽得，有何可立？自性自悟，顿悟顿修，亦无渐次，所以不立一切法。诸法寂灭，”各种佛法你都把它扔掉了。“有何次第？”有什么循序渐进的次序呢？</p>
<p>我们昨天不是讲那个机缘，就是那个行思来见惠能了。行思来见惠能。第一句话就问惠能，我如何去修才能不落阶级吧。不落到某一个次第上去。以何为法不落阶级？惠能反过来问他，你本来自修什么的，是吧？“圣谛尚不为，何阶级之有？”惠能就很赞同他，“深器之。”</p>
<p>这里又讲 “有何次第？”再度说明了顿教、顿悟。我们总觉得顿悟不大可信，渐悟才比较可靠。这是不理解悟这件事情本身。<strong>悟是无所得</strong>，先明白这一点，认知是有所得。你学物理，学一条一条物理学定理，你都要理解它，就叫认知活动。每一次都有收获有所的，<strong>悟是无所得</strong>的，为什么悟是无所得？悟是我们的<strong>心灵跟虚无契合</strong>。跟虚无契合有什么得的呢？无所得的事情如何积累呢？认识活动是不是有所得啊？那当然积累咯，由得之少到得之多。由知之少到知之更多，不就是积累了吗？<strong>悟没有得的</strong>。他如何积累。他就是<strong>顿悟</strong>。要么没悟，要么悟。怎么悟？自见本性。<strong>自见本性</strong>并不是有所得而是把那些遮蔽全去掉了。豁然契合了。一下子的事情，这一下子的事情是<strong>心</strong>。不是你的偷来的，是你的性提升了。假如性即理的话，我们认识天理，朱熹讲的就是性即理。积累还很漫长的，叫致物穷理。王阳明一度相信的朱熹的，所以去认真实践一一格物。最著名的叫格竹子，还格了七天七夜的，他要及物出理。格出一身的病。在神秀身上，我们看到的将来的朱熹。</p>
<p>在这个惠能在那里，我们看到将来的阳明。于是文化大革命当中，有一句话就非常有意思，很恰当的说出了悟是什么？<strong>灵魂深处爆发革命</strong>。虽然是文革的政治用，实在是禅宗精神的表达。中国人没有禅宗的智慧，说不出这样的话。至于这句话派在政治上用处，是当时那个时代，我们不去管，真正的顿悟，顿悟一定是蹦，那叫爆发。一定是革命，叫生命情感的升华。一定是心灵的事情绝不是头脑的事情，那叫灵魂深处。三层意思都有了。讲来讲去这个悟啊，真是很难用语言表达啊。为悟之前和之后的区分是什么？简要的说，叫<strong>人生态度的改变</strong>。别无其他。那么，人生态度的改变是什么？什么态度？不是认识啊。不是对人生的认知的改变。如果是对人生认知的改变，我们又到程朱理学哪里去了。不是知那个理了。所以<strong>人生态度是对生命的情感的改变</strong>。你以往的喜怒哀乐，悟了之后的喜怒哀乐。不一样。悟了之后，照样有喜怒哀乐，否则是无情，如同草木瓦石了。对生命情感的转弯。人生态度就是生命情感。往日之所喜不再是今日之所喜。往日之所哀，不再是今日之所哀。大概能说到就是这个份上。仍然的，也就是这件事。困难就是这件事情，认识没什么难的。从知之不多到知之较多，这有什么难？改变人生态度才叫难了。那么人生态度的改变的难，当然有那个习性起作用。要对付这个累世累积的习性真难，正在因为这个习性在种子识里的，阿赖耶识，就带着以往的业力叫种子识，来了嘛，要对付他。所以，失败的多。在悟这件事失败的多，成功的少，于是就有一个退步，退让一步说，我们要修好几次，就这个意思，这一次修不成了，积累一点儿，下一次在这一次的基础上继续，这一个退一步的说法惠能恐怕也是能接受，就是说小根之人嘛，那他认为，应该是上根之人那就顿悟啊。所以，这都有个让步的，确实有个让步。除非我们不把超脱生死轮回当件事情，那就不必修行，只要修福的就可以了。所以这是一个choice。（选择）</p>
<p>学佛的人嘛，两类：一类求福德。<strong>修福德求福报</strong>，还有一类是<strong>修功德求解脱</strong>。哪个choice？你选择吧。佛教的好处是什么？大多数人虽然不修功德修福德也好，对社会生活好。大家比较太平一点。每个人都想到要多修修福吧，那么冲突就少。所以，执政党不要害怕佛教。佛教好事情。说完这些话之后呢 “志成礼拜。愿为执侍，朝夕不懈。”从此就不到北面去了。始终追随惠能左右。这是顿渐品的第一个人。叫志诚，后来就有更厉害的，来了，那叫刺客，张行昌。</p>
<p>这个顿渐品里边其实有三个机缘。机缘品有十二个机缘，顿渐品，其实又有三个机缘。第一个机缘，刚才我们已经讲了，就是志诚。神秀把他派到南面来找惠能。要听惠能说佛法，后来有一番对话。志诚大受启发也就不回北面。始终追随于惠能左右。</p>
<p>第二个机缘来了。我们看166页。一个叫志彻的，法号志彻。后来出家之后的法号。江西人，俗名张行昌。“少任侠，”这个行侠仗义之人。所以南北分化，弘忍法师，两个最重要的弟子，一个惠能，一个神秀，南北分化——二宗旨，也就是神秀和惠能。这两个人彼此倒是不分彼我的，并不说彼此要对立，这个亡就是消失。就是不分彼我，就没有宗派的这个对立。“二宗主虽亡彼我，而徒侣竞起爱憎。”他们的弟子彼此之间就有一个对抗，对抗的态度。其实，不光是神秀底下的弟子是这样，惠能底下的弟子其实也这样。所以我们刚才课间休息讨论到这个事情啊，这个中国寺庙历史上许多的出家人跟在家人没什么区别。都是有要宗派的对立，然后求的是世俗的利益，纷争不已，直到今天。当时你看弘忍法师，是在那个黄梅县东禅寺里边，其实环境也非常险恶吧，其实弘忍法师心里很明白，所以他要到舂米房里去见舂米的惠能叫“祖潜至碓坊”。坛经里用了个<strong>潜</strong>字，潜伏的“潜”。弘忍法师要去见这个惠能，要偷偷地溜进去的要避人耳目，这就是当时寺庙。今天其实也是这样，我们多少都知道一点。所以他当时的这个南北，北宗和南宗的弟子都彼此有对抗。</p>
<p>“时，北宗门人，自立秀师为第六祖，”虽然衣没有传给神秀，但神秀的弟子们还是把他封为第六祖，禅宗第六祖。</p>
<p>但是，最难过的是衣钵不在他们的师傅那里，倒是在惠能那里。而”忌祖师传衣为天下闻”，天下人都知道，弘忍的衣钵是传给了惠能而不是神秀。这件事情让他们很难过，为什么难过？牵扯到实际利益。神秀现在倒是真的朝廷供养着，他自己说叫“虚受国恩。”神秀走的时候，弟子们当了百姓。如果神秀确实是第六祖，那么衣钵也在神秀那里。他们当然就可以传承了。这个禅宗的谱系就可以写下去，他们的地位就不可撼动。这个佛门里边还追求富贵。所以，他们就派了一个叫张行昌的人。来刺杀惠能。</p>
<p>167页上第二段，就讲“师心通”，心通就是他心通。六种神通之一，我们看这个注释啊，哪六种神通？注释3，心通就是他心通。又有一个名称叫致他心通，是六通之一，其他的五种神通：天眼通，天耳通，宿命通，神足通，也有称为神境通，境界的境，神境通。漏尽通。漏就是烦恼的别名。对一切烦恼都消失了，叫漏尽，漏尽通。具体每一种神通的体现是什么我也不是很清楚。</p>
<p>这个天眼通、天耳通完全可以理解的。空间的距离，对他们来说是不存在的。在某地发生的事，有天眼通、天耳通的这个人在这里就明白。宿命通当然应当有的，知道自己本来面目，也能看出别人的面目。他心通就是别人心里想什么，还没说呢你已经知道了，这就叫他心通。有人告诉我，确实碰到过这样的人，几个人在一起吃饭，其中有一个就有他心通。就跟那几个人还没说话，他说你在想什么我知道，你真知道吗？说说看，你在想这个事情吗？是的。去显示一下他的神通。他心通。这个神通怎么来？密宗是最清楚的，怎么修成功是吧？密宗的目标就是修神通的。当然密宗之前应该修显宗的。</p>
<p>显宗就是佛教的教义啊！要立一个境界就，叫显和密，显就是显现出来的显。显宗修好了才修密宗才对，否则你有了神通可能用来做坏事。先显后密才是对的。那么，也有人有神通，未必六种神通都具备，突然之间由于某种缘故，突然有了某种神通，这种事情在生活中也会发生，甚至于我，我听说的一个人，是我的好朋友告诉我，这个好朋友的好朋友，有一次出了车祸。头撞了一下，撞到蛮厉害，后来也没什么事，哎，有神通了，他自己也不知道怎么来的？</p>
<p>所以，这个事情很神秘但真实。这宿命通很多了，很清楚了。这个《坛经》里边也讲得多，你比方说，弘忍法师跟那个惠能讲啊，你现在拿着衣钵赶快逃吧，这里你命不可久留，命若悬丝呢，然后跟惠能分手的时候，跟他讲三年之后，我就走啦。弘忍法师知道三年之后，自己要圆寂的，这些都是宿命通。这三年之后的事，他知道。那么也跟惠能讲的，他将来的归宿啊。这就是宿命通，惠能自己也知道他什么时候走，后面我们今天会读到咐嘱品，怎么安排好自己的后事。然后还预言多少，六年之后，就有人来取我的首级。到时候你们别害了他。他是孝子。为了奉养母亲。人家许了他的钱，这他都知道。这就宿命通。那么我们当然无法理解。因为科学昌明的时代，科学无法说明这件事。科学不能说的事太多了。科学不能说的不等于他不存在，例子太多。所以这个不是宣扬迷信。我曾经在这里讲过龙华寺一个九十几岁老和尚，就这么预先告诉弟子要走了。弟子还慌了，通报了宗教局了。是不是把他送到医院里去？后来才有更大的宗教局领导说就不能做这个事的，要尊重佛教徒的。他自己要走了，你怎么把他送到医院里插各种管子啊？还了得，这种事情都是真实的。说这个惠能有他心通，所以在南面的惠能已经知道北面有这件事情要来了。预做准备，把十两金子放在座间案几上等他来。那时候真来了。</p>
<p>那一天“夜暮”，张“行昌入祖室”，到了宝林寺的方丈室里面去了。“将欲加害”，他带了一把剑来了。惠能居然是“舒颈就之”，你砍吧。“行昌挥刃者三”，砍了3下。</p>
<p>“悉无所损。”一点影响都没有，这下倒把张行昌吓坏了。</p>
<p>惠能说“正剑不邪，邪剑不正。只负汝金，不负汝命。”我只欠你的金子不欠你的命，你可以把黄金拿走。这时候行昌吓坏了，竟然一时昏厥过去。</p>
<p>“久而方苏”，后来才醒过来，他就求，哀求，“求哀悔过，即愿出家。”你有什么话要说的，现在没话好说了，马上皈依吧。</p>
<p>“师遂与金”，惠能当时没马上接受他做弟子，为什么？这里很危险，你也得跑。惠能心里明白的很，他底下的弟子也在斗呢，所以这个跟他讲，“汝且去，恐徒众翻害于汝。”这里也有人要害你，如果知道你这么一件事情来的，他们也害你，赶快逃吧。</p>
<p>“汝可他日易形而来”，你以后要改衣服穿了以后再过来，不要让别人认出你。</p>
<p>“吾当摄受。”到时候我会接受你做弟子的。“行昌禀旨宵遁”，连夜就跑了。</p>
<p>“后投僧出家”，到后来倒真出家了。</p>
<p>“具戒精进。”守具足戒，修行精进得很。这就是张行昌。</p>
<p>一天，他突然想起来了，惠能叫他来的。“忆师之言，远来礼觐。师曰：‘吾久念汝，汝何来晚？’”惠能还想念着他呢，你怎么这么晚才来。所以这个佛家看人啦。张行昌不就是一个行凶的人嘛。惠能有慧眼的，知道这个不一般。这种人肯定有根器的嘛？这不知道怎么看出来啊，所以会想念他。你怎么这么晚才来的。</p>
<p>“昨”，就是以前，往昔，“蒙和尚舍罪，今虽出家苦行，终难报德，其惟传法度生乎。”大概只有一件事能报答你了，就是传佛法度众生。</p>
<p>“弟子常览《涅槃经》，未晓常无常义。乞和尚慈悲，略为解说。”他带着问题来了。那么这个机缘来了。他说他自己，张行昌说他自己出家之后经常要读那个《涅槃经》。《涅槃经》讲涅槃境界。那么涅槃是常啊，常就是不朽。无常就是速朽，世界上的事物都无常。那么涅槃的境界是常，常就是不朽咯，他要问，不朽和速朽的含义。</p>
<p>“乞和尚慈悲，略为解说。”惠能就说了“无常者，即佛性也。”，这话说的奇怪的。“有常者，即一切善恶诸法分别心也”。我们一定是觉得有问题了。佛性倒变成无常了，这个“一切善恶诸法分别心”倒变成不朽的了，叫有常，这怎么理解的？所以张行昌马上说的，你刚才说的话叫“大违经文”啊？跟《涅槃经》的经文刚好说反了，说倒了。</p>
<p>我们通常都说佛性是常，是吧？人间万事万物，包括我们这个假的心，分别心都是无常。你怎么倒过来说就是这个意思。“师曰：‘吾传佛心印’”，禅宗又叫佛心宗。传的是心印。这个印很重要，是吧？有印有心印。</p>
<p>“安敢违于佛经”，我怎么敢违背佛经呢？</p>
<p>那么这个张行昌就说，经说佛性是常。和尚却说无常。善恶诸法，乃至菩提心，皆是无常，和尚却言是常；此即相违，令学人转加疑惑。这个疑惑我们一样有了。《涅槃经》惠能讲，因为惠能不识字，他曾经听人念过，听谁呢？听那个在家修行的尼姑无尽藏。就刘志略的家里的这个姑妈嘛，我们知道前面有一段。无尽藏读一遍《涅槃经》，惠能就在旁边听了一遍。而且还为无尽藏解说过。</p>
<p>“吾昔听尼无尽藏读诵一遍，便为讲说，无一字一义不合经文。乃至为汝，终无二说。”今天我跟你说，也跟先前的无尽藏说不会改变啊。张行昌说，“学人识量浅昧”，我的认识的境界很浅，“愿和尚委曲开示。”好，惠能就开示了。给他开示了。</p>
<p>“汝知否？佛性若常，更说什么善恶诸法、乃至穷劫无有一人发菩提心者？”。你看，天下，到今天，为什么老是没有人真正的发菩提心呢？如果佛性不朽，怎么人世间还有那么多善恶诸法呢？</p>
<p>这话题已经开始启发我们了。第一，佛性不能脱离现实世界吧？这个我们曾经讲过僧肇这个人写了《宝藏论》，各位还记得，我提到说一个人来到一个仓库，这个仓库里堆满了各种金器。金戒指，金项链，金碗、金筷子等等那叫器，说这个人来到这个仓库里所看看到是常观金体，不睹众相。然后虽睹众相。他当然能分别戒指和项链的区分了。这叫睹众相，虽睹众相，亦是一金。他看到的，还是金子本身呢？僧肇拿这个做比喻。把佛性比如为金体，金子本身在哪里呢？总在各种金器里的。佛性在哪里呢？总在各种事物当中。你能把金子本身单独拿出来吗？拿不出来。金子要么以金项链的方式存在，要么以金戒指的方式存在，要么以金碗、金筷子、金调羹的方式存在。总是种种的金器。但是，那个人来看到的确实金子本身。那么这个比喻啊，《宝藏论》的比喻非常重要，说明了两个道理，第一个道理佛性并不离开人世间单独存在，就像金子本身不可能脱离金器单独存在，这是第一个道理；第二个道理，观看到金子本身的可不是我们通常的眼睛吧。通常的眼睛所看到的，只能是不同的器。看到了戒指和项链的区分。要看到金子本身可不是我们通常的视觉。</p>
<p>常观金体的这个观者是谁？这个问题好啊。不是我们的前五识吧。也不是第六识，意识吧。<strong>意识是分别识</strong>。能观到金体的，一定是我们的心。也就是说，能看到佛性的，一定是<strong>心</strong>。我们通常的五官感觉区分是看到杯子就是杯子，看到桌子就是桌子那个，杯子就是不同于桌子。那么杯子是明相，桌子也是明相，我们给他们的区分给了他的相。但是如果我们用心去观的，那就不一样了，我们摆脱了相。看到了不同的事物都共有的佛性。不同的金器都同时是金子。观就是心，所以即心即佛。你把心拿掉哪有佛性被你领会到了？这个《宝藏论》两层含义都清楚，所以惠能说“佛法在世间，不离世间觉，离世觅菩提”，离开人世间的生活去寻求觉悟，“恰如求兔角。”就好像你很荒谬的想要让兔子长出两个角来。很通俗的话。好我们理解了这一点，我们自然能理解惠能为什么好倒过来说，说“佛性无常”。就佛性总在无常的事物中。如果佛性脱离无常的事物，它单独存在，那么你怎么理解这个人世间总是善善恶恶呢。所以这个道理啊，太有意思了。</p>
<p>我们知道司马迁在《史记》当中有一篇《货殖列传》，司马迁在《货殖列传》讲天下的人都为名利而奋斗的。天下熙熙皆为利来，天下攘攘皆为利往，利来利往。千年之前的司马迁说了这句话，今天这个世界改变了没有？依然如此。将来恐怕也如此。这个人群熙熙攘攘，都无常的，佛性就在其中的。否则，你就不能解释这个世间为什么老这样啊。而且你把佛性跟这个现实世界脱离开来，就误解了佛性。在这个善善恶恶利来利往的世界上佛性就在其中的。于是要说佛性无常。因为无常的事物都体现佛性的，你别把它拒绝了。这个世界真不好。你看直到今天还利来利往的，你看不惯。看不惯嘛，就是弃世而去，这不对的！你别看不惯，将来也会这样的。你不要厌世，只不过你不参与而已，这就是你的境界。你别看不惯别人熙熙攘攘的，你别去指责啊！这没什么好指责的。<strong>佛不责世</strong>的。不要去谴责这个世界。你谴责也没用。你也活在此世界中，活在此世界中。只是你领会佛性，你心看到佛性，你就可以了。然后你就不参与这种利益的争斗，但你不去要骂别人，你们怎么这么干，将来、过去如此，现在还这样，就这么回事。你就在这个世界中修吧——人间佛教。惠能看来是用心良苦，就怕这个张行昌读《涅槃经》读到最后坚持与两者的对立，一个常佛性一个无常世界，两者分离开的，对立起来。为了避免他这种对立的理解，偏偏倒过来说。所以，人世间的善善恶恶倒是常，佛性倒是无常一一倒过来说。所以“故吾说无常”，最后一行，167页，“故吾说无常，正是佛说真常之道也。又，一切诸法若无常者，即物物皆有自性，容受生死，而真常性有不遍之处。”你必须说万事万物都经常都不断要出现的。所以它常，此事物就是此事物，彼事物就是彼事物。当然它轮受生死，它生生灭灭。你必须说它总是这样的生生灭灭的，产生了又消失了。你不能说他们不存在。</p>
<p>“故吾说常者，正是佛说真无常之义。”加一个<strong>真</strong>字，就是常与无常如果对立的话，都不是真常和真无常的，这<strong>两者不对立才有真常，真无常</strong>。</p>
<p>底下就更进一步来说，这层意思，“佛比为凡夫外道执于邪常”，这是一种情况，就是我们凡夫不领会佛理的，都“执与邪常”。</p>
<p>“诸二乘人于常计无常”，第二类人的是什么境界呢？叫二乘人，哪二乘人呢？一为声闻乘，二为缘觉乘，合起来叫二乘人，跟凡夫有区别。</p>
<p>现在有两类人，凡夫、外道，我们这些凡夫俗子，情况是什么？叫“执于邪常”，什么叫邪常？我们看一看，这个“执于邪常”什么意思？为什么再加上“二乘人于常计无常”，共成八种颠倒？那么先说前面的凡夫的四种颠倒，再加上“二乘人”的四种颠倒，合起来一共是八种颠倒。</p>
<p>我们活在现实世界中，那么就是生生死死，生生死死当中的我净四种：“常、乐、我、净”，在生死的世界里边，“常、乐、我、净”都应该加<strong>无</strong>的。一种是<strong>涅槃</strong>，一种叫<strong>生死</strong>，我们<strong>生死</strong>就是<strong>此岸</strong>，<strong>涅槃</strong>就是<strong>彼岸</strong>，是吧？我们在现实世界中叫在生死界中，此岸，那么应该是“无常、无乐、无我、无净”才对。万事万物都无常，快乐很快的变成苦，我会消失，干净会变成肮脏，“无常、无乐、无我、无净”，但是凡夫用一定会把“无常、无乐、无我、无净”，择为 “常、乐、我、净”，就把无字拿掉，把本无常的无乐的无我无净的择定为常乐，这叫<strong>凡夫</strong>，这叫凡夫的四种颠倒，<strong>四倒</strong>，这什么意思呢？是我们不想离开这个世界，这世界中本是“无常、无乐、无我、无净”的，却一定要择定为“常、乐、我、净”，凡夫就如此，不想离开这世界。再用红楼梦当中的那个甄士隐的散曲来说，其中有一句话叫 “反认他乡为故乡”，这就<strong>凡夫</strong>、<strong>四倒</strong>。他们把现实世界看成是真实的，其实是 “无常、无乐、无我、无净”，他们一定颠倒的择定为 “常、乐、我、净”，这个世界真是，用甄士隐的话叫反认他乡为故乡，这就凡夫的四倒。</p>
<p>那么比凡夫境界高的人叫“二乘人”，那么他领会涅槃了，那么涅槃是“不朽”了，彼岸喽，“常、乐、我、净”，他把涅槃这个境界中的“常、乐、我、净”择定为 “无常、无乐、无我、无净”，什么意思呢？反认故乡为“死常”。这种“不朽”是寂灭，永远的空寂，里边没什么快乐，把“常、乐、我、净”择定为“无常、无乐、无我、无净”，就把涅槃境界择定为彻底的空寂，这就是“二乘人”的四倒，四种颠倒，合起来叫八倒。</p>
<p>凡夫反认他乡为故乡，我们只是这个世界的匆匆的过客，但是我们不想走，这里应当是“常、乐、我、净”，其实是“无常、无乐、无我、无净”。那么，“二乘人”领会到涅繁境界，那么涅槃境界是什么？倒是“常、乐、我、净”，但是他忘了，他把“常、乐、我、净”，这个快乐、干净、我啊，都给他干掉了，没了，叫永远的寂灭，那就是把“常、乐、我、净”择定为 “无常、无乐、无我、无净”，涅槃就是这样一种状况，这叫翻做苦相，反认故乡为“死常”。凡夫是反认他乡为故乡，那么故乡有了，好，“二乘人”知道故乡就是涅槃，结果涅槃变成“死常”，这就是“二乘人”的四种颠倒。</p>
<p>惠能说，“故于涅槃了义教中”，最终的最高的佛法的意义叫“了义教”，要按照涅槃了义教来“破彼偏见”，而显说“真常真乐真我真净”，在涅槃境界中才是 “真常真乐真我真净”，“真常真乐真我真净”并不是把涅槃跟生死的此岸隔离开来，昨天我们就讲了，涅槃并不是一个跟现实世界分离的另外一个世界，不朽就在当下，净土就在目前，这才叫“真常真乐真我真净”。“汝今依言背义”，你跟着《涅槃经》的文字走，却不能明白《涅槃经》讲的“真常真乐真我真净”，你这个叫“以断灭无常，及确定死常”。</p>
<p>实际上就张行昌读《涅槃经》读到的是“二乘人”的境界，就择定了涅槃才是“常、乐、我、净”，但这个“常、乐、我、净”，结果又是“死常”，没有快乐，没有干净，没有、什么都没了，这叫“死常”。</p>
<p>“错解佛之圆妙最后微言，纵览千遍，有何所益？”你读《涅槃经》读一千遍也没什么好处，也对你没什么帮助。</p>
<p>行昌豁然大悟，说偈曰：“因守无常心，佛说有常性”，就是说我的心本来是无常的，我守着无常的心，心去喽，他还没有解，把这个心变成什么常的东西，有不朽的，我们的心是不在时间中的，在时间中的心叫过去心、现在心、未来心，那叫无常、无常心，所以《金刚经》里说“过去心不可得，现在心不可得，未来心不可得。”我们平时就守住自己过去、现在、未来的心，这叫<strong>无常心</strong>。</p>
<p>所以张行昌认识到了，自己还是守着无常心，佛说有常性，就我的心跟佛的无常，就佛性是无常当中隔开来了，即心即佛，你这个心要是摆脱无常心你才能领会佛性的心之体常。所以他领会佛性之常，无常心如何领会、常知佛性呢？不朽的佛性呢？“不知方便者，犹春池拾砾”，他也知道这个典故讲池水是吧？有一块宝石掉进去了，人们就纷纷跳到池水里去捞那块宝石，结果大家跳进去捞宝石，把水弄浑了，捡起来的全是什么？不是宝石，是瓦砾，这叫“春池拾砾”。“春池拾砾”是拿来比喻抓住经文不放，来解释文字，把经文的境界弄浑了。“春池拾砾”专门来批评，那些佛学的学者靠解释经文来说佛法的，你也去解释它，他也去解释佛经，大家一起去解释佛经，就好像大家一起跳到水池子里面捞宝石一样，结果解释的越多，佛经的经义越被弄混淆了，就像大家跳进去捞宝石把水弄浑了一样。“春池拾砾”，如果你拿这个典故来批评某些佛学的学者，他一定明白你在说我，说他什么。所以他现在张行昌认为自己也把《涅槃经》搞浑了，如“春池拾砾”一般。所以惠能知道他一定会浑，所以干脆倒过来说让他不浑，佛性叫无常，世上诸事务叫常，不是倒着说吗？倒着说才会让张行昌明白佛经的妙义不在文字里面，那叫 “圆妙微言”，所以他做了自己的偈句了，“我今不施功，佛性而现前；”，而先前必须努力的拼命的去解释经文的文字，这拼命的努力叫施功，我不施功，佛性自然在眼前。“非师相授予，我亦无所得。”，如果不是你惠能这样的教我，我读《涅槃经》无所得，惠能认可他了。“汝今彻也，”你大彻大悟了，“宜名志彻”，所以给你一个合适的法号：志彻。“彻礼谢而退。”</p>
<p>这一个机缘说了一个道理，破了许多人学佛的人的所谓邪见，追求涅槃什么意思？不是脱离现实世界。我们过完自己在这现实世界中的一生，然后终于到涅槃境界去了，错了！强调的就是<strong>当下涅槃</strong>！这是关键！</p>
<p>所以说这世界常啊，反过来说佛性无常，让我们知道<strong>当下涅槃</strong>。就是为了说明这一点，不要区分我们当下和未来的涅槃。这个道理在哲学上是蛮有意思的。我们把人生今生今世看成是通向涅槃的旅途，走完了旅途终于达到涅槃，这倒是像基督教的思想。基督教就认为人生，人类的在这个世界上生活，通向天国的旅途。所以人世间没什么意思的。基督教的信仰就这样，人世间是什么？它的意义等于零。我们在这个世界上走一遭是通向天国的一个短暂的旅途，最后我们经受末日审判，灵魂终于到了天国，永远跟上帝在一起。那么这用佛教的话，就是一种 “二乘人”的境界，区分了现实与将来的涅槃，涅槃在基督教里叫天国，这种区分是不对的！现实世界的价值不等于零，他常啊！佛性就在其中。用简单的话说，出世而后入世，你不能出世不入世的，出世和入世的统一，这是“二乘人”没想到的。这又是佛学中国化的一个典型的方面。</p>
<p>所以学佛不是说让我们马上把这个世界扔掉，那么佛学变成教我们自杀的学问。我们要活得更好，在根本上热爱生活。我们平时并不热爱生活，我们自以为热爱生活，我们无非贪恋着这个世界上的名和利，这叫热爱生活吗？我们奔走了一辈子，因为前面有东西等着我们，我们不断的追逐，前面有利，名和利、社会地位和富贵等着我们追逐，我们都没有注意到今天的天空是那么的晴朗，路边的花草是那么的芳香，我们没感受到过，我们往前面奔，奔了一辈子，你能说这叫热爱生活吗？</p>
<p>佛教才让我们真正的热爱生活，热爱生活的真谛，这叫出世和入世的统一。你未出过世你不可能真正热爱生活，你这是被自己小我的欲望所驱动。我们在路上行走，我们注意到了路边的花草的芳香，感受到了今天天空特别的晴朗、阳光明媚，感受到了没有呢？没有，我们就奔了一辈子。如惠能前面的《无相颂》里讲的叫“波波度一生，到头还自懊”，死到临头了，才觉得自己虚度了一生，怎么会虚度的了？忙得很，忙什么？忙那些不应该追求的东西，因为那叫<strong>谋虚逐妄</strong>。你把这个世界上的事情都看成彻底的虚幻，那么你又错了。生活本是非常美好，“二乘人”的错误就是这种颠倒，所以要跟张行昌说这番话。</p>
<p>我们觉得阳光明媚不重要，花草的芳香也不重要，前面有要追求的目标才重要，但永远追求不完的。后来叔本华深有体会，你看这个德国哲学家他读了佛经，然后他居然是这么说的。他这样比喻人生的，他说我们就好像一匹马，或者一条狗吧，有人在我们的背上附了一根竹竿，竹竿的前头吊了块肉，那么这个狗是不知道这个肉实际上是跟它的身体连在一起的那个竹竿前端的东西，他就往肉奔吧，这个肉永远在他的前方。就这样奔了一辈子，叔本华很有想象力的，佛陀的学问对他的启发，他就写出这样的话说，我们就准备好了，一根竹竿前面吊了一块肉，总在你的前面，你就啪……跑，一辈子跑完了，结束了。</p>
<p>叔本华的散文是很值得看的，写得真好。这里边都有哲理的。我们中国有中印本的，叔本华的散文集，散文学一一赏心悦目。这个人很潇洒，他的文字是很潇洒的，他大受佛学启发才写这些话。那么这就是我们看到了张行昌大悟之后的偈句的，就我们跟佛经的关系，佛经的经文所表达的道理，我们要活看不能死看。常与无常截然二分不对了。中国思想就讲究一个活看，不要执着于文字。所以他说“我今不施功，佛性而现前”。</p>
<p>那么下面还有第3个呢，在顿渐品里面就讲到神会来了。我们翻到174页，很年轻的神会才13岁呀。他从神秀那里来，从玉泉寺那里来，找惠能了。惠能就跟他讲“知识”，对人的一个比较尊重的称呼，在前面加个善也可以的，善知识。“远来艰辛”，你从北面，从湖北那里来到我这广东，“还将得本来否？”，你知道自己的本来面目吗？</p>
<p>“若有本则合识主”，<strong>主</strong>是什么？<strong>主</strong>就是<strong>自性、佛性</strong>，<strong>本</strong>就是<strong>本来面目</strong>，本来面目是不在时间中的，其实也是<strong>本心</strong>。“若有本则合识主”，就能够见佛性了，就能见自性，“试说看！”就本和主的关系。</p>
<p>神会回答了“无住为本，见即是主”，这句话就说明神会此人是聪明的，他一定读过《金刚经》，《金刚经》说“应无所住而生其心”。<strong>无所住，本心</strong>起来了是吧？结果他把“无住”直接等同于<strong>本心</strong>，“以无住为本”，见性是吧？“见即是主”。这句话说出来之后，惠能就说了“这沙弥争合取次语”。这个争是疑问词，你怎么就这么轻率的说话呢？</p>
<p>禅宗主张见性成佛，那么结果他把佛性扔掉了，他说见就是主了，见性这件事情就是佛性。那么<strong>本</strong>是<strong>无住</strong>，其实<strong>无住是本性起来的前提，并不是无住就等于本</strong>了。</p>
<p>惠能自己有过经历的。他的偈句，他达到的境界，“菩提本无树、明镜亦非台、本来无一物、何处惹尘埃。”它达到境界其实只当时这个偈句达到的境界指是 “应无所住而生其心”八个字的前四个字，“应无所住”，无所住了就什么都没了，有东西啊。当时惠能不知道，就本心起来。谁让他知道？弘忍法师让他知道，知道了以后他才见性，见性是自见本性，自性叫什么？他连说5个何其，悟了之后的惠能，“何其自性，本自清净”，自性就是佛性，“何其自性、本无生灭，何其自性、本不动摇，何其自性、本自具足，何其自性、能生万法”。现在呢，神会居然把无住直接等同于本了，把见性的“见”直接等同于佛性，无住等同于本心，见等同于佛性，所以惠能就说了，这沙弥怎么好是如此轻率的说话，“次语”、“取次语”就是轻率的说话，我们要知道佛性是真实的，这个真实不能用实体来理解。</p>
<p>佛性，我们曾经说过我举的例子就是比如说男女爱情，其实是佛性的一个方面。我们来到世界上的每一个男人和女人都注定了要爱一次的，这件事情不是他们自己主观所做的决定。假如是他们的主观决定，这世界上会分两类人，一类人决定去爱，另一个人决定不爱。没这种事情。每一个来到世界上的男男女女注定了要爱一次，这不是他们自己的选择。那么它证明什么呢？证明我们还没来到世界上之前，已经有东西等着我们每一个人了，其中一个叫<strong>爱</strong>。<strong>爱</strong>就是<strong>佛性</strong>的一个方面，具体的那份爱情会消失，不等于爱没了。具体的爱情当然会消失，如此这般一个男人跟如此这般的女人的具体的相爱，是他们的这种具体的情感联系。它是个具体的事物跟所有具体的事都一样，<strong>生生灭灭</strong>，但是这份具体的爱情的消失不等于爱本身没了。所以这个道理我曾经拿来说“佛性不是空”，“<strong>佛性是人生人类生活一切不朽的价值的总和</strong>”，哪里好把它拿掉呢了？过去的人曾经相爱，现在的人也会相爱，将来无论什么时代的人也会相爱，这一点是不因时代而转变的。你说今天的时代没爱情了，不能说这句话，爱情导向婚姻的成功率比较低了，不等于爱情没了。过去的人爱了，今天的人爱了，将来的人也一定会爱。佛性就是指这个。<strong>所有人类生活不朽的价值，就是佛性</strong>！每一个人的生活，生命的意义都被佛性所规定，其中一项就是爱。这样来理解，你不能把佛性拿掉。现在他把他拿掉了是吧？说见就是主、主就是佛性，见就是主。前面说无住为本，你不执着于外部事务。对的，这是第一个条件。你心不往外求了，你把它收回来，他在，他是什么你还不知道。所以中国人的思想让中国人能够领会佛学，是因为中国人有智慧，儒家和道家做了一个基础。孟子讲 “学问之道无他，求其放心而已”，这句话什么意思呢？他打了一个比喻，我们农民早晨都会把鸡、鸭都放出去，黄昏的时候都没忘了把它们叫回来。但是我们人每每会把自己的心放出去，却忘了把他叫回来。那么学问什么意思呢？再把这放出的心找回来了，叫求其放心而已。这本心是在的，这就是神会不明白，不明白了之后，惠能通过这句话就知道他不明白，以无住直接等同于本心，以见即主直接等同于佛性，这叫轻率的说话。</p>
<p>然后神会反问他，你惠能“和尚坐禅，还见不见？”，坐禅不就为了见性吗？见性就等于成佛了，你见还是不见？现在轮到他来问他了，轮到神会回来问惠能，你见了还没见？惠能不说，他不说话，打了3杖打下去，拿起柱杖打3下，那叫<strong>棒喝</strong>的源头。打了3下，问他一句话，你痛还是不痛？“吾打汝痛不痛？”“亦痛亦不痛”。你看多聪明，神会真聪明的，他也不能说痛，也不能说不痛，干脆来个“亦痛亦不痛”。你既然这么说，我也用你的句型，“吾亦见亦不见。”你说我见性吗？“吾亦见亦不见”，这句话说出来，神会其实急了，他真想问清楚，你见性了还是没见性？你如果见性了我就拜你为师，你居然这么回答我，亦见亦不见，我怎么办？“如何是亦见亦不见”，这一问才问的真切，也表明你神会放弃了逻辑上的聪明，你不是说亦痛亦不痛吗？我就回答你亦见亦不见了，就结束了。你终于追问了，“如何是亦见亦不见”的？你这一问我们真切，态度很恳切，好，回答你。“吾之所见，常见自心过愆，不见他人是非好恶，是以亦见亦不见”。“汝言”，你刚才说亦痛亦不痛是什么回事呢？“汝若不痛，同其木石；若痛，则同凡夫，即起恚恨”。你说不痛的话你肯定说假话，你是血肉之躯，我打了你3下，你怎么好说不痛呢？所以你说痛，然后你如果这个痛是指我打了你，你心里恨我了，那叫<strong>凡夫</strong>。“汝向前见不见是二边，痛不痛是生灭。”你问我见还是不见？然后我问你痛还是不痛？你说亦痛亦不痛，那叫先前痛后来不痛，叫生灭。痛起来了，叫生，不痛的叫灭，实际上是时间。见或者不见是二边对立，所以你说这种话。“汝自性且不见，敢而弄人”，你自性不见反过来问我，用逻辑的东西来跟我讨论，这叫<strong>弄人</strong>。</p>
<p>这一段对话是蛮有意思的，亦痛亦不痛应该是怎么理解？不能是说先前痛后来不痛，而是说痛肯定痛，我打了你血肉之躯。<strong>不痛</strong>是<strong>心里不恨我</strong>，这叫<strong>不痛</strong>，这就对了。我们要有这个境界。你买了那辆豪华轿车，其实攒了很久的钱，终于买下来的。才开了3天被人偷掉了，你难过吧？肯定难过。你这钱不是偷来的，你积攒起来终于买下这辆豪华轿车，3天就被人偷掉了，这很真实。假如你同时恨死了他们窃车贼，那叫心里也痛了，这叫双重损失。物质精神起痛了，这就境界不高了。所以我们有时候是要痛的，被人伤害的，但是你别去恨伤害你的人，他伤害你肯定错了，但却别去恨伤害你的人，你去恨伤害你的人你是心里也痛了。想想看这个境界是不是对，是不是应当达到。</p>
<p>前面说惠能说我的亦见亦不见什么意思？常见自心过意，过愆就是过错，不见他人是非好恶。我们想不通，他人不是有是非吗？不是有好和坏吗？好人坏人吗？惠能说不应该有！不是说禅宗不分是非，佛教当然分是非善恶。但是不把是非和善恶用到什么？人身上去，只用到那件事情上去。<strong>事情有是非，人没有是非</strong>。这是最难做到的。因为坏事是那个人做出来的，那个人一做出坏事，我们自然把坏这个标签也贴到那个人上去了，不能贴上去的！只是这件事情是错的。这个人还是有佛性的，他做出坏事是迷了，但佛性还在。我们永远不要把好人坏人的标签贴到任何人头上去，这是原则。这叫“常见自心过愆，不见他人之是非”，就是“人无是非”，虽然事情有是非。这是一个禅宗讲的平等，永不轻视任何人。为什么不轻视任何人？做了坏事的人你也不轻视他。事情是他做的，人不能贴一个坏人的标签，你把他关起来判了刑，以免他继续危害社会，这是必要的。但不能轻视他，佛性还在，他还能觉悟的。“前念迷是凡夫，后念悟即是佛”，所以佛教认为没有任何一个人是没希望的。于是就有那句话：放下屠刀，立地成佛。张行昌不是来杀他们？惠能没恨他，说你拿着黄金快逃，你等将来再过来，我收你做弟子，就这样的。常人做的到吗？你来砍我，你要我的性命，我不欠你的命，但是他没恨张行昌，这是<strong>佛家</strong>。我们要有一点<strong>境界</strong>，人与人的许多事情就是人与人的关系造成的烦恼，那件事情错了，把它纠正就没事了。因为心里放着那个人坏于是你的烦恼就没停过了，我们不断的把是与非做两个标签贴到打交道的周围的人身上去，好与坏都贴上去，那你就烦恼不断，那叫心里痛。所以肉体痛没关系，心中不起<strong>恚恨</strong>。虽然这3杖是我打你的，但你不恨我就对了。机缘就是这个意思。这个意思说完了才让神会服服帖帖的礼拜，悔谢。后来的神会就不离开惠能了，也不再到北面去了。神会这个人物很重要，将来还要说他，特别是后来，他为禅宗的发扬光大做出很大的贡献，此人在世间法上有本事的，每每会让我想起我们现在台湾的星云，就有神会的东西，为禅宗的发扬、寺庙的建设做出很大的贡献，神会当初就是帮助了朝廷为什么？安史之乱起来了，神会就到处募集，为朝廷募集军费，结果很成功，大大的帮助了朝廷，平定了安史之乱，于是朝廷反过来帮助南禅宗发扬，后来做出很大贡献，也必须承认。但是惠能老说神会境界不够。</p>
<p>在顿渐品当中其实包含了三个机缘，一个是惠能为志诚说禅修和戒定慧法，惠能明确的反对把禅修仅仅理解为坐禅，打坐。如果是这样想，他认为我们是在一把臭骨头上做功课，这是不可能的。然后讲戒定慧，不离自性来讲戒、定、慧。不是光讲一个礼，而是要从心上说，<strong>心地无非、这叫戒，心地无痴、这叫慧，心地无乱、这叫定</strong>。这是顿渐品的第一个机缘。</p>
<p>第二个机缘，刺客张行昌后来出家，出家之后又来到惠能这，做了惠能的弟子。他带着疑问来，就是《涅槃经》。如何是常与无常？涅槃境界叫常，那么现实生活世界叫无常，涅槃是境界，是佛性的呈现，佛性是常，万事万物都是无常。但惠能偏偏把《涅槃经》的说法倒一下说，佛性无常，现实世界诸善恶法相是常。这一个颠倒的说法，其实是为了把张行昌从《涅槃经》的文字的概念当中摆脱出来。</p>
<p>我们学习佛学，如果仅仅是从佛经的文字当中去讨真理，那是把佛经所呈现的境界反而弄糊涂了。所谓“春池拾砾”这个典故，那么多人不断的注解佛经，自古以来，佛经不断被注释解说。按照“春池拾砾”的故事来说，就好像许多人纷纷的跳到你那个水池里去捞宝石，结果没捞到宝石。对佛经的解释，种种解释都变成瓦砾，这是惠能非常了不起的一点。</p>
<p>继续讲了禅宗的破文字执的原则。我们照样可以说佛性无常，因为佛性就体现在这世界中。我们照样可以讲现在是感性世界是常，因为它自古以来始终存在这个世界。这样就把常与无常之间的分割状态打破了，不像西方思想设想一个彼岸的天国跟现实的人生世界割据开的这是西方的一个毛病。当然他可以解决一点问题，就是说西方人的心灵可以安顿到天国去，安顿到一个超验的上帝的世界中去但问题在哪里呢？问题是我们感性世界中的真理就不能展现，欧洲基督教时代最后文化生命的衰落就是这个缘故。我们对现实世界不再关心，他善也罢恶也罢都是上帝意志的体现。整个超感性世界的崩塌就是被尼采呼唤出来的。尼采说上帝死了，一个超感性的彼岸世界就崩塌了。这一点反过来反衬了中国思想的高明，西方人要折腾很大一番，终于明白两个世界的话都是错的。</p>
<p>人们曾经，欧洲人曾经听不懂尼采的声音，经过了第一次世界大战以及第二次世界大战之后的欧洲人，才听懂了尼采的声音。因为这两次世界大战是人类历史上空前规模的自相残杀，它恰好发生在信仰同一个上帝的基督教国家之间，以上帝死了。未来人类的文明恐怕不能在欧洲的文明不能再退回到尼采前的水平，那么将来跟中国思想有沟通汇通的可能，重新理解人类世界。</p>
<p>说起来这个事情都很大，这是我们读《坛经》的时候可以想到的，为什么一定要把《涅槃经》当中讲常和无常的说法正好倒一倒呢？我们不能理解为什么佛性无常？佛性总是不朽，他却说佛性无常，就是把不朽的东西跟当下变灭的世界统一起来，不要把不朽推向彼岸。当然《坛经》是佛经，中国人自己说的佛经，还是关注这是个人修行的境界。但是你如果把它领会为文明的境界的话，这也是极高的启发。</p>
<p>所以无怪乎欧洲20世纪以来最重要的思想无一不关注东方的思想，即关注道家老子庄子的学说，也关注禅宗的思想，这一点大可以破我们中国人对西方文明的迷信。</p>
<p>我不知道在这里讲过吧，就是《人民的名义》，那个事情就大丰厂和山水集团是吧？就冲突展开，叫劳资冲突。一个人带着英文的单词来了reason，那叫达康书记是吧？中国人现在都接受许多西方的价值观念了，理性。</p>
<p>还有一个叫退休了的老检察长陈岩石，带了两个汉字来了“道理”，天道在哪里？在人民生活里。所以说中西文化的冲突在今天深入的展开了，他变成每个中国人都会面对的问题。我们究竞怎么看待市场经济？怎么看待企业的行为？怎么看待家庭生活，家庭中的成员之间的关系？这一切都在考验着我们当下的中国人。</p>
<p>100多年向西方学，学了100多年，终于发现我们的智慧，中国人如果若要有智慧，不能离开本民族的。中国人是儒、道、佛三家的智慧，这是我的感想。对志彻，后来叫志彻的张行昌，惠能收他做弟子的，给了他一个法号：志彻，因为如今他已经大彻大悟。</p>
<p>那么第3个机缘讲神会，绝顶聪明的人。用我们今天心理学的话叫智商很高，智商高的主要表现就是逻辑能力强，是开口说话就很聪明。倒过来他去问惠能：你见还是不见呢？惠能就知道太聪明了，打他，打了后问痛还是不痛？你问我见还是不见？我问你痛还是不痛？见性跟痛有关，否则不用打。我们这些小根之人生活中没有大痛苦，不可能见性。人类始终以痛苦为代价领会真理，知识只是用来排除麻烦，知识无法排除痛苦，所以学佛。否则学科学就可以了。所以这一个机缘，第3个机缘很有意思就得打，3杖打下去，痛还是不痛？他到又聪明起来了，“亦痛亦不痛”，惠能当然知道他所谓亦痛亦不痛的含义，其实就是生灭。先前痛后来不痛，逻辑上的聪明，惠能给他说明了，我的“亦见亦不见”是指“常见自己过愆，不见他人是非好恶”，真正的亦痛亦不痛应当是指肉体是痛的，心中不起恚恨，就心没有痛。这样神会终于服了。</p>
<p>躯体痛真实的很，心里痛叫凡大。你打我身体打不到我心，你骂我也骂不到我的心，一切荣辱，一切赞美和指责都不关乎到我们的本心。如果我们当回事，叫荣辱皆惊。那就脱离本心，把自己这样一个小我当回事了。小我嘛，两个方面，一个躯体，一个执着于这个躯体的我，老子都知道，老子道德经第13章，“宠辱若惊,贵大患若身”，有根源的。为我们最担心的身，这个小我，得宠了，惊了。失宠了，也惊了。有根源的，就放不了这个小我。若没有身呢？何患之有。道德经第13章的思想，在其他章里边都没有，就第13章。整个道家学说教我们全生避害，终于发现那个生全不了的，人活在这世界上，哪能避得了害呢。所以老子思想很深刻，到第13章这样讲了，有根源，就放不下自己的身，身体的身。如果身把它拿掉了，第13章的思想后来被谁发挥了？庄子。庄子跟老子的关系就是这样。老子说过了那么多话，庄子也就不必重复了，但是就从第13章发挥出庄子来。你在这世界上怎么躲都没用。那庄子都讲了，有人很有意思，有一艘船呢，一艘舟，一艘舟它很宝贵，他把它藏在一个山坳甲面，这山坳之中，不知道谁半夜三更，有力气很大的人把他扛走了，你怎么藏？不如寄生于天下。老子来了，“天地与我并生，万物与我为宜”。这是又让我想到的再说一说，为什么心里痛就是凡夫？其实我拐杖没打到你心上，打到的只是你的躯体，你心却痛起来了，这叫凡夫。我们学《坛经》学禅宗要达到此境界，才看得明白。</p>
<p>底下关于神会还有一段，当时神会也就服了，礼拜了，悔谢了。然后惠能又对他谆谆教导了一遍 “汝若心迷不见，问善知识觅路。汝若心悟、则自见性，依法修行。”就可以了。</p>
<p>“汝自迷不见自心，却来问吾见与不见”。所以你离开禅宗的境界多远？你当初来这么问我的时候，你问别人见性还是不见性这是很荒谬的。人家怎么跟你讲？我见性了，然后你再追问你见到什么了？如何说得出来？我们自见本心的是是最真切的事物，它无法表达。正因为无法表达，所以这个惠能当初悟的时候就说了“如人饮水、冷暖自知”，所以像你问我这样的问题，你已经很傻了。你问我见还是不见？“汝自迷不见自心，却来问吾见与不见，吾见自知”，如果我见性我自己知道。</p>
<p>“岂代汝迷？”，我能代替你的迷吗？代替不了。“汝若自见，亦不代吾迷。”各自还得自己解决问题。</p>
<p>“何不自知自见，乃问吾见与不见？”，你这个问题就错了。</p>
<p>假如有人问你，见性了没有？你只能这样回答：哈哈~，今天天气不错。你只能这样回答，你还能说什么？除非你没见性给他解释了，我见性了，见到什么了？完美了。</p>
<p>“如何是西来意？”，那个人问了。</p>
<p>禅宗祖师说，“庐陵今天米价是多少？”</p>
<p>这么回答的？我问你今天这里米卖多少钱一斤？能不能觉得很怪，我不是问你达摩到中土来干嘛的就是这件事情，他回答说庐陵今日米价如何？奇怪吧？禅宗公案里有的。就你问错了你知道吧？所以这些事情都是值得我们参，《五灯会元》的那些禅宗公案就是参。有一两条参透了，然后境界就爬上去了。就不会问那些蠢问题是吧？蠢问题每每被我们看来是很好的问题，因为在知识层面上，我们每每就从知识层面上思考问题，也就会问这个问题，殊不知禅宗讲的智慧超越知识。所以你用知识层面来提问他，一定就有莫名其妙的话回答你就把你这个问题给废掉，这是禅宗公案的一种读法。你总觉得他问的也没错，什么叫没错？在知识层面上可以这么问，在逻辑层面上可以这么问的，但他本超逻辑。<strong>禅宗的境界超逻辑</strong>，怎么好在<strong>逻辑层面</strong>上问呢？然后他也是下来给你回答，他把自己降低了，变成逻辑的东西讨论起来了。就像《论语》当中一样的，宰予问孔子。你主张恢复周礼，那么假如父母亲去世的话，按照周礼要服丧3年，3年是不是太长了？能不能短一点？孔子怎么回答？跟他讨论为什么要3年，或者两年半也可以，那傻掉了。</p>
<p>这不是理性的计算，他只是反问了宰予，假如你父母亲去世的话，你服丧3年。哦，你不服丧，你吃的好穿的好。“食夫稻，衣夫锦，予汝安否？”就这么问。服丧3年不是<strong>理性</strong>推论的结果，是心安与否。所以他不能把自己降下来，孔子降到一个理性计算的层面上来回答你这个问题。</p>
<p>与此同理，许多禅宗公案都这样，我们不明白的情况下我们读者一读，这个问题问的蛮好，哎！你怎么回避了呢？我就顺带讲一讲如何读禅宗公案。问的人因为没悟，他每每只是在逻辑和知识层面上提出这个问题，那个人就不回答或者扯开来，罔顾左右而言他。必有缘故。此问题这样问不对，他不是逻辑问题，他不是知识问题。得这样读禅宗公案，这是一个方面。还不仅一个方面，有时候他问问题，禅宗是不回答的，是做动作的，一个动作一个行为已经把意思告诉你了。所以这些都是我们读《五灯会元》这样的禅宗公案的偈子要做的一些准备否则参不透。有些学者也去解释什么都不一样。我看过几篇，一看我就觉得这个作者就是在勉强解释，他试图把他合理化逻辑化，他本不是逻辑问题，所以这是一个说明。</p>
<p>所以最后这段话就跟他讲，你当时问我见不见是问错了。“神会再礼百余拜”，这也是厉害了，磕头如捣蒜，百余拜。</p>
<p>“求谢过愆，服勤给侍，不离左右”。但这个病还很难治，后面又来，就神会的病还很难治。又有一天，惠能在众弟子面前说话，他说我“吾有一物无头无尾，无名无字，无背无面，诸人还识否？”你这个问题，我有个东西，这个东西怎么样的？无头无尾，无名无字，无背无面，你们认识吗？</p>
<p>神会又来了，他说他知道的，是“诸佛之本源，神会之佛性”，似乎也回答的妙，可见聪明是蛮难克服的，聪明是智慧的障碍。</p>
<p>惠能说了，“向汝道无名无字，汝便唤作本源佛性，汝向去有把芔盖头”，<strong>芔</strong>就是茅草，盖头就是做一个茅草房，你就住在里面吧。</p>
<p>“也只成个知解宗徒。”修佛的人有一类人可以称他为称他们为知解宗徒。什么叫知解宗徒？他们是这么修行的，就从佛经的字、文义，文字的意义当中去修佛，仅仅借助经文来修行的叫知解宗徒。神会说的话似乎满有道理，人皆有佛性。那么我神会也是人，所以我也有佛性，你说的那个东西我知道，比方说就是我的佛性，比方说诸佛之本源。那么为什么还是错的呢？诸佛都来源于这个东西，就这件事，它无头无尾，无始无终，本不在此间中，也谈不上本源，佛性向来在。</p>
<p>我们都说释迦摩尼是第一个佛其实不是。在他前面也有佛。释迦摩尼是第一个佛是什么意思？是第一个完整的说佛法的人，并不是说佛性因为释迦摩尼才有了。释迦摩尼之前有许许多多佛了。人都有佛性，修行成功就是佛，但他没说佛经可以吧？没关系，但说佛经了，说了49年了，释迦摩尼，这是第一个。叫“无始以来”，就不要去追问他本源。所以惠能又说他了，只是个知解宗徒。一个人聪明倒也不是罪过，没办法就聪明了怎么办呢？但是要提醒自己的，因为聪明就比较累，因为事情都看得太清楚了，就累。</p>
<p>最典型王熙凤。这个贾府里面大概诸女子当中，唯独她最聪明的，反应快的不得了，什么事情看不清楚？你在巧取暗夺是吧？王熙凤一眼就看透了，聪明的不得了。所以贾母临终的时候就跟王熙凤讲：“我的儿，你太过聪明了，多修修佛吧。”可见贾母有智慧。所以凤姐的判词是这么写的，在太虚幻境，有一个大殿，大殿里面有大橱，大橱里边有抽屉，抽屉里边有命册是吧？那么金陵十二钗都在正册里边的，每一个人物有一幅画，然后有一首诗，叫判词。王熙凤的判词是这么写的，“凡鸟偏从末世来”，凡鸟两个字合起来就凤了，他的不幸是生逢末世。“都知爱幕此生才”，人聪明就要发挥，不发挥是不可能的，“一从二令三人木，哭向金陵事更哀。”到最后的结局就是被贾府休了，回老家金陵去，就回南京。这个，人有聪明才华不发挥很难过的，王熙风很典型的这种人，越是这样的人，越是要学点佛或者道家。</p>
<p>好，我们再看后面讲神会的功劳讲了一句，“祖师灭后”，就惠能圆寂之后，“会入京洛”，到京城去了，“大弘曹溪顿教”，他还有“著”作“《显宗记》，盛行于世”，后来被称为 “菏泽禅师。”</p>
<p>这个《坛经》也不是我们现在读到《坛经》，也并不就是当初的原本，在原本的基础上说了修改补充，有许多补充的人是神会的信徒，非常的爱戴和尊重自己的师傅神会的。佛教祖师这样传下来，所以前面这句话也不能不讲，惠能对神会的批评也得落下米。但后面还在补充，说明神会的功绩。这也是神会的弟子们对于他的爱嘛，所以要补充说明。</p>
<p>后面还讲神会境界高的地方，后面还有。那么最荒唐是胡适，胡适考证到后来的结果是《六祖坛经》不是惠能的，是神会的。是更荒谬的事。反正胡适先生做历史研究有8个字 “大胆假设，小心求证”，这个假设够大的了。在《顿渐品》里面最后还谈到这样一层意思，就是说实际上汇集在惠能身边的许多人不好，“师见诸宗难问”，不同派别的人都混过来了，不断向他发难，诘难，“成起恶心，多集座下，愍而谓曰”，其实惠能很怜悯他，跟他们讲“学道之人，一切善念恶念，应当尽除，无名可名，名于自性”，就佛性，我们的自性本没办法用名称来说的，本没有名相，常明知叫<strong>自性</strong>。这就让我们想起老子道德经 “道可道、非常道、名可名、非常名”，它本是无名，勉强名字叫道，其实道就是无名，有名呢就是具体事务的概念层面，对道怎么能形成概念呢？所以在这里惠能等于说自性就是无名了。在老子那里，道是无名。在惠能那里自性或佛性就是无名，“无名可名，名于自性，无二之性，是名实性”。无二之性就没有两边对立，没有二元对立叫无二，这叫实性。“‘于实性上建立一切教门，言下便须自见。’诸人闻说，总皆作礼，请事为师。”效果真这么大？不知道，姑且这么记录下米，本来都有那种想法，问难，听他这几句话，大家都听的做他的徒弟去了，这是经文这么写的。</p>
<p>好，我们这样就把《顿渐品》就讲完了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="护法品"><a class="header" href="#护法品">护法品</a></h1>
<p>我们现在进入了第九品，就《护法品》。信佛的在家人，凡是帮助寺庙和帮助佛教事业的都叫护法，那么当时最大的护法是谁？皇帝呀，皇帝是最大的护法，那叫大护法。所以护法品讲的是什么呢？讲的是惠能跟政权的关系，也就是禅宗或整个佛教跟政治的关系，这叫护法品。</p>
<p>我们翻到180页，说“神龙元年上元日”，上月的第一个元月的月圆的日子元宵。武则天跟唐中宗一起颁布了一个诏书要请惠能到朝廷。</p>
<p>诏书中这么说“朕请安、秀二师”，安国师和神秀师，安国、神秀都是弘忍法师的弟子，他们已经被朝廷供养了。“万几之暇”，皇帝日理万机，略有片暇，总是要去跟他们讨论佛教。“每究一乘”，一佛乘、一乘教。</p>
<p>那么这两位师傅呢，这两位主持就推脱，“南方有能禅师，密授忍大师衣法，传佛心印，可请彼问”。跟皇帝讲，你还不如去问惠能，我们两位都不如他，他才是得了弘忍法师衣体的人，他在传佛心印。</p>
<p>诏书中就写了“今遣内侍薛简”，内侍就是太监，“驰诏迎请”，亲自到南面来迎请你惠能北上，“愿师慈念，速赴上京”，惠能“上表辞疾”，说自己身体不好，谢绝了朝廷的请求。说自己“愿终林麓”，终老山林，不想到朝廷上来。</p>
<p>薛简来了，跟惠能讲，翻过来182页，这里边又有一个机缘。其实就是惠能给皇帝说佛法，借助当中的薛简来传话，为皇帝讲开示，这叫护法品。</p>
<p>薛简跟惠能讲“京城禅德皆云”，禅宗大德们都说，“欲得会道，必须坐禅习定；若不因禅定而得解脱者，未之有也。”，这话许多人现在还这么说的，它符合事实，大多数的宗派不光是禅宗，其他的宗派都打坐。密宗修神通也打坐，还闭关打坐。所以未有不落禅定的人能解脱的，“未审师所说法如何？”，就不知道你惠能怎么理解？怎么说法？“师曰：道由心悟，岂在坐也？”</p>
<p>“经云：若言如来若坐若卧，是行邪道”。经文中本有这样的话：如来佛，就是释迦摩尼佛若坐若卧，他究竞是坐的还是卧的？你在讨论这个事情那叫邪道。“何故？”为什么这么说？“无所从来，亦无所去。无生无灭，是如来清净禅，诸法空寂是如来清净坐”，应当这么理解，坐不是身体不动，是心，心灵明白，悟到诸法空寂，坐禅本来的意思也是帮助我们理解“诸法空寂”的。</p>
<p>我们平时都忙这件事，忙那件事，都跟着事务走，执着于这个事物，执着于那件事，那么留一点时间给自己打坐，打坐的时候就把各种念头都放下来，也就是把各种事物、诸法都驱赶走了，从一个空寂是吧？这是外在的功夫，当然目标还是这件事，“诸法空寂”。</p>
<p>但是惠能认为未必一定要坐禅能达到，其实我们心悟就可以了，这叫“清净坐”。“究竟无证，岂况坐耶？”，如来清净坐，实际上就是心的功夫，心灵的境界，他也没办法证，你就坐了就能证，况且你坐就能证吗？这是第一个问题的回答。所以对薛简第一个问题的回答，“道由心悟，岂在坐也”？</p>
<p>那么底下薛简又提出请求了，“弟子回京，主上必问”，皇帝一定会问，惠能跟你说些什么？“愿师慈悲，指示心要”，佛法心要，心法的要领，“传奏两宫，及京城学道者。譬如一灯，然百千灯，冥者皆明，明明无尽”，如果你跟我说一些话，我带到京城去，效果很大，影响很大，是很大的功德的。但他说话又出问题，所谓“冥者皆明”，冥就是黑暗了，都光明了，而且是光明无穷无尽。惠能回答说，“道无明暗，明暗是代谢之义”，彼此取代，明取代暗或暗取代明，它并不两者对立，代谢不是对立。好像道只能在明中，不能在暗中似的，不是，道无名。“明明无尽，亦是有尽，相待立名”，你说没完没了的光明不可能，这个道理也是蛮高明的。我们试想一下，纯粹的光明不就是纯粹的黑暗吗？你还看得见东西吗？想一想这个道理。事物向我们早现一定要有暗的一面的，暗的一面他就能留下影子。纯粹的光明，你还看得到事物吗？什么事我都看不到了。纯粹的光明等于纯粹的黑暗，不一回事吗？</p>
<p>我们看到桌子了，看到东西了，都因为有暗。没有暗，你看到的东西吗？事物的轮廓都是因为有暗才被你发现的。所以明暗是“相待立名”而己。“故《净名经》（维摩经）云：法无有比，无相待故”。真正的佛法并没有一个跟他对立的非佛法，没有。没有相对，相相并立，相互对立，没有。无相待故。</p>
<p>那么薛简还是不明白，薛简继续问，“明喻智慧，暗喻烦恼。修道之人，倘不以智慧照破烦恼，无始生死，凭何出离？”无始就是没有开头，无始以来就时间没开端，一直是生生死死不断，轮回是不会停下来，怎么办？你就没办法出离生死之苦海。智慧跟烦恼要用智慧照破烦恼，又出问题了吧？就智慧和烦恼对立，智慧要战胜烦恼，那就变成这个事情。明要战胜暗，前面惠能已经说了，明暗不是对立的，是<strong>代谢</strong>。</p>
<p>惠能回答直截了当，你说要智慧照破烦恼，我告诉你“烦恼即是菩提，无二无别”，这让我们真领会到正法了。我们常以为自己烦恼不断是吧？那很糟糕，有朝一日有智慧就好了。有了智慧，烦恼被驱赶走了。我们常这样想。惠能说“若以智慧照破烦恼者，是二乘见解”，我们上午讲的二乘人，声闻乘、缘觉乘，这叫二乘，声闻乘叫架的羊车，缘觉乘叫架着鹿车，缘觉乘上面有菩萨，菩萨乘是叫做牛车，还有最高的佛，一佛乘，那叫架着白牛车，这是个比喻，就学佛的境界有不同。你这种说法属于二乘见解。“羊鹿等机：上智大根，悉不如是”，上智大根之人都不会这么想。</p>
<p>那么薛简就问，“如何是大乘见解？”“明与无明”，无明不就是暗，“凡夫见二”，凡夫认为他们两者对立，“智者了达，其性无二”，这很有意思的，禅宗让我们建立起一种自信，我们生烦恼什么意思？烦恼从心里走出来的，蛮了不起的，我们无，没有这个心就不会有烦恼，动物没烦恼，动物有焦虑，人才会生烦恼的，这叫心的力量。为什么叫生烦恼？就筹划未来，筹划未来而不能实现叫不如意，就是烦恼。我们的心可以超出事实，超出现实去筹划未来，很了不起的。</p>
<p>所以烦恼跟智慧不是两个对立的东西。“其性无二，明与无明，其性无二，无二之性，即是实性。实性者，处凡愚而不减，在贤圣而不增；”如果你是凡夫、愚人，并没有减少你的实性，你是贤圣，也没有增加你的实性，“住烦恼而不乱，居禅定而不寂”。我们昨天也提到了，不用害怕烦恼，不用拒绝烦恼，我们就在烦恼中，但是不乱，住烦恼而不乱就是智慧，不要认为自己有烦恼就不好，还不干净。</p>
<p>什么叫干净和肮脏？也是代谢。真谛与俗谛不可两者对立，一开始学佛把它对立起来，我在俗谛中你在真谛中，真俗其实不二，到后来一层境界叫俗谛即真谛。我也要糊口谋衣吧，肚子饿了就要谋食吧，身上冷了就要谋衣吧，俗不俗？很俗。</p>
<p>俗谛就是真谛。关键是心不乱，心怎么乱的跟人比较呀，你看人家锦衣玉食的，我却是破衣烂衫，难过了，就乱了嘛。一乱，然后你去谋衣谋食，那就变成尘劳。所以“住烦恼而不乱”。人生日用常行柴米油盐，你可以说都是烦恼，但你不乱就没有烦恼就是智慧，这个是非常重要的。</p>
<p>中国思想高明，“极高明而道中庸”，**中庸就是庸常，就是普通生活，里面有天道，天道至极致，无非柴米油盐。**你严冬的时候没有御寒之衣怎么办？当然烦恼，你要冻死了。这种烦恼你用智慧怎么照破？你智慧来了我就不冷了？很冷的。去谋冬衣吧，谋冬衣这时候就是觉悟，但是心不乱。处寒冷之中心不乱，谋冬衣正行之中，这就跟智慧没区别。不要把智慧高举到烦恼之上，它是另外一个境界，智慧就在烦恼中呈现了，因为你不乱。所以禅宗达到这个境界，后来就一句话，叫“担水砍柴，无非妙道”，得担水呀，得砍柴呀，妙道就在其中，哪里有真俗二分呢？住烦恼而不乱。</p>
<p>禅定，就心定了，但是并不空寂，照样活活泼泼的生活，叫“居禅定而不寂”，不是什么心如死灰，这叫禅定了吗？还是活活泼泼的。“不断不常，不来不去，不在中间及其内外。”无内外这件事情，我们到传习录里边这个要展开的。心无内外的，你说现在身体内部，昨天我们讲，我也没有事情，不，心就这个事情当中，一切事情都是心思。心不在事情上，这个事情不叫事。有什么事？这个事变只在人情里，就心无内外。“事变只在人情里”，这句话就是阳明原话。所以禅宗极大的启发了宋明心学，怎么叫事情来了？你的喜悦或者忧惧来了。</p>
<p>2007年，我大概讲过这事，复旦大学校长办公室打电话给我王德峰，叫我去做一个2007年复旦大学研究生毕业典礼上的演讲，作为教师代表，把一个电话打过来，哎呦！事情来了，什么事情？心里的感受来了，第一学校看得起我，校长都认为我是可以的，像这种获得演讲机会的人，一般都被认为是复旦大学大牌教授，心里有受宠的感觉。然后转念一想就慌了，万一被我讲砸了怎么办？自己没了脸面，复旦也没了脸面。复旦大学的毕业典礼，上海的媒体都在场的，第二天就得发表的，事变只在人情中。</p>
<p>什么叫事情？事情就是心思，就这个道理。你离开事情不要去那个心，所以晚年的王阳明提出“事上磨练”，在事情上磨练，无内外，“不生不灭，心下如如，常住不迁，名之曰道”，勉强说嘛，就叫道。</p>
<p>薛简又说了，“师说不生不灭，何异外道？”，外面的其他的什么派别或者其他什么非佛教也说不生不灭的事情，外道所说不生不灭者其实是 “将灭止生，以生显灭”，两者还对立，灭了就生命结束了，生命表明另一面叫死亡，“灭犹不灭”，这时候能灭其实没有灭，“生说不生，我说不生不灭者，本自无生，今亦不灭”，这根本。自以为我们活着，其实又没有活着，本无生。也就没什么东西要灭，仍然是讲<strong>不朽</strong>的意思。</p>
<p><strong>不朽</strong>就是不在时间中，不在时间中，当然不生不灭，跟时间无关，跟生灭都无关。本自无生进亦不灭，这是哲学上的一个蛮重要的思辨，就西方人老早就有这个思辨，就柏拉图开始就有。中国人没这个思辨，中国人是借助了佛教，而后在近代才能理解西方哲学的。因为佛教的思想是跟印度古印度的哲学关联在一起。人类的哲学有三大系，欧洲哲学、中国哲学，当中一块叫印度哲学。除此之外无哲学。但印度哲学衰落了，印度哲学对世界的基本理解都进入了佛学。</p>
<p>古印度的一本书是了不起的，基本上都读不懂的，叫《奥义书》啊。</p>
<p>在佛教成立之前，《奥义书》是古代印度的哲学思想。那么古印度的哲学跟欧洲希腊哲学跟中国哲学之间正好是它像中间地带一样。西方人的抽象思维，抽象的思辨，中国人向来没有。古代印度的哲学是两者都具备，就像我们上午讲的僧肇讲《宝藏论》，“常观金体于不睹众相”。具体的事物都是有相的嘛。然后它有一种抽象，金子本身抽象出来了。这是西方思想的特征。</p>
<p>古印度哲学也具备这一层，所以因为佛学中国化，中国人就对那种西方的形而上学的思想已经有了，通过接触佛学有了，然后再近代去读康德黑格尔，去读。这件事情也有蛮有意思的。</p>
<p>就不朽。你比如说一句话，你怎么说爱情是永恒的？你怎么理解？你千万别把爱情是永恒的，这句话理解为爱情将没完没了的进行下去。永恒的是指<strong>与时间无关</strong>，这是个思辨。</p>
<p>所以你说不生不灭，是拿生来显灭，还是把灭来指生，都错了？超越生命之上。生命一定在时间中的，超越时间。就要说无生也无灭，这就对了。爱情没有产生出来，因此爱情也不会说被灭掉。因为什么？爱情不朽。具体的那份爱是吧，两个人的关系，他当然是生生灭灭。爱本身不生不灭，爱一旦发生了，它哪怕只持续了一瞬间，它已经是不朽的。它不是长短的问题，不是时间长短的问题。我就纳闷啊惠能怎么会懂的？不是文盲吗？哎，我学西方哲学还很累的，读西方哲学是读到康德、黑格尔，哎呦不得了了，费尽气力，然后终于得了。惠能就说了，咱不明白，也无法推测啊，慧根呐，宿慧，能领会这种超越时间的东西。</p>
<p>与时间无关，西方人他这个思想啊也了不起的，在古希腊起源的时候，他就发现一个很重要的事情，你要讨论字宙的具体事物，它一直变嘛，所以赫拉克里特说：人不能两次踏入同一条河流。变化。赫拉克里特的思想没有成为西方哲学的主流啊，成为西方哲学的主流，西方哲学就跟中国哲学没区别。</p>
<p>中国第一部了不起的著作是什么？有哲学思想在里边的，叫《周易》呀，《周易》的书名就是change呀，<strong>易</strong>就是<strong>变</strong>。中国人抓住变来说宇宙的，西方人也有一个人抓住变来说宇宙，那赫拉克利特啊，但赫拉克利特很快被超越了，抓到不变的东西。</p>
<p>比方说毕达哥拉斯几何学，毕达哥拉斯是数论的开创者，也是几何学的开创者。你比如说研究三角形吧。三角形，比如说他们发现了，我们中国人叫勾股定理是吧？它叫毕达哥拉斯定理，一个直角三角形，三条边之间的关系：A平方加B平方等于C平方，他发现了。发现了他们很高兴呐，举行了隆重的庆典，为什么？这个东西是不朽的。跟世界上有没有三角形的事物一点关系都没有。世界上根本没有三角形的事物的话，几何学家照样讨论三角形。而一旦这个世界上真出现三角形的时候，一定是符合几何学家对他的所有讨论，这个思想就来了。</p>
<p>从此西方哲学就打下了这个特征，总是去发现那个immortal being，就<strong>不朽的存在者</strong>。你比方说万有引力定律，万有引力定律需要至少有两个物体来体现它是吧？比方说一个地球一个苹果，假如能够体现万有引力定律的两个物体都没了，请问万有引力定律消失了没有？它不会消失的。一旦宇宙中出现两个物体，它一定服从<strong>万有引力定律</strong>。西方哲学，我们借助佛学能够理解西方哲学，有一种超越超验的思维。</p>
<p>几何学讨论的所有的事情都跟观察和实验没关系的，他是理性自己推出来的东西，他超越现实的。你比方说，一个几何学老师跟大家讲，两条彼此平行的直线线段，若无限延伸将永不相交，是不是？有个同学提问题，老师你怎么知道的？老师回答说我画过的，你画了多长？我从上海的静安寺一直画到外滩他们没相交呀。学生继续追问，如果越过黄浦江它们交了再怎么办？在几何学课堂上会有这种讨论吗？没有。</p>
<p>这句话一说出来同学都同意了啊，因为我们都是理性的存在者。它不是实验和观察的结果，世界上根本没有平行线也没关系呀，几何学家照样讨论他呀，那个不朽的存在，这就是为西方哲学打下了它的特征，基本的烙印，就延续到近代。</p>
<p>所以这些事情呢，<strong>佛学是把它用来解决人生问题的</strong>。如何理解涅槃？叫不生不死。是这样来讨论的。西方呢，把哲学的形而上的思辨来讨论关于世界的客观知识的基础是用法不一样的。</p>
<p>佛陀把古印度的哲学用来解决人生问题，西方人用形而上的思辨来形成关于宇宙的客观知识。知识这件事情可了不得，它并不依赖于经验，我们总觉得很奇怪，我们是学过马克思主义哲学的，从感性认识上升到理性认识。其实不对的！这话今天现在不展开，他非常有意思。</p>
<p>好，这样我就一直认为很有意思的事情就是，怎么惠能都懂？“我说不生不灭者，本自无生，今亦不灭”，他超出时间了，超出生灭，这个事情是重要的，所以不同外道了。</p>
<p>“汝若欲知心要，但一切善恶都莫思量，自然得入清净心体，湛然常寂”，湛然这个湛字，中国人的汉字“湛”字真有意思噢，既清且深，那个水。“寂”是安静、平静。“妙用恒沙”，它的妙用是无穷无尽的，如恒河沙数一样，叫“妙用恒沙”。</p>
<p>“简蒙指教，豁然大悟，礼辞归阙”，阙就是朝廷，回到朝廷上去了，“表奏师语”，表奏把惠能说的话全部传达给皇帝了，皇帝就要回信给那个惠能了。就翻过来看186页。</p>
<p>“其年九月三日，有诏”，当初是正月十五，到了九月三号，有诏书来了，“奖谕师”，奖谕惠能了。</p>
<p>“师辞老疾”，你是说你身体不好，又老了。</p>
<p>“为朕修道，国之福田”。就皇帝同意了，你就不来吧，你修道也是为朕，也是为天下，你惠能其实成了，你的修行，你的说佛法就成了国之福田了。</p>
<p>“师若净名”你就象净名一样的人，是跟维摩诘是一样的人。我们知道维摩诘就是跟释边摩尼同时代的大居士，他也曾经这样，曾经说自己身体不好，不去跟政治有任何关系。</p>
<p>“托疾毗耶”，他不离开那里，这表明皇帝知道你是托诘而已，一个推脱，是不肯来。等于告诉他，我知道你并不是身体真的有病。</p>
<p>“阐扬大乘，传诸佛心，谈不二法”你就是在做这样的事。传心法啊，教大家佛法是不二之法，</p>
<p>“薛简传师指授如来知见”。薛简做到了这件事情，把你说的话传给我了，你教导我，教了我怎么是，如来知见。</p>
<p>“朕积善余庆”，皇帝还说自己是积善的人，将来呢还要福泽后代呐。中国人说的是吧？余庆就庆到自己的后代身上的，“积善之家必有余庆”嘛。</p>
<p>“宿种善根”，说他自己以往前世，在前世也是种了善根的人，所以得到这个机会，得到你，我跟你一起来到这同一个时代出现，那是幸运啊。</p>
<p>“值师出世，顿悟上乘”，这种事情都是蛮有意思的，这个皇帝境界还可以的噢，他认为自己跟惠能同时代人，这是件了不得的幸事。</p>
<p>汉武帝就认为他跟那个谁呀？董仲舒，这也是幸运的。一个政治家汉武帝，一个思想家董仲舒联起手来，罢黜百家独尊儒术，从此让儒家成为中国的道统。这也是躬逢其世。伟大的政治家跟伟大的思想家。这里呢皇帝也认为自己还不错，我是天子。你是佛家中的贤圣，我们同时代。</p>
<p>“宿种善根”，这种诏书都写得很好的，“值师出世，顿悟上乘，感荷师恩，顶戴无已”，你看，这是皇帝是人王，惠能是法王，法王不让人王的啊，这就是佛教跟政治的关系。</p>
<p>通常都说世界三大宗教：基督教、伊斯兰教、佛教。基督教、伊斯兰教都跟政治结合了，最厉害的叫政教合一，唯独佛教不可能这样。现在有点问题，那些方丈啊，寺庙的方丈住持跟政治官场的官员很密切，其实不好。各自独立。那个政治的统治者也应该看清楚，佛教有利于天下，为国种福田的人。这才是境界嘛。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="付嘱品"><a class="header" href="#付嘱品">付嘱品</a></h1>
<p>最后的教导嘱托，所以叫付嘱品。这一品里面有4个方面的内容。第一个方面就是讲对这些弟子们说你们都会都将担当重要的使命，让这个心法的传承不要断了。怎样去接引和开示前来问佛法的人一些最基本的方法。所谓<strong>三科法门，三十六对法</strong>。我们把书翻到188页，“师一日唤门人”底下的名字都列出来了，“法海、志诚、法达、神会、智常、智通、志彻、志道、法珍、法如等”，法珍、法如前面没都提到，至于从法海一直到志道都提到了。跟他们讲“汝等不同余人”，你们这些人跟其他人不一样的。“吾灭度后”佛教中的人出家修行，然后要走，把自己走了，说成是灭度。灭是指灭障，我们有种种的障啊，终于灭了。“度”就是度苦，脱离这苦海叫灭度。灭障度苦，这称为，那当然我们一般都叫这样的人叫圆寂呢。</p>
<p>“吾灭度后，各为一方师。”你看他们都有使命。</p>
<p>“吾今教汝说法，不失本宗。”现在我跟你们讲，怎样说佛法才能不失本宗呢？就我们这个禅宗顿教，不要脱离它，底下就来了。</p>
<p>先跟他们讲，说我“先须举三科法门”，然后“动用三十六对”法，“出没即离两边。说一切法，莫离自性。”</p>
<p>已经说了讲出了，说佛法的原则两个：第一个“莫离自性”，不要脱离自性来说佛法，这是禅宗的原则。比方说讲三皈依，还要自性三皈依都讲自性，不离自性。还有一个原则，“出没即离两边”，就要消解二元对立，不落两边。风吹幡动，既不站在风动一边，也不站在幡动一边，要离开两边对立，这是原则两条。</p>
<p>“忽有人问汝法”假如突然有人来问你们佛法，</p>
<p>“出语尽双，皆取对法”，你不要两边对立，你只抓住一边说话，“出语尽双，皆取对法，来去相园，究竟”，最后达到一个目的，“二法尽除”，妄念都来自二相，我们反复讲这个道理，我们别把妄念仅仅理解成虚幻的空想，这叫妄念。</p>
<p>妄念经常发生，我们还不知其妄，这个妄是什么意思呀？<strong>二</strong>！区分来了，利、害、得、失、贵、贱、富、贫、善、恶、苦、乐、顺、逆，等等等……</p>
<p>妄念就在这种二相当中形成的，它表现为要趋利避害，要趋乐避苦，趋富避贫。趋贵避贱，趋顺避逆，如此等等。所以这叫二相的。所以让人领会佛法，要去开悟，那就是要达到 “究竟二法尽除”。</p>
<p>像这个阳明也是二法尽除啊，知和行不能对立，知行合一，都是“二法尽除”的意思。“出语尽双”，什么意思？你比方说王阳明跟人家讲知和行的关系他怎么说？说知就要用行来说，说行就要用知来说，这叫“出语尽双”。“知是行之始，行是知之成”， “出语尽双”你不能说先讲讲知识，然后再讲讲，另外讲讲行。讲知就要用行来说，讲行就要用知来说。</p>
<p>“知是行的主意”，拿定主意啊，叫主意。行是知的功夫。用知来说明行，用行来说明知，“出语尽双”，定是慧之体吧，慧是定之用，“慧是定用”。</p>
<p>你不能脱离慧来说定，也不能脱离定来说慧，“出语尽双”，你才能把二元对立扬弃掉，消减掉了。知和行怎么对立的呢？本是一体的嘛，知行一体呀，定慧一体呀，这个道理。</p>
<p>所以我们讲王阳明就是儒家中的惠能呀，他跟人家讲道理也是这么讲的。所以不免让我觉得这里好像还有一个王阳明呢！惠能就弟子当中有一个啊，后来果然变儒家了啊，就这个道理。</p>
<p>所以禅宗为宋明儒学做了准备，“出语尽双，皆取对法，来去相因”，代谢而不是对立。叫相因，相因就是前后啊，“究竟二法尽除，更无去处”。没有别的地方可以来说的。</p>
<p>说这个三科法门，哪三科？我们看啊，这个“三科法门者，阴界入也”。阴是指五阴“色、受、想、行、识是也”。</p>
<p>“入是十二入”，哪十二入呢？外有“六尘，色、声、香、味、触、法”，内有“六门，眼、耳、鼻、舌、身、意”。实际就讲我们的五种感觉，再加上第六识，意识，这主观的一面，对应着外部的客观的一面，叫“色、声、香、味、触、法”。</p>
<p>用我们的眼看到事物的形象，用我们的耳闻到的声音，我们的鼻子嗅到了气味，我们舌头尝到了滋味，然后都对应，身体就触觉，意！就意识了，把前面五种感觉材料综合为一个对象，一个事物，那叫法，意对着法。</p>
<p>一个苹果拿在手里，你对它有五种感觉。看到他一个球状物掉在地上嘣一声，那叫声音，闻一闻是香的，咬一口是甜的，碰上去是硬邦邦的，这些都是杂多的感觉材料还不成为一个apple，一个苹果呢？要称其为苹果就要第六识，就把五种感觉材料综合为一，就第六识，这就是苹果不是梨子，分别识什么？意识也是分别识，法就是事物。</p>
<p>那么加起来是不是十二？入是十二入，界是十八界。六尘、六门、六识，三六十八。尘，六尘就是色、声、香、味、触、法：六门就是5种感觉器官，再加上意识，这叫门，通向外部世界的门户。那么形成的是六识。眼识、耳识、鼻识、舌识、身识、意识。我们的感觉能力和意识能力，对应着外部六尘结合起来形成我们的识叫六识。这样把世界万物都在里边了。</p>
<p>主观的世界，客观的世界以及主观与客观相应产生的人类文明都在里面。一幅绘画作品就是眼识的体现。你看到东西是眼睛的能力，看到外部事物的形象，然后再把它描画出来，不就是眼识吗？眼识就是作品吧。所以这个世界宇宙万物就都囊入在其中了。</p>
<p>在我们身上本有的能力叫<strong>六门</strong>，对应了获得外部事物，叫<strong>六尘</strong>。两者一结合六识，加起来十八，叫十八界。好，三科，哪三科？<strong>阴、入、界</strong>。阴是指我们的五阴，入就是十二入，界就是十八界，叫三科门，<strong>阴科、入科、界科</strong>。</p>
<p>“自性能含万法”，其实都不离自性的。</p>
<p>“名含藏识。若起思量。即是转识”，逻辑思考一来，加强了分别识，那就转了“生六识，出六门，见六尘，如是一十八界，皆从自性起用。”这个有道理。自性就我们每个人身上都有一个佛性，把他们统率在一起的，就是<strong>佛性</strong>。把六识六门都统率在一起的，把六尘都统率在一起的，主宰了他们的就是<strong>自性</strong>。这个我们有感觉吧，动物也有感觉。狗和猫也能看，也能听，也能闻，也能摸，也能触摸等等。但是人的感觉跟动物的感觉是不一样的，人的感觉有灵性的，于是我们创造艺术作品呐。</p>
<p>我们有能辨别音律的耳朵，你播放音乐给动物听没什么意思，人类的感觉是灵华。我们说测听力有两种含义了，一种是物理学的意义上的听力，你能够听到很微弱的声音，听力好。还有一个人听力不够好，声音比较小，他还没听见，这是一个生理的能力。但是音乐学院也要考你的听力，他考你的是什么？你的听觉的人类性，听觉的灵性。你能感受到这个旋律跟那个旋律的区分，你能感受到这个旋律的美，感觉到人类性，人性。用佛家的话叫自性其人，你一定要自性，这些感觉全坏掉了，跟动物的感觉没区别，你都不能审美了，这叫<strong>自性其有</strong>。</p>
<p>“如是一十八界，皆从自性起用”。翻过来看啊，190页，“自性若邪，起十八邪；自性若正，起十八正。”什么叫“自性若邪”？自性被遮蔽了，然后我们对事物的感受就不一样了，我们失去了审美的能力。比方说一个商人是看不到矿石的美的，他只看到矿石的商业价值，一个饥肠辘辘的穷人是看不到自然景色的美，这里都有很重要的意思。</p>
<p>我们能保持我们对周遭事务的审美能力吗？“自性若正，起十八正”人以人性的方式对待外物，这是用佛性的方式来对待外物。</p>
<p>今天的文明是异化的，叫资本的文明，我们对事物的感觉都是异化了的感觉，事物只是作为一种有用性呈现在给我们面前，然后我们自己也被物化了，这叫自性邪了，人被物化是很真实的事情呀各位。</p>
<p>怎么证实呢？很简单，你说一个语言就知道了，你看以前一个单位叫人事处是吧，或者人事，我跟复旦大学毕业的同学们讲。</p>
<p>我说：“你们在复旦大学读书的时候有一种骄做感、光荣感，考进复旦，你们知道吗？当你们离开复旦的时候，你们立刻知道自己是谁？”，他们问“我们是谁？”</p>
<p>我说：“你们叫human resouce，叫人力资源跟石油并列在一起。大的企业有个能源部，还有一个人力资源部，他们考虑你们就好像考虑石油的质量一样，人力资源也有考虑的指标的，还是管理科学的一个重要分支呢。你读human resouce，还拿个博士学位，然后到单位里去做人力资源部部长，专门考虑你们，你们被物化了”。</p>
<p>他们听了很沮丧，我说事情的真相，就是如此。一个时代的语言透露了这个时代的哲学，透露了这个文明的真相。以前说人事部，说的真对，做的针对是人的事情的呀。现在不叫人的事情，叫资源的事情。所以用佛家这面镜子一照这个文明病大了。这个且不说，你看广告业干嘛？不断让我们着相啊。那个广告片拍给我们看，这种豪华别墅你还没拥有它吗？你的人生失败了你知道吧？这么高贵的一个包，你还没拥有它吗？完蛋了。广告，自性邪了！</p>
<p>“自性若正，起十八正。若恶用即众生用，善用即佛用”当然众生可以成佛的噢。前念你就是众生，后念我就是佛。</p>
<p>“用由何等”，用从哪里来？“由自性有”自性邪就是用，今天的话叫异化，不是说自性没了，异化了，那叫邪。</p>
<p>我又想起梁漱溟那句话好玩，后来解放以后大家也得学点马克思主义嘛，了解了以后，他说了一句话，我知道共产主义了。人家说梁先生共产主义是什么？共产主义嘛就是儒道佛呀，这话也没错噢。儒家是不是有大同的理想？道教是不是有一个超然的自由的态度？自由的人生态度，佛家是不是不要着相？共产主义嘛，嘿嘿，还蛮有意思。</p>
<p>好，讲了这个三科法门之后要讲三十六对法，人家来问你你怎么跟他对？他说一共有三十六对。</p>
<p>“对法外境，无情五对”对法，其实对法这里要加个冒号才好。开始说对法，对法冒号，外境无情之间的逗号拿掉，对法冒号，外境无情五对。（“对法：外境无情五对”）五对全讲的是自然界，“天与地对，日与月对，明与暗对，阴与阳对，水与火对，此是五对也”。讲的是自然界，人家来问你天你用地来回，人家跟你说日你用月来回应，然后就是明与暗等等。人家问你明你有暗来说明，人家问你明你用暗来说明。讲到自然界的事情，五对。这叫对法，冒号，外境无情五对。</p>
<p>还有“法相语言十二对：”我们看看就知道了，十二对是指哪个领域？“语与法对，有与无对，有色与无色对，有相与无相对，有渴与无漏对，色与空对，动与静对，清与浊对，凡与圣对，僧与俗对，老与少对，大与小对，此是十二对也”，讲的其实是人类社会。不是讲的是自然的宇宙，其中的大与小都不是自然界的大与小，动与静也不是自然界的动与静，语就是言说，法就是佛法，有与无，有色与无色，这样就有一共有十二对了。这都是有道理的。</p>
<p>因为讲到最高的境界，用西方人来说就是最高的范畴，最高的概念就是范畴。范畴是无法下定义的。物质是个范畴，精神是个范畴是吧？你要说明物质这个范畴要靠什么来说？靠精神来说。就物质不是精神是吧？那么你要说明精神这个范畴离不开物，用物质来说他，范畴是无法下定义的，比范畴小一点的概念可以下定义。你比如说人是能制造工具的动物。这个就是对人下的一个定义。为什么呢？人还不是最高的概念？人上面还有动物，动物当中有人。那么人这一个种跟这一个类之间有个差，就当中的一句话：能制造工具。概念可定义，最高的概念被称为category，就范畴，他无法定义，它只能成对成对的说。</p>
<p>你比如说左是什么？左就是右的对立面，你说一个东西绝对在左吗？不。他在左就对于这个东西来说在左，那么相对于另外一个他就右了嘛。什么叫上面？因为有东西在他下面，然后它又变成下面的了，因为又有东西又在它上面。不就是成对的嘛。什么叫大？因为有小。然后庄子说小里面有大，大的不了了，如宇宙一般，一粒沙子哦。大得不得了，为什么？他无限可分，所以都是相对的。你说彭祖寿命很长，那么更长的，那么彭祖叫夭，短命的，《齐物论》去读一读就知道了。都是成对的来解释的，因为它达到范畴了，所以惠能有道理呀。你就说什么叫圣人？用一种凡人来说，什么叫绝对的圣人？他跟凡，相应。所以这就是他教教他的弟子们啊，人家来问你你怎么对？别忘了。都是一对对的来讲。十二对。</p>
<p>我们再看下面“自性起用十九对：长与短对，邪与正对，痴与慧对，愚与智对，乱与定对，慈与毒对，戒与非对，直与曲对，实与虚对，险与平对，烦恼与菩提对，常与无常对，悲与害对，喜与嗔对，舍与悭对，进与退对，生与灭对，法身与色身对，化身与报身对，此是十九对也”，前面的5对是自然界，后面的12对是人类社会，那么后面19对事情讲修行之法，个人的修行，19对。长短邪正痴慧愚智乱定慈毒等等等等……共19。</p>
<p>“此三十六对法”，加起来嘛，。5对。加上12对。已经是17对了。17对再加19对36对，所以叫36对法。此36对法若解用，如果你能领会“即道贯一切经法，出入即离两边”佛经浩如烟海嘛，你会这36对法，你一切经都能解呀，充满自信的。一个人要跟人家说佛法，是不是把佛经都读完了，这不可能。所以惠能做出很大的贡献。</p>
<p>36对法“即道贯一切经法，出入即离两边”，为什么？人家问明你用的暗的，这样才不入两边呐。人家问慧你用痴来跟他说，不入两边就是离两边。离两边就是你不站在这一边，也不站在那一边，让他们成为一体的东西，被领会为一体，明暗一体，痴慧一体。</p>
<p>一个痴的人最有希望慧，就怕你不痴，半痴你就离开慧远一点。这个，学佛的人呢真能修行跟佛有缘的人呢每每是奇僻之人啊。奇僻，你不奇不僻。很尴尬的，离开佛缘分就比较浅了。奇僻之人是很可爱的噢，你比方说惜春这个人奇僻啊，说话冷，口冷心冷意冷，其实她很关怀人。倒是那个谁看得清楚呀？宝玉看的清楚，她本来就想出家，但是像贾府这样一个富贵人家，一个女孩居然出家做了一个尼姑的，那叫奇耻大辱了。如果他去出家一定什么？贾府要责怪谁？妙玉，就是你勾引坏的，妙玉就没有好日子过了，说不定要得到严厉的惩罚。妙玉不是依傍着贾府的吗？这个奇僻的惜春明白这个道理。她是等妙玉后来走了，不是被强盗抢走了之后，她才放了这个心，坚决要去出家。否则她叫投鼠忌器呀。她的修行出家修行的决心老早下定了，但她不能害了妙玉，这是这种奇僻这人，她不会同流合污的跟这个社会。你就看不惯他，一个人不奇不僻，怎么可能清静呢？这些道理很有意思，所以惠能就讲修行的人，你如果把痴和慧绝对地对立起来，其实不对的。</p>
<p>一个人在某件事情上执着了，这个人就有希望了，就怕我们碰到什么都无所谓。一个人跟头扎的深了，悟的可能性就极大。所以他就是成对成对的说，这是讲的，让我们再翻过来看192页，他说“自性动用，共人言语”和人一起说话嘛，</p>
<p>“外于相离相，内于空离空”你不能不承认事物的差别，那叫相，客观的。但是不停留在相，那叫<strong>离相</strong>。</p>
<p>内就是心里面，先要空，不空心不会大，但是空的不能什么东西都没有。能含万物，叫内于空又离空，就不执着于空，若全着相，就不能离相啊，那叫长了邪见。若全执空又长了无明，无明就是暗了。执空之人有谤经，他们以为就学佛嘛，学佛就领悟到空嘛，既然空是根本嘛，佛经算什么？也空掉他吧。这种叫毁谤佛经。他们说什么不用文字。是禅宗是讲“教外别传，不立文字”。不立文字不是不用文字，立文字就是以为文字可以把真理说出来，这不可能。</p>
<p>但文字是必须用的。这个道理我们已经反复讲过了，就像攀登城楼要爬梯子。你要达到禅宗的智慧，心法传过去。你现在说话达到那不可说，所以那些执空见。若全执空又长了无明，无明就是暗了。执空之人有谤经，他们以为就学佛嘛，学佛就领悟到空嘛，既然空是根本嘛，佛经算什么？也空掉他吧。这种叫毁谤佛经。他们说什么不用文字。是禅宗是讲“教外别传，不立文字”。不立文字不是不用文字，立文字就是以为文字可以把真理说出来，这不可能。</p>
<p>但文字是必须用的。这个道理我们已经反复讲过了，就像攀登城楼要爬梯子，你要达到禅宗的智慧，心法传过去，你现在说话达到那不可说，所以那些执空之人，搞错了。</p>
<p>“既云不用文字”，如果真是不用文字，</p>
<p>“人亦不合语言”，你也不应该说话的，这合就是应该，不应该说话的。“只此语言，便是文字之相。又云，直道不立文字，即此不立两字，亦是文字”了。呵呵，不是已经说了吗？</p>
<p>“见人所说，便即谤他言着文字”，人家一说话，你就说他，哎呀，着了文字，这不可以的。</p>
<p>“汝等须知自迷犹可，又访佛经；不要谤经，罪障无数。”如果毁谤了佛经，那叫罪障无数。佛经自有它的用，所以要纠正我们对惠能和禅宗误解，他不识字，有好处。为什么？他不会被文字概念所束缚，这是不识字的好处。但是你不能说他不在乎文字，为什么？他说话嘛，语言嘛。所以他就会活，就活说，不是死板，不是教条，是这个意思。</p>
<p>“若着相于外，而作法求真：或广立道场，说有无之过患，如是之人，累劫不得见性”。不能求真啊，但需去妄。你以为这个真理就在你手里了，然后向众人颁布真理，这叫做法求真。</p>
<p>这样的人还广立道场，还到处说，做有和无的过和坏，“如是之人。累劫不可见性。但听依法修行，又莫百物不思”你们一定要依法修行，但是千万不要百物不思，</p>
<p>“而于道性室碍”。你当然要了解这个人世间的关系了，否则道性室碍，道就在事物当中体现的。</p>
<p>“若听说不修，令人反生邪念”。确实讲不修之修的，不修之修的是很高的境界。就是说所谓不修，是不按照确定的既定的规则和程序来修，但照样在修，在日常生活中修。但是你这样跟人家讲，到反是生了那些不容聊，不懂的人的邪念最后都应验。</p>
<p>就惠能的禅宗后来被诟病，也是有的人借他的话头呀，我照样喝酒，酒肉穿肠过，我什么都可以做。邪淫之类都行，反正心中有佛祖嘛，这叫生了邪念。就像阳明心学后来也被诟病一样的，可能惠能是预先知道，所以一般情况下你不能说不修的，其实最高的境界不是专门去修，就在日常生活中修，人生无处不是道场。但是这话呢跟常人讲恐怕倒是让人生了邪念。</p>
<p>“但依法修行无住相法施”，修行但不住相，</p>
<p>“汝等若悟，依此说，依此用，依此行，依此作，即不失本宗。”“若有人问汝义”，问你佛佛法的要义，问有，你就拿无来对，“问无将有对”。</p>
<p>“问凡以圣对，问圣以凡对。二道相因，生中道义”这很符合中国本来的智慧。就讲一个中。对哇。儒家是这样看，道家也这么看。孔子说过犹不及，一个是过了，一个是没达到。其实都一样，都不对。中道！中国思想非常精彩的一点是西方人永远不能理解的，我看，中国人讲的正确，不是跟错误相对的，正确就是<strong>恰当</strong>，中国人最追求的就是<strong>恰当</strong>。</p>
<p>西方人一定说出个一个是和非来，我们不说是也不说非，而是恰到好处才是对的。中国思想的精华之一，你跟老外讲不清楚的，他总有一个理性的标准，要么对的要么错的是吧？我们说这也没什么错，我们只要恰到好处，他怎么听得懂？道家也是这个意思，都不能过分了，过分他就走向反面。你成功到辉煌的地步了，你是中国人一定会警觉的，然后你在最黑暗的最痛苦的时候，你知道光明就在前面。因为“反者道之动”，然后如果你要一个事物保持的更长久一点，你就要让事物能包含自己的对立面。中国思想道家也这么看，在这一点儒道就是相通的。</p>
<p>资本主义要活得长一点就必须包含社会主义，不包含社会主义它怎么活的长呢？做事情要做到成功，就是一定要有敌人的，要有对立面。没有对立面一帆风顺，好了这个事情做不到什么境界的，敌人是我们的老师，困难是我们的恩人。</p>
<p>道家。我们都很天真，没有道家的思想的话，我们就很天真，要么不做事，第一一做事，第一，不要有敌人，不要有对立面，第二要一帆风顺。</p>
<p>世界上的事物不是这样的，所以讲一个<strong>中道</strong>，“如一问一对，余问一依此作，即不失理也。”所以他教我们36对法。</p>
<p>“设有人问：何名为暗？答云：明是因，暗是缘”，就可以了。</p>
<p>“明没则暗。以明显暗，以暗显明，未去相国，成中道义。余问悉皆如此。”这是谆谆教导一番。</p>
<p>“汝等于后传法，依此转相教授，勿失宗旨。”你们以后还要传给后人呐，都这样。好，这就是付嘱品的第一个方面。</p>
<p>第二个方面表现出惠能面临生死时的自在。195页，</p>
<p>“师于太极元年壬子，延和七月，命门人往新州”，他曾经从小就在那里生活。</p>
<p>“国恩寺建塔”，国恩寺是皇帝要求命令制造建造的，国恩寺，就要在这寺里面建塔，为什么要建塔？和尚圆寂了之后什么？送到塔里呀。“仍令促工。次年夏末落成。七月一日，集徒众曰”把周围的弟子都招来了，“吾至八月”我到8月份的时候就要离开了，“欲离世间。汝等有疑，早须相问，为汝破疑，令汝迷尽。吾若去后，无人教汝。”你们趁早快点，有疑问就来问吧。</p>
<p>“法海等闻，悉皆涕泣”就都哭了，“惟有神会，神情不动，亦无涕泣”赞扬他了。惠能说，“神会小师，却得善不善等，毁誉不动，哀乐不生。余者不得”，你们其他人都没到。“数年山中，竞修何道？”有人说后来是后人加进去的话，为了赞美一下神会“汝今悲泣，为忧阿谁？”阿谁是是古汉语经常说的话，就你为哪一个呢？究竟为谁来忧呢？“若忧吾不知去处”，你们担忧我走了之后不知道到哪里去是吧？</p>
<p>“吾自知去处，吾若不知去处，终不预报于汝。”我怎么会预先告诉你们呢？我预先告诉你们我要走了，我当然知道我到哪里去了。</p>
<p>“汝等悲泣，盖为不知吾去处”你们为什么哭了？就不知道我到哪里去了，“若知吾去处，即不合悲泣。法性本无生灭去来，汝等尽坐”你们都坐下，“吾与汝说一偈，名曰《真假动静偈》。汝等诵取此偈，与吾意同；依此修行，不失宗旨。”在最后的付嘱品里面有两个偈。</p>
<p>第一个偈就这里的《真假动静》，</p>
<p>“一切无有真，不以见于真；若见于真者，是见尽非真。”事物都没有是他自己的本性的，</p>
<p>“若能自有真，离假即心真；”如果你自己有真，那是你的心。“自心不离假，无真何处真？”你的心是假的心的话，哪里有真呢？“有情即解动，无情即不动；”打坐就是如果说不动，是什么不动？如果是心不动就不对了，那就是无情了。</p>
<p>“若修不动行”，身体一定在那里坚持不动，</p>
<p>“同无情不动”，就跟无情一样，什么叫无情？草木瓦石。</p>
<p>“若觅真不动”，如果什么叫真不动，动上有不动，你老是做事情，就动了。很忙，身忙心不忙，叫动上有不动啊。</p>
<p>“不动是不动”，如果不动这个是不动的话，那叫无情，那就没有付出了，无情没付出。所以佛性是生命情感，不是空寂啊。</p>
<p>“能善分别相，第一义不动”。你知道这些分别都是相，你第一义就不动了。第一义就是真如自性其一，这叫第一义。这就是佛学当中讲的第一义，“真如自性其一”这一点是不动的，别的都可以动。</p>
<p>“但作如此见，即是真如用”就真如自性其一。</p>
<p><strong>真</strong>，即<strong>不假</strong>，<strong>如</strong>就是<strong>不倒</strong>，合起来叫<strong>真如</strong>。我们的自性本就真如，从他那里有，世界上数千变万化，以不变应万变，这不变的是真如自性。古人千百年前是古人，今天是人，未来是人，只是同一个性，这没有变的。这话谁说的？陆象山。“报诸学道人，努力须用意；莫于大乘门，却执生死智。”执着于生与死的区分，那个智不叫智慧，叫<strong>没意智</strong>。<strong>没意智</strong>就是我们通常的所谓机巧机智，机巧机智叫<strong>没意智</strong>，为什么呢？没就是呈现，呈现于自己的意欲之中的技巧。通常人的聪明就是<strong>没意智</strong>，所以惠能讲下下人有上上智，上上人没意智。“若言下相应，即共论佛义”，你说话人家就要马上应了，这应的好，那么这种情况下，我们才可以共同讨论佛意，及功德佛义，</p>
<p>“若实不相应，合掌令欢喜”。你说的话人家没有应，也不要瞧不起别人，也不要难过，也不要愤怒，合掌，令他欢喜。这是跟那些弟子们讲，你们都是和尚了，人家来问佛法，你帮人家开悟，结果没成功，没成功我们合掌，也仍然是善哉不就好了。达摩想要度化梁武帝还没成呢，于是不投缘了，不投缘我们合掌。</p>
<p>投缘就相应，“此宗本无静”，不要争论，不要辩论，“诤即失道意”，不要在文字当中语言概念当中争来争去的。</p>
<p>“执逆静法门，自性入生死”，你一定要跟人家对抗，说我这法门高，你的法门低，你的自性就到了时间中去，没有了，生生死死的，自性本来是不朽的，这是一个真假动静偈。</p>
<p>我们看197页上说，“时”，就当时，“时，徒众闻说偈已，普皆作礼，并体师意”，大家都领会到了体会到了惠能的一番苦心。所以“各各摄心，依法修行，更不敢诤。”藏传佛教有辩经，这个惠能就不会主张辩经的。这个佛教辩经我也没有亲身经历过，他们的根据都是用因明学的。佛教当中的逻辑学，叫因明学。然后辩来辩去的，看来惠能是反对这种做法的。</p>
<p>“乃知大师不久住世，法海上座，再拜问曰：‘和尚入灭之后，衣法当付何人？”惠能做交代，“吾于大梵寺说法，以至于今，抄录流行，目曰《法宝坛经》”，这是跟法海讲的，你要干什么？抄录。让他留布于世，所以我们今天读到的《六祖坛经》。</p>
<p>“汝等守护，递相传授，度诸群生。但依此说，是名正法。今为汝等说法，不付其衣。”这是当时弘忍法师就跟他讲的，衣传到你那里就停下来，“止汝勿传”。因为衣要起争端，起争端大家就要斗，那么命若悬丝。</p>
<p>“盖为汝等信根淳熟”，你们这些人都是性根成熟，“决定无疑，堪任大事。然据先祖达摩大师，付授偈意，衣不合传。”一开始是不能不有衣来传，那叫信物。到禅宗到中国来就是达摩初祖来传心法。谁相信呢？修佛要么说话有语言有文字，然后有程序，你偏偏这些都不要，说什么传心法，随性，有性无债，权益就这么来。但是后面不能再传。</p>
<p>“吾本来兹土”，就是我达摩来到中土，就是中国。</p>
<p>“传法教途情，一花开五叶，结果自然成。”底下注释二说一花，华就是花了，开五叶有两种解释，一种解释是说从达摩后面就传五代，那么五叶就是五代，慧可、僧璨、道信、弘忍、惠能。还有一种说法就五个分支出来，沩仰宗、临济宗、云门宗、法眼宗、曹洞宗。那现在一般都理解为五个支脉。叫一花开五叶，这是惠能说达摩当初有这个偈的，结果自然成。</p>
<p>然后又跟大家讲了，“诸善知识，汝等各各净心，听吾说法。若欲成就种智，须达一相三昧、一行三味。若于一切处而不住相，于彼相中不生憎爱，亦无取舍，不念利益成坏等事，安闲恬静，虚融淡泊，此名‘一相三昧’。”这是对世界的看法，一相三昧。</p>
<p>“若于一切处行住坐卧，纯一直心，不动道场，真成净土，”“直心是道场，直心是净土”，这是《净名经》当中的话，直心就是不转弯，一行这叫什么一行三昧，叫实践，前面一相三昧看待世界，<strong>一行三味叫生命实践</strong>。</p>
<p>“若人具二‘三昧’，如地有种，含藏长养，成熟其实；一相、一行，亦复如是。”这里是他是转用了，三本来是，不是数量词，他有一转一转，如果你没达到也没关系，如头脑里面有种子，会长成的。</p>
<p>“我今说法，犹如时雨普润大地，汝等佛性警诸种子，你们的佛性就像种子，遇兹沾洽，悉得发生。”我降了雨给你们，你们是种子，都能发萌芽生长。</p>
<p>“承吾旨者，决获菩提，一定达到觉悟，依吾行者，定证妙果。”又来一个偈：“心地含诸种，普雨悉皆萌：顿悟花情已，菩提果自成。”华就是花，顿悟的时候就是花开了，生命情感得到提升，觉悟自然得。</p>
<p>“师说偈已，曰：‘其法无二，其心亦然；其道清净，亦无诸相。汝等慎勿观静及空其心，不要这样打坐，此心本净，无可取舍。各自努力，随缘好去。’尔时，徒众作礼而退”。这是第二方面的内容。说出了惠能走之前的这种态度。面对生死的自在，然后又对他们作了一番教导，然后第三个方面的东西就是讲禅宗的传法徒系。</p>
<p>“七月八日，忽谓门人曰：‘吾欲归新州，汝等速理舟楫。’我要走了，大众哀留甚坚。”留下，惠能就说诸佛出现有此涅槃，以往的那些佛都是涅槃，就他这么走。都给大家看。有种种的走法，有许多精彩的故事，没时间讲。马祖道一的一个弟子后来也成了禅宗祖师，后来他走之前跟大家弟子讲：我走了，然后他就坐化了，边上弟子全在哭，哭了一整天，结果他居然睁开眼睛说你们哭什么？跟他们讲，这样吧，你们去做饭，我跟你们一起吃，那么他们要留他多一点，饭做了两天才做好，然后一起吃，吃完了，用了素斋之后，这个祖师说我走了，回到自己寮房里，等大家再进去看，圆寂了。</p>
<p>他本来走得好好的，拼命的哭，他眼睛睁开：“你们哭什么？”，这种事情全是真的，都记载下来，有不同的走法。说佛法说到正好这个经讲完了，他站在树边上讲话，南华寺的事情，就保留了，讲完了身体往树上一靠：“我走了”。大家以为他开玩笑，刚才讲的振振有词的，怎么说走就走了，一看他真走了。</p>
<p>那么还有一个人好玩，他后来也是禅宗祖师，性格就是调皮，他成了祖师还一天到晚跟人家开玩笑，有一次他就跟弟子说我要走了，你们都看到过什么走法，弟子们跟他说佛是这样的，我不走的时候不是侧卧，拖着腮帮子，还有的人站着，我现在倒立着走，他果然倒立着走，人家认为他又开玩笑又调皮了，过去一看已经走了，倒立着，就这么走的。后来他的另外一个师兄来了，跑过来又调皮，连走还要淘气，这种事情都有，就性格不改。倒立着走给你们看。这蛮有意思。</p>
<p>所以他说“‘诸佛出现”都会示涅槃给大家看，（“诸佛出现，犹示涅槃”）“有未必去，理亦常然，吾此形骸，归必有所。’‘师从此去，早晚可回？’‘叶落归根，来时无口。’”我们出生的时候还不会说话的，无口，我们归去就没什么好说的。</p>
<p>“正法眼藏，传付何人”又问他这个问题？正法眼藏就是释迦牟尼传给迦叶尊者，我们现在就又传给谁？</p>
<p>“有道者得，无心者通”，你不要有意的执着的长期的破。</p>
<p>“后莫有难否？”，又问他你走了之后会不会还有什么难降临到你头上？有啊。</p>
<p>“吾灭后五六年，当有一人未取吾首。听吾记曰：头上养亲，口里须餐：遇满之难，杨柳为官”</p>
<p>告诉你们关照的话，叫“头上养亲，口里须餐”，此人是个苦人，穷人，要奉养回？‘叶落归根，来时无口。’”我们出生的时候还不会说话的，无口，我们归去就没什么好说的。</p>
<p>“正法眼藏，传付何人”又问他这个问题？正法眼藏就是释迦牟尼传给迦叶尊者，是吧？我们现在就又传给谁？</p>
<p>“有道者得，无心者通”，你不要有意的执着的长期的破。</p>
<p>“后莫有难否？”，又问他你走了之后会不会还有什么难降临到你头上？有啊。“吾灭后五六年，当有一人未取吾首。听吾记曰：头上养亲，口里须餐：遇满之难，杨柳为官”告诉你们关照的话，叫“头上养亲，口里须餐”，此人是个苦人，穷人，要奉养母亲，也要吃饭的，所以他会来取我首级。“遇满之难”就叫满的人，他会被抓走的，然后会送到官那里去，当时一个官姓杨一个官姓刘，“杨柳为官”，当时就有人记住这件事，果然有。</p>
<p>底下我们不讲，大家自己可以看，从东方来，一出家，一在家，两个菩萨，那么后面我们看自己总结，自己看，有两种说法，是指谁。这是注释3，有的人说出家的菩萨是指马祖道一，在家的菩萨是指彭韵居士，又有另外的说法，这些无紧要。</p>
<p>“未知从上佛祖应现已来，传授几代？愿垂开示。”那么惠能就说了，“古佛应世，已无数量”，这就是古佛一路传传传传。你看我们注意到以上七佛都是在释迦摩尼之前。对，第八个就是释迦文佛，释迦文佛就释迦摩了，开始往下传。第一迦叶，第二迦叶后边有阿难尊者，有商那和修尊者，一直到第二十八祖，达摩。达摩到东土来传来五个。二十八家，惠能就是三十三祖。“从上诸祖，各有慕承。汝等向后，递代流传，毋令乖误。”乖是偏离，乖误。204页就是最后一个方面的内容，叫话导后代迷人。如何话导后代迷人，这是一个概括。惠能在这里对他一辈子说禅宗顿教的佛法来一个最后的概括。</p>
<p>“大师先天二年癸丑岁，八月初三日，于国恩寺斋罢，谓诸徒众曰：‘汝等各依位坐，吾与汝别。’”告别，告别时我说一番话。</p>
<p>“汝等谛听，后代迷人，若识众生，即是佛性；若不识众生，万劫觅佛难逢。众生是佛，吾今教汝识自心众生，见自心佛性。欲求见佛，但识众生，只为众生迷佛，非是佛途众生。自性若悟，众生是佛”，就像禅宗公案里边一个弟子问他的师傅，佛究竟在哪里？这师傅回答弟子说在你面前，听你说佛法的就是佛，所以你“要识众生，皆是佛性，若不识众生，万劫觅佛难逢”，你哪里去找释迦摩尼呢？</p>
<p>“吾今教汝识自心众生”，众生的烦恼，你心中其实都有，众生的罪过，你哪怕没做出来也有，如果碰到合适的时候也不就是罪过来了吗？别把自己跟众生分得清清楚楚，这叫“自心众生，见自心佛性，欲求见佛，但识众生，只为众生迷佛，非是佛迷众生。”众生迷了不见自己的佛性，不是佛迷了众生。</p>
<p>“自性若悟，众生是佛，自性若迷，佛是众生。自性平等，众生是佛；自性邪险，佛是众生。如等心若险雀，即不在众生中，汝等心若险曲，即佛在众生中。一念平直，即是众生成佛。我心自有佛，自佛是真佛。”每个人相信自己，“自若无佛心，何处求真佛？”。禅宗的根本原则，“汝等自心是佛，更莫狐疑，外无一物而能建立”，没有一个事物可以依靠的。“皆是本心生万种法”，佛法无穷无尽，从你本心中出自然对。</p>
<p>“故经云：‘心生种种法生，心灭种种法灭。’吾今留一偈，与汝等别，名自性真佛偈”。两个场偈，前面叫真假动静偈，这里是自性真佛偈。</p>
<p>“后代之人，识此偈意，自见本心，自成佛道。”</p>
<p>“真如自性是真佛，邪见三毒是魔王。”三毒就是贪、嗔、痴。“邪迷之时魔在舍，正见之时佛在堂。性中邪见三毒生，即是魔王来住舍。”魔王就到你家里来了。“正见自除三毒心，魔变成佛真无假。法身报身及化身，三身本来是一身。若向性中能自见，即是成佛菩提因。本从化身生净性，净性常在化身中”化身千百亦化身。我们在人世间打交道，办事，跟人打交道，就不断的是各种化身。</p>
<p>“性使化身行正道，当来圆满真无穷。”圆满报生佛。</p>
<p>“淫性本是净性园”，淫就是肮脏，倒是净性的因，“除淫即是净性身。”“性中各自离五欲，见性刹那即是真。今生若遇顿教门，忽悟自性见世尊。”就见到释迦摩尼了。</p>
<p>“若欲修行竟作佛，不知何处拟求真？”不要到外面去寻找，不要刻意的做佛，寻求作佛，否则你都不知道在哪里可以得到真。</p>
<p>“若能心中自见真，有真即是成佛因。不见自性外觅佛，起心总是大痴人。”起这种愿望的人都是大痴人，我们每个人怀里都有个宝，就是佛性。</p>
<p>“顿教法门今已留，救度世人须自修，报汝当来学道者，”要告诉一切来学道的人，“不作此见大悠悠。”人生就虚度了。</p>
<p>好，翻过来再看206页。“师说偈己，告曰：‘汝等好住，吾灭度后，莫作世情悲泣雨泪，受人吊问，’”千万别来吊唁，什么身着孝服，这就不是我的弟子了。“亦非正法。”</p>
<p>“但识自本心，见自本性，无动无静，无生无灭，无去无来，无是无非，无住无往。恐汝等心迹，不会吾意，今再嘱汝，令汝见性。吾灭度后，依此修行，如吾在日。”只要你们按照我说的去修行，就好像我跟你们在一起。</p>
<p>“若违吾教，纵吾在世，亦无有益。复说偈曰：兀兀不修善，腾腾不选恶。”兀兀就是不动，腾腾就是做事情不断的动，但是要不造恶。</p>
<p>“寂寂断见闻，荡荡心无着。师说偈已，端坐至三更，忽谓门人曰：‘吾行矣！’在然迁化。”灭度又叫迁化。</p>
<p>“于时异香满室，白虹属地，林木变白，禽兽哀鸣。”说他圆寂时候的情景。我们看最后一段，也就是208页，“十一月，广、韶、新三郡官僚，治门人僧俗，争迎真身”，大家都已经抢着迎真身。“莫决所之”，不知道该往把他送到哪里。有人提议了，干脆焚香吧，看这个香的烟往哪里飘，“乃焚香祷曰：香烟指处，师所归焉。时香烟直贯曾溪。”</p>
<p>往曹溪送，“十一月十三日，迁神龛并所传衣钵而回。”又从新州要到曹溪去，终于还不在国恩寺，国恩寺里边的塔也不是他用了，仍然回归曹溪。次年七月出，把它从龛里面取出来，这是它的真身了。然后方辩起作用了，雕塑家来了，比较方便，用香泥上之。</p>
<p>门人记忆想起他曾经说过的取首，有人在五六年时候要取他的首级，所以欲做防备，“仍以铁叶漆布，固护师颈。”把他的脖子周边用铁叶箍好了。“入塔”。</p>
<p>刚入塔就看到什么？“白光出现，直上冲天，三日始散。韶州奏闻，”奏闻皇上那么皇上就有的指示下来了，要立碑。“奉救立碑，纪师道行。”来把惠能的道行记录下来。</p>
<p>“师春秋七十有六”，76岁走的。</p>
<p>“年二十四传衣，”弘忍法师把衣钵传给惠能，他24岁隐居15年，隐居15年就39岁，祝发就剃度了。在广州法性寺剃度，开始说法，说了37年，嗣法一共得到他的佛法的人有43人。这就是碑文上写的，碑上写的话。“师春秋七十有六，……”笔录写下来。</p>
<p>“悟道超凡者莫知其数。达摩所传信衣，”后来的事情，“中宗赐磨神宝钵，及方辩塑师真相，并道具，永镇宝林道场。”我们现在也能看到，去瞻仰他的真身，到南华寺，当时叫宝林寺，现在叫南华寺，广东韶关。“留传《坛经》，以显宗旨，兴隆三宝。”佛法僧三宝，“善利群生者。”《坛经》全文到此。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结语"><a class="header" href="#结语">结语</a></h1>
<p>我们的课也到此。刚才杨老师说。有没有互动的需要？老师给我们总结。</p>
<p>学生问：禅宗到底什么是<strong>禅</strong>？</p>
<p>德峰先生答：禅这个汉字本来是禅，禅让的禅，尧舜都是禅让王位，但是后来拿这个字来翻译dhyana，dhyana就是梵文。所以一一开始两个字叫<strong>禅那</strong>，后来觉得一个字可以的。dhyana这个梵语的意思就是<strong>静虑</strong>，<strong>修禅</strong>也叫<strong>思维修</strong>。但这个思维不是我们今天汉语当中思维的意思，汉语当中这个单词思维表示逻辑的思考，在范畴和概念当中是思维，思维本不是指概念，不是头脑，是<strong>心</strong>。</p>
<p>因为中国人翻译佛经，汉语当中多了一大堆本来根本没有的词，其中有一个词就是思维，还有意识。</p>
<p>第六识译成意识，汉语当中有一个词叫意识。真理境界缘分都是翻译佛经才出现在汉语当中的词，包括思维。所以梵文单词dhyana，表示<strong>思维修</strong>，思维修的时候就<strong>静虑</strong>。把种种的<strong>欲</strong>都静下来，这就变成一种修行的方法。禅宗因此得名的。不是外在的修为。是我们的心灵的修为，所以就有禅。既然是思维修能达到超出语言，于是我们就经常说禅意，禅意很难用文字表达，倒是用艺术可以表现。比方说王维就是笃信禅宗，这个画家也是诗人，唐朝的王维，摩诘。王摩诘，他的诗中有禅意，他的话中亦有禅意，这是一个禅宗的情况。</p>
<p>学生问：达摩的禅和惠能的禅有点不同，不同在哪里？</p>
<p>德峰先生答：有蛮大的不同。达摩确实还有许多外在的要求，包括他自己，你上午要讲他这个闭关了，他闭关9年的，在少林寺，他说反正没有人知道。</p>
<p>没有人来求我。求的都是不懂的人，他也就算了，自己在闭关，就有点像守株待兔的样子。那么他在那里也讲做禅的功夫，都讲了。所以达摩这个禅宗就是直接的原本的从印度传过来，那么也讲究坐禅的方法，都讲究的。那么当时禅宗的最初的阶段以《楞严经》做它的基础。到了弘忍法师那里？变了。抓住这个<strong>无相</strong>，我们禅修就是要达到<strong>无相</strong>。这是最根本的。而《金刚经》的主题就是<strong>无相</strong>。</p>
<p>所以弘忍法师就跟大家讲了，佛经浩如烟海，读不胜读。最要紧的《金刚经》，读这部经就够了。到弘忍法师那里有变化，可以说弘忍法师跟惠能都是禅宗中国化的什么——奠基人。但是现在把禅宗奠基者这个地位给了惠能了，是因为弘忍法师那里关于禅宗教人开悟的方法并没有展现出来，到惠能那里展现出来了。所以后面一花开五叶，包括反问你，包括打你，包括做动作提示你，参禅的一来一去的必须的话，这些东西在坛经里面都初具规模，所以这样就视惠能为禅宗真正的奠基人。那么这里边在修禅方面惠能非常彻底的把打坐这件事情看成是绝对纯粹是外在的东西，这就是不同了。</p>
<p>而且特别强调在家修行。在日常生活中修，时时的去发现自己妄念的根源，这是在日常生活中修，别把自己的生活分成两部分，一部分专门打坐，还有一部分还是一如既往的该怎么样就怎么样，这就不对了。统一起来。那么这就是惠能跟达摩的不同。对。达摩虽然跟惠能不同，但达摩确实是传心法的，开了个头，所以他自己也知道叫一花开五叶。你看他跟慧可的一翻对话就是抓住心的方法，就<strong>安心</strong>，这就是对的。</p>
<p>然后具体的怎么能中国化，这就是靠惠能的。惠能是在中国文化世界中长大，中国的社会环境里面，儒家的道家的他都知道，都是听人家说了，听人家说就是在文化里边的，所以他做成了一件了不起的事。其实已经把佛教修行跟儒家和道家的境界什么？结合，这叫中国化。达摩是做不到这一点的，他毕竟是印度的嘛。</p>
<p>学生问：王老师我来问一个我困惑的问题，因为即使我们的课程是把坛经智慧和阳明心学放在一起，在上面，在这一段课程里面，老师也多次讲到阳明是儒家中的惠能，证明阳明心学从佛家的智慧里面吸取了很多的营养，可是我们到《传习录》了以后，发现了阳明先生对佛老学说批评还是蛮很多的，这个给我造成一些困惑。</p>
<p>德峰先生答：这个问题非常好。在黄子路里，《传习录》里面有一个叫黄子路。他就跟黄子路讲的，他说，佛家不着相，其实着了相，吾儒着相其实不着相，因世人都这么说，佛家是不着相的，他说其实着了相，说我们儒家是很着相的，其实不着相，他可能说道理了。佛家怕福祉累，逃了福祉，怕君臣累，逃了君臣。你出家门，出家门就不承担对家族的责任了。父子关系多累啊，逃了吧？君臣关系多累啊，你要担当天下，逃了。佛家怕夫妇累，夫妻关系也很累的。逃了，为什么要逃呢？着了相，逃就说明他们着相，吾儒不着相，父子还它一个仁，仁爱的仁，君臣还它一个义，夫妇还它一个别，就是两个人的合作嘛，妻子有妻子的活要干，丈夫有丈夫的活儿要干。这叫分别，分别然后才合作的。这个别就这个意思。</p>
<p>所以我们在这世界上总有几种关系逃不了。君臣、父子、夫妇、兄弟、朋友叫<strong>五伦</strong>，佛家统统要逃，逃就说明你<strong>着相</strong>。我们不逃。也没着相，为什么？不是一定要区分一个君与臣的区分，君臣关系还它一个本来的价值，叫义，父子关系还他本来的价值，叫仁，夫妇关系还他一个本来的价值，叫别，并没有着相。</p>
<p>那么这就是你刚才提到的问题。因为阳明曾经出入于佛老之间，他进入佛家的学说也深受启发，所以才会有这个说法，就我的说法。我相信这话没有错，就是儒家中的惠能，但是他这个批评指向惠能肯定不会的。为什么？惠能就主张大多数的在家修行，不是到处鼓励人家出家的。你们都在家修行嘛。强调<strong>人生无处不是道场</strong>，这些都表明王阳明对佛家的批评是对一般的世人的佛家观念的批评，其实不是对惠能的批评。</p>
<p>惠能的在家修行的10个要点，有好多要点都是儒家的精神，你在上要报父母之恩，不能不报的，上下相怜，兄弟之间要友爱要相怜，这都是说的儒家的原则，所以这就是我们要看的问题，就是说实际上佛家和儒家目标不一样，达到的境界都很高。</p>
<p>特别是因为佛家启发儒家，让儒家的境界往上走一走，才有心学的，但是差别就在于目标。你学佛修佛目标就是涅槃，解脱生死。你儒家就是天下关怀，目标不一样，所以完成了一个转变。就从禅宗到宋明新儒学完成一个什么转变？就两句话，第一句话就是说禅宗终于达到什么境界？担水砍案，无非妙道，然后儒家不免接下去一句，事君事父，亦是妙道。这就转了一下，上乘禅宗，然后又回归儒家的目标，儒家的境界，天下关怀。从家族的关怀到天下的关怀都不能推却。事父就是家族的关怀。事君就是天下的关怀，他也是妙道。你佛家不可能讲事君事父的，因为你就出家，做一件事情，修行，达到涅槃，叫<strong>了生死</strong>。但儒家的目标是与天下同在，所以这叫<strong>天下关怀</strong>。</p>
<p>这样一来我们就看清楚了，王阳明是不免要批评佛家的，这是免不了的事情。否则他也就在佛家的目标里面了，他要超越佛家的目标，所以要批评佛家着相的。所以这个事情是这样的。</p>
<p>学生问：自性并无一法可得，但自性又能含万法，这两个法可能是不一样的。那么又有以出世的心态来做入世事情？这也同样是一个世，也就是说这两个法和这两个世，这两个世、这两个法有什么不同？</p>
<p>德峰先生答：一样的。这自性行本无一法可得，法，法就是事，事物。这个自性不是可以依靠什么东西的，它就是自本性。如一个太阳悬于虚空，不需要什么东西撑着他。我们在人世间最终要相信自己，没有什么东西可以依靠的，本无一法可得。</p>
<p>那么还有一句话，自性能含万法，因为自性是能把万事万物的真实意义加以领会，他不会局限于某些事物上，不能领会另外一些事物，能含万法，就像太阳没东西撑着他，但他射出光芒来了是吧？阳光让万物毕现，这叫能含万法。</p>
<p>学生问：老师，我想问一下为什么这本书叫《坛经》，因为其他的经都是佛祖所说的话，好像有不一样？</p>
<p>德峰先生答：对。就是我们中国人把佛教传到中国以后，中国人开始翻译佛经，后来有了这本《坛经》之后，它就称为经了，就表明什么？中国的修行者都公认了，公认是惠能所说的跟释迦摩尼所说的没什么差别。唯一一部中国人自己说的佛法便被抬高到经的地位，所以称它为<strong>经</strong>，如果不是经，它只能叫<strong>论</strong>，经论经论嘛，抬得非常高了，这是有道理的，因为没有《坛经》的话，禅宗不可能在中国发扬光大的，惠能之后禅宗开始发扬光大。到什么程度？各地的寺庙纷纷成了禅宗的寺庙。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
